<html><head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<meta name="Author" content="2011/04/20,white">
	<meta name="Description" content="整个 Linux 系统下的开关机流程介绍，以及启动管理软件的介绍">
	<title>鸟哥的 Linux 私房菜 -- 启动关机流程与 Loader</title>
    <script src="../script/SpryMenuBar.js" type="text/javascript"></script>
	<script src="../script/index.js" type="text/javascript"></script>
	<link href="../css/SpryMenuBarHorizontal.css" rel="stylesheet" type="text/css" />
    <link href="../css/main.css" rel="stylesheet" type="text/css" />
    </head><body style="margin: 0pt; padding: 0pt;" class="table"onload="MM_preloadImages('../index-2.html','../index-2.html','../index-2.html','../index-2.html','../index-2.html','../index-2.html','../index-2.html','../index-2.html')">

<center>
<div id="apDiv5">
<div> <LINK REL="SHORTCUT ICON" HREF="../index-2.html">
<!-- ImageReady Slices (title3.ai) -->
<table id="___01" width="898" height="81" border="0" align="center" cellpadding="0" cellspacing="0";>
	<tr>
		<td colspan="15">
			<img src="image/title/title_01.png" width="900" height="1" alt=""></td>
	</tr>
	<tr>
		<td rowspan="4" bgcolor="#182448"><p><img src="http://linux.vbird.org/cgi-bin/Count.cgi?dd=C&amp;ft=5&amp;sh=T&amp;md=8&amp;pad=Y&amp;df=vbird.dic.ksu.edu.tw.dat" width="93" align="left" title="計數器" /></p>
	    <p><font color="#FFFFFF" size="-1">since2012/04/23</font></p></td>
		<td rowspan="4" align="left" valign="top"><a href="../index.html"><img src="image/title/title_03.png" alt="" width="263" height="79" border="0"></a></td>
		<td colspan="13">
			<img src="image/title/title_04.png" alt="" width="535" height="9" border="0"></td>
	</tr>
	<tr>
		<td rowspan="3">
			<img src="image/title/title_05.png" alt="" width="53" height="70" border="0"></td>
		<td colspan="2" align="left" valign="top"><a href="0110whatislinux.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image51','','image/title/title_06.png',1)"><img src="image/title/title3_06.png" name="Image51" width="106" height="25" border="0" id="Image51" alt=""/></a></td>
		<td rowspan="2">
			<img src="image/title/title_07.png" alt="" width="27" height="37" border="0"></td>
		<td colspan="3" align="left" valign="top"><a href="../linux_server/0110network_basic.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image52','','image/title/title_08.png',1)"><img src="image/title/title3_08.png" name="Image52" width="107" height="25" border="0" id="Image52" alt=""/></a></td>
		<td rowspan="2">
			<img src="image/title/title_09.png" alt="" width="37" height="37" border="0"></td>
		<td colspan="2" align="left" valign="top"><a href="../about.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image53','','image/title/title_10.png',1)"><img src="image/title/title3_10.png" name="Image53" width="75" height="25" border="0" id="Image53" alt=""/></a></td>
		<td rowspan="3">
			<img src="image/title/title_11.png" alt="" width="35" height="70" border="0"></td>
		<td align="left" valign="top"><a href="mailto:vbird@mail.vbird.idv.tw" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image54','','image/title/title_12.png',1)"><img src="image/title/title3_12.png" name="Image54" width="74" height="25" border="0" id="Image54" alt=""/></a></td>
		<td rowspan="3">
			<img src="image/title/title_13.png" alt="" width="21" height="70" border="0"></td>
	</tr>
	<tr>
		<td colspan="2">
			<img src="image/title/title_14.png" alt="" width="106" height="12" border="0"></td>
		<td colspan="3">
			<img src="image/title/title_15.png" alt="" width="107" height="12" border="0"></td>
		<td colspan="2">
			<img src="image/title/title_16.png" width="75" height="12" alt=""></td>
		<td rowspan="2">
			<img src="image/title/title_17.png" alt="" width="74" height="45" border="0"></td>
	</tr>
	<tr>
		<td>
			<img src="image/title/title_18.png" alt="" width="15" height="33" border="0"></td>
		<td colspan="3" align="left" valign="top"><ul id="MenuBar1" class="MenuBarHorizontal">
	  <li><a href="linux_basic.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image44','','image/title/title_19.png',1)"><img src="image/title/title3_19.png" name="Image44" width="123" height="33" border="0" id="Image44" /></a>
			    <ul>
			      <li><a href="Mandrake9.0/mandrake9.0.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image46','','image/title/title_26.png',1)"><img src="image/title/title_23.png" name="Image46" width="120" height="26" border="0" id="Image46" alt="" /></a></li>
                  <li><a href="fedora_4/fc4.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image47','','image/title/title_27.png',1)"><img src="image/title/title_24.png" name="Image47" width="120" height="26" border="0" id="Image47" alt="" /></a></li>
                  <li><a href="linux_basic.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image48','','image/title/title_28.png',1)"><img src="image/title/title_25.png" name="Image48" width="120" height="26" border="0" id="Image48" alt="" /></a></li>
                </ul>
		      </li>
		</ul></td>
		<td>
			<img src="image/title/title_20.png" alt="" width="42" height="33" border="0"></td>
		<td colspan="3" align="left" valign="top"><ul id="MenuBar2" class="MenuBarHorizontal">
	  <li><a href="../linux_server/index.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image45','','image/title/title_21.png',1)"><img src="image/title/title3_21.png" name="Image45" width="125" height="33" border="0" id="Image45" /></a>
			    <ul>
			      <li><a href="../linux_server/linux_redhat9/redhat9.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image43','','image/title/title_26.png',1)"><img src="image/title/title_23.png" name="Image43" width="120" height="26" border="0" id="Image43" alt=""/></a></li>
			      <li><a href="../linux_server/centos4.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image49','','image/title/title_27.png',1)"><img src="image/title/title_24.png" name="Image49" width="120" height="26" border="0" id="Image49" alt="" /></a></li>
			      <li><a href="../linux_server/index.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image50','','image/title/title_28.png',1)"><img src="image/title/title_25.png" name="Image50" width="120" height="26" border="0" id="Image50" alt="" /></a></li>
		        </ul>
		      </li>
		</ul></td>
		<td>
			<img src="image/title/title_22.png" alt="" width="47" height="33" border="0"></td>
	</tr>
	<tr>
		<td>
			<img src="image/title/Spacer.gif" width="101" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="263" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="53" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="15" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="91" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="27" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="5" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="42" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="60" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="37" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="28" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="47" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="35" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="74" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="22" height="1" alt=""></td>
	</tr>
</table>
<!-- End ImageReady Slices -->
<script type="text/javascript">
<!--
var MenuBar1 = new Spry.Widget.MenuBar("MenuBar1", {imgDown:"SpryAssets/SpryMenuBarDownHover.gif", imgRight:"SpryAssets/SpryMenuBarRightHover.gif"});
var MenuBar2 = new Spry.Widget.MenuBar("MenuBar2", {imgDown:"SpryAssets/SpryMenuBarDownHover.gif", imgRight:"SpryAssets/SpryMenuBarRightHover.gif"});
//-->
</script>
</div>
<table summary="本文内容的排版" style="width: 898px;" border="0" cellpadding="0" cellspacing="0">
<tbody><tr><td style="width: 16px; height: 16px;">　</td>
    <td style="width: 866px; height: 16px;">　</td>
    <td style="width: 16px; height: 16px;">　</td></tr>
<tr><td style="width: 16px; font-size: 6px;">　</td>
    <td width="866">
<!-- 本文的档头部分 -->
<div style="text-align: center;">
    <a href="0510osloader.html">
    <span class="text_head0">第二十章、启动流程、模块管理与<span class="text_head_en"> Loader</span></span></a><br>
</div>
    <div style="text-align: right;">
        <span class="text_history">最近升级日期：2009/09/14</span>
    </div>
<!-- 本文的连结区部分 -->
<div class="block1">
<span class="text_h1">
3. <a href="#grub">Boot loader: Grub</a><br>
	<span class="text_h2">
	　　3.1 <a href="#grub_loader">boot loader 的两个 stage</a><br>
	　　3.2 <a href="#grub_menulist">grub 的配置档 /boot/grub/menu.lst 与菜单类型</a>： 
		<a href="#grub_hd">磁碟代号</a>, <a href="#grub_menu_lst">menu.lst</a><br>
	　　3.3 <a href="#grub_initrd">initrd 的重要性与创建新 initrd 文件</a>： <a href="#mkinitrd">mkinitrd</a><br>
	　　3.4 <a href="#grub_install">测试与安装 grub</a>： <a href="#grub-install">grub-install</a>, 
		<a href="#grubshell">grub shell</a><br>
	　　3.5 <a href="#grub_other">启动前的额外功能修改</a><br>
	　　3.6 <a href="#grub_vga">关於核心功能当中的 vga 配置</a><br>
	　　3.7 <a href="#grub_hd">BIOS 无法读取大硬盘的问题</a><br>
	　　3.8 <a href="#grub_password">为个别菜单加上口令</a>： <a href="#grub-md5-crypt">grub-md5-crypt</a><br>
	</span>
</span></div>
<!-- 本文的正式部分 -->
<hr><a name="grub"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">Boot Loader: Grub</span><br>
<div class="block1">
	<p>在看完了前面的整个启动流程，以及核心模块的整理之后，你应该会发现到一件事情，
	那就是『 boot loader 是加载核心的重要工具』啊！没有 boot loader 的话，那么
	kernel 根本就没有办法被系统加载的呢！所以，底下我们会先谈一谈 boot loader 的功能，
	然后再讲一讲现阶段 Linux 里头最主流的 grub 这个 boot loader 吧！<br><br></p>

	<hr><a name="grub_loader"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">boot loader 的两个 stage</span><br>
	<div class="block2">
		<p>我们在第一小节启动流程的地方曾经讲过，在 BIOS 读完资讯后，接下来就是会<a href="#process_2">到第一个启动装置的 MBR 去读取 boot loader</a> 了。这个 boot loader 
		可以具有菜单功能、直接加载核心文件以及控制权移交的功能等，
		系统必须要有 loader 才有办法加载该操作系统的核心就是了。但是我们都知道， <span class="text_import2">MBR 
		是整个硬盘的第一个 sector 内的一个区块，充其量整个大小也才 446 bytes 而已。</span>
		我们的 loader 功能这么强，光是程序码与配置数据不可能只占不到 446 bytes 的容量吧？那如何安装？</p>

		<p>为了解决这个问题，所以 Linux 将 boot loader 的程序码运行与配置值加载分成两个阶段 (stage) 来运行：</p>

		<ul>
		<li><span class="text_import2">Stage 1：运行 boot loader 主程序：</span><br>
		第一阶段为运行 boot loader 的主程序，这个主程序必须要被安装在启动区，亦即是 MBR 或者是 boot sector
		。但如前所述，因为 MBR 实在太小了，所以，MBR 或 boot sector 通常仅安装 boot loader 的最小主程序，
		并没有安装 loader 的相关配置档；<br><br></li>

		<li><span class="text_import2">Stage 2：主程序加载配置档：</span><br>
		第二阶段为透过 boot loader 加载所有配置档与相关的环境参数文件 (包括文件系统定义与主要配置档 menu.lst)，
		一般来说，配置档都在 /boot 底下。</li>
		</ul>

		<p>那么这些配置档是放在哪里啊？这些与 grub 有关的文件都放置到 /boot/grub 中，那我们就来看看有哪些文件吧！</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">ls -l /boot/grub</span>
-rw-r--r--  device.map              <span class="term_note">&lt;==grub 的装置对应档(底下会谈到)</span>
-rw-r--r--  e2fs_stage1_5           <span class="term_note">&lt;==ext2/ext3 文件系统之定义档</span>
-rw-r--r--  fat_stage1_5            <span class="term_note">&lt;==FAT 文件系统之定义档</span>
-rw-r--r--  ffs_stage1_5            <span class="term_note">&lt;==FFS 文件系统之定义档</span>
-rw-------  grub.conf               <span class="term_note">&lt;==grub 在 Red Hat 的配置档</span>
-rw-r--r--  iso9660_stage1_5        <span class="term_note">&lt;==光驱文件系统定义档</span>
-rw-r--r--  jfs_stage1_5            <span class="term_note">&lt;==jfs 文件系统定义档</span>
lrwxrwxrwx  menu.lst -&gt; ./grub.conf <span class="term_note">&lt;==其实 menu.lst 才是配置档！</span>
-rw-r--r--  minix_stage1_5          <span class="term_note">&lt;==minix 文件系统定义档</span>
-rw-r--r--  reiserfs_stage1_5       <span class="term_note">&lt;==reiserfs 文件系统定义档</span>
-rw-r--r--  splash.xpm.gz           <span class="term_note">&lt;==启动时在 grub 底下的背景图示</span>
-rw-r--r--  stage1                  <span class="term_note">&lt;==stage 1 的相关说明</span>
-rw-r--r--  stage2                  <span class="term_note">&lt;==stage 2 的相关说明</span>
-rw-r--r--  ufs2_stage1_5           <span class="term_note">&lt;==UFS 的文件系统定义档</span>
-rw-r--r--  vstafs_stage1_5         <span class="term_note">&lt;==vstafs 文件系统定义档</span>
-rw-r--r--  xfs_stage1_5            <span class="term_note">&lt;==xfs 文件系统定义档</span>
</pre></td></tr></tbody></table>

		<p>从上面的说明你可以知道 /boot/grub/ 目录下最重要的就是配置档 (menu.lst) 以及各种文件系统的定义！
		我们的 loader 读取了这种文件系统定义数据后，就能够认识文件系统并读取在该文件系统内的核心文件罗。
		至於 grub  的配置档档名，其实应该是 menu.lst 的，只是在 Red Hat 里面被定义成为 /boot/grub.conf 而已。
		鸟哥建议您还是记忆 menu.lst 比较好喔！</p>

		<p>所以从上面的文件来看， grub 认识的文件系统真的非常多喔！正因为如此，所以 grub
		才会取代 Lilo 这个老牌的 boot loader 嘛！好了，接下来就来瞧瞧配置档内有啥配置值吧！</p>
	</div>

	<hr><a name="grub_menulist"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">grub 的配置档 
	/boot/grub/menu.lst 与菜单类型</span><br>
	<div class="block2">
		<p>grub 是目前使用最广泛的 Linux 启动管理程序，旧的 Lilo 这个启动管理程序现在已经很少见了，
		所以本章才会将 Lilo 的介绍舍弃的说。grub 的优点挺多的，包括有：</p>

		<ul>
		<li>认识与支持较多的文件系统，并且可以使用 grub 的主程序直接在文件系统中搜寻核心档名；</li>
		<li>启动的时候，可以『自行编辑与修改启动配置项目』，类似 bash 的命令模式；</li>
		<li>可以动态搜寻配置档，而不需要在修改配置档后重新安装 grub 。亦即是我们只要修改完
			/boot/grub/menu.lst 里头的配置后，下次启动就生效了！</li>
		</ul>

		<p>上面第三点其实就是 Stage 1, Stage 2 分别安装在 MBR (主程序) 与文件系统当中 (配置档与定义档) 的原因啦！
		好了，接下来，让我们好好了解一下 grub 的配置档： /boot/grub/menu.lst 这玩意儿吧！
		要注意喔，那个 lst 是 LST 的小写，不要搞错罗！<br><br></p>

		<a name="grub_hd"></a>
		<hr><ul class="list1"><li class="text_import1">硬盘与分割槽在 grub 中的代号</li></ul>

		<p>安装在 MBR 的 grub 主程序，最重要的任务之一就是<span class="text_import2">从磁碟当中加载核心文件</span>，
		以让核心能够顺利的驱动整个系统的硬件。所以罗， grub 必须要认识硬盘才行啊！那么 grub 到底是如何认识硬盘的呢？
		嘿嘿！ grub 对硬盘的代号配置与传统的 Linux 磁碟代号可完全是不同的！grub 对硬盘的识别使用的是如下的代号：</p>

		<blockquote class="text_import2" style="font-family: '细明体';">(hd0,0)</blockquote>

		<p>够神了吧？跟 /dev/hda1 风马牛不相干～怎么办啊？其实只要注意几个东西即可，那就是：</p>

		<ul class="text_import2">
		<li>硬盘代号以小括号 ( ) 包起来；</li>
		<li>硬盘以 hd 表示，后面会接一组数字；</li>
		<li>以『搜寻顺序』做为硬盘的编号，而不是依照硬盘排线的排序！(这个重要！)</li>
		<li>第一个搜寻到的硬盘为 0 号，第二个为 1 号，以此类推；</li>
		<li>每颗硬盘的第一个 partition 代号为 0 ，依序类推。</li>
		</ul>

		<p>所以说，第一颗『搜寻到的硬盘』代号为：『(hd0)』，而该颗硬盘的第一号分割槽为『(hd0,0)』，这样说了解了吧？
		反正你要记得，在 grub 里面，他开始的数字是 0 而不是 1 就是了！</p>

		<div style="padding: 10pt 0pt;" align="right"><table width="90%"><tbody><tr><td><b>Tips:</b><br><span style="color: rgb(0, 144, 0);"><font size="-1">		在较旧的主板上面，通常第一颗硬盘会插在 IDE 1 的 master 上，就会是 /dev/hda，所以常常我们可能会误会 
		/dev/hda 就是 (hd0)，其实不是喔！要看你的 BIOS 配置值才行！有的主板 BIOS 
		可以调整启动的硬盘搜寻顺序，那么就要注意了，因为 grub 的硬盘代号可能会跟著改变呐！留意留意！
		</font></span></td><td><img src="0510osloader_files/vbird_face.gif" alt="鸟哥的图示" title="鸟哥的图示"></td></tr></tbody></table></div>
		<p>所以说，整个硬盘代号为：</p>


<table bgcolor="lightyellow" border="1" cellpadding="3" cellspacing="0" width="95%">
<tbody><tr align="center" bgcolor="#182448"><td><font color="#FFFFFF">硬盘搜寻顺序</font></td><td><font color="#FFFFFF">在 Grub  当中的代号</font></td></tr>
<tr><td align="center">第一颗</td><td>(hd0) (hd0,0) (hd0,1) (hd0,4)....</td></tr>
<tr><td align="center">第二颗</td><td>(hd1) (hd1,0) (hd1,1) (hd1,4)....</td></tr>
<tr><td align="center">第三颗</td><td>(hd2) (hd2,0) (hd2,1) (hd2,4)....</td></tr>
</tbody></table>

		<p>这样应该比较好看出来了吧？第一颗硬盘的 MBR 安装处的硬盘代号就是『(hd0)』，
		而第一颗硬盘的第一个分割槽的 boot sector 代号就是『(hd0,0)』第一颗硬盘的第一个逻辑分割槽的 
		boot sector 代号为『(hd0,4)』了了吧！</p>

<table border="1" cellpadding="5" cellspacing="0" width="90%"><tbody><tr><td>
例题：<div class="block2">
假设你的系统仅有一颗 SATA 硬盘，请说明该硬盘的第一个逻辑分割槽在 Linux 与 grub 当中的档名与代号：
</div>
答：<div class="block2">
因为是 SATA 磁碟，加上使用逻辑分割槽，因此 Linux 当中的档名为 /dev/sda5 才对 (1~4 保留给 primary 与 extended 使用)。
至於 grub 当中的磁碟代号则由於仅有一颗磁碟，因此代号会是『 (hd0,4) 』才对。
</div>
</td></tr></tbody></table><br>

		<a name="grub_menu_lst"></a>
		<hr><ul class="list1"><li class="text_import1">/boot/grub/menu.lst 配置档：</li></ul>

		<p>了解了 grub 当中最麻烦的硬盘代号后，接下来，我们就可以瞧一瞧配置档的内容了。先看一下鸟哥的 CentOS
		内的 /boot/grub/menu.lst 好了：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">vim /boot/grub/menu.lst</span>
default=0     <span class="term_note">&lt;==默认启动选项，使用第 1 个启动菜单 (title)</span>
timeout=5     <span class="term_note">&lt;==若 5 秒内未动键盘，使用默认菜单启动</span>
splashimage=(hd0,0)/grub/splash.xpm.gz <span class="term_note">&lt;==背景图示所在的文件</span>
hiddenmenu    <span class="term_note">&lt;==读秒期间是否显示出完整的菜单画面(默认隐藏)</span>
title CentOS (2.6.18-92.el5)    <span class="term_note">&lt;==第一个菜单的内容</span>
        root (hd0,0)
        kernel /vmlinuz-2.6.18-92.el5 ro root=LABEL=/1 rhgb quiet
        initrd /initrd-2.6.18-92.el5.img
</pre></td></tr></tbody></table>

		<p>在 title 以前的四行，都是属於 grub 的整体配置，包括默认的等待时间与默认的启动项目，
		还有显示的画面特性等等。至於 title 后面才是指定启动的核心文件或者是 boot loader 控制权。
		在整体配置方面的项目主要常见的有：</p>

		<ul>
		<li><span class="text_import1">default=0</span><br>
		这个必须要与 title 作为对照，在配置档里面有几个 title ，启动的时候就会有几个菜单可以选择。
		由於 grub 启始号码为 0 号，因此 default=0 代表使用『第一个 title 项目』来启动的意思。
		default 的意思是，如果在读秒时间结束前都没有动到键盘， grub 默认使用此 title 项目 (在此为 0 号) 来启动。<br><br></li>

		<li><span class="text_import1">timeout=5</span><br>
		启动时会进行读秒，如果在 5 秒钟内没有按下任何按键，就会使用上面提到的 default 后面接的那个 title 
		项目来启动的意思。如果你觉得 5 秒太短，那可以将这个数值调大 (例如 30 秒) 即可。此外，如果 timeout=0 
		代表直接使用 default 值进行启动而不读秒，timeout=-1 则代表直接进入菜单不读秒了！<br><br></li>

		<li><span class="text_import1">splashimage=(hd0,0)/grub/splash.xpm.gz</span><br>
		有没有发现你的 CentOS 在启动的时候背景不是黑白而是有色彩变化的呢？那就是这个文件提供的背景图示啦(<a href="#ps3">注3</a>)！不过这个文件的实际路径写法怎么会是这样啊？很简单啊～上述的意思是：<span class="text_import2">在 (hd0,0)	这个分割槽内的最顶层目录中，底下的 grub/splash.xpm.gz 那个文件</span>的意思。
		由於鸟哥将 /boot 这个目录独立成为 /dev/hda1 ，因此这边就会写成『在 /dev/hda1 
		里面的 grub/splash.xpm.gz 』的意思啦！想一想，如果你的 /boot 目录并没有独立成为一个分割槽，
		这里会写成如何？<br><br></li>

		<li><span class="text_import1">hiddenmenu</span><br>
		这个说的是，启动时是否要显示菜单？目前 CentOS 默认是不要显示菜单，
		如果您想要显示菜单，那就将这个配置值注解掉！</li>
		</ul>

		<p>整体配置的地方大概是这样，而底下那个 title 则是显示启动的配置项目。如同前一小节提到的，启动时可以选择
		<span class="text_import2">(1)直接指定核心文件启动或 (2)将 boot loader 控制权转移到下个 loader 
		(此过程称为 chain-loader)</span>。每个 title 后面接的是『该启动项目名称的显示』，亦即是在菜单出现时，菜单上面的名称而已。
		那么这两种方式的配置有啥不同呢？</p>

		<ol>
		<li><span class="text_import1">直接指定核心启动</span><br><br>

		既然要指定核心启动，所以当然要找到核心文件啦！此外，有可能还需要用到 initrd 的 RAM Disk 配置档。但是如前说的，
		尚未启动完成，所以我们必须要以 grub 的硬盘识别方式找出完整的 kernel 与 initrd 档名才行。
		因此，我们可能需要有底下的方式来配置才行！<br>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">1. 先指定核心文件放置的 partition，再读取文件 (目录树)，
   最后才加入文件的实际档名与路径 (kernel 与 initrd)；
   鸟哥的 /boot 为 /dev/hda1 ，因此核心文件的配置则成为：</span>
root    (hd0,0)          <span class="term_note">&lt;==代表核心文件放在那个 partition 当中</span>
kernel  /vmlinuz-2.6.18-92.el5 ro root=LABEL=/1 rhgb quiet
initrd  /initrd-2.6.18-92.el5.img
</pre></td></tr></tbody></table>

		上面的 root, kernel, initrd 后面接的参数的意义说明如下：<br><br>

		<span class="text_import2">root</span> ：代表的是『核心文件放置的那个 partition 而不是根目录』喔！不要搞错了！
		以鸟哥的案例来说，我的根目录为 /dev/hda2 而 /boot 独立为 /dev/hda1 ，因为与 /boot 有关，
		所以磁碟代号就会成为 (hd0,0) 罗。<br><br>

		<span class="text_import2">kernel</span> ：至於 kernel 后面接的则是核心的档名，而在档名后面接的则是核心的参数。
		由於启动过程中需要挂载根目录，因此 kernel 后面接的那个 root=LABEL=/1 指的是『Linux 的根目录在哪个 partition 』的意思。
		还记得<a href="0230filesystem.html#e2label">第八章谈过的 LABEL 挂载</a>功能吧？
		是的，这里使用 LABEL 来挂载根目录。至於 rhgb 为色彩显示而 quiet 则是安静模式 (萤幕不会输出核心侦测的资讯)。
		<br><br>

		<span class="text_import2">initrd</span> ：就是前面提到的 initrd 制作出 RAM Disk 的文件档名啦！<br>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">2. 直接指定 partition 与档名，不需要额外指定核心文件所在装置代号</span>
kernel  (hd0,0)/vmlinuz-2.6.18-92.el5 ro root=LABEL=/1 rhgb quiet
initrd  (hd0,0)/initrd-2.6.18-92.el5.img
</pre></td></tr></tbody></table>

		老实说，鸟哥比较喜欢这种样式的档名写法，因为这样我们就能够知道核心文件是在哪个装置内的某个档名，
		而不会去想到我们的根目录 (/, root) 啦！让我们来想想 /boot 有独立分割与无独立分割的情况吧！<br><br>

<table border="1" cellpadding="5" cellspacing="0" width="90%"><tbody><tr><td>
例题：<div class="block2">
我的系统分割是： /dev/hda1 (/), /dev/hda2 (swap) 而已，且我的核心文件为 /boot/vmlinuz，请问 grub 的 menu.lst 
内该如何撰写核心文件位置？
</div>
答：<div class="block2">
我们使用叠代的方式来了解一下好了。由於核心档名为 /boot/vmlinuz，转成装置档名与代号会成为如下的过程：<pre>原始文件：  <u>/</u>boot/vmlinuz ↓
Linux 装置：<u>(/dev/hda1)</u>/boot/vmlinuz ↓
grub  装置：<u>(hd0,0)</u>/boot/vmlinuz</pre>
所以最终的 kernel 写法会变成：
<blockquote class="text_import2" style="font-family: '细明体';">kernel (hd0,0)/boot/vmlinuz root=/dev/hda1 ...</blockquote>
</div>
</td></tr></tbody></table><br>

<table border="1" cellpadding="5" cellspacing="0" width="90%"><tbody><tr><td>
例题：<div class="block2">
同上，只是我的分割情况变成： /dev/sda1 (/boot), /dev/sda5 (/) 时？
</div>
答：<div class="block2">
由於 /boot 被独立出来了，所以情况会不一样喔！如下所示：<pre>原始文件：  <u>/boot</u>/vmlinuz ↓
Linux 装置：<u>(/dev/sda1)</u>/vmlinuz ↓
grub  装置：<u>(hd0,0)</u>/vmlinuz</pre>
所以最终的 kernel 写法会变成：
<blockquote class="text_import2" style="font-family: '细明体';">kernel (hd0,0)/vmlinuz root=/dev/sda5 ...</blockquote>
</div>
</td></tr></tbody></table><br></li>

		<li><span class="text_import1">利用 chain loader 的方式转交控制权</span><br><br>

		所谓的 chain loader (启动管理程序的链结) 仅是在将控制权交给下一个 boot loader 而已，
		所以 grub 并不需要认识与找出 kernel 的档名 ，『 <span class="text_import2">他只是将 boot
		的控制权交给下一个 boot sector 或 MBR 内的 boot loader 而已</span> 』
		所以通常他也不需要去查验下一个 boot loader 的文件系统！<br><br>

		一般来说， chain loader 的配置只要两个就够了，一个是预计要前往的 boot sector 所在的分割槽代号，
		另一个则是配置 chainloader 在那个分割槽的 boot sector (第一个磁区) 上！假设我的 Windows 分割槽在 
		/dev/hda1 ，且我又只有一颗硬盘，那么要 grub 将控制权交给 windows 的 loader 只要这样就够了：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">vi /boot/grub/menu.lst</span>
<span class="term_say">....前略....</span>
title Windows partition
	root (hd0,0)    <span class="term_note">&lt;==配置使用此分割槽</span>
	chainloader +1  <span class="term_note">&lt;== +1 可以想成第一个磁区，亦即是 boot sector</span>
</pre></td></tr></tbody></table>

		上面的范例中，我们可以很简单的这样想：那个 (hd0,0) 就是 Windows 的 C 槽所在磁碟，
		而 chainloader +1 就是让系统加载该分割槽当中的第一个磁区 (就是 boot sector) 内的启动管理程序。
		不过，由於 Windows 的启动碟需要配置为活化 (active) 状态，且我们的 grub 默认会去检验该分割槽的文件系统。
		因此我们可以重新将上面的范例改写成这样：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">vi /boot/grub/menu.lst</span>
<span class="term_say">....前略....</span>
title Windows partition
	rootnoverify (hd0,0)   <span class="term_note">&lt;==不检验此分割槽</span>
	chainloader +1
	makeactive             <span class="term_note">&lt;==配置此分割槽为启动碟(active)</span>
</pre></td></tr></tbody></table>

		grub 的功能还不止此，他还能够隐藏某些分割槽。举例来说，我的 /dev/hda5 是安装 Linux 的分割槽，
		我不想让 Windows 能够认识这个分割槽时，你可以这样做：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">vi /boot/grub/menu.lst</span>
<span class="term_say">....前略....</span>
title Windows partition
	hide (hd0,4)           <span class="term_note">&lt;==隐藏 (hd0,4) 这个分割槽</span>
	rootnoverify (hd0,0)
	chainloader +1
	makeactive
</pre></td></tr></tbody></table>

		</li></ol>
	</div>

	<hr><a name="grub_initrd"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">initrd 的重要性与创建新 
	initrd 文件</span><br>
	<div class="block2">
		<p>我们在本章稍早之前『 <a href="#startup_loader">boot loader 与 kernel 加载</a>』的地方已经提到过 initrd 
		这玩意儿，他的目的在於提供启动过程中所需要的最重要核心模块，以让系统启动过程可以顺利完成。
		会需要 initrd 的原因，是因为核心模块放置於 /lib/modules/$(uname -r)/kernel/ 当中，
		这些模块必须要根目录 (/) 被挂载时才能够被读取。但是如果核心本身不具备磁碟的驱动程序时，
		当然无法挂载根目录，也就没有办法取得驱动程序，因此造成两难的地步。</p>

		<p>initrd 可以将 /lib/modules/.... 内的『启动过程当中一定需要的模块』包成一个文件 (档名就是 initrd)，
		然后在启动时透过主机的 INT 13 硬件功能将该文件读出来解压缩，并且 initrd 在内存内会模拟成为根目录，
		由於此虚拟文件系统 (Initial RAM Disk) 主要包含磁碟与文件系统的模块，因此我们的核心最后就能够认识实际的磁碟，
		那就能够进行实际根目录的挂载啦！所以说：『<span class="text_import2">initrd
		内所包含的模块大多是与启动过程有关，而主要以文件系统及硬盘模块 (如 usb, SCSI 等) 为主</span>』的啦！</p>

		<p>一般来说，需要 initrd 的时刻为：</p>

		<ul class="text_import2">
		<li>根目录所在磁碟为 SATA、U盘 或 SCSI 等连接介面；</li>
		<li>根目录所在文件系统为 LVM, RAID 等特殊格式；</li>
		<li>根目录所在文件系统为非传统 Linux 认识的文件系统时；</li>
		<li>其他必须要在核心加载时提供的模块。</li>
		</ul>

		<div style="padding: 10pt 0pt;" align="right"><table width="90%"><tbody><tr><td><b>Tips:</b><br><span style="color: rgb(0, 144, 0);"><font size="-1">		之前鸟哥忽略 initrd 这个文件的重要性，是因为鸟哥很穷... ^_^。因为鸟哥的 Linux 主机都是较早期的硬件，
		使用的是 IDE 介面的硬盘，而且并没有使用 LVM 等特殊格式的文件系统，而 Linux 核心本身就认识 IDE 介面的磁碟，
		因此不需要 initrd 也可以顺利启动完成的。<u>自从 SATA 硬盘流行起来后，没有 initrd 就没办法启动了</u>！
		因为 SATA 硬盘使用的是 SCSI 模块来驱动的，而 Linux 默认将 SCSI 功能编译成为模块....
		</font></span></td><td><img src="0510osloader_files/vbird_face.gif" alt="鸟哥的图示" title="鸟哥的图示"></td></tr></tbody></table></div>
		<p>一般来说，各 distribution 提供的核心都会附上 initrd 文件，但如果你有特殊需要所以想重制 initrd 文件的话，
		可以使用 mkinitrd 来处理的。这个文件的处理方式很简单， man mkinitrd 就知道了！ ^_^。
		我们还是简单的介绍一下去！</p>

<a name="mkinitrd"></a>
<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">mkinitrd [-v] [--with=模块名称] initrd档名 核心版本</span>
<span class="term_say">选项与参数：
-v  ：显示 mkinitrd 的运行过程
--with=模块名称：模块名称指的是模块的名字而已，不需要填写档名。举例来说，
       目前核心版本的 ext3 文件系统模块为底下的档名：
       /lib/modules/$(uname -r)/kernel/fs/ext3/ext3.ko
       那你应该要写成： --with=ext3 就好了 (省略 .ko)
initrd档名：你所要创建的 initrd 档名，尽量取有意义又好记的名字。
核心版本  ：某一个核心的版本，如果是目前的核心则是『 $(uname -r) 』</span>

<span class="term_hd">范例一：以 mkinitrd 的默认功能创建一个 initrd 虚拟磁碟文件</span>
[root@www ~]# <span class="term_command">mkinitrd -v initrd_$(uname -r) $(uname -r)</span>
Creating initramfs
Looking for deps of module ehci-hcd
Looking for deps of module ohci-hcd
<span class="term_say">....(中间省略)....</span>
Adding module ehci-hcd  <span class="term_note">&lt;==最终加入 initrd 的就是底下的模块</span>
Adding module ohci-hcd
Adding module uhci-hcd
Adding module jbd
Adding module ext3
Adding module scsi_mod
Adding module sd_mod
Adding module libata
Adding module pata_sis

[root@www ~]# <span class="term_command">ll initrd_*</span>
-rw------- 1 root root 2406443 Apr 30 02:55 initrd_2.6.18-92.el5
<span class="term_say"># 由於目前的核心版本可使用 uname -r 取得，因此鸟哥使用较简单的命令来处理罗～
# 此时 initrd 会被创建起来，你可以将他移动到 /boot 等待使用。</span>

<span class="term_hd">范例二：添加 8139too 这个模块的 initrd 文件</span>
[root@www ~]# <span class="term_command">mkinitrd -v --with=8139too initrd_vbirdtest $(uname -r)</span>
<span class="term_say">....(前面省略)....</span>
Adding module mii
Adding module 8139too  <span class="term_note">&lt;==看到没！这样就加入了！</span>
</pre></td></tr></tbody></table>

		<p>initrd 创建完成之后，同时核心也处理完毕后，我们就可以使用 grub 来创建菜单了！底下继续瞧一瞧吧！</p>
	</div>

	<hr><a name="grub_install"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">测试与安装 grub</span><br>
	<div class="block2">
		<p>如果你的 Linux 主机本来就是使用 grub 作为 loader 的话，那么你就不需要重新安装 grub 了，
		因为 grub 本来就会主动去读取配置档啊！您说是吧！但如果你的 Linux 原来使用的并非 grub ，
		那么就需要来安装啦！如何安装呢？首先，你必须要使用 grub-install 将一些必要的文件复制到
		/boot/grub 里面去，你应该这样做的：</p>

		<div style="padding: 10pt 0pt;" align="right"><table width="90%"><tbody><tr><td><b>Tips:</b><br><span style="color: rgb(0, 144, 0);"><font size="-1">		安装些什么呢？因为 boot loader 有两个 stage ，而配置档得要放置到适当的地方。
		这个 grub-install 就是在安装配置档 (包括文件系统定义档与 menu.lst 等等) 而已！
		如果要将 grub 的 stage1 主程序安装起来，就得要使用 grub shell 的功能喔！本章稍后会介绍。
		</font></span></td><td><img src="0510osloader_files/vbird_face.gif" alt="鸟哥的图示" title="鸟哥的图示"></td></tr></tbody></table></div>
<a name="grub-install"></a>
<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">grub-install [--root-directory=DIR] INSTALL_DEVICE</span>
<span class="term_say">选项与参数：
--root-directory=DIR 那个 DIR 为实际的目录，使用 grub-install 默认会将
  grub 所有的文件都复制到 /boot/grub/* ，如果想要复制到其他目录与装置去，
  就得要用这个参数。
INSTALL_DEVICE 安装的装置代号啦！</span>

<span class="term_hd">范例一：将 grub 安装在目前系统的 MBR 底下，我的系统为 /dev/hda：</span>
[root@www ~]# <span class="term_command">grub-install /dev/hda</span>
<span class="term_say"># 因为原本 /dev/hda 就是使用 grub ，所以似乎不会出现什么特别的信息。
# 如果去查阅一下 /boot/grub 的内容，会发现所有的文件都升级了，因为我们重装了！</span>

<span class="term_hd">范例二：我的 /home 为独立的 /dev/hda3 ，如何安装 grub 到 /dev/hda3 (boot sector)</span>
[root@www ~]# <span class="term_command">grub-install --root-directory=/home /dev/hda3</span>
Probing devices to guess BIOS drives. This may take a long time.
Installation finished. No error reported.
This is the contents of the device map <span class="term_write">/home/boot/grub/device.map.</span>
Check if this is correct or not. If any of the lines is incorrect,
fix it and re-run the script `grub-install'.

(fd0)   /dev/fd0
(hd0)   /dev/hda   <span class="term_note">&lt;==会给予装置代号的对应表！</span>

[root@www ~]# <span class="term_command">ll /home/boot/grub/</span>
-rw-r--r-- 1 root root     30 Apr 30 11:12 device.map
-rw-r--r-- 1 root root   7584 Apr 30 11:12 e2fs_stage1_5
<span class="term_say">....(底下省略)....</span>
<span class="term_say"># 看！文件都安装进来了！但是注意到，我们并没有配置档喔！那要自己创建！</span>
</pre></td></tr></tbody></table>

		<p>所以说， <span class="text_import2">grub-install 是安装 grub 相关的文件 (例如文件系统定义档) 
		到你的装置上面去等待在启动时被读取，但还需要配置好配置档 (menu.lst) 后，再以 grub shell 来安装 grub 主程序到 
		MBR 或者是 boot sector 上面去喔</span>！好了，那我们来思考一下想要安装的数据。</p>

<table border="1" cellpadding="5" cellspacing="0" width="90%"><tbody><tr><td>
例题：<div class="block2">
我预计启动时要直接显示菜单，且菜单倒数为 30 秒。另外，在原本的 menu.lst 当中新增三个启动菜单，分别如下说明：
<ol><li>假设 /dev/hda1 内含有 boot loader ，此 loader 如何取得控制权？</li>
<li>如何重新读取 MBR 内的 loader ？</li>
<li>利用你原本的系统核心文件，创建一个可强制进入单人维护模式的菜单</li>
</ol>
</div>
答：<div class="block2">
第一点很简单，就利用上一小节的说明来处理即可。至於第二点，MBR 的读取读的是整颗硬盘的第一个磁区，
因此 root (hd0) 才是对的。第三点则与核心的后续参数有关。整个文件可以被改写成这样：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">vim /boot/grub/menu.lst</span>
default=0
<span class="term_write">timeout=30</span>
splashimage=(hd0,0)/grub/splash.xpm.gz
<span class="term_write">#hiddenmenu</span>
title CentOS (2.6.18-92.el5)
        root (hd0,0)
        kernel /vmlinuz-2.6.18-92.el5 ro root=LABEL=/1 rhgb quiet
        initrd /initrd-2.6.18-92.el5.img
title /dev/hda1 boot sector  <span class="term_note">&lt;==本例中的第一个新增菜单</span>
        root (hd0,0)
        chainloader +1
title MBR loader             <span class="term_note">&lt;==新增的第二个菜单</span>
        root (hd0)           <span class="term_note">&lt;==MBR 为整颗磁碟的第一个磁区，所以用整颗磁碟的代号</span>
        chainloader +1
title single user mode       <span class="term_note">&lt;==新增的第三个菜单(其实由原本的title复制来的)</span>
        root (hd0,0)
        kernel /vmlinuz-2.6.18-92.el5 ro root=LABEL=/1 rhgb quiet <span class="term_write">single</span>
        initrd /initrd-2.6.18-92.el5.img
</pre></td></tr></tbody></table>

	下次启动时，你就会发现有四个菜单可以选择，而默认会以第一个菜单来启动喔！
</div>
</td></tr></tbody></table><br>

		<a name="grubshell"></a>
		<p>我们已经将配置档处理完毕，但是你要知道的是，我们并不知道 /dev/hda1 到底有没有包含 grub 的主程序，
		因此我们想要将 grub 主程序再次的安装到 /dev/hda1 的 boot sector  ，也想要重新安装 grub 到 MBR 上面去。
		此时我们就得要使用 grub shell 罗！整个安装与 grub shell 的动作其实很简单，
		如果您有兴趣研究的话，可以使用 info grub 去查阅～鸟哥这里仅介绍几个有用的命令而已。</p>

		<ul class="text_import2">
		<li>用『 root (hdx,x) 』选择含有 grub 目录的那个 partition 代号；</li>
		<li>用『 find /boot/grub/stage1 』看看能否找到安装资讯文件；</li>
		<li>用『 find /boot/vmlinuz 』看看能否找到 kernel file (不一定要成功！)；</li>
		<li>用『 setup (hdx,x) 』或『 setup (hdx) 』将 grub 安装在 boot sector 或 MBR；</li>
		<li>用『 quit 』来离开 grub shell ！</li>
		</ul>

		<p>由於我们最需要安装的就是那个 stage1 啦！那才是 grub 的主程序嘛！而且配置档通常与主程序摆在同一个目录下。
		因此我们需要使用 root (hd0,0) 去找到 /boot/grub/stage1 喔！接下来，请用 grub 来进入 grub shell 吧！进入 
		grub 后，会出现一个『 grub&gt; 』的提示字节啊！</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">grub</span>

<span class="term_hd"># 1. 先配置一下含有 grub 目录的那个 partition 啊！</span>
grub&gt; <span class="term_command">root (hd0,0)</span>
 Filesystem type is ext2fs, partition type 0x83
<span class="term_say"># 鸟哥主机的分割中，/boot/grub 在 /boot 的分割槽，亦即是 /dev/hda1 内喔！
# 另外， grub 也能够分辨出该分割槽的文件系统 (ext2)。</span>

<span class="term_hd"># 2. 搜寻一下，是否存在 stage1 这个资讯文件？</span>
grub&gt; <span class="term_command">find /boot/grub/stage1</span>
 (hd0,2)
<span class="term_say"># 见鬼！怎么会只有一个！我们明明有 /boot/grub 与 /home/boot/grub 啊！
# 因为 /boot 是独立的，因此要找到该档名就得要用如下的方式：</span>

grub&gt; <span class="term_command">find /grub/stage1</span>
 (hd0,0)
<span class="term_say"># 这样就能够找到罗！要特别注意 grub 找到不是目录树，而是装置内的文件。</span>

<span class="term_hd"># 3. 搜寻一下是否可以找到核心？ /boot/vmlinuz-2.6.18-92.el5 ？</span>
grub&gt; <span class="term_command">find /boot/vmlinuz-2.6.18-92.el5</span>
Error 15: File not found
grub&gt; <span class="term_command">find /vmlinuz-2.6.18-92.el5</span>
 (hd0,0)
<span class="term_say"># 再次强调，因为 /boot/ 是独立的，因此就会变成上头的模样罗！</span>

<span class="term_hd"># 4. 将主程序安装上去吧！安装到 MBR 看看！</span>
grub&gt; <span class="term_command">setup (hd0)</span>
 Checking if "/boot/grub/stage1" exists... no <span class="term_note">&lt;==因为 /boot 是独立的</span>
 Checking if "/grub/stage1" exists... yes     <span class="term_note">&lt;==所以这个档名才是对的！</span>
 Checking if "/grub/stage2" exists... yes
 Checking if "/grub/e2fs_stage1_5" exists... yes
 Running "embed /grub/e2fs_stage1_5 (hd0)"...  15 sectors are embedded.
succeeded
 Running "install /grub/stage1 (hd0) (hd0)1+15 p (hd0,0)/grub/stage2 
/grub/grub.conf"... succeeded  <span class="term_note">&lt;==将 stage1 程序安装妥当罗！</span>
Done.
<span class="term_say"># 很好！确实有装起来～这样 grub 就在 MBR 当中了！</span>

<span class="term_hd"># 5. 那么重复安装到我的 /dev/hda1 呢？亦即是 boot sector 当中？</span>
grub&gt; <span class="term_command">setup (hd0,0)</span>
 Checking if "/boot/grub/stage1" exists... no
 Checking if "/grub/stage1" exists... yes
 Checking if "/grub/stage2" exists... yes
 Checking if "/grub/e2fs_stage1_5" exists... yes
 Running "embed /grub/e2fs_stage1_5 (hd0,0)"... <span class="term_write">failed (this is not fatal)</span>
 Running "embed /grub/e2fs_stage1_5 (hd0,0)"... <span class="term_write">failed (this is not fatal)</span>
 Running "install /grub/stage1 (hd0,0) /grub/stage2 p /grub/grub.conf "... 
<span class="term_write">succeeded</span>
Done.
<span class="term_say"># 虽然无法将 stage1_5 安装到 boot sector 去，不过，还不会有问题，
# 重点是最后面那个 stage1 要安装后，显示 succeeded 字样就可以了！</span>

grub&gt; <span class="term_command">quit</span>
</pre></td></tr></tbody></table>

		<p>如此一来，就已经将 grub 安装到 MBR 及 /dev/hda1 的 boot sector 里面去了！
		而且读取的是 (hd0,0) 里面的 /grub/menu.lst 那个文件喔！真是很重要啊！重要到不行！</p>

		<p>最后总结一下：</p>
		<ol class="text_import2">
		<li>如果是从其他 boot loader 转成 grub 时，得先使用 grub-install 安装 grub 配置档；</li>
		<li>开始编辑 menu.lst 这个重要的配置档；</li>
		<li>透过 grub 来将主程序安装到系统中，如 MBR 的 (hd0) 或 boot sector 的 (hd0,0) 等等。</li>
		</ol>
	</div>

	<hr><a name="grub_other"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">启动前的额外功能修改</span><br>
	<div class="block2">
		<p>事实上，上一个小节配置好之后，你的 grub 就已经在你的 Linux 系统上面了，而且同时存在於
		MBR 与 boot sector 当中呢！所以，我们已经可以重新启动来查阅看看啦！
		另外，如果你正在进行启动，那么请注意，我们可以在默认菜单 (鸟哥的范例当中是 30 秒) 按下任意键，
		还可以进行 grub 的『线上编修』功能喔！真是棒啊！先来看看启动画面吧！</p>

		<center><img src="0510osloader_files/grub-01.jpg" alt="grub 启动画面示意图" title="grub 启动画面示意图" border="1"><br>
		图 3.5.1、grub 启动画面示意图<br></center>

		<p>由於鸟哥将隐藏菜单的功能取消了，因此你会直接看到这四个菜单，同时会有读秒的咚咚在倒数。
		菜单部分的画面其实就是 title 后面的文字啦！你现在知道如何修改 title 后面的文字了吧！ ^_^。
		如果你使用上下键去选择第二 (/dev/hda1 boot sector) 或第三 (MBR loader) 时，会发现同样的画面重复出现！
		这是因为那两个是 loader 移交而已嘛！而我们都使用相同的 grub 与相同的 menu.lst 配置档！
		因此这个画面就会重复出现了！这样了解乎？</p>

		<p>另外，如果你再仔细看的话，会发现到上图中底部还有一些细部的选项，似乎有个 'e' edit 的样子！
		没错～ grub 支持线上编修命令喔！这是个很有用的功能！假如刚刚你将 menu.lst 的内容写错了，导致出现无法启动的问题时，
		我们可以查阅该 title 菜单的内容并加以修改喔！举例来说，我想要知道第一个菜单的实际内容时，将反白光棒移动到第一个菜单，
		再按下 'e' 会进入如下画面：</p>

		<center><img src="0510osloader_files/grub-02.jpg" alt="grub 单一菜单内容" title="grub 单一菜单内容" border="1"><br>
		图 3.5.2、grub 单一菜单内容<br></center>

		<p>哈哈！这不就是我们在 menu.lst 里面配置的东西吗？没错！此时你还可以继续进一步修改喔！
		注意看到上图最底下的说明，你还可以使用：</p>

		<ul>
		<li>e：进入 grub shell 的编辑画面；</li>
		<li>o：在光标所在行底下再新增一行；</li>
		<li>d：将光标所在行删除。</li></ul>

		<p>我们说过， grub 是可以直接使用核心文件来启动的，所以，如果您很清楚的知道你的根目录 (/) 
		在那个 partition ，而且知道你的核心文件档名 (通常都会有个 /boot/vmlinuz 连结到正确的档名)，
		那么直接在图三的画面当中，以上述的 o, d, e 三个按键来编修，成为类似底下这样：</p>

		<center><img src="0510osloader_files/grub-03.jpg" alt="grub edit 的线上编修功能" title="grub edit 的线上编修功能" border="1"><br>
		图 3.5.3、grub edit 的线上编修功能<br></center>

		<p>按下 [Enter] 按键后，然后输入 b 来 boot ，就可以启动啦！所以说，万一你的 /boot/grub/menu.lst 
		配置错误，或者是因为安装的缘故，或者是因为核心文件的缘故，导致无法顺利启动时，记得啊，可以在 grub 的菜单部分，
		使用 grub shell 的方式去查询 (find) 或者是直接指定核心文件，就能够启动啦！ ^_^</p>

		<p>另外，很多时候我们的 grub 可能会发生错误，导致『连 grub 都无法启动』，那么根本就无法使用
		grub 的线上编修功能嘛！怎么办？没关系啊！我们可以利用具有 grub 启动的 CD 来启动，
		然后再以 CD 的 grub 的线上编修，嘿嘿！同样可以使用硬盘上面的核心文件来启动啦！很好玩吧！ ^_^</p>
	</div>

	<hr><a name="grub_vga"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">关於核心功能当中的 vga 配置</span><br>
	<div class="block2">
		<p>事实上，你的 tty1~tty6 除了 80x24 的解析度外，还能够有其他解析度的支持喔！但前提之下是你的核心必须支持
		FRAMEBUFFER_CONSOLE 这个核心功能选项才行。如何确定有没有支持呢？你可以查阅 /boot/config-2.6.18-92.el5 
		这个文件，然后这样搜寻：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">grep 'FRAMEBUFFER_CONSOLE' /boot/config-2.6.18-92.el5</span>
CONFIG_FRAMEBUFFER_CONSOLE=y
<span class="term_say"># 这个项目如果出现 y 那就是有支持啦！如果被注解或是 n ，那就是没支持啦！</span>
</pre></td></tr></tbody></table>

		<p>那么如何调整 tty1 ~ tty6 终端机的解析度呢？先参考底下的表格再说 (此为十进位数值)：</p>


<table bgcolor="lightyellow" border="1" cellpadding="3" cellspacing="0" width="95%">
<tbody><tr align="center" bgcolor="#182448"><td><font color="#FFFFFF">彩度\解析度</font></td><td><font color="#FFFFFF">640x480</font></td><td><font color="#FFFFFF">800x600</font></td><td><font color="#FFFFFF">1024x768</font></td>
	<td><font color="#FFFFFF">1280x1024</font></td><td><font color="#FFFFFF">bit</font></td></tr>
<tr align="center"><td bgcolor="#182448"><font color="#FFFFFF">256</font></td><td>769</td><td>771</td><td>773</td><td>775</td><td>8 bit</td></tr>
<tr align="center"><td bgcolor="#182448"><font color="#FFFFFF">32768</font></td><td>784</td><td>787</td><td>790</td><td>793</td><td>15 bit</td></tr>
<tr align="center"><td bgcolor="#182448"><font color="#FFFFFF">65536</font></td><td>785</td><td>788</td><td>791</td><td>794</td><td>16 bit</td></tr>
<tr align="center"><td bgcolor="#182448"><font color="#FFFFFF">16.8M</font></td><td>786</td><td>789</td><td>792</td><td>795</td><td>32 bit</td></tr>
</tbody></table>

		<p>假设你想要将你的终端机萤幕解析度调整到 1024x768 ，且色彩深度为 15bit 色的时候，就得要指定 vga=790 那个数字！
		举例来说，鸟哥的 tty1 就想要这样的解析度时，你可以这样做：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">vim /boot/grub/menu.lst</span>
<span class="term_say">....(前面省略)....</span>
title CentOS (2.6.18-92.el5)
        root (hd0,0)
        kernel /vmlinuz-2.6.18-92.el5 ro root=LABEL=/1 rhgb quiet <span class="term_write">vga=790</span>
        initrd /initrd-2.6.18-92.el5.img
<span class="term_say">....(后面省略)....</span>
</pre></td></tr></tbody></table>

		<p>重新启动并选择此菜单进入 Linux，你跑到 tty1 去看看，嘿嘿！就已经是 1024x768 的解析度罗！
		只是字会变的很小，但是画面的范围会加大就是了。不过，某些版本支持的是 16 进位制，所以还需要修改一下格式呢！
		一般使用上表当中的值应该就可以了。不过，由於不同的操作系统与硬件可能会有不一样的情况，因此，
		上面的值不见得一定可以在您的机器上面测试成功，建议您可以分别配置看看哩～以找出可以使用的值！ ^_^</p>
	</div>

	<hr><a name="grub_hd"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">BIOS 无法读取大硬盘的问题</span><br>
	<div class="block2">
		<p>现今的硬盘容量越来越大，如果你使用旧的主板来安插大容量硬盘时，可能由於系统 BIOS 或者是其他问题，
		导致 BIOS 无法判断该硬盘的容量，此时你的系统读取可能会有问题。为什么呢？</p>

		<p>我们在本章一开始的启动流程讲过，当进入 Linux 核心功能后，他会主动的再去侦测一下整个系统，
		因此 BIOS 捉不到的硬件在 Linux 核心反而可能会可以捉到而正常使用。举例来说，过去很多朋友常常会发现，
		『<span class="text_import2">我的系统使用 DVD 启动安装时，可以顺利的安装好 Linux ，但是第一次启动时，
		萤幕只出现黑压压的一片，且出现 grub&gt; 的字样，而无法进入 Linux 系统中</span>』，这又是怎么一回事？</p>

		<ul>
		<li>在安装的过程中，由於是使用 DVD 或 CD 启动，因此加载 Linux 核心不成问题，而核心会去侦测系统硬件，因此可以捉到
		BIOS 捉不到的硬盘，此时你确实可以安装 Linux 在大容量的硬盘上，且不会出现任何问题。<br><br></li>
		<li>但是在进入硬盘启动时，由於 kernel 与 initrd 文件都是透过 BIOS 的 INT 13 通道读取的，
		因此你的 kernel 与 initrd  如果放置在 BIOS 无法判断的磁区中，当然就无法被系统加载，而仅会出现 grub shell (grub&gt;)
		等待你的处理而已。</li>
		</ul>

		<p>更多 grub 错误的代码查询可以到底下的连结查阅：</p>
		<ul><li><a href="http://orgs.man.ac.uk/documentation/grub/grub_toc.html#SEC_Contents" target="_blank">http://orgs.man.ac.uk/documentation/grub/grub_toc.html#SEC_Contents</a></li></ul>

		<p>现在你知道问题所在啦！那就是 <span class="text_import2">BIOS 无法读取大容量磁碟内的 kernel 与 initrd 文件</span>。
		那如何解决呢？很简单啦！就让 kernel 与 initrd 文件放置在大硬盘的最前头，由於 BIOS 至少可以读到大磁碟的
		1024 磁柱内的数据，因此就能够读取核心与虚拟文件系统的文件罗。那如何让 kernel 与 initrd 
		放置到整颗硬盘的最前面呢？简单的要命吧！就<span class="text_import2">创建 /boot 独立分割槽，并将 /boot 
		放置到最前面</span>即可！更多其他的解决方案可参考文后的延伸阅读(<a href="#ps4">注4</a>)</p>

		<p>万一你已经安装了 Linux 且发生了上述的问题，那该怎办？你可以这样作的：</p>

		<ul>
		<li>最简单的做法，就是直接重灌，并且制作出 /boot 挂载的 partition ，同时确认该 partition 是在 1024 cylinder 
		之前才行。<br><br></li>
		<li>如果实在不想重灌，没有关系，利用我们刚刚上头提到的 grub 功能，额外创建一个可启动软盘，
		或者是直接以光驱启动，然后以 grub 的编写能力进入 Linux 。<br><br></li>
		<li>另外的办法其实是骗过 BIOS ，直接将硬盘的 cylinder, head, sector 等等资讯直接写到
		BIOS 当中去，如此一来你的 BIOS 可能就可以读得到与支持的到你的大硬盘了。</li>
		</ul>

		<p>不过，鸟哥还是建议您可以重新安装，并且制作出 /boot 这个 partition 啦！ ^_^！这也是为啥这次更版中，
		鸟哥特别强调要分割出 /boot 这个分割槽的原因啊！</p>
	</div>

	<hr><a name="grub_password"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">为个别菜单加上口令</span><br>
	<div class="block2">
		<p>想像一个环境，如果你管理的是一间计算机教室，这间计算机教室因为可对外开放，但是你又担心某些 partition 
		被学生不小心的弄乱，因此你可能会想要将某些启动菜单作个保护。这个时候，为每个菜单作个加密的口令就是个可行的方案啦！
		那如何在启动的过程里面提供口令保护呢？首先，你必须要创建口令，而且还需要是加密过后的喔！
		否则人家跑到 /boot/grub/menu.lst 不就可以探查到你的启动口令了？那如何创建加密的口令呢？
		我们可以透过 grub 提供的 md5 编码来处理的，如下所示：</p>

<a name="grub-md5-crypt"></a>
<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">grub-md5-crypt</span>
Password: <span class="term_note">&lt;==输入口令</span>
Retype password: <span class="term_note">&lt;==再输入一次</span>
$1$kvlI0/$byrbNgkt/.REKPQdfg287. <span class="term_note">&lt;==这就是产生的 md5 口令！</span>
</pre></td></tr></tbody></table>

		<p>上面产生的最后一行，由 $ 开始到 . 结束的那行，就是你的口令经过 md5 编码过后的咚咚！
		将这个口令复制下来吧！假设我们要将第一个选项加入这个口令，而第四个选项加入另外的口令，
		那你应该要这样做：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">vim /boot/grub/menu.lst</span>
<span class="term_say">....(前面省略)....</span>
title CentOS (2.6.18-92.el5)
        <span class="term_write">password --md5 $1$kvlI0/$byrbNgkt/.REKPQdfg287.</span>
        root (hd0,0)
        kernel /vmlinuz-2.6.18-92.el5 ro root=LABEL=/1 rhgb quiet vga=790
        initrd /initrd-2.6.18-92.el5.img
<span class="term_say">....(中间省略)....</span>
title single user mode
        <span class="term_write">password --md5 $1$GFnI0/$UuiZc/7snugLtVN4J/WyM/</span>
        root (hd0,0)
        kernel /vmlinuz-2.6.18-92.el5 ro root=LABEL=/1 rhgb quiet single
        initrd /initrd-2.6.18-92.el5.img
</pre></td></tr></tbody></table>

		<p>上表的案例中，我们两个菜单进入的口令并不相同，可以进行同学的分类啦！不过这样也造成一个问题，
		那就是一定要输入口令才能够进入启动流程，如果你在远程使用 reboot 重新启动，并且主机前面并没有任何人的话....
		你的主机并不会主动进入启动程序喔！ ^_^</p>

		<p>你必须要注意的是：<span class="text_import2">password 这个项目一定要在 title 底下的第一行</span>。
		不过，此项功能还是可能被破解的，因为使用者可以透过编辑模式 (e) 进入菜单，并删除口令栏位并按下 b 
		就能够进行启动流程了！真糟糕！那怎办？只好透过整体的 password (放在所有的 title 之前) ，
		然后在 title 底下的第一行配置 lock ，那使用者想要编辑时，也得要输入口令才行啊！配置有点像这样：</p>

<table class="term"><tbody><tr><td class="term"><pre>[root@www ~]# <span class="term_command">vim /boot/grub/menu.lst</span>
default=0
timeout=30
<span class="term_write">password --md5 $1$kvlI0/$byrbNgkt/.REKPQdfg287.</span>  <span class="term_note">&lt;==放在整体配置处</span>
splashimage=(hd0,0)/grub/splash.xpm.gz
#hiddenmenu
title CentOS (2.6.18-92.el5)
        <span class="term_write">lock</span>  <span class="term_note">&lt;==多了锁死的功能</span>
        root (hd0,0)
        kernel /vmlinuz-2.6.18-92.el5 ro root=LABEL=/1 rhgb quiet vga=790
        initrd /initrd-2.6.18-92.el5.img
</pre></td></tr></tbody></table>

		<p>那么重新启动后，画面会像这样：</p>

		<center><img src="0510osloader_files/grub-04.jpg" alt="grub 加密的示意图" title="grub 加密的示意图" border="1"><br>
		图 3.8.1、 grub 加密的示意图<br></center>

		<p>你可以看到最下方仅出现 p 的功能，由於 2, 3, 4 菜单并没有使用 lock ，因此这三个菜单使用者还是可以运行启动程序，
		但是第一个菜单由於有 lock 项目，因此除非你输入正确的口令，否则第一个菜单是无法被加载运行的。
		另外，这个项目也能够避免你的 menu.lst 在启动的过程中被乱改，是具有保密 menu.lst 的功能啦！
		与刚刚的菜单口令功能不同。</p>
	</div>
</div>
<hr />
    </td>
    <td style="width: 16px; font-size: 6px;">　</td></tr>
<tr><td style="width: 16px; height: 16px;">　</td>
    <td style="width: 866px; height: 16px;">　</td>
    <td style="width: 16px; height: 16px;">　</td></tr>
</tbody></table>

<div style="padding-top: 0px; text-align: center;">
<span style="font-size: 80%;">
	<a href="http://linux.vbird.org/" target="_top" title="前往鸟哥的首页">http://linux.vbird.org</a>
	is designed by <a href="mailto:vbird@mail.vbird.idv.tw" title="联络鸟哥(我不要广告信！)">VBird</a>
		during 2001-2011. <a href="http://www.ksu.edu.tw/" target="_blank">ksu.edu</a></span>
         ﻿<div id="apDiv4">
      <p>本网页主要以Firefox配合解析度 1024x768 作为设计依据&nbsp;&nbsp;&nbsp;&nbsp; 鸟哥自由软件整合应用研究室</p></div></div>
</div>
</center>
</body></html>
