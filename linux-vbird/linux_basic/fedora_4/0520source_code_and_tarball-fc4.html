<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="zh-TW"><head>

	<meta http-equiv="Content-Type" content="text/html; charset=utf8">
	<meta name="Author" content="VBird, 鸟哥">
	<meta name="Description" content="谈一下，在 Linux 里面的套件管理，用最原始的原始码与 tarball 来管理的。">
	<title>鸟哥的 Linux 私房菜 -- 原始码与 Tarball 套件管理员</title>
    <script src="../../script/SpryMenuBar.js" type="text/javascript"></script>
	<script src="../../script/index.js" type="text/javascript"></script>
	<link href="../../css/SpryMenuBarHorizontal.css" rel="stylesheet" type="text/css" />
    <link href="../../css/main.css" rel="stylesheet" type="text/css" />
</head><body style="margin: 0pt; padding: 0pt;" class="table"onload="MM_preloadImages('../../index-2.html','../../index-2.html','../../index-2.html','../../index-2.html','../../index-2.html','../../index-2.html','../../index-2.html','../../index-2.html')">

<center>
<div id="apDiv5">
<div> <LINK REL="SHORTCUT ICON" HREF="../../index-2.html">
<!-- ImageReady Slices (title3.ai) -->
<table id="___01" width="898" height="81" border="0" align="center" cellpadding="0" cellspacing="0";>
	<tr>
		<td colspan="15">
			<img src="image/title/title_01.png" width="900" height="1" alt=""></td>
	</tr>
	<tr>
		<td rowspan="4" bgcolor="#182448"><p><img src="http://linux.vbird.org/cgi-bin/Count.cgi?dd=C&amp;ft=5&amp;sh=T&amp;md=8&amp;pad=Y&amp;df=vbird.dic.ksu.edu.tw.dat" width="93" align="left" title="計數器" /></p>
	    <p><font color="#FFFFFF" size="-1">since2012/04/23</font></p></td>
		<td rowspan="4" align="left" valign="top"><a href="../../index.html"><img src="image/title/title_03.png" alt="" width="263" height="79" border="0"></a></td>
		<td colspan="13">
			<img src="image/title/title_04.png" alt="" width="535" height="9" border="0"></td>
	</tr>
	<tr>
		<td rowspan="3">
			<img src="image/title/title_05.png" alt="" width="53" height="70" border="0"></td>
		<td colspan="2" align="left" valign="top"><a href="../0110whatislinux.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image51','','image/title/title_06.png',1)"><img src="image/title/title3_06.png" name="Image51" width="106" height="25" border="0" id="Image51" alt=""/></a></td>
		<td rowspan="2">
			<img src="image/title/title_07.png" alt="" width="27" height="37" border="0"></td>
		<td colspan="3" align="left" valign="top"><a href="../../linux_server/0110network_basic.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image52','','image/title/title_08.png',1)"><img src="image/title/title3_08.png" name="Image52" width="107" height="25" border="0" id="Image52" alt=""/></a></td>
		<td rowspan="2">
			<img src="image/title/title_09.png" alt="" width="37" height="37" border="0"></td>
		<td colspan="2" align="left" valign="top"><a href="../../about.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image53','','image/title/title_10.png',1)"><img src="image/title/title3_10.png" name="Image53" width="75" height="25" border="0" id="Image53" alt=""/></a></td>
		<td rowspan="3">
			<img src="image/title/title_11.png" alt="" width="35" height="70" border="0"></td>
		<td align="left" valign="top"><a href="mailto:vbird@mail.vbird.idv.tw" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image54','','image/title/title_12.png',1)"><img src="image/title/title3_12.png" name="Image54" width="74" height="25" border="0" id="Image54" alt=""/></a></td>
		<td rowspan="3">
			<img src="image/title/title_13.png" alt="" width="21" height="70" border="0"></td>
	</tr>
	<tr>
		<td colspan="2">
			<img src="image/title/title_14.png" alt="" width="106" height="12" border="0"></td>
		<td colspan="3">
			<img src="image/title/title_15.png" alt="" width="107" height="12" border="0"></td>
		<td colspan="2">
			<img src="image/title/title_16.png" width="75" height="12" alt=""></td>
		<td rowspan="2">
			<img src="image/title/title_17.png" alt="" width="74" height="45" border="0"></td>
	</tr>
	<tr>
		<td>
			<img src="image/title/title_18.png" alt="" width="15" height="33" border="0"></td>
		<td colspan="3" align="left" valign="top"><ul id="MenuBar1" class="MenuBarHorizontal">
	  <li><a href="../linux_basic.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image44','','image/title/title_19.png',1)"><img src="image/title/title3_19.png" name="Image44" width="123" height="33" border="0" id="Image44" /></a>
			    <ul>
			      <li><a href="../Mandrake9.0/mandrake9.0.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image46','','image/title/title_26.png',1)"><img src="image/title/title_23.png" name="Image46" width="120" height="26" border="0" id="Image46" alt="" /></a></li>
                  <li><a href="fc4.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image47','','image/title/title_27.png',1)"><img src="image/title/title_24.png" name="Image47" width="120" height="26" border="0" id="Image47" alt="" /></a></li>
                  <li><a href="../linux_basic.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image48','','image/title/title_28.png',1)"><img src="image/title/title_25.png" name="Image48" width="120" height="26" border="0" id="Image48" alt="" /></a></li>
                </ul>
		      </li>
		</ul></td>
		<td>
			<img src="image/title/title_20.png" alt="" width="42" height="33" border="0"></td>
		<td colspan="3" align="left" valign="top"><ul id="MenuBar2" class="MenuBarHorizontal">
	  <li><a href="../../linux_server/index.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image45','','image/title/title_21.png',1)"><img src="image/title/title3_21.png" name="Image45" width="125" height="33" border="0" id="Image45" /></a>
			    <ul>
			      <li><a href="../../linux_server/linux_redhat9/redhat9.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image43','','image/title/title_26.png',1)"><img src="image/title/title_23.png" name="Image43" width="120" height="26" border="0" id="Image43" alt=""/></a></li>
			      <li><a href="../../linux_server/centos4.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image49','','image/title/title_27.png',1)"><img src="image/title/title_24.png" name="Image49" width="120" height="26" border="0" id="Image49" alt="" /></a></li>
			      <li><a href="../../linux_server/index.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image50','','image/title/title_28.png',1)"><img src="image/title/title_25.png" name="Image50" width="120" height="26" border="0" id="Image50" alt="" /></a></li>
		        </ul>
		      </li>
		</ul></td>
		<td>
			<img src="image/title/title_22.png" alt="" width="47" height="33" border="0"></td>
	</tr>
	<tr>
		<td>
			<img src="image/title/Spacer.gif" width="101" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="263" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="53" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="15" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="91" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="27" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="5" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="42" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="60" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="37" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="28" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="47" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="35" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="74" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="22" height="1" alt=""></td>
	</tr>
</table>
<!-- End ImageReady Slices -->
<script type="text/javascript">
<!--
var MenuBar1 = new Spry.Widget.MenuBar("MenuBar1", {imgDown:"SpryAssets/SpryMenuBarDownHover.gif", imgRight:"SpryAssets/SpryMenuBarRightHover.gif"});
var MenuBar2 = new Spry.Widget.MenuBar("MenuBar2", {imgDown:"SpryAssets/SpryMenuBarDownHover.gif", imgRight:"SpryAssets/SpryMenuBarRightHover.gif"});
//-->
</script>
</div>
<table summary="本文内容的排版" style="width: 898px;" border="0" cellpadding="0" cellspacing="0">
<tbody><tr><td style="width: 16px; height: 16px;">　</td>
    <td style="width: 866px; height: 16px;">　</td>
    <td style="width: 16px; height: 16px;">　</td></tr>
<tr><td style="width: 16px; font-size: 6px;">　</td>
    <td width="866">

<!-- 本文的档头部分 -->
<div style="text-align: center;">
    <a href="http://linux.vbird.org/linux_basic/0520source/0520source_code_and_tarball-fc4.php">
    <span class="text_head0">原始码与<span class="text_head_en"> Tarball </span>套件管理员</span></a><br>
</div>
    <div style="text-align: right;">
        <span class="text_history">最近更新日期：2005/10/01</span>
    </div>

<center>本文已不再维护，更新文章请参考<a href="http://linux.vbird.org/linux_basic/0520source_code_and_tarball.php">此处</a></center>
<!-- 本文的档头部分 -->
<center><table class="head1" summary="排版：文章档头的说明"><tbody><tr><td class="head1">
	我们在 <a href="http://linux.vbird.org/linux_basic/0520source/0110whatislinux.php">Linux 是什么</a> 一文当中，提到了 GNU 与 
	GPL 还有开放源码等咚咚，不过，前面都还没有提到真正的开放源码是什么的讯息！在这一章当中，我们将藉由
	Linux 操作系统里面的执行文件，来理解什么是可执行的程序，以及了解什么是编译程序。
	另外，与程序息息相关的函式库 (library) 的信息也需要了解一番！不过，
	在这个章节当中，鸟哥并不是要您成为一个开放源码的程序设计师，
	而是希望您可以了解如何将开放源码的程序设计、加入函式库的原理、透过编译而成为可以执行
	的 binary file ，最后该执行档可被我们所使用的一连串过程！<br><br>

	了解上面的咚咚有什么好处呢？！因为在 Linux 的世界里面，我们常常需要自行安装套件在自己的 
	Linux 系统上面，所以如果您有简单的程序编译概念，那么将很容易进行套件的安装，
	甚至在发生套件编译过程中的错误时，您也可以自行作一些简易的修订呢！而最传统的套件安装过程，
	自然就是由原始码编译而来的啰！所以，在这里我们将介绍最原始的套件管理方式：使用
	Tarball 来安装与升级管理我们的套件喔！
</td></tr></tbody></table></center>

<!-- 本文的连结区部分 -->
<div class="block1">
<span class="text_h1">
1. <a href="#intro">前言</a>：<br>
	<span class="text_h2">
	　　1.1 <a href="#intro_whatisopensource">什么是开放源码、编译程序与可执行文件</a>？<br>
	　　1.2 <a href="#intro_library">什么是函式库</a>？<br>
	　　1.3 <a href="#intro_make">什么是&nbsp;make 与 configure</a> ？<br>
	　　1.4 <a href="#intro_tarball">什么是 Tarball 的套件</a>？<br>
	　　1.5 <a href="#intro_howto">如何安装与升级套件</a>？<br>
	</span>
2. <a href="#simple_ex">一个简单的范例</a>：<br>
	<span class="text_h2">
	　　2.1 <a href="#simple_ex_hello">印出 Hello World</a><br>
	　　2.2 <a href="#simple_ex_function">子程序的编译</a><br>
	　　2.3 <a href="#simple_ex_lib">加入连结的函式库</a><br>
	　　2.4 <a href="#simple_ex_gcc">gcc 的用法</a><br>
	</span>
3. <a href="#make">make 的简易用法</a>：<br>
	<span class="text_h2">
	　　3.1 <a href="#make_why">为什么要用 make</a> ？<br>
	　　3.2 <a href="#make_makefile">make 的基本语法与变量</a><br>
	</span>
4. <a href="#tarball">Tarball 的管理与建议</a>：<br>
	<span class="text_h2">
	　　4.1 <a href="#tarball_pack">使用原始码管理套件所需要的基础套件</a><br>
	　　4.2 <a href="#tarball_step">Tarball 安装的基本步骤</a><br>
	　　4.3 <a href="#tarball_common">一般 Tarball 套件安装的建议事项( 如何移除？升级？ )</a><br>
	　　4.4 <a href="#tarball_exntp">一个简单的范例、利用 ntp 来示范</a><br>
	　　4.5 <a href="#tarball_patch">利用 patch 更新原始码</a><br>
	</span>
5. <a href="#library">函式库管理</a>：<br>
	<span class="text_h2">
	　　5.1 <a href="#library_dyna_sta">动态与静态函式库</a><br>
	　　5.2 <a href="#library_ldconfig">ldconfig 与 /etc/ld.so.conf</a>, <a href="#library_ldd">ldd</a><br>
	</span>
6. <a href="#check">检验套件软件的正确性</a>：<br>
	<span class="text_h2">
	　　6.1 <a href="#check_md5sum">md5sum</a><br>
	</span>
7. <a href="#important">重点回顾</a><br>
8. <a href="#reference">参考资源</a><br>
<span class="text_h2">
9. <a href="http://phorum.vbird.org/viewtopic.php?t=23892" target="_blank">针对本文的建议：http://phorum.vbird.org/viewtopic.php?t=23892</a>
</span>
</span>
</div>


<!-- 本文的正式部分 -->
<hr><a name="intro"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">前言</span><br>
<div class="block1">
	如果鸟哥想要在我的 Linux 服务器上面跑网页服务器( WWW server
	)这项服务，那么我应该要做些什么事呢？呵呵！当然就一定需要『
	<span class="text_import2">安装网页服务器的套件</span>』啰！
	如果鸟哥的服务器上面没有这个套件的话，那当然也就无法启用 WWW 的服务啦！所以啦，想要在您的
	Linux 上面进行一些有的没的功能，学会『<span class="text_import2">如何安装套件</span>』是很重要的一个课题！<br><br>

	咦！安装套件有什么难的？在 Windows 操作系统上面安装套件时，不是只要一直给他按
	『下一步』就可以安装妥当了吗？话是这样说没错啦，不过，也由于如此，所以在
	Windows 系统上面的软件都是一模一样的，也就是说，您『
	<span class="text_import2">无法修改该软件的源代码</span>』，因此，
	万一您想要增加或者减少该软件的某些功能时，呵呵！大概只能求助于当初发行该软件套件的厂商了！<br><br>

	或许你会说：『唉呦！我不过是一般人，不会用到多余的功能，所以不太可能会更动到程序代码的部分吧！？』
	如果您这么想的话，很抱歉～是有问题的！怎么说呢？
	像目前网络上面的病毒、黑客软件、臭虫程序等等，都可能对您的主机上面的某些软件造成影响
	(<span class="text_vbird">这是因为软件开发者在写作之初可能并没有想到某些问题所致！</span>)
	，导致主机的当机或者是其他数据损毁等等的伤害。如果您可以藉由安全信息单位所提供的修订方式进行修改，
	那么您将可以很快速的自行修补好该软件的漏洞，而不必一定要等到套件开发商提供修补的程序包哩！要知道，
	<span class="text_import2">提早补洞</span>是很重要的一件事。<br><br>

	这样说可以了解 Linux 的优点了吗？！没错！因为 <span class="text_import2">Linux
	上面的套件几乎都是经过 GPL 的授权</span>，所以每个套件几乎均提供源代码，
	并且您可以自行修改该程序代码，以符合您个人的需求呢！很棒吧！这就是开放源码(
	Open source )的优点啰！不过，到底什么是开放源码？这些程序代码是什么咚咚？又
	Linux 上面可以执行的相关套件档案与开放源码之间是如何转换的？不同版本的
	Linux 之间能不能使用同一个执行档？或者是该执行档需要由源代码的部分重新进行转换？
	这些都是需要厘清观念的。底下我们先就源代码与可执行文件来进行说明。<br><br>

	<hr><a name="intro_whatisopensource"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">什么是开放源码、
	编译程序与可执行文件？</span>
	<div class="block2">
		在讨论程序代码是什么之前，我们先来谈论一下什么是可执行文件？我们说过，在
		Linux 系统上面，一个档案能不能被执行看的是有没有可执行的那个权限( 具有
		x permission )，不过，<span class="text_import2">Linux 系统上真正认识的可执行文件其实是二进制文件(
		binary file )</span>，例如 /usr/bin/passwd, /bin/touch 这些个档案即为 binary
		的可执行文件案！<br><br>

		或许您会说，咦！ shell scripts 不是也可以执行吗？！其实 shell
		scripts 只是利用 shell ( 例如 bash )这支程序的功能进行一些判断式，而最终执行的除了
		bash 提供的功能外，仍是呼叫一些已经编译好的 binary 档案来执行的呢！( 
		<span class="text_vbird">bash 本身就是 binary file 喔！</span>)
		那么我怎么知道一个档案是否为 binary 呢？！还记得我们在
		<a href="http://linux.vbird.org/linux_basic/0520source/0220filemanager.php#suid_sgid_sticky">Linux 档案与目录管理</a> 
		里面提到的 file 这个指令的功能吗？！对啦！用他就是了！我们现在来测试一下：<br>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd"># 先以系统的档案测试看看：</span>
[root@linux ~]# <span class="term_command">file /bin/bash</span>
/bin/bash: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), 
for GNU/Linux 2.2.5, dynamically linked (uses shared libs), stripped

<span class="term_hd"># 如果是系统提供的 /etc/init.d/syslog 呢？</span>
[root@linux ~]# <span class="term_command">file /etc/init.d/syslog</span>
/etc/init.d/syslog: Bourne-Again shell script text executable
</pre></td></tr></tbody></table>

		看到了吧！如果是 binary file 而且是可以执行的时候，他就会显示执行文件类别
		( ELF 32-bit LSB executable )，同时会说明是否使用<span class="text_import1">动态函式库(
		shared libs )</span>，而如果是一般的 script ，那他就会显示出 text executables
		之类的字样！<br>

		<div style="padding: 10pt 0pt;" align="right"><table width="90%"><tbody><tr><td><b>Tips:</b><br><span style="color: rgb(0, 144, 0);"><font size="-1">		事实上，syslog 的数据显示出 Bourne-Again ... 那一行，是因为您的 
		scripts 上面第一行有宣告 #!/bin/bash
		的缘故，如果您将 script 的第一行拿掉，呵呵！那么不管 /etc/init.d/syslog 
		的权限为何，他其实显示的是 ASCII 文本文件的信息喔！
		</font></span></td><td><img src="0520source_code_and_tarball-fc4_files/vbird_face.gif" alt="鸟哥的图示" title="鸟哥的图示"></td></tr></tbody></table></div>
		既然 Linux 操作系统真正认识的其实是 binary file ，那么我们是如何做出这样的一支
		binary 的程序呢？！首先，我们必须要写程序，用什么东西写程序？就是一般的字处理器啊！我都喜欢使用
		<a href="http://linux.vbird.org/linux_basic/0520source/0310vi.php">vi</a>
		来进行程序的撰写，写完的程序就是所谓的源代码啰！
		<span class="text_import1">这个程序代码档案其实就是一般的纯文本档( text file )</span>。
		在完成这个原始码档案的编写之后，再来就是要将这个档案『
		<span class="text_import1">编译</span>』成为操作系统看的懂得
		binary file 啰！而要编译自然就需要『<span class="text_import1">编译程序</span>』来动作，
		经过编译程序的编译之后，就会产生一支可以执行的 binary file 啰。<br><br>

		举个例子来说，在 Linux 上面最标准的程序语言为 C ，所以我使用 C 
		的语法进行源代码的书写，写完之后，以
		Linux 上标准的 C 语言编译程序
		<span class="text_import1">gcc</span> 这支程序来编译，就可以制作一支可以执行的
		binary file 啰。整个的流程有点像这样：<br><br>

		<center><a name="fig_1"></a><img src="0520source_code_and_tarball-fc4_files/source_to_binary.html" title="简易的 gcc 编译流程" alt="简易的 gcc 编译流程"><br>
			图一、简易的 gcc 编译流程</center><br>

		事实上，在编译的过程当中，还会产生所谓的<span class="text_import1">目标文件(
		Object file )</span>，这些档案是以 *.o 的扩展名样式存在的！至于 C 
		语言的原始码档案通常以 *.c 作为扩展名。此外，有的时候，我们会在程序当中『引用、呼叫』
		其他的外部子程序，或者是利用其他套件提供的『函数功能』，
		这个时候，我们就必须要在编译的过程当中，将该函式库给他加进去，如此一来，
		编译程序就可以将所有的程序代码与函式库作一个连结(
		Link )以产生正确的执行档啰。<br><br>
	</div>

	<hr><a name="intro_library"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">什么是函式库？</span>
	<div class="block2">
		在前一小节的<a href="#fig_1">图一</a>示意图中，在编译的过程里面有提到函式库。好啦，
		那么什么是函式库呢？先举个例子来说，我们的
		Linux 系统上，系统通常已经提供一个可以进行身份验证的模块，称为 PAM ，这个
		PAM 提供的功能可以让很多的程序在被执行的时候，除了可以验证用户登入的信息外，
		还可以将身份确认的数据记录在登录文件( log file, 请查阅后续的 <a href="http://linux.vbird.org/linux_basic/0520source/0570syslog.php">认识登录档</a> 
		一文 )里面，以方便系统管理员的追踪！<br><br>

		既然有这么好用的功能，那如果我要编写具有身份认证功能的程序时，
		直接引用该 PAM 的功能就好啦，如此一来，我就不需要重新设计认证机制啰！也就是说，
		只要在我写的程序代码里面，设定去呼叫 PAM 的函式功能，呵呵！我的程序就可以利用 Linux 
		原本就有的身份认证的程序咯！除此之外，其实我们的 Linux 核心( kernel 
		)也提供了相当多的函式库来给硬件开发者利用喔。<br><br>

		函式库又分为动态与静态函式库，这两个咚咚的分别我们在后面的章节再加以说明。
		这里我们以一个简单的流程图，来示意一支有呼叫外部函式库的程序的执行情况。<br><br>

		<center><a name="fig_2"></a><img src="0520source_code_and_tarball-fc4_files/library.html" title="程序引用函式库的示意图" alt="程序引用函式库的示意图"><br>
			图二、程序引用函式库的示意图</center><br>

		很简单的示意图啊！^_^！而如果要在程序里面加入引用的函式库，就需要如<a href="#fig_1">图一</a>所示，
		亦即在编译的过程当中，就需要加入函式库的相关设定啰。<br><br>

		事实上， Linux 的核心提供很多的核心相关函式库与外部参数，
		这些核心功能在设计硬件的驱动程序的时候是相当有用的信息，这些核心相关信息大多放置在
		<span class="text_import2">/usr/include, /lib, /usr/lib</span>
		里面哩！我们在本章的后续小节再来探讨。<br><br>
	</div>

	<hr><a name="intro_make"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">什么是 make 与 configure ？</span>
	<div class="block2">
		事实上，使用类似 gcc 的编译程序来进行编译的过程并不简单，
		因为除了每个主程序与子程序均需要写上一笔编译过程的指令外，还需要写上最终的链接程序。
		程序代码小的时候还好，如果是类似 WWW 服务器软件( 例如 <a href="http://linux.vbird.org/linux_basic/linux_server/0360apache.php">Apache</a>
		)，或者是类似核心的原始码，动则数百 MBytes 的资料量，呵呵！指令会写到疯掉～这个时候，我们就可以使用
		make 这个指令的相关功能来进行编译过程的指令简化了！<br><br>

		当执行 make 时，make 会在当时的目录下搜寻 <span class="text_import1">Makefile
		( or makefile )</span> 这个文本文件，而 Makefile 里面则记录了原始码如何编译的详细信息！&nbsp;
		make 会自动的判别原始码是否经过变动了，而自动更新执行档，是软件工程师相当好用的一个辅助工具呢！<br><br>

		咦！make 是一支程序，会去找 Makefile ，那 Makefile 怎么写？呵呵！
		通常软件开发商都会写一支侦测程序来侦测用户的作业环境，
		以及该作业环境是否有软件开发商所需要的其他功能，该侦测程序侦测完毕后，就会主动的建立这个
		Makefile 的规则档案啦！通常这支侦测程序的文件名为 configure 或者是 config 。<br><br>

		咦！？那为什么要侦测作业环境呢？！在 <a href="http://linux.vbird.org/linux_basic/0520source/0110whatislinux.php">什么是 Linux </a>那个章节当中，
		不是有提到 Linux 不过就是一个核心吗？！是这样没错啦！但是您必须要了解的是，
		某些软件套件需要一些相关的套件辅助，并且，某些驱动程序则是适用在不同的核心系统(
		<span class="text_vbird">因为核心提供的函式库可能并不相同，例如
		kernel 2.4.xx 与 kernel 2.6.xx 就不太一样！</span> )，并且每个 Linux
		distribution 所提供的函式库名称与路径可能也不太一样，所以说，在 Fedora Core 4
		上面可以执行的一个 binary file ，直接复制到 SuSE 平台上，可不见得可以顺利执行(
		<span class="text_vbird">事实上，是不太可能可以执行啦！^_^</span> )。
		所以啦，原始码写出来之后，需要针对不同的作业环境来进行编译的行为吶！这个时候就很需要
		configure 以及 make 的功能啊！<br><br>

		详细的 make 用法与 Makefile 规则，在后续的小节里面再探讨啰！<br><br>
	</div>

	<hr><a name="intro_tarball"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">什么是 Tarball 的套件 ？</span>
	<div class="block2">
		从前面几个小节的说明来看，我们知道所谓的源代码，其实就是一些写满了程序代码的纯文本档案。那我们从前面的
		<a href="http://linux.vbird.org/linux_basic/0520source/0240tarcompress.php">档案的压缩与打包</a>
		章节当中，也了解了纯文本文件其实是很浪费硬盘空间的一种文件格式！(<span class="text_vbird">
		想一想，一个核心的原始码档案大约要 200~300 MB 以上，如果每个人都去下载这样的一个核心档案，
		呵呵！那么网络带宽不被吃的死翘翘才怪呢！</span> )
		所以啦，如果能够将这些原始码透过档案的打包与压缩技术来将档案的数量与容量减小，
		不但让使用者容易下载，套件开发商的网站带宽也能够节省很多很多啊！这就是
		Tarball 档案的由来啰！<br><br>

		所谓的 Tarball 档案，其实就是将套件的所有原始码档案先以 <a href="http://linux.vbird.org/linux_basic/0520source/0240tarcompress.php#tar">tar</a>
		打包，然后再以压缩技术来压缩，通常最常见的就是以 <a href="http://linux.vbird.org/linux_basic/0520source/0240tarcompress.php#gzip">gzip</a>
		来压缩了。因为利用了 tar 与 gzip 的功能，所以 <span class="text_import2">tarball
		档案一般的扩展名就会写成 *.tar.gz 或者是简写为 *.tgz 啰</span>！也就是说，
		Tarball 套件解压缩之后，里面的档案通常就会有：<ul><span class="text_import2">
		<li>源代码档案；
		</li><li>侦测程序档案( 可能是 configure 或 config 等檔名 )；
		</li><li>本套件的简易说明与安装说明( INSTALL 或 README )。</li></span></ul>

		其中最重要的是那个 INSTALL 或者是 README 这两个档案，通常您只要能够参考这两个档案，呵呵！
		Tarball 套件的安装是很简单的啦！我们在后面的章节会再继续介绍 Tarball 这个玩意儿。<br><br>
	</div>

	<hr><a name="intro_howto"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">如何安装与升级套件</span>
	<div class="block2">
		将原始码作了一个简单的介绍，也知道了系统其实认识的可执行文件是
		binary file 之后，好了，得要聊一聊，那么怎么安装与升级一个 Tarball 
		的套件？为什么要安装一个新的套件呢？当然是因为我们的主机上面没有该套件啰！那么，
		为何要升级呢？！原因可能有底下这些：<ul><span class="text_import2">
		<li>需要新的功能，但旧有主机的旧版套件并没有，所以需要升级到新版的套件；
		</li><li>旧版本的套件上面可能有安全上的顾虑，所以需要更新到新版的套件；
		</li><li>旧版的套件执行效能不彰，或者执行的能力不能让管理者满足。</li></span></ul>

		在上面的需求当中，尤其需要注意的是第二点，当一个套件有安全上的顾虑时，千万不要怀疑，
		赶紧更新套件吧！否则造成网络危机，那可不是闹着玩的！那么更新的方法有哪些呢？
		基本上更新的方法可以分为两大类，分别是：<ul><span class="text_import2">
		<li>直接以原始码透过编译来安装与升级；
		</li><li>直接以编译好的 binary file 来安装与升级。</li></span></ul>

		上面第一点很简单，就是直接以 Tarball 在自己的机器上面进行侦测、编译、
		安装与设定等等动作来升级就是了。不过，这样的动作虽然让使用者在安装过程当中具有很高的弹性，
		但毕竟是比较麻烦一点，如果
		Linux distribution 厂商能够针对自己的作业平台先进行编译等过程，再将编译好的
		binary file 释出的话，那由于我的系统与该 Linux distribution 的环境是相同的，所以他所释出的
		binary file 就可以在我的机器上面直接安装啦！省略了侦测与编译等等繁杂的过程呢！<br><br>

		目前很多 binary file 升级的机制呢，包括有 <span class="text_import2">Red Hat 系统
		( 含 Fedora 系列 ) 发展的 RPM
		与 up2date, yum 等在线更新模式；Mandrake 的 urpmi 套件更新方式； Debian
		使用的 dpkg ； Sun Unix 使用的 pkg ，以及目前很流行的 apt 在线更新模式等等</span>，
		以使用率来说，目前最传统的是以
		Tarball 直接进行编译的安装与升级，而另一个则是以 RPM 相关的机制来进行安装与升级啰！本章节主要针对
		Tarball ，至于 RPM 则留待下个章节再来介绍呢！<br><br>

		好了，那么一个套件的 Tarball 是如何安装的呢？基本流程是这样的啦：<ol><span class="text_import2">
		<li>将 Tarball 由厂商的网页下载下来；
		</li><li>将 Tarball 解开，产生很多的原始码档案；
		</li><li>开始以 gcc 进行原始码的编译( 会产生目标文件 object files )；
		</li><li>然后以 gcc 进行函式库、主、子程序的链接，以形成主要的 binary file；
		</li><li>将上述的 binary file 以及相关的配置文件安装至自己的主机上面。</li></span></ol>

		上面第 3, 4 步骤当中，我们可以透过 make 这个指令的功能来简化他，
		所以整个步骤其实是很简单的啦！只不过您就得需要至少有
		gcc 以及 make 这两个套件在您的 Linux 系统里面才行喔！
		详细的过程以及需要的套件我们在后面的章节继续来介绍的啦！
	</div>
</div>


<hr><a name="simple_ex"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">一个简单的范例：</span>
<div class="block1">
	经过上面的介绍之后，您应该比较清楚的知道原始码、编译程序、函式库与执行档之间的相关性了。
	不过，详细的流程可能还是不很清楚，所以，在这里我们以一个简单的程序范例来说明整个编译的过程喔！赶紧进入
	Linux 系统，实地的操作一下底下的范例呢！<br><br>

	<hr><a name="simple_ex_hello"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">印出 Hello World</span>
	<div class="block2">
		我们以 Linux 上面最常见的 C 语言来撰写第一支程序！第一支程序最常作的就是.....
		在屏幕上面印出『<span class="text_import2">Hello World！</span>』的字样～当然，
		这里我们是以简单的 C 语言来撰写，如果您对于
		C 有兴趣的话，那么请自行购买相关的书籍喔！ ^_^好了，不啰唆，立刻编辑第一支程序吧！
		( <span class="text_vbird">请先确认您的 Linux 系统里面已经安装了 gcc 了喔！如果尚未安装 
		gcc 的话，请先参考下一节的 RPM 安装法，先安装好 gcc 之后，再回来阅读本章</span> )<br>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd"># 1. 先编辑原始码：</span>
[root@linux ~]# <span class="term_command">vi hello.c</span>   <span class="term_note">&lt;==注意一下， C 语言用 .c 的扩展名</span>
<span class="term_write">#include &lt;stdio.h&gt;
int main(void)
{
        printf("Hello World\n");
}</span>

<span class="term_say"># 上面是 C 语言的语法，那个第一行的 # 并不是批注喔！如果您担心
# 输入错误，请到底下的连结下载这个档案：
# <a href="http://linux.vbird.org/linux_basic/0520source/hello.c">http://linux.vbird.org/linux_basic/0520source/hello.c</a>
</span>
<span class="term_hd"># 2. 开始将原始码编译成为可执行的 binary file ：</span>
[root@linux ~]# <span class="term_command">gcc hello.c</span>
<span class="term_say"># 这个时候，在本目录下会产生一个名为 a.out 的执行档！
# 在预设的状态下，如果我们直接以 gcc 编译原始码，并且没有加上
# 任何参数，则 <span class="term_note_b">执行档的档名会被自动设定为 a.out 这个文件名</span>！</span>

<span class="term_hd"># 3. 执行一下这个档案：</span>
[root@linux ~]# <span class="term_command">./a.out</span>
Hello World  <span class="term_note">&lt;==呵呵！成果出现了！</span>
</pre></td></tr></tbody></table>

		好了，上面的例子很简单吧！那个 hello.c 就是原始码，而
		gcc 就是编译程序，至于 a.out 就是编译成功的可执行 binary file 啰！咦！如果我想要产生目标文件(
		object file )来进行其他的动作( <span class="text_vbird">在较大的套件当中，
		就需要使用多个目标文件来进行相关的连结</span>)，而且执行档的档名也不要用预设的
		a.out ，那该如何是好？可以将上面的第 2 个步骤改成这样：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">gcc -c hello.c</span>
<span class="term_say"># 会产生一个名为 hello.o 的目标文件，object file 的扩展名为 *.o 喔！</span>

[root@linux ~]# <span class="term_command">gcc -o hello hello.o</span>
<span class="term_say"># 这个步骤是利用 hello.o 这个目标文件制作出一个名为 hello 的执行档
# 详细的 gcc 语法我们会在后续章节中继续介绍！
# 透过这个动作后，我们可以得到 hello 及 hello.o 两个档案，
# 真正可以执行的是 hello 这个 binary file 喔！</span>

<span class="term_hd"># 3. 执行一下这个档案：</span>
[root@linux ~]# <span class="term_command">./hello</span>
Hello World
</pre></td></tr></tbody></table>

		或许您会觉得，咦！只要一个动作作出 a.out 就好了，干嘛还要先制作目标文件再做成执行档呢？！
		呵呵！透过下个范例，您就可以知道为什么啦！<br><br>
	</div>

	<hr><a name="simple_ex_function"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">子程序的编译</span>
	<div class="block2">
		如果我们在一个主程序里面又呼叫了另一个子程序呢！？这是很常见的一个程序写法，
		因为可以简化整个程序的易读性！在底下的例子当中，我们以
		thanks.c 这个主程序去呼叫 thanks_2.c 这个子程序，写法很简单：<br>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd"># 1. 先编辑原始码 thanks.c 与 thanks_2.c：</span>
[root@linux ~]# <span class="term_command">vi thanks.c</span>
<span class="term_write">#include &lt;stdio.h&gt;
int main(void)
{
        printf("Hello World\n");
        thanks_2();
}</span>
<span class="term_say"># 上面的 thanks_2(); 那一行就是呼叫子程序啦！</span>

[root@linux ~]# <span class="term_command">vi thanks_2.c</span>
<span class="term_write">void thanks_2(void)
{
        printf("Thank you!\n");
}</span>
<span class="term_say"># 上面这两个档案您可以到底下下载：
# <a href="http://linux.vbird.org/linux_basic/0520source/thanks.c">http://linux.vbird.org/linux_basic/0520source/thanks.c</a>
# <a href="http://linux.vbird.org/linux_basic/0520source/thanks_2.c">http://linux.vbird.org/linux_basic/0520source/thanks_2.c</a>
</span>
<span class="term_hd"># 2. 开始将原始码编译成为可执行的 binary file ：</span>
[root@linux ~]# <span class="term_command">gcc -c thanks.c thanks_2.c</span>
<span class="term_say"># 产生了两个目标文件！且编译过程里面可能会产生一些 warning (警告) 的讯息，
# 因为仅是警告而已，所以该讯息你可以先略过去不打紧的！ ^_^</span>
[root@linux ~]# <span class="term_command">gcc -o thanks thanks.o thanks_2.o</span>

<span class="term_hd"># 3. 执行一下这个档案：</span>
[root@linux ~]# <span class="term_command">./thanks</span>
Hello World
Thank you!
</pre></td></tr></tbody></table>

		知道为什么要制作出目标文件了吗？！由于我们的原始码档案有时并非仅只有一个档案，
		所以我们无法直接进行编译。这个时候就需要先产生目标文件，然后再以连结制作成为
		binary 可执行文件。另外，<span class="text_import2">如果有一天，您更新了
		thanks_2.c 这个档案的内容，则您只要重新编译 thanks_2.c 来产生新的 thanks_2.o
		，然后再以连结制作出新的 binary 可执行文件即可！而不必重新编译其他没有更动过的原始码档案</span>。
		这对于软件开发者来说，是一个很重要的功能，因为有时候要将偌大的原始码全部编译完成，
		会花很长的一段时间呢！<br><br>

		此外，如果您想要让程序在执行的时候具有比较好的效能，或者是其他的除错功能时，
		可以在编译的过程里面加入适当的参数，例如底下的例子：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">gcc -O -c thanks.c thanks_2.c</span>
<span class="term_say"># -O 为产生优化的参数</span>

[root@linux ~]# <span class="term_command">gcc -Wall -c thanks.c thanks_2.c</span>
thanks.c: In function 'main':
thanks.c:5: warning: implicit declaration of function 'thanks_2'
thanks.c:6: warning: control reaches end of non-void function
thanks_2.c: In function 'thanks_2':
thanks_2.c:3: warning: implicit declaration of function 'printf'
thanks_2.c:3: warning: incompatible implicit declaration of built-in function 'printf'
<span class="term_say"># -Wall 为产生更详细的编译过程信息。上面的讯息为警告讯息( warning )
# 所以不用理会也没有关系！</span>
</pre></td></tr></tbody></table>

		至于更多的 gcc 额外参数功能，就得要 man gcc 啰～呵呵！可多的跟天书一样～<br><br>
	</div>

	<hr><a name="simple_ex_lib"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">加入连结的函式库</span>
	<div class="block2">
		刚刚我们都仅只是在屏幕上面印出一些字眼而已，如果说要计算数学公式呢？！
		例如我们想要计算出三角函数里面的
		sin(90度角)，要注意的是，大多数的程序语言都是使用径度而不是一般我们在计算的『角度』，
		180 度角约等于 3.14 径度！嗯！那我们就来写一下这个程序吧！<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">vi sin.c</span>
<span class="term_write">#include &lt;stdio.h&gt;
int main(void)
{
        float value;
        value = sin ( 3.14 / 2 );
        printf("%f\n",value);
}</span>
<span class="term_say"># 上面这个档案的内容可以在底下取得！
# <a href="http://linux.vbird.org/linux_basic/0520source/sin.c">http://linux.vbird.org/linux_basic/0520source/sin.c</a></span>
</pre></td></tr></tbody></table>

		那要如何编译这支程序呢？我们先直接编译看看：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">gcc sin.c</span>
sin.c: In function 'main':
sin.c:5: warning: incompatible implicit declaration of built-in function 'sin'
/tmp/cciDlilg.o(.text+0x2c): In function `main':
sin.c: <b>undefined reference to `sin'</b>
collect2: ld returned 1 exit status
<span class="term_say"># 注意看到上面最后一行，会有个错误讯息，代表没有成功！</span>
</pre></td></tr></tbody></table>

		特别注意上面的错误讯息，唉啊！怎么没有编译成功？它说的是『<span class="text_import2">undefined
		reference to sin</span>』，说的是『<span class="text_import2">没有
		sin 的相关定义参考值！</span>』，为什么会这样呢？这是因为
		C 语言里面的 sin 函示是写在 libm.so 这个函式库中，而我们并没有在原始码里面加入相关的说明，
		所以当然就需要在编译与连结的时候将这个函式库给他连结进执行档里面啊！所以我们可以这样做：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">gcc sin.c -lm -L/lib -L/usr/lib</span>
<span class="term_say"># 特别注意，那个 -lm 可以拆开成两部份来看：
# -l ：是『加入某个函式库(library)』的意思，而
# m  ：则是 libm.so 这个函式库，其中， lib 与扩展名(.a 或 .so)不需要写
# 所以 -lm 表示使用 libm.so (或 libm.a) 这个函式库的意思～
# 至于那个 -L 后面接的路径呢？这表示：
#『<span class="term_note_b">我要的函式库 libm.so 请到 /lib 或 /usr/lib 里面搜寻</span>！』</span>
[root@linux ~]# <span class="term_command">./a.out</span>
1.000000
</pre></td></tr></tbody></table>

		上面的说明很清楚了吧！！不过，要注意的是，由于
		Linux 预设是将函式库放置在 /lib 与 /usr/lib 当中，所以您没有写 -L/lib 与
		-L/usr/lib 也没有关系的！不过，万一哪天您使用的函式库并非放置在这两个目录下，那么
		-L/path 就很重要了！否则会找不到函式库喔！<br><br>

		除了连结的函式库之外，您或许已经发现一个奇怪的地方，那就是在我们的
		sin.c 当中第一行『<span class="text_import2"><font face="细明体"> #include
		&lt;stdio.h&gt;</font></span><font face="细明体"></font>』，这行说的是要将一些定义数据由
		stdio.h 这个档案读入，这包括 printf 的相关设定。这个档案其实是放置在 /usr/include/stdio.h
		的！那么万一这个档案并非放置在这里呢？那么我们就可以使用底下的方式来定义出要读取的
		include 档案放置的目录：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">gcc sin.c -lm -I/usr/include</span>
</pre></td></tr></tbody></table>

		-I/path 后面接的路径( Path )就是设定要去搜寻相关的
		include 档案的目录啦！不过，同样的，默认值是放置在 /usr/include 底下，除非您的
		include 档案放置在其他路径，否则也可以略过这个项目！<br><br>

		透过上面的几个小范例，您应该对于 gcc 以及原始码有一定程度的认识了，再接下来，我们来稍微整理一下
		gcc 的简易使用方法吧！<br><br>
	</div>

	<hr><a name="simple_ex_gcc"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">gcc 的用法</span>
	<div class="block2">
		前面说过， gcc 为 Linux 上面最标准的编译程序，这个 gcc 是由 
		<a href="http://www.gnu.org/" target="_blank">GNU</a>
		所维护的，有兴趣的朋友请自行前往参考。既然 gcc 对于 Linux 上的 Open source
		是这么样的重要，所以底下我们就列举几个 gcc 常见的参数，如此一来大家应该更容易了解原始码的各项功能吧？！<br>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd"># 仅将原始码编译成为目标文件，并不制作链接等功能：</span>
[root@linux ~]# <span class="term_command">gcc -c hello.c</span>
<span class="term_say"># 会自动的产生 hello.o 这个档案，但是并不会产生 binary 执行档。</span>

<span class="term_hd"># 在编译的时候，依据作业环境给予优化执行速度</span>
[root@linux ~]# <span class="term_command">gcc -O hello.c -c</span>
<span class="term_say"># 会自动的产生 hello.o 这个档案，并且进行优化喔！</span>

<span class="term_hd"># 在进行 binary file 制作时，将连结的函式库与相关的路径填入</span>
[root@linux ~]# <span class="term_command">gcc sin.c -lm -L/usr/lib -I/usr/include</span>
<span class="term_say"># 这个指令较常下达在最终连结成 binary file 的时候，
# -lm 指的是 libm.so 或 libm.a 这个函式库档案；
# -L 后面接的路径是刚刚上面那个函式库的搜寻目录；
# -I 后面接的是原始码内的 include 档案之所在目录。</span>

<span class="term_hd"># 将编译的结果输出成某个特定档名</span>
[root@linux ~]# <span class="term_command">gcc -o hello hello.c</span>
<span class="term_say"># -o 后面接的是要输出的 binary file 檔名</span>

<span class="term_hd"># 在编译的时候，输出较多的讯息说明</span>
[root@linux ~]# <span class="term_command">gcc -o hello hello.c -Wall</span>
<span class="term_say"># 加入 -Wall 之后，程序的编译会变的较为严谨一点，
# 所以警告讯息也会显示出来！</span>
</pre></td></tr></tbody></table>

		比较重要的大概就是这一些。<span class="text_import2">另外，我们通常称
		-Wall 或者 -O 这些非必要的参数为旗标( FLAGS )，因为我们使用的是 GCC ，所以有时候也会简称这些旗标为
		CFLAGS ，</span>这些变量偶尔会被使用的喔！尤其是在后头会介绍的
		make 相关的用法时，更是重要的很吶！ ^_^<br>
	</div>
</div>


<hr><a name="make"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">make 的简易用法</span>
<div class="block1">
	在前言的部分我们提到过 make 的功能是可以简化编译过程里面所下达的指令，
	同时还具有很多很方便的功能！那么底下咱们就来试看看使用
	make 简化下达编译指令的流程吧！<br><br>

	<hr width="100%"><a name="make_why"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">为什么要用 make</span>
	<div class="block2">
		先来想象一个案例，假设我的执行档里面包含了四个原始码档案，分别是
		main.c haha.c sin_value.c cos_value.c 这四个档案，这四个档案您可以到
		<a href="../../../linux.vbird.org/linux_basic/0520source/main.gz">http://linux.vbird.org/linux_basic/0520source/main.tgz</a>
		来下载，由于这四个档案里面包含了相关性，并且还用到数学函式在里面，
		所以如果您想要让这个程序可以跑，那么就需要这样编译：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">gcc -c main.c</span>
[root@linux ~]# <span class="term_command">gcc -c haha.c</span>
[root@linux ~]# <span class="term_command">gcc -c sin_value.c</span>
[root@linux ~]# <span class="term_command">gcc -c cos_value.c</span>
<span class="term_say"># 先以上面的动作制作出四个目标文件，然后再进行下面的动作：</span>

[root@linux ~]# <span class="term_command">gcc -o main main.o haha.o sin_value.o cos_value.o \</span>
&gt; <span class="term_command">-lm -L/usr/lib -L/lib</span>
<span class="term_say"># 这样就可以制作出  main 这个执行档啰！执行看看吧！</span>

[root@linux ~]# <span class="term_command">./main </span>
HaHa! I'm the King of the world
0.706825
0.707388
</pre></td></tr></tbody></table>

		呵呵！要做好多动作啊！真是麻烦，如果可以的话，能不能一个步骤就给他完成上面所有的动作呢？
		试看看在这个目录下建立一个 makefile 档案，内容如下：<br>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd"># 1. 先建立编译的规则</span>
[root@linux ~]# <span class="term_command">vi makefile</span>
<span class="term_write">main: main.o haha.o sin_value.o cos_value.o
	gcc -o main main.o haha.o sin_value.o cos_value.o -lm</span>
<span class="term_say"># 注意：第二行的 gcc 之前是 &lt;tab&gt; 按键产生的空格喔！</span>

<span class="term_hd"># 2. 尝试给他建立规则看看</span>
[root@linux ~]# <span class="term_command">rm -f main *.o   <span class="term_note">&lt;==先将之前的目标文件去除</span></span>
[root@linux ~]# <span class="term_command">make</span>
cc    -c -o main.o main.c
cc    -c -o haha.o haha.c
cc    -c -o sin_value.o sin_value.c
cc    -c -o cos_value.o cos_value.c
gcc -o main main.o haha.o sin_value.o cos_value.o -lm
<span class="term_say"># 这个时候 make 会主动去读取 makefile 这个档案的内容，
# 并根据内容直接去给他编译起相关的执行档啰！</span>

<span class="term_hd"># 3. 如果再执行一次 make 会怎样？！</span>
[root@linux ~]# <span class="term_command">make</span>
make: `main' is up to date.
<span class="term_say"># 看到了吧？！是否很方便呢？！</span>
</pre></td></tr></tbody></table>

		或许您会说：『如果我建立一个 shell script 来将上面的所有动作都集结在一起，
		不是具有同样的效果吗？』呵呵！效果当然不一样，以上面的测试为例，我们仅写出
		main 需要的目标文件，结果 make 会主动的去判断每个目标文件相关的原始码档案，并直接予以编译，
		最后再直接进行连结的动作！哈哈！真的是很方便啊！此外，如果我们更动过某些原始码档案，则
		make 也可以主动的判断哪一个原始码与相关的目标文件档案有更新过，
		并仅更新该档案，如此一来，将可大大的节省很多编译的时间呢！要知道，某些程序在进行编译的行为时，会消耗很多的
		CPU 资源呢！所以说， make 有这些好处：<ul><span class="text_import2">
		<li>简化编译时所需要下达的指令；
		</li><li>若在编译完成之后，修改了某个原始码档案，则 make 仅会针对被修改了的档案进行编译，其他的
			object file 不会被更动；
		</li><li>最后可以依照相依性来更新( update )执行档。</li></span></ul>

		既然 make 有这么多的优点，那么我们当然就得好好的了解一下
		make 这个令人关心的家伙啦！而 make 里面最需要注意的大概就是那个规则档案，也就是
		makefile 这个档案的语法啦！底下我们针对 makefile 的语法来加以介绍啰。<br><br>
	</div>

	<hr><a name="make_makefile"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">make 的基本语法与变量</span>
	<div class="block2">
		<a name="20080110"></a>make 的语法可是相当的多而复杂的，有兴趣的话可以到
		<a href="http://www.gnu.org/software/make/manual/make.html" target="_blank">http://www.gnu.org/software/make/manual/make.html</a>
		去查阅相关的说明，鸟哥这里仅列出一些基本的规则，重点在于让读者们未来在接触原始码时，不会太紧张啊！
		^_^好了，基本的 makefile 规则是这样的：<br>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_write">目标(target): 目标文件1 目标文件2
&lt;tab&gt;   gcc -o 欲建立的执行文件 目标文件1 目标文件2</span>
</pre></td></tr></tbody></table>

		那个目标(target)就是我们想要建立的信息，而目标文件就是具有相关性的
		object files ，那建立执行文件的语法就是以 &lt;tab&gt; 按键开头的那一行！特别给他留意喔，
		『<span class="text_import1">命令行必须要以 tab 按键作为开头</span>』才行！
		他的规则基本上是这样的：<ul><span class="text_import2">
		<li>在 makefile 当中的 # 代表批注；
		</li><li>&lt;tab&gt; 需要在命令行的第一个字符；
		</li><li>目标(target)与相依档案(就是目标文件)之间需以『:』隔开。</li></span></ul>

		同样的，我们以刚刚上一个小节的范例进一步说明，如果我想要有两个以上的执行动作时，
		例如下达一个指令就直接清除掉所有的目标文件与执行文件，该如何制作呢？<br>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd"># 1. 先建立编译的规则</span>
[root@linux ~]# <span class="term_command">vi makefile</span>
main: main.o haha.o sin_value.o cos_value.o
	gcc -o main main.o haha.o sin_value.o cos_value.o -lm
<span class="term_write">clean:
	rm -f main main.o haha.o sin_value.o cos_value.o</span>

<span class="term_hd"># 2. 测试看看：</span>
[root@linux ~]# <span class="term_command">make clean</span>
rm -rf main main.o haha.o sin_value.o cos_value.o
</pre></td></tr></tbody></table>

		如此一来，我们的 makefile 里面就具有至少两个目标，分别是
		main 与 clean ，如果我们想要建立 main 的话，输入『<span class="text_import1">make
		main</span>』，如果想要清除有的没的，输入『<span class="text_import1">make
		clean</span>』即可啊！而如果想要先清除目标文件再编译
		main 这个程序的话，就可以这样输入：『make clean main』，如下所示：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">make clean main</span>
rm -rf main main.o haha.o sin_value.o cos_value.o
cc    -c -o main.o main.c
cc    -c -o haha.o haha.c
cc    -c -o sin_value.o sin_value.c
cc    -c -o cos_value.o cos_value.c
gcc -o main main.o haha.o sin_value.o cos_value.o -lm
</pre></td></tr></tbody></table>

		这样就很清楚了吧！？但是，您是否会觉得，咦！
		makefile 里面怎么重复的数据这么多啊！呵呵！没错！所以我们可以再藉由 shell
		script 那时学到的『变数』来更简化 makefile 喔：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">vi makefile</span>
<span class="term_write">LIBS = -lm
OBJS = main.o haha.o sin_value.o cos_value.o
main: ${OBJS}
        gcc -o main ${OBJS} ${LIBS}
clean:
        rm -f main ${OBJS}</span>
</pre></td></tr></tbody></table>

		与 bash shell script 的语法有点不太相同，变量的基本语法为：<ol><span class="text_import2">
		<li>变量与变量内容以『=』隔开，同时两边可以具有空格；
		</li><li>变量左边不可以有 &lt;tab&gt; ，例如上面范例的第一行 LIBS 左边不可以是 &lt;tab&gt;；
		</li><li>变量与变量内容在『=』两边不能具有『:』；
		</li><li>在习惯上，变数最好是以『大写字母』为主；
		</li><li>运用变量时，以 ${变量} 或 $(变量) 使用；
		</li><li>在该 shell 的环境变量是可以被套用的，例如提到的 CFLAGS 这个变数！
		</li><li>在指令列模式也可以给予变量。</li></span></ol>

		由于 <span class="text_import2">gcc 在进行编译的行为时，会主动的去读取 CFLAGS
		这个环境变量</span>，所以，您可以直接在 shell 定义出这个环境变量，也可以在
		makefile 档案里面去定义，更可以在指令列当中给予这个咚咚呢！例如：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">CFLAGS="-Wall" make clean main</span>
<span class="term_say"># 这个动作在上 make 进行编译时，会去取用 CFLAGS 的变量内容！</span>
</pre></td></tr></tbody></table>

		也可以这样：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">vi makefile</span>
LIBS = -lm
OBJS = main.o haha.o sin_value.o cos_value.o
<span class="term_write">CFLAGS = -Wall</span>
main: ${OBJS}
	gcc -o main ${OBJS} ${LIBS}
clean:
	rm -f main ${OBJS}
</pre></td></tr></tbody></table>

		咦！我可以利用指令列进行环境变量的输入，也可以在档案内直接指定环境变量，那万一这个
		CFLAGS 的内容在指令列与 makefile 里面并不相同时，以那个方式输入的为主？呵呵！
		环境变量取用的规则是这样的：<ol><span class="text_import2">
		<li>make 指令列后面加上的环境变量为优先；
		</li><li>makefile 里面指定的环境变量第二；
		</li><li>shell 原本具有的环境变量第三。</li></span></ol>

		此外，还有一些特殊的变量需要了解的喔：<ul><span class="text_import2">
		<li>$@：代表目前的目标(target)</li></span></ul>

		所以我也可以将 makefile 改成：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">vi makefile</span>
LIBS = -lm
OBJS = main.o haha.o sin_value.o cos_value.o
CFLAGS = -Wall
main: ${OBJS}
	<span class="term_write">gcc -o $@ ${OBJS} ${LIBS}</span>   <span class="term_note">&lt;==那个 $@ 就是 main ！</span>
clean:
	rm -f main ${OBJS}
</pre></td></tr></tbody></table>

		这样是否稍微了解了 makefile ( 也可能是 Makefile
		) 的基本语法？这对于您未来自行修改原始码的编译规则时，是很有帮助的喔！^_^！
	</div>
</div>


<hr><a name="tarball"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">Tarball 的管理与建议：</span>
<div class="block1">
	好了！在我们知道了原始码的相关信息之后，再来要了解的自然就是如何使用具有原始码的
	Tarball 来建立一个属于自己的套件啰！从前面几个小节的说明当中，我们晓得<span class="text_import2">其实
	Tarball 的安装是可以跨平台的，因为 C 语言的程序代码在各个平台上面是可以共通的</span>，
	只是需要的编译程序可能并不相同而已。例如
	Linux 上面用 gcc 而 Windows 上面也有相关的 C 编译程序啊～所以呢，同样的一组原始码，既可以在
	Fedora Linux 上面编译，也可以在 SuSE Linux 上面编译，当然，也可以在大部分的
	Unix 平台上面编译成功的！<br><br>

	所以啰， Tarball 原始码程序应该可以在大部分的环境底下安装成功的！举例来说，鸟哥在上面几个小节所提供的
	C 程序是在 Fedora Core 4 及 Red Hat 9 上面测试编译的，那么您可以下载之后在自己的 Linux 
	环境下测试看看，我想，每个人应该都可以顺利的编译成功的才是！因为
	C 的语法是没有不一样的啊！ ^_^<br><br>

	如果万一没有编译成功怎么办？很简单啊，透过修改小部分的程序代码( 通常是因为很小部分的异动而已
	)就可以进行跨平台的移植了！也就是说，刚刚我们在 Linux 底下写的程序『<span class="text_import2">理论上，是可以在
	Windows 上面编译的</span>！』这就是原始码的好处啦！所以说，如果朋友们想要学习程序语言的话，
	鸟哥个人是比较建议学习『<span class="text_import1">具有跨平台能力的程序语言</span>』，例如
	C 就是很不错的一个！<br><br>

	唉啊！又扯远了～赶紧拉回来继续说明我们的 Tarball 啦！<br><br>

	<hr><a name="tarball_pack"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">使用原始码管理套件所需要的基础套件</span>
	<div class="block2">
		从原始码的说明我们晓得要制作一个 binary
		执行档需要很多咚咚的呢！这包括底下这些基础的套件：<ul>
		<li><span class="text_import1">gcc 或 cc 等 C 语言编译程序( compiler )：</span><br>
			这是一定要的啦！要将原始码编译成为可执行的 binary
			才行，所以当然就需要编译程序啰！在 Linux 上面用的当然就是 GNU 发展的 gcc
			这个超好用的免费的 C 编译程序啦！并且，很多在 Linux 平台上面发展的套件的原始码，原本就是以
			gcc 为底来设计的呢。</li><br>
		<li><span class="text_import1">make 及 autoconfig 等套件：</span><br>
			一般来说，以 Tarball 方式释出的套件当中，为了简化编译的行程，通常都是配合前几个小节提到的
			make 这个指令来依据目标档案的相依性而进行编译。但是我们也知道说 make 需要
			makefile 这个档案的规则，那由于不同的系统里面可能具有的基础套件环境并不相同，
			所以就需要侦测用户的作业环境，好自行建立一个
			makefile 档案。这个自行侦测的小程序也必须要藉由 autoconfig 这个相关的套件来辅助才行。</li><br>
		<li><span class="text_import1">需要 Kernel 提供的 Library 以及相关的 Include 档案：</span><br>
			从前面的原始码编译过程，我们晓得函式库( library )的重要性，同时也晓得有
			include 档案的存在。很多的套件在发展的时候都是直接取用系统核心提供的函式库与
			include 档案的，这样才可以与这个操作系统兼容啊！尤其是在『
			<span class="text_import2">驱动程序方面的套件</span> 』，例如网络卡、声卡、USB
			等驱动程序在安装的时候，常常是需要核心提供的相关信息的。在 Red Hat
			 的系统当中 ( 包含 Fedora 等系列 ) ，这个核心相关的功能通常都是被包含在
			<span class="text_import2">kernel-source</span>
			或 <span class="text_import2"> kernel-header</span> 这些套件名称当中，所以记得要安装这些套件喔！
			</li></ul>

		虽然 Tarball 的安装上面相当的简单，如同我们前面几个小节的例子，只要顺着开发商提供的
		README 与 INSTALL 档案所载明的步骤来进行，安装是很容易的。但是我们却还是常常会在
		BBS 或者是新闻组当中发现这些留言：『我在执行某个程序的侦测档案时，他都会告诉我没有
		gcc 这个套件，这是怎么回事？』还有：『我没有办法使用 make 耶！这是什么问题？』呵呵！
		这就是没有安装上面提到的那些基础套件啦！<br><br>

		咦！为什么使用者不安装这些套件啊？呵呵！这是因为目前的 Linux distribution
		大多已经偏向于桌面计算机的使用，他们希望使用者能够按照厂商自己的希望来安装相关的套件即可，
		所以通常『预设』是没有安装
		gcc 或者是 make 等套件的。所以啦，<span class="text_import2">如果您希望未来可以自行安装一些以
		Tarball 方式释出的套件时，记得请自行挑选想要安装的套件名称喔</span>！例如在
		Fedora 或者是 Red Hat 当中记得选择 <span class="text_import2">Software Development</span>
		以及 <span class="text_import2">Kernel Source Development</span> 等相关字眼的群集呢。<br><br>

		<span class="text_import2">那万一我已经安装好一部 Linux 主机，但是使用的是默认值所安装的套件，所以没有
		make, gcc 等咚咚，该如何是好</span>？呵呵！问题其实不大啦，目前使用最广泛的 Fedora
		或者是 Red Hat 大多是以 RPM ( 下一章会介绍 ) 来安装套件的，所以，您只要拿出当初安装
		Linux 时的原版光盘，然后以下一章介绍的 RPM 来一个一个的加入到您的 Linux
		主机里面就好啦！很简单的啦！<br><br>
	</div>

	<hr><a name="tarball_step"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">Tarball 安装的基本步骤</span>
	<div class="block2">
		我们提过以 Tarball 方式释出的套件是需要重新编译可执行的
		binary file 的。而 Tarball 是以 tar 这个指令来打包与压缩的档案，所以啦，当然就需要先将
		Tarball 解压缩，然后到原始码所在的目录下进行 makefile 的建立，再以 make
		来进行编译与安装的动作啊！所以整个安装的基础动作大多是这样的：<ol><span class="text_import2">
		<li>将 tarball 档案在 /usr/local/src 目录下解压缩；
		</li><li>进入新建立的目录底下，去查阅 INSTALL 与 README 等相关档案内容( 很重要的步骤！ )；
		</li><li>根据 INSTALL/README 的内容察看并安装好一些相依的套件( 非必要 )；
		</li><li>以自动侦测程序( configure 或 config )侦测作业环境，并建立 Makefile 这个档案；
		</li><li>以 make 这个程序并使用该目录下的 Makefile 做为他的参数配置文件，来进行 make ( 编译或其他 )的动作；
		</li><li>以 make 这个程序，并以 Makefile 这个参数配置文件，依据
			install 这个目标( target )的指定来安装到正确的路径！</li></span></ol>

		注意到上面的第二个步骤，通常在每个软件在释出的时候，都会附上
		INSTALL 或者是 README 这种档名的说明档，这些说明档请『<span class="text_import2">确实详细的</span>』
		阅读过一遍，通常这些档案会记录这个软件的安装要求、软件的工作项目、
		与软件的安装参数设定及技巧等，只要仔细的读完这些档案，基本上，要安装好
		tarball 的档案，都不会有什么大问题啰。至于 makefile 在制作出来之后，里头会有相当多的目标(
		target )，最常见的就是 install 与 clean 啰！通常『make clean』代表着将目标文件(
		object file )清除掉，『make』则是将原始码进行编译而已。
		注意喔！编译完成的可执行文件与相关的配置文件还在原始码所在的目录当中喔！因此，最后要进行『make
		install』来将编译完成的所有咚咚都给他安装到正确的路径去，这样就可以使用该套件啦！<br><br>

		OK！我们底下约略提一下大部分的 tarball 软件之安装的指令下达方式：<ol>
		<li><span class="text_import1">./configure</span><br>
			这个步骤就是在建立 Makefile 这的档案啰！通常程序开发者会写一支
			scripts 来检查您的 Linux 系统、相关的套件属性等等，这个步骤相当的重要，
			因为未来您的安装信息都是这一步骤内完成的！另外，这个步骤的相关信息应该要参考一下该目录下的
			README 或 INSTALL 相关的档案！！基本上，这个步骤完成之后会建立( 或修改
			)一个 Makefile ，这就是参数档啦！</li><br>
		<li><span class="text_import1">make clean</span><br>
			make 会读取 Makefile 中关于 clean 的工作。这个步骤不一定会有，但是希望执行一下！
			为什么呢？因为在进行编译的时候，会产生一些
			*.o 的档案，例如有个 abc.c 的原始码，经过编译后会产生 abc.o 的档案！我们称这些档案为
			object file ，这些档案如果之前已经编译过并留下来的话，那么这次再编译的时候，
			就不会编译该档案，然而由于我们可能已经修改了部分的参数，因此该档案的编译结果事实
			上应该会有所不同！因此，为了避免前一次留下来的数据可能影响到这次编译的结果，
			所以通常可以进行一下这个步骤啰！</li><br>
		<li><span class="text_import1">make</span><br>
			make 会依据 Makefile 当中的预设工作进行编译的行为！编译的工作主要是进行
			gcc 来将原始码编译成为可以被执行的 object files ，但是这些 object files
			通常还需要一些函式库之类的 link 后，才能产生一个完整的执行档！使用 make
			就是要将原始码编译成为可以被执行的可执行文件，而这个可执行文件会放置在目前所在的目录之下，
			尚未被安装到预定安装的目录中；</li><br>
		<li><span class="text_import1">make install</span><br>
			通常这就是最后的安装步骤了，make 会依据 Makefile
			这个档案里面关于 install 的项目，将上一个步骤所编译完成的数据给他安装到预定的目录中，
			就完成安装啦！</li></ol>
		请注意，上面的步骤是一步一步来进行的，而
		<span class="text_import2">其中只要一个步骤无法成功，那么后续的步骤就完全没有办法进行的！</span>
		因此，要确定每一的步骤都是成功的才可以！举个
		例子来说，万一今天你在 ./configure 就不成功了，那么就表示 Makefile
		无法被建立起来，要知道，后面的步骤都是根据
		Makefile 来进行的，既然无法建立 Makefile ，后续的步骤当然无法成功啰！另外，如果在
		make 无法成功的话，那就表示源文件无法被编译成可执行文件，那么 make install
		主要是将编译完成的档案给他安装下去的，既然都没有成功的执行档了，怎么进行安装？
		所以啰，要每一个步骤都正确无误才能往下继续做！此外，如果安装成功，
		并且是安装在独立的一个目录中，例如 /usr/local/packages 这个目录中好了，那么您就必需手动的将这个套件的
		man page 给他放到 /etc/man.config 里面去。<br><br>
	</div>

	<hr><a name="tarball_common"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">一般
	Tarball 套件安装的建议事项( 如何移除？升级？ )</span>
	<div class="block2">
		或许您已经发现了也说不定，那就是<span class="text_import2">为什么前一个小节里面，
		Tarball 要在 /usr/local/src 里面解压缩呢</span>？呵呵！基本上，在预设的情况下，原本的
		Linux distribution 释出安装的套件大多是在 /usr 里面的，而使用者自行安装的套件则建议放置在
		/usr/local 里面。这是考虑到管理使用者所安装套件的便利性。<br><br>

		怎么说呢？我们晓得几乎每个套件都会提供联机帮助的服务，那就是
		info 与 man 的功能。在预设的情况下， man 会去搜寻 /usr/local/man 里面的说明文件，
		因此，如果我们将套件安装在 /usr/local 底下的话，那么自然安装完成之后，
		该套件的说明文件就可以被找到了。此外，如果您所管理的主机其实是由多人共同管理的，
		或者是如同学校里面，一部主机是由学生管理的，但是学生总会毕业吧？
		所以需要进行交接，如果大家都将套件安装在
		/usr/local 底下，那么管理上不就显的特别的容易吗？！<br><br>

		所以啰，通常我们会建议大家将自己安装的套件放置在
		/usr/local 下，至于原始码( Tarball )则建议放置在 /usr/local/src( src 为
		source 的缩写 )底下啊。<br><br>

		再来，让我们先来看一看 Linux distribution 默认的安装套件的路径会用到哪些？我们以
		apache 这个软件来说明的话( apache 是 WWW 服务器软件，详细的数据请参考服务器架设篇。
		您的系统不见得有装这个套件 )：<ul><span class="text_import2"><font face="细明体">
		<li>/etc/httpd
		</li><li>/usr/lib
		</li><li>/usr/bin
		</li><li>/usr/share/man</li></font></span></ul><font face="细明体"></font>

		我们会发现套件的内容大致上是摆在<span class="text_import2"> etc, lib, bin, man</span>
		等目录当中，分别代表『<span class="text_import2">配置文件、函式库、执行档、联机帮助档』。</span>
		好了，那么你是以 tarball 来安装时呢？如果是放在预设的 /usr/local 里面，由于 
		/usr/local 原本就默认这几个目录了，所以你的数据就会被放在：
		<ul><span class="text_import2"><font face="细明体">
		<li>/usr/local/etc
		</li><li>/usr/local/bin
		</li><li>/usr/local/lib
		</li><li>/usr/local/man</li></font></span></ul><font face="细明体"></font>

		但是如果你每个套件都选择在这个默认的路径下安装的话，
		那么所有的套件的档案都将放置在这四个目录当中，因此，如果你都安装在这个目录下的话，
		那么未来再想要升级或移除的时候，就会比较难以追查档案的来源啰！
		而如果您在安装的时候选择的是单独的目录，例如我将
		apache 安装在 /usr/local/apache 当中，那么您的档案目录就会变成：
		<ul><span class="text_import2"><font face="细明体">
		<li>/usr/local/apache/etc
		</li><li>/usr/local/apache/bin
		</li><li>/usr/local/apache/lib
		</li><li>/usr/local/apache/man</li></font></span></ul><font face="细明体"></font>

		呵呵呵呵！单一套件的档案都在同一个目录之下，那么要移除该套件就简单的多了！
		<span class="text_import2">只要将该目录移除即可视为该套件已经被移除啰</span>
		！以上面为例，我想要移除
		apache 只要下达『<span class="text_import2">rm -rf /usr/local/apache</span>』
		就算移除这个套件啦！当然啰，实际安装的时候还是得视该软件的
		Makefile 里头的 install 信息才能知道到底他的安装情况为何的。因为例如 sendmail
		的安装就很麻烦......这个方式虽然有利于套件的移除，但不晓得您有没有发现，
		我们在执行某些指令的时候，与该指令是否在
		PATH 这个环境变量所记录的路径有关，以上面为例，我的 /usr/local/apache/bin
		肯定是不在 PATH 里面的，所以执行 apache 的指令就得要利用绝对路径了，否则就得将这个
		/usr/local/apache/bin 加入 PATH 里面。另外，那个 /usr/local/apache/man
		也需要加入 man page 搜寻的路径当中啊！<br><br>

		除此之外， Tarball 在升级的时候也是挺困扰的，怎么说呢？我们还是以 apache
		来说明好了。WWW 服务器为了考虑互动性，所以通常会将 PHP+MySQL+Apache 一起安装起来(
		详细的信息请参考服务器架设篇 )，果真如此的话，那么每个套件在安装的时候『
		<span class="text_import2">都有一定的顺序与程序</span>！』因为他们三者之间具有相关性，
		所以安装时必需要三者同时考虑到他们的函式库与相关的编译参数。那么如果今天我只要升级
		PHP 呢？有的时候因为只有涉及动态函式库的升级，那么我只要升级 PHP 即可！其他的部分或许影响不大。但是如果今天
		PHP 需要重新编译的模块比较多，那么可能会连带的，连 Apache 
		这个程序也需要重新编译过才行！真是有点给他头痛的！没办法啦！使用
		tarball 确实有他的优点啦，但是在这方面，确实也有他一定的伤脑筋程度。<br><br>

		由于 Tarball 在升级与安装上面具有这些特色，亦即 Tarball 在反安装上面具有比较高的难度(
		如果您没有好好规划的话～ )，所以，为了方便 Tarball 的管理，通常我们会这样建议使用者：
		<ol>
		<li><span class="text_import2">最好将 tarball 的原始数据解压缩到 /usr/local/src 当中；</span></li><br>
		<li><span class="text_import2">安装时，最好安装到 /usr/local 这个默认路径下；</span></li><br>
		<li><span class="text_import2">考虑未来的反安装步骤，最好可以将每个套件单独的安装在 
		/usr/local 底下：</span><br>
			例如安装 rp-pppoe-2.6.tar.gz 时，则可以指定该套件需要安装于
			/usr/local/rp-pppoe 当中，如此一来，该套件会将所有的数据都写入 /usr/local/rp-pppoe
			当中，因此，未来如果要移除该套件，只要将该目录删除即可视为成功的移除了！</li><br>
		<li><span class="text_import2">加上 man path </span><br>
			不过单独安装某个套件在某一特定路径下的作法，会导致当有
			man page 的时候，使用预设的 MANPATH 会找不到相关的说明档案内容。这个时候就必须要将
			man page 的路径加到 /etc/man.config 档案中了！否则使用 man 
			也查询不到指令的使用方法的。以上面的例子为例，如果是安装了
			/usr/local/rp-pppoe 当中，通常 man page 会放在 /usr/local/rp-pppoe/man
			当中，所以，您就必需要在 /etc/man.config 里面差不多 40~50 
			行左右的地方，加入底下这一行：
			<ul><br><span class="text_import2">MANPATH /usr/local/rp-pppoe/man</span></ul><br>
			这样就可以使用 man 来查询资料啰！</li></ol>
	</div>

	<hr><a name="tarball_exntp"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">一个简单的范例、利用
	ntp 来示范</span>
	<div class="block2">
		读万卷书不如行万里路啊！所以当然我们就来给他测试看看，看您是否真的了解了如何利用
		Tarball 来安装软件呢？！我们利用时间服务器 ntp-4.1.2 这个套件来测试安装看看。先请到
		<a href="http://www.ntp.org/downloads.html" target="_blank">http://www.ntp.org/downloads.html</a>
		这个目录去下载文件，(<span class="text_vbird">您也可以下载比较新的档案来测试的啦！</span>)
		或者直接到鸟哥的网站下载：<ul>
		<a href="../../../linux.vbird.org/linux_basic/0520source/ntp-stable-4.2.0a-20050816.tar.gz">http://linux.vbird.org/linux_basic/0520source/ntp-stable-4.2.0a-20050816.tar.gz</a>。</ul>

		假设我对这个套件的要求是这样的：
		<ul>
		<li>假设 ntp-stable-4.2.0a-20050816.tar.gz 这个档案放置在 /root 这个目录下；</li>
		<li>原始码请解开在 /usr/local/src 底下；</li>
		<li>我要安装到 /usr/local/ntp 这个目录中；</li></ul>

		那么您可以依照底下的步骤来安装测试看看( 
		<span class="text_vbird">如果可以的话，请您不要参考底下的文件数据，
		先自行安装过一遍这个软件，然后再来对照一下鸟哥的步骤喔！</span>)。

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd"># 1. 解压缩，并阅读一下 ntp 底下的 README 与 INSTALL：</span>
[root@linux ~]# <span class="term_command">cd /usr/local/src</span>
[root@linux src]# <span class="term_command">tar -zxvf /root/ntp-stable-4.2.0a-20050816.tar.gz</span>
<span class="term_say"># 这个步骤会让原始码解开成为 /usr/local/src/ntp-stable-4.2.0a-20050816 这个目录</span>

<span class="term_hd"># 2. 进入原始码所在目录，并且查阅如何安装的技巧：</span>
[root@linux src]# <span class="term_command">cd ntp-stable-4.2.0a-20050816</span>
[root@linux ntp*]# <span class="term_command">vi INSTALL ( 或 vi README )</span>

<span class="term_hd"># 3. 开始设定参数、编译与安装：</span>
[root@linux ntp*]# <span class="term_command">./configure --help | more</span>
<span class="term_say"># 上面这个动作可以察看一下可用的参数！</span>

[root@linux ntp*]# <span class="term_command">./configure --prefix=/usr/local/ntp \</span>
&gt; <span class="term_command"> --enable-all-clocks --enable-parse-clocks</span>
checking build system type... i686-pc-linux-gnu
checking host system type... i686-pc-linux-gnu
checking target system type... i686-pc-linux-gnu
<span class="term_say">......中间省略......</span>
config.status: creating util/Makefile
config.status: creating config.h
config.status: executing depfiles commands
<span class="term_say"># 一般来说 configure 设定参数较重要的就是那个 --prefix=/path 了，
# --prefix 后面接的路径就是『<span class="term_note_b">这个软件未来要安装到那个目录去</span>？』
# 如果您没有指定 --prefix=/path 这个参数，通常预设参数就是 /usr/local
# 至于其他的参数意义就得要参考 ./configure --help 了！
# 这个动作完成之后会产生 makefile 或 Makefile 这个档案
# 当然啦，这个侦测检查的过程会显示在屏幕上，<span class="term_note_b">特别留意关于 gcc 的检查</span>，
# 还有最重要的是<span class="term_note_b">最后需要成功的建立起 Makefile 才行</span>！(上面最后一行) </span>

<span class="term_hd"># 4. 编译与安装：</span>
[root@linux ntp*]# <span class="term_command">make clean; make</span>
[root@linux ntp*]# <span class="term_command">make check</span>
[root@linux ntp*]# <span class="term_command">make install</span>
<span class="term_say"># 将数据给他安装在 /usr/local/ntp 底下</span>
</pre></td></tr></tbody></table>

		整个动作就这么简单，您完成了吗？！完成之后到
		/usr/local/ntp 您发现了什么？！<br><br>
	</div>

	<hr><a name="tarball_patch"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">利用 patch 更新原始码</span>
	<div class="block2">
		我们在前言里面介绍了<a href="#intro_howto">为何需要进行套件的升级</a>，这是很重要的喔！那假如我是以
		Tarball 来进行某个套件的安装，那么是否当我要升级这个套件时，就得要下载这个套件的完整全新的
		Tarball 呢？举个例子来说，鸟哥有个讨论区在 <a href="http://phorum.vbird.org/">http://phorum.vbird.org</a>
		这个网址，这个讨论区是以 phpBB 这个套件来架设的，而鸟哥的讨论区版本为 phpbb2.0.1.tar.gz
		，目前( 2005/09/30 )最新释出的版本则是 phpbb2.0.17.tar.gz 。那我是否需要下载全新的
		phpbb2.0.17.tar.gz 这个档案来更新原本的旧程序呢？<br><br>

		事实上，当我们发现一些套件的漏洞，通常是某一段程序代码写的不好所致。因此，
		所谓的『更新原始码』常常是只有更改部分档案的小部分内容而已。
		既然如此的话，那么我们是否可以就那些被更动的档案来进行修改就可以咯？
		也就是说，旧版本到新版本间没有更动过的档案就不要理他，仅将有修订过的档案部分来处理即可。
		这有什么好处呢？首先，没有更动过的档案的目标文件(
		object file )根本就不需要重新编译，而且有更动过的档案又可以利用 make 来自动
		update ( 更新 )，如此一来，呵呵！我们原先的设定( makefile 档案里面的规则
		)将不需要重新改写或侦测！呵呵！可以节省很多宝贵的时间呢( 例如后续章节会提到的核心的编译！)<br><br>

		从上面的说明当中，我们可以发现，如果可以将旧版的原始码数据改写成新版的版本，
		那么就能直接编译了，而不需要将全部的新版
		Tarball 重新下载一次呢！可以节省带宽与时间说！那么如何改写原始码？
		难道要我们一个档案一个档案去参考然后修订吗？当然没有这么没人性！<br><br>

		我们在<a href="http://linux.vbird.org/linux_basic/0520source/0330regularex.php">正规表示法</a>的时候有提到一个比对两个档案的指令，那就是
		diff ，这个指令可以将『<span class="text_import2">两个档案之间的差异性列出来</span>』呢！
		那我们也知道新旧版本的档案之间，其实只有修改一些程序而已，那么我们可以透过
		diff 比对出新旧版本之间的文字差异，然后再以相关的指令来将旧版的档案更新吗？！呵呵！当然可以啦！那就是
		patch 这个指令啦！很多的套件开发商在更新了原始码之后，几乎都会释出所谓的
		patch file，也就是直接将原始码 update 而已的一个方式喔！我们底下以一个简单的范例来说明给您了解喔！<br><br>

		假设我们有两个档案，分别是 expatch.old 与 expatch.new ，他们的内容是这样的：

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">vi expatch.old</span>
<span class="term_write">echo "check your postfix's body and header drop settings"
echo "postmap -q - regexp:header_checks &lt; header_checks"
postmap -q - regexp:header_checks &lt; header_checks
echo "postmap -q - regexp:body_checks &lt; body_checks"
postmap -q - regexp:body_checks &lt; body_checks</span>

[root@linux ~]# <span class="term_command">vi expatch.new</span>
<span class="term_write">echo "check your postfix's body and header drop settings"
echo "postmap -q - regexp:header_checks &lt; header_checks This's right"
postmap -q - regexp:header_checks &lt; header_checks
echo "postmap -q - regexp:body_checks &lt; body_checks This's right"
postmap -q - regexp:body_checks &lt; body_checks</span>
</pre></td></tr></tbody></table>

		两个档案的不同点在于：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">diff expatch.old expatch.new</span>
2c2
&lt; echo "postmap -q - regexp:header_checks &lt; header_checks"
---
&gt; echo "postmap -q - regexp:header_checks &lt; header_checks This's right"
4c4
&lt; echo "postmap -q - regexp:body_checks &lt; body_checks"
---
&gt; echo "postmap -q - regexp:body_checks &lt; body_checks This's right"
</pre></td></tr></tbody></table>

		上面显示出两个档案的不同点，详细的意义请参考正规表示法那个章节的介绍。
		好了，假如我以『 <span class="text_import2"><font face="细明体">diff -c expatch.old
		expatch.new</font></span> 』以及上面显示的信息，做成一个档案，内容是这样的：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">diff -Naur expatch.old expatch.new &gt; expatch.patch</span>
[root@linux ~]# <span class="term_command">vi expatch.patch</span>
--- expatch.old 2005-09-30 15:47:54.000000000 +0800
+++ expatch.new 2005-09-30 15:48:06.000000000 +0800
@@ -1,5 +1,5 @@
 echo "check your postfix's body and header drop settings"
-echo "postmap -q - regexp:header_checks &lt; header_checks"
+echo "postmap -q - regexp:header_checks &lt; header_checks This's right"
 postmap -q - regexp:header_checks &lt; header_checks
-echo "postmap -q - regexp:body_checks &lt; body_checks"
+echo "postmap -q - regexp:body_checks &lt; body_checks This's right"
 postmap -q - regexp:body_checks &lt; body_checks
</pre></td></tr></tbody></table>

		注意到，这个档案的第一行显示出旧版本的文件名，而第二行则为新版本的档名与时间，
		第三行以后则是两个档案的差异性。那么我们将以
		patch 来进行更新，将 expatch.old 更新到 expatch.new 看看。patch 的基本语法是这样的：

		<ul><span class="text_import1"><font face="细明体">patch -p数字 &lt; patch_file</font></span></ul>

		特别留意那个 -p数字，那是与 patch_file 里面列出的文件名有关的信息。假如在
		patch_file 第一行写的是这样：

		<ul><span class="text_import1"><font face="细明体">*** /home/guest/example/expatch.old</font></span></ul>

		那么当我下达『 patch -p0 &lt; patch_file 』时，则更新的档案是『 /home/guest/example/expatch.old
		』，如果『 patch -p1 &lt; patch_file』，则更新的档案为『home/guest/example/expatch.old』，如果『patch
		-p4 &lt; patch_file』则更新『expatch.old』，也就是说， 
		-pxx 那个 xx 代表『拿掉几个斜线(/)』的意思！这样可以理解了吗？！好了，那么我要开始来更新我的
		expatch.old 了，可以这样搞定：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">patch -p0 &lt; expatch.patch</span>
patching file expatch.old
<span class="term_say"># 注意喔，这个时候我的工作目录底下会存在 expatch.old 才对！
# 然后立刻察看一下，您会发觉， expatch.new 与 expatch.old 变成一模一样的了！</span>
</pre></td></tr></tbody></table>

		很容易了解吧！上面三个档案您可以在底下的网址取得：
		<ul><a href="../../../linux.vbird.org/linux_basic/0520source/expatch.gz">http://linux.vbird.org/linux_basic/0520source/expatch.tgz</a></ul>
		加油的啦！另外，<span class="text_import2">如果您是以 patch 更新原始码，那么记得，
		您可能必须要重新编译，并且重新 install 才算成功更新喔！并不是 patch 就好了！因为 patch 
		的功能主要仅只是更新原始码档案而已！切记切记</span>！<br><br>

		鸟哥提问题：如果我有一个很旧版的套件，这个套件已经更新到很新的版本，例如核心，那么我可以使用
		patch file 来更新吗？<ul>
		这个问题挺有趣的，首先，您必须要确定旧版本与新版本之间『确实有释出
		patch file 』才行，以 kernel 2.2.xx 及 2.4.xx 来说，这两者基本上的架构已经不同了，所以两者间是无法以
		patch file 来更新的。不过， 2.4.xx 与 2.4.yy 就可以更新了。不过，因为 kernel
		每次推出的 patch 档案都仅针对前一个版本而已，所以假设要由 kernel 2.4.20
		升级到 2.4.26 ，就必须要使用 patch 2.4.21, 2.4.22, 2.4.23, 2.4.24, 2.4.25,
		2.4.26 六个档案来『<b>依序更新</b>』才行喔！当然，如果有朋友帮您比对过
		2.4.20 与 2.4.26 ，那您自然就可以使用该 patch file 来直接一次更新啰！</ul>
	</div>
</div>


<hr><a name="library"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">函式库管理：</span>
<div class="block1">
	在我们的 Linux 操作系统当中，函式库是很重要的一个项目。
	因为很多的套件之间都会互相取用彼此提供的函式库来进行特殊功能的运作，例如很多需要验证身份的程序都习惯利用
	PAM 这个模块提供的验证机制来实作，而很多网络联机机制则习惯利用 SSL
	函式库来进行联机加密的机制。所以说，函式库的利用是很重要的。不过，
	函式库又依照是否被编译到程序内部而分为动态与静态函式库，这两者之间有何差异？哪一种函式库比较好？
	底下我们就来谈一谈先！<br><br>

	<hr><a name="library_dyna_sta"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">动态与静态函式库</span>
	<div class="block2">
		首先我们要知道的是，函式库的类型有哪些？依据函式库被使用的类型而分为两大类，分别是静态(
		Static )与动态( Dynamic )函式库两类。底下我们来谈一谈这两种类行的函式库吧！<br><br>

		<li><span class="text_import1">静态函式库：</span></li>
		<ul>
		<li><b>扩展名</b>：<br>
		这类的函式库通常扩展名为 <span class="text_import2">libxxx.a</span> 的类型；</li><br>
		<li><b>编译行为</b>：<br>
		这一类型的函式库在被使用到程序当中的时候，都是整个函式库的所有数据被整合到执行文件当中，
		也就是说，当我们在进行编译的动作时，这个函式库会被加入到执行档内，所以
		<span class="text_import2">利用静态函式库编译成的档案会比较大一些喔</span>；</li><br>
		<li><b>独立执行的状态</b>：<br>这类函式库最大的优点，就是编译成功的可执行文件
		<span class="text_import2">可以独立执行</span>，而不需要再向外部要求读取函式库的内容(
		请参照动态函式库的说明 )。</li><br>
		<li><b>升级难易度</b>：<br>虽然执行档可以独立执行，然而当函式库升级的时候，
		由于我们的执行档取用的是之前版本的函式库，所以当函式库升级后，
		连执行档也需要重新编译过一次，才能将新的函式库整合到执行档当中。</li></ul>
　
		<li><span class="text_import1">动态函式库：</span></li>
		<ul>
		<li><b>扩展名</b>：<br>这类函式库通常扩展名为 <span class="text_import2">libxxx.so</span>
		的类型；</li><br>
		<li><b>编译行为</b>：<br>动态函式库与静态函式库的编译行为差异挺大的，
		静态函式库是整个被编译到执行文件当中，但是动态函式库在编译的时候，在程序里面只有一个『
		<span class="text_import2">指向( Pointer )</span>』 的位置而已。
		也就是说，动态函式库的内容并没有被整合到执行档当中，而是当执行档要使用到函式库的机制时，
		程序才会去读取函式库来使用。由于执行文件当中仅具有指向动态函式库所在的指标而已，
		并不包含函式库的内容，所以<span class="text_import2">他的档案会比较小一点</span>。</li><br>
		<li><b>独立执行的状态</b>：<br>这类型的函式库<span class="text_import2">不能被独立执行</span>，
		因为当我们使用到函式库的机制时，程序会去读取函式库，所以函式库『
		<span class="text_import2">必须要存在</span>』才行，而且，函式库的『
		<span class="text_import2">所在目录也不能改变</span>』，
		因为我们的可执行文件里面仅有『指标』亦即当要取用该动态函式库时，程序会主动去某个路径下读取，
		呵呵！所以动态函式库可不能随意移动或删除，会影响很多相依的程序软件喔！</li><br>
		<li><b>升级难易度</b>：<br>虽然这类型的执行档无法独立运作，然而由于是具有指向的功能，
		所以，当函式库升级后，执行档根本不需要进行重新编译的行为，因为执行档会直接指向新的函式库档案(
		前提是函式库新旧版本的档名相同喔！ )。</li></ul>

		在目前的 Linux distribution 当中，我们比较倾向于使用动态函式库，
		因为如同上面提到的最重要的一点，就是函式库的升级方便！由于
		Linux 系统里面的套件相依性太复杂了，如果使用太多的静态函式库，那么升级某一个函式库时，
		都会对整个系统造成很大的冲击！因为其他相依的执行档也要同时重新编译啊！
		这个时候动态函式库可就有用多了，因为只要动态函式库升级就好，其他的套件根本无须变动。<br><br>

		那么这些函式库放置在哪里呢？绝大多数的函式库都放置在：<ul>
		<li>/usr/lib</li>
		<li>/lib</li></ul>

		此外，Linux 系统里面很多的函式库其实 kernel 就提供了，那么 kernel 
		的函式库放在哪里？呵呵！就是在<span class="text_import1">
		/lib/modules</span> 里面啦！里面的数据可多着呢！不过要注意的是，
		<span class="text_import2">不同版本的核心提供的函式库差异性是挺大的，所以
		kernel 2.4.xx 版本的系统不要想将核心换成 2.6.xx 喔！
		很容易由于函式库的不同而导致很多原本可以执行的软件套件无法顺利运作呢</span>！
		更多的核心相关说明我们在后面会继续的给他介绍的。
	</div>
　
	<hr><a name="library_ldconfig"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">ldconfig
	与 /etc/ld.so.conf</span>
	<div class="block2">
		在了解了动态与静态函式库，也知道我们目前的 Linux 
		大多是将函式库做成动态函式库之后，再来要知道的就是，那有没有办法增加函式库的读取效能？！
		我们知道内存的访问速度是硬盘的好几倍，所以，
		<span class="text_import2">如果我们将常用到的动态函式库先加载内存当中(
		快取, cache )，如此一来，当软件套件要取用动态函式库时，就不需要重从头由硬盘里面读出啰！
		这样不就可以增进动态函式库的读取速度</span>？没错，是这样的！这个时候就需要
		ldconfig 与 /etc/ld.so.conf 的协助了。<br><br>

		如何将动态函式库加载高速缓存( cache )当中呢？
		<ol>
		<li>首先，我们必须要在 /etc/ld.so.conf 里面写下『
		<span class="text_import2">想要读入高速缓存当中的动态函式库所在的目录</span>』，注意喔，
		<span class="text_import2">是目录而不是档案；</span></li>
		<li>接下来则是利用 ldconfig 这个执行档将 /etc/ld.so.conf 的资料读入快取当中；</li>
		<li>同时也将数据记录一份在 /etc/ld.so.cache 这个档案当中吶！</li>
		</ol>

		事实上， ldconfig 还可以用来判断动态函式库的链接信息呢！赶紧利用 Fedora Core 4
		来测试看看。假设我还想要将我的 MySQL 函式库加入到快取当中：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">ldconfig [-f conf] [ -C cache] [-p]</span>
<span class="term_say">参数：
-f conf ：那个 conf 指的是某个文件名，也就是说，使用 conf 作为 libarary 
	  函式库的取得路径，而不以 /etc/ld.so.conf 为默认值
-C cache：那个 cache 指的是某个文件名，也就是说，使用 cache 作为快取暂存
	  的函式库资料，而不以 /etc/ld.so.cache 为默认值
-p	：列出目前有的所有函式库资料内容（在 /etc/ld.so.cache 内的资料！）
范例：</span>

<span class="term_hd">范例一：假设我的 MySQL 数据库函式库在 /usr/lib/mysql 当中，如何读入 cache ？</span>
[root@linux ~]# <span class="term_command">vi /etc/ld.so.conf</span>
include ld.so.conf.d/*.conf
<span class="term_write">/usr/lib/mysql</span>   <span class="term_note">&lt;==这一行新增的啦！</span>

[root@linux ~]# <span class="term_command">ldconfig</span>
<span class="term_say"># 画面上不会显示任何的信息，不要太紧张！正常的！</span>

[root@linux ~]# <span class="term_command">ldconfig -p</span>
928 libs found in cache `/etc/ld.so.cache'
        libz.so.1 (libc6) =&gt; /usr/lib/libz.so.1
        libz.so (libc6) =&gt; /usr/lib/libz.so
<span class="term_say">......中间省略......</span>
</pre></td></tr></tbody></table>

		透过上面的动作，我们可以将 MySQL 的相关函式库给他读入快取当中，
		这样可以加快函式库读取的效率呢！在某些时候，您可能会自行加入某些
		Tarball 安装的动态函式库，而您想要让这些动态函式库的相关连结可以被读入到快取当中，
		这个时候您可以将动态函式库所在的目录名称写入
		/etc/ld.so.conf 当中，然后执行 ldconfig 就可以啦！<br><br>
	</div>

	<hr><a name="library_ldd"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">ldd</span>
	<div class="block2">
		说了这么多，那么我如何判断某个可执行的 binary 档案含有什么动态函式库呢？很简单，利用
		ldd 就可以晓得了！例如我想要知道 /usr/bin/passwd 这个程序含有的动态函式库有哪些，可以这样做：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">ldd [-vdr] [filename]</span>
<span class="term_say">参数：
-v ：列出所有内容信息；
-d ：重新将资料有遗失的 link 点秀出来！
-r ：将 ELF 有关的错误内容秀出来！
范例：</span>

<span class="term_hd">范例一：找出 /usr/bin/passwd 这个档案的函式库数据</span>
[root@linux ~]# <span class="term_command">ldd /usr/bin/passwd</span>
        linux-gate.so.1 =&gt;  (0x00d19000)
	<span class="term_say">.......中间省略......</span>
        libpam_misc.so.0 =&gt; /lib/libpam_misc.so.0 (0x00bd6000)
	<span class="term_say">.......中间省略......</span>
<span class="term_say"># 我们前言的部分不是一直提到 passwd 有使用到 pam 的模块吗？！怎么知道？
# 利用 ldd 察看一下这个档案，看到 libpam.so 了吧？这就是 pam 提供的函式库</span>

<span class="term_hd">范例二：找出 /lib/libc.so.6 这个函式的相关其他函式库！</span>
[root@linux ~]# <span class="term_command">ldd /lib/libc.so.6</span>
        /lib/ld-linux.so.2 (0x00bf1000)
        linux-gate.so.1 =&gt;  (0x00632000)

[root@linux ~]# <span class="term_command">ldd -v /lib/libc.so.6</span>
        /lib/ld-linux.so.2 (0x00bf1000)
        linux-gate.so.1 =&gt;  (0x00111000)

        Version information:
        /lib/libc.so.6:
                ld-linux.so.2 (GLIBC_2.1) =&gt; /lib/ld-linux.so.2
                ld-linux.so.2 (GLIBC_2.3) =&gt; /lib/ld-linux.so.2
                ld-linux.so.2 (GLIBC_PRIVATE) =&gt; /lib/ld-linux.so.2
</pre></td></tr></tbody></table>

		未来如果您常常升级安装 RPM 的套件时( 下一章节会介绍 )，应该常常会发现那个『
		<span class="text_import2">相依属性</span>』的问题吧！？没错！我们可以先以
		ldd 来视察『<span class="text_import2">相依函式库</span>』之间的相关性！以先取得了解！
		例如上面的例子中，我们检查了 libc.so.6 这个在 /lib 当中的函式库，结果发现他其实还跟 
		ld-linux.so.2 有关！所以我们就需要来了解一下，那个档案到底是什么套件的函式库呀！？使用
		-v 这个参数还可以得知该函式库来自于哪一个套件！像上面的数据中，就可以得到该
		libc.so.6 其实可以支持 GLIBC_2.1 等的版本！
	</div>
</div>


<hr><a name="check"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">检验软件正确性</span>
<div class="block1">
	前面提到很多升级与安装需要注意的事项，因为我们需要克服很多的程序漏洞，所以需要前往
	Linux distribution 或者是某些套件开发商的网站，下载最新并且较安全的档案来安装才行。
	好了，那么『<span class="text_import1">有没有可能我们下载的档案本身就有问题</span>？』
	是可能的！因为黑客无所不在，很多的套件开发商已经公布过他们的网页所放置的档案曾经被窜改过！
	那怎么办？连下载原版的数据都可能有问题了？难道没有办法判断档案的正确性吗？！<br><br>

	这个时候我们就要透过每个档案独特的指纹验证数据了！因为每个档案的内容与档案大小都不相同，
	所以如果一个档案被修改之后，必然会有部分的信息不一样！利用这个咚咚，我们可以使用
	MD5 这个指纹验证机制来判断该档案有没有被更动过！举个例子来说，义守大学提供的
	Red Hat 9 原版光盘下载点( <a href="http://ftp.isu.edu.tw/pub/Linux/RedHat/linux/9/en/iso/i386/" target="_blank">http://ftp.isu.edu.tw/pub/Linux/RedHat/linux/9/en/iso/i386/</a>
	)同时提供了 Red Hat 9 所有光盘 ISO 档案的 MD5 编码，透过这个编码的比对，
	我们就可以晓得下载的档案是否有问题。那么万一
	Red Hat 提供的光盘映象文件(image)被下载之后，让有心人士偷偷修改过，再转到
	Internet 上面流传，那么你下载的这个档案偏偏不是原厂提供的，呵呵！
	你能保证该档案的内容完全没有问题吗？！当然不能对不对？！是的，这个时候就有
	md5sum 这个档案指纹的咚咚出现啦！说说他的用法吧！<br><br>

	<hr><a name="check_md5sum"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">md5sum</span>
	<div class="block2">
		我们以 Red Hat 在 2004 年发布的一则程序臭虫修订程序为例：
		<ul><a href="https://rhn.redhat.com/errata/RHBA-2004-083.html" target="_blank">https://rhn.redhat.com/errata/RHBA-2004-083.html</a></ul>

		这个 grep-2.5.1-7.8.i386.rpm 的档案他的 MD5 指纹编码是：
		『5a0c3fcfcd4c3f937644b8cd71a0cf89』，如果您下载了这个档案，并且执行底下的指令，应该得到相同的指纹码的：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">md5sum [-bct] filename</span>
[root@linux ~]# <span class="term_command">md5sum [--status|--warn] --check filename</span>
<span class="term_say">参数：
-b ：使用 binary 的读档方式，默认为 Windows/DOS 档案型态的读取方式；
-c ：检验 md5sum 档案指纹；
-t ：以文字型态来读取 md5sum 的档案指纹。
范例：</span>

<span class="term_hd">范例一：将刚刚的档案下载后，测试看看！</span>
[root@linux ~]# <span class="term_command">wget \</span>
&gt; <span class="term_command">ftp://updates.redhat.com/9/en/os/i386/grep-2.5.1-7.8.i386.rpm</span>
[root@linux ~]# <span class="term_command">md5sum grep-2.5.1-7.8.i386.rpm</span>
5a0c3fcfcd4c3f937644b8cd71a0cf89  grep-2.5.1-7.8.i386.rpm
<span class="term_say"># 看！显示的编码是否与上面相同呢？！赶紧测试看看！</span>
</pre></td></tr></tbody></table>

		一般而言，每个系统里面的档案内容大概都不相同，例如你的系统中的 /etc/passwd
		这个登入信息文件与我的一定不一样，因为我们的用户与密码、 Shell 及家目录等大概都不相同，所以由
		md5sum 这个档案指纹分析程序所自行计算出来的指纹表当然就不相同啰！<br><br>

		好了，那么如何使用这个东西呢？基本上，您必须要在您的 Linux 系统上为您的这些重要的档案进行指纹数据库的建立(
		好像在做户口调查！ )，将底下这些档案建立数据库：<ul><span class="text_import2"><font face="细明体">
		<li>/etc/passwd
		</li><li>/etc/shadow( 假如你不让用户改密码了 )
		</li><li>/etc/group
		</li><li>/usr/bin/passwd
		</li><li>/sbin/portmap
		</li><li>/bin/login ( 这个也很容易被骇！ )
		</li><li>/bin/ls
		</li><li>/bin/ps
		</li><li>/usr/bin/top</li></font></span></ul><font face="细明体"></font>

		等等，这几个档案最容易被修改了！因为很多木马程序执行的时候，还是会有所谓的『执行序,
		PID』为了怕被 root 追查出来，所以他们都会修改这些检查排程的档案，如果你可以替这些档案建立指纹数据库(
		就是使用 md5sum 检查一次，将该档案指纹记录下来，然后常常以 
		<a href="http://linux.vbird.org/linux_basic/0520source/0340bashshell-scripts.php">shell script</a> 
		的方式由程序自行来检查指纹表是否不同了！ )，那么对于文件系统会比较安全啦！！
	</div>
</div>


<hr><a name="important"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">重点回顾</span>
<div class="block1">
<ul><span class="text_import2">
	<li>原始码其实大多是纯文本档，需要透过编译程序的编译动作后，才能够制作出 Linux 系统能够认识的可执行的 binary file ；
	</li><li>在 Linux 系统当中，最标准的 C 语言编译程序为 gcc ；
	</li><li>在编译的过程当中，可以藉由其他套件提供的函式库来使用该套件的相关机制与功能；
	</li><li>为了简化编译过程当中的复杂的指令输入，可以藉由 make 与 makefile 规则定义，来简化程序的更新、编译与连结等动作；
	</li><li>Tarball 为使用 tar 与 gzip 压缩功能所打包与压缩的，具有原始码程序文件的档案；
	</li><li>一般而言，要使用 Tarball 管理 Linux 系统上的套件，最好需要 gcc, make, autoconfig, kernel source, 
		kernel header 等前驱套件才行，所以在安装 Linux 之初，最好就能够选择 
		Software development 以及 kernel development 之类的群组；
	</li><li>函式库有动态函式库与静态函式库，动态函式库在升级上具有较佳的优势。动态函式库的扩展名为 *.so 而静态则是 *.a ；
	</li><li>patch 的主要功能在更新原始码，所以更新原始码之后，还需要进行重新编译的动作才行；
	</li><li>可以利用 ldconfig 与 /etc/ld.so.conf 来制作动态函式库的链接与快取！
	</li><li>透过 MD5 的编码可以判断下载的档案是否为原本厂商所释出的档案。
</li></span></ul>
</div>


<hr><a name="reference"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">参考资源</span>
<div class="block1">
	如果您对于程序的开发相当的有兴趣，那么真的建议挑这个跨平台的 C 语言来学习！
	<ul><li>gcc 的使用简介：<a href="http://zope.slat.org/Members/ycheng/Document/gcc" target="_blank">http://zope.slat.org/Members/ycheng/Document/gcc</a></li>
	<li>gdb 的使用简介：<a href="http://zope.slat.org/Members/ycheng/Document/gdb" target="_blank">http://zope.slat.org/Members/ycheng/Document/gdb</a></li>
	<li>C 程序语言：<a href="http://www.cyut.edu.tw/~ckhung/b/c/" target="_blank">http://www.cyut.edu.tw/~ckhung/b/c/</a></li>
	</ul>
</div>


<hr><span class="text_history">
2002/08/21：第一次完成<br>
2003/02/11：重新编排与加入 FAQ<br>
2004/03/25：原本是 Tarball 与 RPM ，本日开始将 Tarball 与 RPM&nbsp; 分开说明与讲解(后续会花好几天喔！)，<br>
　　　　　 最重要的是 Source code 的说明，并提到相关的 gcc compile 功能等等！<br>
2004/04/10：经历了当兵中的无奈生活，终于将这篇给他完工了～(当时的鸟哥在将军渔港与青山港～)<br>
2005/09/30：旧版文章 (Tarball 与 RPM 的简单说明) 移动到 <a href="http://linux.vbird.org/linux_basic/0520softwaremanager/0520rpmtarball.php">此处</a> 。<br>
2005/10/01：将风格作个转变之外，也将一些测试移转到 FC4 上面进行！<br>
2008/01/10：感谢网友 ayttk 的说明，原本的 make 语法网页已经移动到其他地方了，请参考 <a href="#20080110">这里</a>。<hr>
</span>
    </td>
    <td style="width: 16px; font-size: 6px;">　</td></tr>
<tr><td style="width: 16px; height: 16px;">　</td>
    <td style="width: 866px; height: 16px;">　</td>
    <td style="width: 16px; height: 16px;">　</td></tr>
</tbody></table>

<div style="padding-top: 0px; text-align: center;">
<span style="font-size: 80%;">
	<a href="http://linux.vbird.org/" target="_top" title="前往鸟哥的首页">http://linux.vbird.org</a>
	is designed by <a href="mailto:vbird@mail.vbird.idv.tw" title="联络鸟哥(我不要广告信！)">VBird</a>
		during 2001-2011. <a href="http://www.ksu.edu.tw/" target="_blank">ksu.edu</a></span>
                        ﻿<div id="apDiv4">
      <p>本网页主要以Firefox配合解析度 1024x768 作为设计依据&nbsp;&nbsp;&nbsp;&nbsp; 鸟哥自由软件整合应用研究室</p></div></div></div>
</center>
</body></html>
