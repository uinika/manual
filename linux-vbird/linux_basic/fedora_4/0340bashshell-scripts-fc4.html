<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="zh-TW"><head>

	<meta http-equiv="Content-Type" content="text/html; charset=utf8">
	<meta name="Author" content="VBird, 鸟哥">
	<meta name="Description" content="学习 Shell Scripts">
	<title>鸟哥的 Linux 私房菜 -- 学习 Shell Scripts</title>
    <script src="../../script/SpryMenuBar.js" type="text/javascript"></script>
	<script src="../../script/index.js" type="text/javascript"></script>
	<link href="../../css/SpryMenuBarHorizontal.css" rel="stylesheet" type="text/css" />
    <link href="../../css/main.css" rel="stylesheet" type="text/css" />
</head><body style="margin: 0pt; padding: 0pt;" class="table"onload="MM_preloadImages('../../index-2.html','../../index-2.html','../../index-2.html','../../index-2.html','../../index-2.html','../../index-2.html','../../index-2.html','../../index-2.html')">

<center>
<div id="apDiv5">
<div> <LINK REL="SHORTCUT ICON" HREF="../../index-2.html">
<!-- ImageReady Slices (title3.ai) -->
<table id="___01" width="898" height="81" border="0" align="center" cellpadding="0" cellspacing="0";>
	<tr>
		<td colspan="15">
			<img src="image/title/title_01.png" width="900" height="1" alt=""></td>
	</tr>
	<tr>
		<td rowspan="4" bgcolor="#182448"><p><img src="http://linux.vbird.org/cgi-bin/Count.cgi?dd=C&amp;ft=5&amp;sh=T&amp;md=8&amp;pad=Y&amp;df=vbird.dic.ksu.edu.tw.dat" width="93" align="left" title="計數器" /></p>
	    <p><font color="#FFFFFF" size="-1">since2012/04/23</font></p></td>
		<td rowspan="4" align="left" valign="top"><a href="../../index.html"><img src="image/title/title_03.png" alt="" width="263" height="79" border="0"></a></td>
		<td colspan="13">
			<img src="image/title/title_04.png" alt="" width="535" height="9" border="0"></td>
	</tr>
	<tr>
		<td rowspan="3">
			<img src="image/title/title_05.png" alt="" width="53" height="70" border="0"></td>
		<td colspan="2" align="left" valign="top"><a href="../0110whatislinux.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image51','','image/title/title_06.png',1)"><img src="image/title/title3_06.png" name="Image51" width="106" height="25" border="0" id="Image51" alt=""/></a></td>
		<td rowspan="2">
			<img src="image/title/title_07.png" alt="" width="27" height="37" border="0"></td>
		<td colspan="3" align="left" valign="top"><a href="../../linux_server/0110network_basic.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image52','','image/title/title_08.png',1)"><img src="image/title/title3_08.png" name="Image52" width="107" height="25" border="0" id="Image52" alt=""/></a></td>
		<td rowspan="2">
			<img src="image/title/title_09.png" alt="" width="37" height="37" border="0"></td>
		<td colspan="2" align="left" valign="top"><a href="../../about.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image53','','image/title/title_10.png',1)"><img src="image/title/title3_10.png" name="Image53" width="75" height="25" border="0" id="Image53" alt=""/></a></td>
		<td rowspan="3">
			<img src="image/title/title_11.png" alt="" width="35" height="70" border="0"></td>
		<td align="left" valign="top"><a href="mailto:vbird@mail.vbird.idv.tw" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image54','','image/title/title_12.png',1)"><img src="image/title/title3_12.png" name="Image54" width="74" height="25" border="0" id="Image54" alt=""/></a></td>
		<td rowspan="3">
			<img src="image/title/title_13.png" alt="" width="21" height="70" border="0"></td>
	</tr>
	<tr>
		<td colspan="2">
			<img src="image/title/title_14.png" alt="" width="106" height="12" border="0"></td>
		<td colspan="3">
			<img src="image/title/title_15.png" alt="" width="107" height="12" border="0"></td>
		<td colspan="2">
			<img src="image/title/title_16.png" width="75" height="12" alt=""></td>
		<td rowspan="2">
			<img src="image/title/title_17.png" alt="" width="74" height="45" border="0"></td>
	</tr>
	<tr>
		<td>
			<img src="image/title/title_18.png" alt="" width="15" height="33" border="0"></td>
		<td colspan="3" align="left" valign="top"><ul id="MenuBar1" class="MenuBarHorizontal">
	  <li><a href="../linux_basic.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image44','','image/title/title_19.png',1)"><img src="image/title/title3_19.png" name="Image44" width="123" height="33" border="0" id="Image44" /></a>
			    <ul>
			      <li><a href="../Mandrake9.0/mandrake9.0.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image46','','image/title/title_26.png',1)"><img src="image/title/title_23.png" name="Image46" width="120" height="26" border="0" id="Image46" alt="" /></a></li>
                  <li><a href="fc4.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image47','','image/title/title_27.png',1)"><img src="image/title/title_24.png" name="Image47" width="120" height="26" border="0" id="Image47" alt="" /></a></li>
                  <li><a href="../linux_basic.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image48','','image/title/title_28.png',1)"><img src="image/title/title_25.png" name="Image48" width="120" height="26" border="0" id="Image48" alt="" /></a></li>
                </ul>
		      </li>
		</ul></td>
		<td>
			<img src="image/title/title_20.png" alt="" width="42" height="33" border="0"></td>
		<td colspan="3" align="left" valign="top"><ul id="MenuBar2" class="MenuBarHorizontal">
	  <li><a href="../../linux_server/index.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image45','','image/title/title_21.png',1)"><img src="image/title/title3_21.png" name="Image45" width="125" height="33" border="0" id="Image45" /></a>
			    <ul>
			      <li><a href="../../linux_server/linux_redhat9/redhat9.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image43','','image/title/title_26.png',1)"><img src="image/title/title_23.png" name="Image43" width="120" height="26" border="0" id="Image43" alt=""/></a></li>
			      <li><a href="../../linux_server/centos4.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image49','','image/title/title_27.png',1)"><img src="image/title/title_24.png" name="Image49" width="120" height="26" border="0" id="Image49" alt="" /></a></li>
			      <li><a href="../../linux_server/index.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image50','','image/title/title_28.png',1)"><img src="image/title/title_25.png" name="Image50" width="120" height="26" border="0" id="Image50" alt="" /></a></li>
		        </ul>
		      </li>
		</ul></td>
		<td>
			<img src="image/title/title_22.png" alt="" width="47" height="33" border="0"></td>
	</tr>
	<tr>
		<td>
			<img src="image/title/Spacer.gif" width="101" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="263" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="53" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="15" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="91" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="27" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="5" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="42" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="60" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="37" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="28" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="47" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="35" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="74" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="22" height="1" alt=""></td>
	</tr>
</table>
<!-- End ImageReady Slices -->
<script type="text/javascript">
<!--
var MenuBar1 = new Spry.Widget.MenuBar("MenuBar1", {imgDown:"SpryAssets/SpryMenuBarDownHover.gif", imgRight:"SpryAssets/SpryMenuBarRightHover.gif"});
var MenuBar2 = new Spry.Widget.MenuBar("MenuBar2", {imgDown:"SpryAssets/SpryMenuBarDownHover.gif", imgRight:"SpryAssets/SpryMenuBarRightHover.gif"});
//-->
</script>
</div>
<table summary="本文内容的排版" style="width: 898px;" border="0" cellpadding="0" cellspacing="0">
<tbody><tr><td style="width: 16px; height: 16px;">　</td>
    <td style="width: 866px; height: 16px;">　</td>
    <td style="width: 16px; height: 16px;">　</td></tr>
<tr><td style="width: 16px; font-size: 6px;">　</td>
    <td width="866">

<!-- 本文的档头部分 -->
<div style="text-align: center;">
    <a href="http://linux.vbird.org/linux_basic/0340bashshell-scripts/0340bashshell-scripts.php">
    <span class="text_head0">学习<span class="text_head_en"> Shell Scripts</span></span></a><br>
</div>
    <div style="text-align: right;">
        <span class="text_history">最近更新日期：2005/08/29</span>
    </div>


<center>本文已不再维护，更新文章请参考<a href="http://linux.vbird.org/linux_basic/0340bashshell-scripts.php">此处</a></center>

<!-- 本文的档头部分 -->
<center><table class="head1" summary="排版：文章档头的说明"><tbody><tr><td class="head1">
	如果您真的很想要走信息这条路，并且想要好好的管理好属于您的主机，那么，别说鸟哥不告诉您，
	Shell Scripts 真的是必须要学习的一项课题呢！基本上， shell script 有点像是早期的批处理文件，
	亦即是将一些指令汇整起来一次执行，但是 Shell script 拥有更强大的功能，那就是，
	他可以进行类似程序 (program) 的撰写，并且，不需要经过编译 (compiler) 就能够执行，
	真的很方便。加上，我们可透过 shell script 来简化我们日常的工作管理，
	而且，整个 Linux 环境中，一些服务 (services) 的启动都是透过 shell script 的，
	如果您对于 script 不了解，嘿嘿！发生问题时，可真是会求助无门喔！
	所以，好好的学一学他吧！
</td></tr></tbody></table></center>

<!-- 本文的连结区部分 -->
<div class="block1">
<span class="text_h1">
1. <a href="#script">什么是 Shell Script</a><br>
	<span class="text_h2">
	　　1.1 <a href="#script_why">干嘛学习 shell scripts?</a><br>
	　　1.2 <a href="#script_1st">第一支 script 的撰写与执行</a><br>
	　　1.3 <a href="#script_be">撰写 shell script 的良好习惯建立</a><br>
	</span>
2. <a href="#some_ex">简单的 shell script 练习：</a><br>
3. <a href="#dis">善用判断式：</a><br>
	<span class="text_h2">
	　　3.1 <a href="#test">利用 test 指令的测试功能</a><br>
	　　3.2 <a href="#test_2">利用判断符号 [ ]</a><br>
	　　3.3 <a href="#dis3">Shell script 的默认变数($0, $1...)</a><br>
	</span>
4. <a href="#rule">条件判断式：</a><br>
	<span class="text_h2">
	　　4.1 <a href="#ifthen">利用 if .... then</a><br>
	　　4.2 <a href="#case">利用 case ..... esac 判断</a><br>
	　　4.3 <a href="#function">利用 function 功能</a><br>
	</span>
5. <a href="#loop">循环 (loop)</a><br>
	<span class="text_h2">
	　　5.1 <a href="#while">while....do....done, until....do....done</a><br>
	　　5.2 <a href="#for">for...do...done</a><br>
	</span>
6. <a href="#debug">shell script 的追踪与 debug</a><br>
7. <a href="#FAQ">本章习题练习</a><br>
<span class="text_h2">
8. <a href="http://phorum.vbird.org/viewtopic.php?t=23886" target="_blank">针对本文的建议：http://phorum.vbird.org/viewtopic.php?t=23886</a>
</span>
</span>
</div>


<!-- 本文的正式部分 -->
<hr><a name="script"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">什么是 Shell scripts ？</span><br>
<div class="block1">
	这个有趣的问题赶紧来回答看看，什么是 shell script 呢？ shell 我们在 <a href="http://linux.vbird.org/linux_basic/0340bashshell-scripts/0320bash.php">认识 bash</a>
	当中已经提过了，那是一个文字接口底下让我们与系统沟通的一个工具接口，那么 script 是啥？
	字面上的意义， script 是『脚本、剧本』的意思。整句话是说， shell script 是针对 shell 所写的『剧本！』
	什么东西啊？呵呵！其实， <span class="text_import2">shell script 是利用 shell 的功能所写的一个『程序 
	(program)』，这个程序是使用纯文本文件，将一些 shell 的语法与指令写在里面，
	搭配正规表示法、管线命令与数据流重导向等功能，以达到我们所想要的处理目的。</span><br><br>

	所以，简单的说， shell script 就像是早期 DOS 年代的批处理文件 (.bat) ，最简单的功能就是将许多指令汇整写在一起，
	让使用者很轻易的就能够 one touch (执行一个档案 "shell script" ，就能够一次执行多个指令)，
	而， shell script 更提供数组、循环、条件与逻辑判断等重要功能，让用户也可以直接以 shell 
	来撰写程序，而不必使用类似 C 程序语言等传统程序撰写的语法呢！<br><br>

	那，这么说您可以了解了吗？是的！ shell script 可以简单的被看成是批处理文件，
	也可以被说成是一个程序语言，且这个程序语言由于都是利用 shell 与相关工具指令，
	所以不需要编译即可执行，且拥有不错的除错 (debug) 工具，所以，他可以帮助系统管理员快速的管理好主机。<br><br>

	<hr><a name="script_why"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">干嘛学习 shell scripts?</span><br>
	<div class="block2">
		这是个好问题，我又干嘛一定要学 shell script ？我又不是信息人，没有写程序的概念，
		那我干嘛还要学 shell script 呢？不要学可不可以啊？呵呵～如果 Linux 对您而言，
		您只是想要『会用』而已，那么，不需要学 shell script 也还无所谓，这部分先给他跳过去，
		等到有空的时候，再来好好的瞧一瞧。但是，如果您是真的想要玩清楚 Linux 的来龙去脉，
		那么 shell script 就不可不知，为什么呢？因为：<br><br>

		<li><span class="text_import1">自动化管理的重要依据</span>：</li>
		<div class="block2">
		不用鸟哥说您也知道，管理一部主机真不是件简单的事情，每天要进行的任务就有：
		查询登录档、追踪流量、监控用户使用主机状态、主机各项硬设备状态、
		主机软件更新查询、更不要说得应付其他使用者的突然要求了。而这些工作，
		您想要自行手动处理，还是写个简单的程序来帮您每日自动处理分析，若有问题才通知您呢？
		当然是让系统自动工作比较好，对吧！呵呵～这就得要良好的 shell script 来帮忙的啦！<br><br>
		</div>

		<li><span class="text_import1">追踪与管理系统的重要工作</span>：</li>
		<div class="block2">
		虽然我们还没有提到服务启动的方法，不过，这里可以先提一下，我们 Linux 系统的服务 
		( services ) 启动的接口，在 /etc/init.d/ 这个目录下，所有的档案都是 scripts ；
		另外，包括开机 (booting) 过程也都是利用 shell script 来帮忙搜寻系统的相关设定数据，
		然后再代入各个服务的设定参数啊！举例来说，如果我们想要重新启动系统注册表档，
		可以使用：『/etc/init.d/syslogd restart』，那个 syslogd 档案就是 script 啦！
		另外，我曾经在某一代的 FC 上面发现，启动 MySQL 这个数据库服务时，确实是可以启动的，
		但是屏幕上却老是出现『failure』，后来才发现，原来是启动 MySQL 那个 script 
		会主动的以『空的密码』去尝试登入 MySQL ，但我修改过 MySQL 的密码啰～当然就登入失败～
		后来改了改 script ，就略去这个问题啦！如此说来， script 确实是需要学习的啊！<br><br>
		</div>

		<li><span class="text_import1">简单入侵检测功能</span>：</li>
		<div class="block2">
		当我们的系统有异状时，大多会将这些异状记录在系统记录器，也就是我们常提到的『系统注册表档』，
		那么我们可以在固定的几分钟内主动的去分析系统注册表档，若察觉有问题，就立刻通报管理员，
		或者是立刻加强防火墙的设定规则，如此一来，您的主机可就能够达到『自我保护』的聪明学习功能啦～
		举例来说，我们可以通过 shell script 去分析『当该封包尝试几次还是联机失败之后，就予以抵挡住该
		IP』之类的举动，例如鸟哥写过一个关于抵挡砍站软件的 shell script ，
		就是用这个想法去达成的呢！<br><br>
		</div>

		<li><span class="text_import1">连续指令单一化</span>：</li>
		<div class="block2">
		其实，对于新手而言， script 最简单的功能就是：『<span class="text_import2">汇整一些在 
		command line 下达的连续指令，将他写入 scripts 当中，而由直接执行 scripts 
		来启动一连串的 command line 指令输出入！</span>』例如： 防火墙连续规则 
		( iptables )，开机加载程序的项目 ( 就是在 /etc/rc.d/rc.local 里头的资料 
		) ，等等都是相似的功能啦！ 其实，说穿了，如果不考虑 program 的部分，那么 
		scripts 也可以想成，仅是帮我们把一大串的指令汇整在一个档案里面，
		而直接执行该档案就可以执行那一串又臭又长的指令段！就是这么简单啦！<br><br>
		</div>

		<li><span class="text_import1">简易的数据处理</span>：</li>
		<div class="block2">
		由前一章 <a href="http://linux.vbird.org/linux_basic/0340bashshell-scripts/0330regularex.php">正规表示法</a> 的 awk 程序说明中，
		您可以发现， awk 可以用来处理简单的数据数据呢！例如薪资单的处理啊等等的。
		shell script 的功能更强大，例如鸟哥曾经用 shell script 直接处理数据数据的比对啊，
		文字数据的处理啊等等的，撰写方便，速度又快(因为在 Linux 效能较佳)，
		真的是很不错用的啦！<br><br>
		</div>

		<li><span class="text_import1">跨平台支持与学习历程较短</span>：</li>
		<div class="block2">
		几乎所有的 Unix Like 上面都可以跑 shell script ，连 MS Windows 系列也有相关的仿真器可以用，
		此外， shell script 的语法是相当亲和的，看都看的懂得文字，而不是机器码，
		很容易学习～这些都是您可以加以考虑的学习点啊！<br><br>
		</div>

		上面这些都是您考虑学习 shell script 的特点～此外， shell script 还可以简单的以 vi 
		来直接编写，实在是很方便的好东西！所以，还是建议您学习一下啦。<br><br>

		不过，虽然 shell script 号称是程序 (program) ，但实际上， shell script 
		处理数据的速度上是不太够的。因为 shell script 用的是外部的指令与 bash shell 
		的一些预设工具，所以，他常常会去呼叫外部的函式库，因此，指令周期上面当然比不上传统的程序语言。
		所以啰， shell script 用在系统管理上面是很好的一项工具，但是用在处理大量数值运算上，
		就不够好了～而且还很麻烦，因为：<span class="text_import2">Shell scripts 的速度较慢，
		且使用的 CPU 资源较多，造成主机资源的分配不良。</span>还好，
		我们确实很少看到利用 shell script 在进行大量数据运算的，所以，不必担心的啦！<br><br>
	</div>

	<hr><a name="script_1st"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">第一支 script 的撰写与执行</span><br>
	<div class="block2">
		如同前面讲到的， shell script 其实就是纯文本档  (ASCII) ，我们可以编辑这个档案，
		然后让这个档案来帮我们一次执行多个指令，或者是利用一些运算与逻辑判断来帮我们达成某些功能。
		所以啦，要编辑这个档案的内容时，当然就需要具备有 bash shell 指令下达的相关认识。
		我们说过，要下达指令需要注意的事项在 <a href="http://linux.vbird.org/linux_basic/0340bashshell-scripts/0320bash.php#bash_command">bash 章节内</a>已经提过，
		在 shell script 的撰写同样需要用到这些注意事项的：<ol><span class="text_import2">
		<li>如同前面 bash command 提到的，指令与参数间的多个空白会被忽略掉；
		</li><li>而空白行也将被忽略掉！，并且 [tab] 也是不会被理会的！
		</li><li>如果读取到一个 Enter 符号 ( CR )），就尝试开始执行该行命令；
		</li><li>至于如果一行的内容太多，则可以使用 \[Enter] 来延伸至下一行；
		</li><li>此外，使用最多的 # 可做为批注！任何<b>加在 # 后面的字</b>，将全部被视为批注文字而被忽略！
		</li></span></ol>
		如此一来，我们在 script 内所撰写的程序，就会被一行一行的执行。好了，那么这个程序假设文件名是
		shell.sh 好了，如何执行这个档案？很简单，可以有底下几个方法：<ul><span class="text_import2">
		<li>将 shell.sh 加上可读与执行 (rx) 的权限，然后就能够以 ./shell.sh 来执行了；
		</li><li>直接以 sh shell.sh 的方式来直接执行即可。</li></span></ul>
		反正重点就是要让那个 shell.sh 内的指令可以被执行的意思啦！咦！那我为何需要使用 ./shell.sh 来下达指令？
		还记得我们在 bash 里面一直强调的，指令是否能够被执行与 PATH 这个环境变量有关，
		所以，要执行『目前这个目录下的某个档案』就需要加上 ./ 这个目录啦！另外，其实您也可以将 
		shell.sh 放在您家目录下的 ~/bin 这个目录中，然后利用 PATH="$PATH":~/bin 的设定，
		嘿嘿，就能够直接执行您的 script 啰～ ^_^<br><br>
		那，为何 sh shell.sh 也可以执行呢？这是因为 /bin/sh 其实就是 /bin/bash ，
		使用 sh shell.sh 亦即告诉系统，我想要直接以 bash 的功能来执行 shell.sh 这个档案内的相关指令的意思。
		而我们也可以利用 sh 的参数，如 -n 及 -x 来检查与追踪 shell.sh 的语法是否正确呢！ ^_^<br><br>

		<hr><li><span class="text_import1">撰写第一支 script</span></li>
		<div class="block2">
		不论是那个门派，要学武功要从扫地做起，那么要学程序呢？呵呵，肯定是由『秀出 Hello World！』
		这个字眼开始的！OK！那么鸟哥就先写一支 script 给大家瞧一瞧：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">mkdir scripts; cd scripts</span>
[root@linux scripts]# <span class="term_command">vi sh01.sh</span>
<span class="term_write">#!/bin/bash
# Program:
#       This program is used to show "Hello World !" in screen.
# History:
# 2005/08/23	VBird	First release
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
export PATH
echo -e "Hello World ! \a \n"
exit 0</span>
</pre></td></tr></tbody></table>

		在我们这个章节当中，请将所有的撰写的 script 放置到您家目录的 ~/scripts 这个目录内，
		比较好管理啦！上面的写法当中，我主要将整个程序的撰写分成数段，大致是这样：<ol>
		<li><span class="text_import2">第一行 #!/bin/bash 在宣告这个 script 使用的 shell 名称：</span><br>
			因为我们使用的是 bash ，所以，必须要以『 <b>#!/bin/bash</b> 』来宣告这个档案内的语法使用
			bash 的语法！那么当这个程序被执行时，他就能够加载 bash 的相关环境配置文件，
			并且执行 bash 来使我们底下的指令能够执行！这很重要的！(在很多状况中，如果没有设定好这一行，
			那么该程序很可能会无法执行，因为系统可能无法判断该程序需要使用什么 shell 来执行啊！)<br><br>
		</li><li><span class="text_import2">程序内容的宣告：<br></span>
			整个 script 当中，除了第一行的 #! 是用来宣告 shell 的之外，其他的 # 都是『批注』用途！
			所以上面的程序当中，第二行以下就是用来说明整个程序的状态。一般来说，
			建议您一定要养成说明该 script 的：1. 内容与功能； 2. 版本信息； 3. 作者与联络方式； 
			4. 建檔日期；5. 历史纪录 等等。这将有助于未来程序的改写与 debug 呢！<br><br>
		</li><li><span class="text_import2">主要环境变量的宣告：</span><br>
			建议务必要将一些重要的环境变量设定好，鸟哥个人认为， PATH 是当中最重要的！
			如此一来，则可让我们这支程序在进行时，可以直接下达指令，
			而不必写绝对路径呢！比较好啦！<br><br>
		</li><li><span class="text_import2">主要程序部分</span><br>
			就将主要的程序写好即可！在这个例子当中，就是 echo 那一行啦！<br><br>
		</li><li><span class="text_import2">执行成果告知</span><br>
			是否记得我们在 bash 里面要讨论一个指令的执行成功与否，可以使用 $? 这个变量来观察～
			那么我们也可以利用 exit 这个指令来让程序中断，并且回传一个数值给系统。
			在我们这个例子当中，我使用 exit 0 ，这代表离开 script ，并且回传一个 0 给系统，
			所以我执行完这个 script 后，若接着下达 echo $? 则可得到 0 的值喔！
			更聪明的读者应该也知道了，呵呵！利用这个 exit n 的功能，我们还可以自定义错误讯息，
			让这支程序变得更加的 smart 呢！
		</li></ol>
		接下来执行看看结果是怎样吧？<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux scripts]# <span class="term_command">sh sh01.sh</span>
Hello World !

</pre></td></tr></tbody></table>

		您会看到屏幕是这样，而且应该还会听到『咚』的一声，为什么呢？还记得前一章提到的 
		<a href="http://linux.vbird.org/linux_basic/0340bashshell-scripts/0330regularex.php#printf">printf</a> 吧？用 echo 接着那些特殊的按键也可以发生同样的事情～
		不过， echo 必须要加上 -e 的参数才行！
		呵呵！在您写完这个小 script 之后，您就可以大声的说：『我也会写程序了』！哈哈！
		很简单有趣吧～ ^_^<br><br>
		另外，你也可以利用：『chmod a+x sh01.sh; ./sh01.sh』来执行这个 script 的呢！<br>
		</div>
	</div>

	<hr><a name="script_be"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">撰写 shell script 的良好习惯建立</span><br>
	<div class="block2">
		一个良好习惯的养成是很重要的～大家在刚开始撰写程序的时候，最容易忽略这部分，
		认为程序写出来就好了，其他的不重要。其实，如果程序的说明能够更清楚，
		那么对您自己是有很大的帮助的。<br><br>

		举例来说，鸟哥自己为了自己的需求，曾经撰写了不少的 script 来帮我进行主机 IP 的侦测啊、
		登录档分析与管理啊、自动上传下载重要配置文件啊等等的，不过，早期就是因为太懒了，
		管理的主机又太多了，常常同一个程序在不同的主机上面进行更改，到最后，到底哪一支才是最新的都记不起来，
		而且，重点是，我到底是改了哪里？？为什么做那样的修改？都忘的一乾二净～真要命～<br><br>

		所以，后来鸟哥在写程序的时候，通常会比较仔细的将程序的设计过程给他记录下来，
		而且还会记录一些历史纪录，如此一来，好多了～
		至少很容易知道我修改了哪些数据，以及程序修改的理念与逻辑概念等等，
		在维护上面是轻松很多很多的喔！<br><br>

		另外，在一些环境的设定上面，毕竟每个人的环境都不相同，为了取得较佳的执行环境，
		我都会自行先定义好一些一定会被用到的环境变量，例如 PATH 这个玩意儿！
		这样比较好啦～所以说，建议您一定要养成良好的 script 撰写习惯，
		在每个 script 的文件头处记录好：<ul><span class="text_import2">
		<li>script 的功能；
		</li><li>script 的版本信息；
		</li><li>script 的作者与联络方式；
		</li><li>script 的版权宣告方式；
		</li><li>script 的 History (历史纪录)；
		</li><li>script 内较特殊的指令，使用绝对路径的方式来下达；
		</li><li>script 运作时需要的环境变量预先宣告与设定。</li></span></ul>
	</div>
</div>


<hr><a name="some_ex"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">简单的 shell script 练习</span><br>
<div class="block1">
	在第一支 shell script 撰写完毕之后，相信您应该具有基本的撰写功力了。
	接下来，在开始更深入的程序概念之前，我们先来玩一些比较有趣的简单的小范例好了。
	底下的范例中，达成结果的方式相当的多，建议您先自行撰写看看，写完之后再与鸟哥写的内容比对，
	这样才能更加深概念喔！好！不啰唆，我们就一个一个来玩吧！<br><br>

	<hr><li><span class="text_import1">变量内容由用户决定</span></li>
	<div class="block2">
		很多时候我们需要使用者输入一些内容，好让程序可以顺利运作。
		简单的来说，大家应该都有安装过软件的经验，安装的时候，他不是会问您『要安装到那个目录去？』吗？
		那个让用户输入的数据的动作，就是让用户输入变量内容啦。<br><br>
		你应该还记得在 <a href="http://linux.vbird.org/linux_basic/0340bashshell-scripts/0320bash.php">bash</a> 的时候，我们有学到一个 
		<a href="http://linux.vbird.org/linux_basic/0340bashshell-scripts/0320bash.php#read">read</a> 指令吧？忘记的话，请自行回头去阅读一番。
		现在，请你以 read 指令的用途，撰写一个 script ，他可以让使用者输入：1 first name 与 2. last name，
		最后并且在屏幕上显示：『Your full name is: 』的内容：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux scripts]# <span class="term_command">vi sh02.sh</span>
<span class="term_write">#!/bin/bash
# Program:
# 	Let user keyin their first and last name, and show their full name.
# History:
# 2005/08/23	VBird	First release
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
export PATH

read -p "Please input your first name: " firstname
read -p "Please input your last name:  " lastname
echo -e "\nYour full name is: $firstname $lastname"</span>
</pre></td></tr></tbody></table>

		将上面这个 sh02.sh 执行一下，你就能够发现用户自己输入的变量可以被取用的哩！
		很不错吧！加油！<br><br>
	</div>

	<hr><li><span class="text_import1">利用 date 进行档案的建立</span></li>
	<div class="block2">
		想象一个状况，如果我每天要进行备份，而备份的数据又不想被覆盖掉，也就是说，
		我想要将每天备份的数据放在不同的档案中。哇！这真困扰啊？难道要我每天去修改 script ？
		不需要啊！因为每天的『日期』并不相同，所以我可以将档名取成类似： backup.20050802 ，
		不就可以每天一个不同档名了吗？呵呵！确实如此。好了，接下来出个例子：
		我想要建立三个空的档案，档名最开头由使用者输入决定，假设使用者输入 filename 好了，
		那今天的日期是 2005/08/23 ，我想要以前天、昨天、今天的日期来建立这个档案，亦即
		filename_20050821, filename_20050822, filename_20050823 ，该如何是好？<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux scripts]# <span class="term_command">vi sh03.sh</span>
<span class="term_write">#!/bin/bash
# Program:
# 	User can keyin filename to touch 3 new files.
# History:
# 2005/08/23	VBird	First release
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
export PATH

<span class="term_say"># 1. 让使用者输入文件名，并取得 fileuser 这个变量；</span>
echo -e "I will use 'touch' command to create 3 files."
read -p "Please input the filename what you want: " fileuser

<span class="term_say"># 2. 为了避免用户随意按 Enter ，利用变量功能分析文件名是否有设定？</span>
filename=${fileuser:-"filename"}

<span class="term_say"># 3. 开始利用 date 指令来取得所需要的档名了；</span>
date1=`date --date='2 days ago' +%Y%m%d`
date2=`date --date='1 days ago' +%Y%m%d`
date3=`date +%Y%m%d`
file1="$filename""$date1"
file2="$filename""$date2"
file3="$filename""$date3"

<span class="term_say"># 4. 将档名建立吧！</span>
touch $file1
touch $file2
touch $file3</span>
</pre></td></tr></tbody></table>

		我透过一些简单的动作，这些动作都可以在 bash 那一章里面找到，
		包括小指令 (`) 的取得讯息、变量的设定功能、变量的累加以及利用 touch 指令辅助！
		如果您开始执行这个 sh03.sh 之后，你可以进行两次输入，一次直接按 [Enter] 来查阅档名是啥？
		一次可以输入一些字符，这样来判断你的档案喔！关于 date 的指令应用，请 man date 吧！ ^_^<br><br>
	</div>

	<hr><li><span class="text_import1">数值运算的方法</span></li>
	<div class="block2">
		各位看官应该还记得，我们可以使用 declare 来定义变量的类型吧？！
		这样才能够进行加减运算啊！可惜的是， bash shell 里头预设仅支持到整数的数据。
		OK！那我们来玩玩看，如果我们要用户输入两个变量，然后将两个变量的内容相乘，
		最后输出相乘的结果，那可以怎么做？<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux scripts]# <span class="term_command">vi sh04.sh</span>
<span class="term_write">#!/bin/bash
# Program:
# 	User can input 2 integer to cross by!
# History:
# 2005/08/23	VBird	First release
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
export PATH
echo -e "You SHOULD input 2 number, I will cross them! \n"
read -p "first number:  " firstnu
read -p "second number: " secnu
total=$(($firstnu*$secnu))
echo -e "\nThe number $firstnu x $secnu is ==&gt; $total"</span>
</pre></td></tr></tbody></table>

		在数字的运算上，我们可以使用『 <span class="text_import2">declare -i total=$firstnu*$secnu</span> 』
		也可以使用上面的方式来进行！基本上，鸟哥比较建议使用这样的方式来进行运算：
		<ul><span class="text_import2">var=$((运算内容))</span></ul>
		不但容易记忆，而且也比较方便的多～未来您可以使用这种方式来计算的呀！至于数值运算上的处理，
		则有：<span class="text_import2"><font face="细明体">+, -, *, /, %</font></span>等等。
		那个 % 是取余数啦～举例来说， 13 对 3 取余数，结果是 13=4*3+1，所以余数是 1 啊！就是：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux scripts]# <span class="term_command">nu=$((13%3)); echo $nu</span>
1
</pre></td></tr></tbody></table>

		这样了解了吧？！多多学习与应用喔！ ^_^<br>
	</div>
</div>


<hr><a name="dis"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">善用判断式</span><br>
<div class="block1">
	在 <a href="http://linux.vbird.org/linux_basic/0340bashshell-scripts/0320bash.php">bash</a> 章节中，我们提到过 $? 这个变量所代表的意义，
	此外，也透过 &amp;&amp; 及 || 来作为前一个指令是否能够成功进行的一个参考。
	那么，如果我想要知道 /dmtsai 这个目录是否存在时，难道一定要使用 ls 来执行，
	然后再以 $? 来判断执行成果吗？呵呵！当然不需要！
	我们可以透过『 test 』这个指令来侦测呢！<br><br>

	<hr><a name="test"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">利用 test 指令的测试功能</span><br>
	<div class="block2">
		当我要检测系统上面某些档案或者是相关的属性时，利用 test 这个指令来工作，
		真是好用得不得了，举例来说，我要检查 /dmtsai 是否存在时，使用：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">test -e /dmtsai</span>
</pre></td></tr></tbody></table>

		执行结果并不会显示任何讯息，但最后我们可以透过 $? 或 &amp;&amp; 及 || 来展现整个结果呢！
		例如我们在将上面的例子改写成这样：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">test -e /dmtsai &amp;&amp; echo "exist" || echo "Not exist"</span>
</pre></td></tr></tbody></table>

		最终的结果可以告知我们是『exist』还是『Not exist』呢！那我知道 -e 是测试一个『东西』在不在，
		如果还想要测试一下该档名是啥玩意儿时，还有哪些标志可以来判断的呢？呵呵！有底下这些东西喔！<br><br>

<table width="85%" bgcolor="lightyellow" border="1" cellpadding="3" cellspacing="0">
<tbody><tr align="center" bgcolor="#182448"><td width="100"><font color="#FFFFFF">测试的标志</font></td><td><font color="#FFFFFF">代表意义</font></td></tr>
<tr bgcolor="#182448"><td colspan="2"><font color="#FFFFFF">1. 关于某个档名的『类型』侦测(存在与否)，如 test -e filename</font></td></tr>
<tr><td align="center">-e</td><td>该『档名』是否存在？(常用)</td></tr>
<tr><td align="center">-f</td><td>该『档名』是否为档案(file)？(常用)</td></tr>
<tr><td align="center">-d</td><td>该『文件名』是否为目录(directory)？(常用)</td></tr>
<tr><td align="center">-b</td><td>该『档名』是否为一个 block device 装置？</td></tr>
<tr><td align="center">-c</td><td>该『档名』是否为一个 character device 装置？</td></tr>
<tr><td align="center">-S</td><td>该『档名』是否为一个 Socket 档案？</td></tr>
<tr><td align="center">-p</td><td>该『档名』是否为一个 FIFO (pipe) 档案？</td></tr>
<tr><td align="center">-L</td><td>该『档名』是否为一个连结档？</td></tr>
<tr bgcolor="#182448"><td colspan="2"><font color="#FFFFFF">2. 关于档案的权限侦测，如 test -r filename</font></td></tr>
<tr><td align="center">-r</td><td>侦测该档名是否具有『可读』的属性？</td></tr>
<tr><td align="center">-w</td><td>侦测该档名是否具有『可写』的属性？</td></tr>
<tr><td align="center">-x</td><td>侦测该档名是否具有『可执行』的属性？</td></tr>
<tr><td align="center">-u</td><td>侦测该档名是否具有『SUID』的属性？</td></tr>
<tr><td align="center">-g</td><td>侦测该档名是否具有『SGID』的属性？</td></tr>
<tr><td align="center">-k</td><td>侦测该档名是否具有『Sticky bit』的属性？</td></tr>
<tr><td align="center">-s</td><td>侦测该档名是否为『非空白档案』？</td></tr>
<tr bgcolor="#182448"><td colspan="2"><font color="#FFFFFF">3. 两个档案之间的比较，如： test file1 -nt file2</font></td></tr>
<tr><td align="center">-nt</td><td>(newer than)判断 file1 是否比 file2 新</td></tr>
<tr><td align="center">-ot</td><td>(older than)判断 file1 是否比 file2 旧</td></tr>
<tr><td align="center">-ef</td><td>判断 file2 与 file2 是否为同一档案，可用在判断 hard link 的判定上。
				主要意义在判定，两个档案是否均指向同一个 inode 哩！</td></tr>
<tr bgcolor="#182448"><td colspan="2"><font color="#FFFFFF">4. 关于两个整数之间的判定，例如 test n1 -eq n2</font></td></tr>
<tr><td align="center">-eq</td><td>两数值相等 (equal)</td></tr>
<tr><td align="center">-ne</td><td>两数值不等 (not equal)</td></tr>
<tr><td align="center">-gt</td><td>n1 大于 n2 (greater than)</td></tr>
<tr><td align="center">-lt</td><td>n1 小于 n2 (less than)</td></tr>
<tr><td align="center">-ge</td><td>n1 大于等于 n2 (greater than or equal)</td></tr>
<tr><td align="center">-le</td><td>n1 小于等于 n2 (less than or equal)</td></tr>
<tr bgcolor="#182448"><td colspan="2"><font color="#FFFFFF">5. 判定字符串的数据</font></td></tr>
<tr><td align="center">test -z string</td><td>判定字符串是否为 0 ？若 string 为空字符串，则为 true</td></tr>
<tr><td align="center">test -n string</td><td>判定字符串是否非为 0 ？若 string 为空字符串，则为 false。<br>注： -n 亦可省略</td></tr>
<tr><td align="center">test str1 = str2</td><td>判定 str1 是否等于 str2 ，若相等，则回传 true</td></tr>
<tr><td align="center">test str1 != str2</td><td>判定 str1 是否不等于 str2 ，若相等，则回传 false</td></tr>
<tr bgcolor="#182448"><td colspan="2"><font color="#FFFFFF">6. 多重条件判定，例如： test -r filename -a -x filename</font></td></tr>
<tr><td align="center">-a</td><td>(and)两状况同时成立！例如 test -r file -a -x file，则 file 同时具有 r 与
				x 权限时，才回传 true。</td></tr>
<tr><td align="center">-o</td><td>(or)两状况任何一个成立！例如 test -r file -o -x file，则 file 具有 r 或
				x 权限时，就可回传 true。</td></tr>
<tr><td align="center">!</td><td>反相状态，如 test ! -x file ，当 file 不具有 x 时，回传 true</td></tr>
</tbody></table><br>

		OK！现在我们就利用 test 来帮我们写几个简单的例子。首先，判断一下，
		让使用者输入一个档名，我们判断：<ol>
		<li>这个档案是否存在，若不存在则给予一个『Filename does not exist』的讯息，并中断程序；
		</li><li>若这个档案存在，则判断他是个档案或目录，结果输出『Filename is regular file』或
			『Filename is directory』
		</li><li>判断一下，执行者的身份对这个档案或目录所拥有的权限，并输出权限数据！</li></ol>
		你可以先自行创作看看，然后再跟底下的结果讨论讨论。注意利用 test 与 &amp;&amp; 还有 || 等标志！<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux scripts]# <span class="term_command">vi sh05.sh</span>
<span class="term_write">#!/bin/bash
# Program:
# 	Let user input a filename, the program will search the filename
#	1.) exist? 2.) file/directory? 3.) file permissions 
# History:
# 2005/08/25	VBird	First release
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
export PATH

<span class="term_say"># 1. 让使用者输入档名，并且判断使用者是否真的有输入字符串？</span>
echo -e "The program will show you that filename is exist which input by you.\n\n"
read -p "Input a filename : " filename
test -z $filename &amp;&amp; echo "You MUST input a filename." &amp;&amp; exit 0
<span class="term_say"># 2. 判断档案是否存在？</span>
test ! -e $filename &amp;&amp; echo "The filename $filename DO NOT exist" &amp;&amp; exit 0
<span class="term_say"># 3. 开始判断文件类型与属性</span>
test -f $filename &amp;&amp; filetype="regulare file"
test -d $filename &amp;&amp; filetype="directory"
test -r $filename &amp;&amp; perm="readable"
test -w $filename &amp;&amp; perm="$perm writable"
test -x $filename &amp;&amp; perm="$perm executable"
<span class="term_say"># 4. 开始输出信息！</span>
echo "The filename: $filename is a $filetype"
echo "And the permission are : $perm"</span>
</pre></td></tr></tbody></table>

		很有趣的例子吧！您可以自行再以其他的案例来撰写一下可用的功能呢！<br><br>
	</div>

	<hr><a name="test_2"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">利用判断符号 [ ]</span><br>
	<div class="block2">
		除了我们很喜欢使用的 test 之外，其实，我们还可以利用判断符号『 [ ] 』来进行数据的判断呢！
		举例来说，如果我想要知道 $HOME 这个变量是否为空的，可以这样做：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">[ -z "$HOME" ]</span>
</pre></td></tr></tbody></table>

		但使用 [] 要特别注意的是，在上述的每个组件中间都需要有空格键来分隔，假设我空格键使用『□』来表示，
		那么，在这些地方你都需要有空格键：<br>

<table class="term"><tbody><tr><td class="term"><pre>[  "$HOME"  ==  "$MAIL"  ]
[□"$HOME"□==□"$MAIL"□]
 ↑       ↑  ↑       ↑
</pre></td></tr></tbody></table>

		上面的例子在说明，两个字符串 $HOME 与 $MAIL 是否相同的意思，相当于 test $HOME = $MAIL 的意思啦！
		而如果没有空白分隔，例如 [$HOME==$MAIL] 时，我们的 bash 就会显示错误讯息了！这可要很注意啊！
		所以说，您最好要注意：<ul><span class="text_import2">
		<li>在中括号 [] 内的每个组件都需要有空格键来分隔；
		</li><li>在中括号内的变量，最好都以双引号来设定；
		</li><li>在中括号内的常数，最好都以单或双引号来设定。</li></span></ul>
		举例来说，假如我设定了 name="VBird Tsai" ，然后这样判定：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">name="VBird Tsai"</span>
[root@linux ~]# <span class="term_command">[ $name == "VBird" ]</span>
bash: [: too many arguments
</pre></td></tr></tbody></table>

		为什么呢？因为 $name 如果没有使用双引号刮起来，那么上面的判定式会变成：
		<ul><span class="text_import2"><font face="细明体">[ VBird Tsai == "VBird" ] </font></span><font face="细明体"></font></ul>
		而不是我们要的：
		<ul><span class="text_import2"><font face="细明体">[ "VBird Tsai" == "VBird" ] </font></span><font face="细明体"></font></ul>
		这可是差很多的喔！另外，中括号的使用方法与标志与 test 几乎一模一样啊～
		只是中括号比较常用在条件判断式 if ..... then ..... fi 的情况中就是了。
		好，那我们也继续来做一个小案例好了：<ol>
		<li>当执行一个程序的时候，这个程序会让用户选择 Y 或 N ，
		</li><li>如果用户输入 Y 或 y 时，就显示『 OK, continue 』
		</li><li>如果用户输入 n 或 N 时，就显示『 Oh, interrupt ！』
		</li><li>如果不是 Y/y/N/n 之内的其他字符，就显示『I don't know what is your choice』</li></ol>
		利用中括号、 &amp;&amp; 与 || 来继续吧！<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux scripts]# <span class="term_command">vi sh06.sh</span>
<span class="term_write">#!/bin/bash
# Program:
# 	This program will show the user's choice
# History:
# 2005/08/25	VBird	First release
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
export PATH

read -p "Please input (Y/N): " yn
[ "$yn" == "Y" -o "$yn" == "y" ] &amp;&amp; echo "OK, continue" &amp;&amp; exit 0
[ "$yn" == "N" -o "$yn" == "n" ] &amp;&amp; echo "Oh, interrupt!" &amp;&amp; exit 0
echo "I don't know what is your choice" &amp;&amp; exit 0</span>
</pre></td></tr></tbody></table>

		很有趣吧！利用这个字符串判别的方法，我们就可以很轻松的将使用者想要进行的工作分门别类呢！
		接下来，我们再来谈一些其他有的没有的东西吧！<br>

		<div style="padding: 10pt 0pt;" align="right"><table width="90%"><tbody><tr><td><b>Tips:</b><br><span style="color: rgb(0, 144, 0);"><font size="-1">			为什么判断式里面下达等于要用 == 而不是一个 = 就好了呢？我们在前一章正规表示法里面的 awk 提到，
			只有一个 = 用来给予一个变量设定其内容，逻辑判断时，则会给予两个等于，
			亦即『比较』而非『设定』的意思～这里要好好的分辨一下喔！ ^_^
		</font></span></td><td><img src="0340bashshell-scripts-fc4_files/vbird_face.gif" alt="鸟哥的图示" title="鸟哥的图示"></td></tr></tbody></table></div>	</div>

	<hr><a name="dis3"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">Shell script 的默认变数($0, $1...)</span><br>
	<div class="block2">
		其实，当我们执行一个 shell script 时，在这个 shell script 里面就已将帮我们做好一些可用的变量了。
		举例来说，在不久的将来，您就会发现，当我们要启动一个系统服务时，可能会下达类似这样的指令：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">/etc/init.d/crond restart</span>
</pre></td></tr></tbody></table>

		那是啥玩意儿？呵呵！就是『向 /etc/init.d/crond 这个 script 下达 restart 的指令』，
		咦！我们不是都使用 read 来读取用户输入的变量内容吗？为啥我可以直接在 script 后面接上这个参数？
		这是因为 shell script 帮我们设定好一些指定的变量了！变量的对应是这样的：<br>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_write">
/path/to/scriptname  opt1  opt2  opt3  opt4  ...
       $0             $1    $2    $3    $4   ...</span>
</pre></td></tr></tbody></table>

		这样够清楚了吧？！执行的文件名为 $0 这个变量，第一个接的参数就是 $1 啊～
		所以，只要我们在 script 里面善用 $1 的话，就可以很简单的立即下达某些指令功能了！
		好了，来做个例子吧～假设我要执行一个 script ，执行后，该 script 会自动列出自己的档名，
		还有后面接的前三个参数，该如何是好？<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux scripts]# <span class="term_command">vi sh07.sh</span>
<span class="term_write">#!/bin/bash
# Program:
# 	The program will show it's name and first 3 parameters.
# History:
# 2005/08/25	VBird	First release
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
export PATH

echo "The script name is ==&gt; $0"
[ -n "$1" ] &amp;&amp; echo "The 1st parameter is ==&gt; $1" || exit 0
[ -n "$2" ] &amp;&amp; echo "The 2nd parameter is ==&gt; $2" || exit 0
[ -n "$3" ] &amp;&amp; echo "The 3th parameter is ==&gt; $3" || exit 0</span>
</pre></td></tr></tbody></table>

		这支程序里面鸟哥加上了一些控制式，亦即利用 &amp;&amp; 及 || 来加以判断 $1 ~ $3 是否存在？
		若存在才显示，若不存在就中断～执行结果如下：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux scripts]# <span class="term_command">sh sh07.sh theone haha quot</span>
The script name is ==&gt; sh07.sh
The 1st paramter is ==&gt; theone
The 2nd paramter is ==&gt; haha
The 3th paramter is ==&gt; quot
</pre></td></tr></tbody></table>

		上面这7个例子都很简单吧？几乎都是利用 bash 的相关功能而已～
		不难啦～底下我们就要使用条件判断式来进行一些分别功能的设定了，好好瞧一瞧先～
	</div>
</div>


<hr><a name="rule"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">条件判断式：</span><br>
<div class="block1">
	只要讲到『程序』的话，那么条件判断式，亦即是『 if then 』这种判别式肯定一定要学习的！
	因为很多时候，我们都必须要依据某些数据来判断程序该如何进行。举例来说，我们在上头不是有练习当使用者输入 
	Y/N 时，必须要执行不同的讯息输出吗？简单的方式可以利用 &amp;&amp; 与 || ，但如果我还想要执行一堆指令呢？
	那真的得要 if then 来帮忙啰～底下我们就来聊一聊！<br><br>

	<hr><a name="ifthen"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">利用 if .... then</span><br>
	<div class="block2">
		这个 if .... then 是最常见的条件判断式了～简单的说，就是当符合某个条件判断的时候，
		就予以进行某项工作就是了。我们可以简单的这样看：<br>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_write">if [</span> 条件判断式 <span class="term_write">]; then</span>
	当条件判断式成立时，可以进行的指令工作内容；
<span class="term_write">fi</span>
</pre></td></tr></tbody></table>

		至于条件判断式的判断方法，与前一小节的介绍相同啊！较特别的是，如果我有多个条件要判别时，
		除了 sh06.sh 那个案例，也就是将多个条件写入一个中括号内的情况之外，
		我还可以有多个中括号来隔开喔！而括号与括号之间，则以 &amp;&amp; 或 || 来隔开，他们的意义是：
		<ul><span class="text_import2"><font face="细明体">
		<li>&amp;&amp; 代表 AND ；
		</li><li>|| 代表 or ；</li></font></span></ul><font face="细明体"></font>
		所以，在使用中括号的判断式中， &amp;&amp; 及 || 就与指令下达的状态不同了。举例来说，
		sh06.sh 那个例子我可以改写成这样：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux scripts]# <span class="term_command">vi sh06-2.sh</span>
<span class="term_write">#!/bin/bash
# Program:
# 	This program will show the user's choice
# History:
# 2005/08/25	VBird	First release
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
export PATH

read -p "Please input (Y/N): " yn

if [ "$yn" == "Y" ] || [ "$yn" == "y" ]; then
	echo "OK, continue"
	exit 0
fi
if [ "$yn" == "N" ] || [ "$yn" == "n" ]; then
	echo "Oh, interrupt!"
	exit 0
fi
echo "I don't know what is your choice" &amp;&amp; exit 0</span>
</pre></td></tr></tbody></table>

		不过，由这个例子看起来，似乎也没有什么了不起吧？ sh06.sh 还比较简单呢～
		但是，如果我们考虑底下的状态，您就会知道 if then 的好处了：<br>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_write">if [</span> 条件判断式 <span class="term_write">]; then</span>
	当条件判断式成立时，可以进行的指令工作内容；
<span class="term_write">else</span>
	当条件判断式不成立时，可以进行的指令工作内容；
<span class="term_write">fi</span>
</pre></td></tr></tbody></table>

		如果考虑更复杂的情况，则可以使用这个语法：<br>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_write">if [</span> 条件判断式一 <span class="term_write">]; then</span>
	当条件判断式一成立时，可以进行的指令工作内容；
<span class="term_write">elif [</span> 条件判断式二 <span class="term_write">]; then</span>
	当条件判断式二成立时，可以进行的指令工作内容；
<span class="term_write">else</span>
	当条件判断式一与二均不成立时，可以进行的指令工作内容；
<span class="term_write">fi</span>
</pre></td></tr></tbody></table>

		那我就可以将 sh06-2.sh 改写成这样：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux scripts]# <span class="term_command">vi sh06-3.sh</span>
<span class="term_write">#!/bin/bash
# Program:
# 	This program will show the user's choice
# History:
# 2005/08/25	VBird	First release
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
export PATH

read -p "Please input (Y/N): " yn

if [ "$yn" == "Y" ] || [ "$yn" == "y" ]; then
	echo "OK, continue"
elif [ "$yn" == "N" ] || [ "$yn" == "n" ]; then
	echo "Oh, interrupt!"
else
	echo "I don't know what is your choice"
fi</span>
</pre></td></tr></tbody></table>

		是否程序变得很简单，而且依序判断，可以避免掉重复判断的状况，这样真的很容易设计程序的啦！ ^_^
		好了，那么如果我要侦测你所输入的参数是否为 hello 呢 ，
		也就是说，如果我想要知道，你在程序后面所接的第一个参数 (就是 $1 啊！) 是否为 hello ，<ol>
		<li>如果是的话，就显示 "Hello, how are you ?"；
		</li><li>如果没有加任何参数，就提示使用者必须要使用的参数下达法；
		</li><li>而如果加入的参数不是 hello ，就提醒使用者仅能使用 hello 为参数。</li></ol>
		整个程序的撰写可以是这样的：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux scripts]# <span class="term_command">vi sh08.sh</span>
<span class="term_write">#!/bin/bash
# Program:
# 	Show "Hello" from $1....
# History:
# 2005/08/28	VBird	First release
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
export PATH

if [ "$1" == "hello" ]; then
	echo "Hello, how are you ?"
elif [ "$1" == "" ]; then
	echo "You MUST input parameters, ex&gt; $0 someword"
else
	echo "The only parameter is 'hello'"
fi</span>
</pre></td></tr></tbody></table>

		然后您可以执行这支程序，分别在 $1 的位置输入 hello, 没有输入与随意输入，
		就可以看到不同的输出啰～是否还觉得挺简单的啊！ ^_^。事实上，
		学到这里，也真的很厉害了～好了，底下我们继续来玩一些比较大一点的啰～
		我们在前一章已经学会了 grep 这个好用的玩意儿，那么多学一个叫做 netstat 的指令，
		这个指令可以查询到目前主机有开启的网络服务端口口 (service ports)，
		相关的功能我们会在服务器架设篇继续介绍，这里您只要知道，我可以利用『 
		<span class="text_import2">netstat -tuln</span> 』来取得目前主机有启动的服务，
		而且取得的信息有点像这样：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">netstat -tuln</span>
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address   Foreign Address    State
tcp        0      0 0.0.0.0:<span class="term_write">199</span>     0.0.0.0:*          LISTEN
tcp        0      0 :::<span class="term_write">80</span>           :::*               LISTEN
tcp        0      0 :::<span class="term_write">22</span>           :::*               LISTEN
tcp        0      0 :::<span class="term_write">25</span>           :::*               LISTEN
</pre></td></tr></tbody></table>

		上面的重点是特殊字体的那个部分，那些特殊字体的部分代表的就是 port 啰～
		那么每个 port 代表的意义为何呢？几个常见的 port 与相关网络服务的关系是：
		<ul><span class="text_import2"><font face="细明体">
		<li>80: WWW
		</li><li>22: ssh
		</li><li>21: ftp
		</li><li>25: mail</li></font></span></ul>
		那我如何透过 netstat 去侦测我的主机是否有开启这四个主要的网络服务端口口呢？
		我可以简单的这样去写这个程序喔：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux scripts]# <span class="term_command">vi sh09.sh</span>
<span class="term_write">#!/bin/bash
# Program:
# 	Using netstat and grep to detect WWW,SSH,FTP and Mail services.
# History:
# 2005/08/28	VBird	First release
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
export PATH

<span class="term_say"># 1. 先作一些告知的动作而已～</span>
echo "Now, the services of your Linux system will be detect!"
echo -e "The www, ftp, ssh, and mail will be detect! \n"

<span class="term_say"># 2. 开始进行一些测试的工作，并且也输出一些信息啰！</span>
testing=`netstat -tuln | grep ":80 "`
if [ "$testing" != "" ]; then
	echo "WWW is running in your system."
fi
testing=`netstat -tuln | grep ":22 "`
if [ "$testing" != "" ]; then
	echo "SSH is running in your system."
fi
testing=`netstat -tuln | grep ":21 "`
if [ "$testing" != "" ]; then
	echo "FTP is running in your system."
fi
testing=`netstat -tuln | grep ":25 "`
if [ "$testing" != "" ]; then
	echo "Mail is running in your system."
fi</span>
</pre></td></tr></tbody></table>

		这样又能够一个一个的检查啰～是否很有趣啊！ ^_^。接下来，我们再来玩更难一点的。
		我们知道可以利用 date 来显示日期与时间，也可以利用 $((计算式)) 来计算数值运算。
		另外， date 也可以用来显示自 19710101 以来的『总秒数』 (请自行查阅 man date 及 info date)
		。那么，您是否可以撰写一支小程序，用来『计算退伍日期还剩几天？』也就是说：<ol>
		<li>先让使用者输入他们的退伍日期；
		</li><li>再由现在日期比对退伍日期；
		</li><li>由两个日期的比较来显示『还需要几天』才能够退伍的字样。</li></ol>
		似乎挺难的样子？其实也不会啦，利用『 <span class="text_import2">date --date="YYYYMMDD" 
		+%s</span> 』就能够达到我们所想要的啰～如果您已经写完了程序，对照底下的写法试看看：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux scripts]# <span class="term_command">vi sh10.sh</span>
<span class="term_write">#!/bin/bash
# Program:
# 	Tring to calculate your demobilization date at how many days 
#	later...
# History:
# 2005/08/29	VBird	First release
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
export PATH

<span class="term_say"># 1. 告知用户这支程序的用途，并且告知应该如何输入日期格式？</span>
echo "This program will try to calculate :"
echo "How many days about your demobilization date..."
read -p "Please input your demobilization date (YYYYMMDD ex&gt;20050401): " date2

<span class="term_say"># 2. 测试一下，这个输入的内容是否正确？利用正规表示法啰～</span>
date_d=`echo $date2 |grep '[0-9]\{8\}'`
if [ "$date_d" == "" ]; then
	echo "You input the wrong format of date...."
	exit 1
fi

<span class="term_say"># 3. 开始计算日期啰～</span>
declare -i date_dem=`date --date="$date2" +%s`
declare -i date_now=`date +%s`
declare -i date_total_s=$(($date_dem-$date_now))
declare -i date_d=$(($date_total_s/60/60/24))
if [ "$date_total_s" -lt "0" ]; then
	echo "You had been demobilization before: " $((-1*$date_d)) " ago"
else
	declare -i date_h=$(($(($date_total_s-$date_d*60*60*24))/60/60))
	echo "You will be demobilized after $date_d days and $date_h hours."
fi</span>
</pre></td></tr></tbody></table>

		瞧一瞧，这支程序可以帮您计算退伍日期呢～如果是已经退伍的朋友，
		还可以知道已经退伍多久了～哈哈！很可爱吧～利用 date 算出自 1971/01/01 以来的总秒数，
		再与目前的总秒数来比对，然后以一天的总秒数 (60*60*24) 为基数去计算总日数，
		就能够得知两者的差异了～瞧～全部的动作都没有超出我们所学的范围吧～ ^_^
		还能够避免用户输入错误的数字，所以多了一个正规表示法的判断式呢～
		这个例子比较难，有兴趣想要一探究竟的朋友，可以作一下<a href="#FAQ">课后练习题</a>
		关于计算生日的那一题喔！～加油！<br><br>
	</div>

	<hr><a name="case"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">利用 case ..... esac 判断</span><br>
	<div class="block2">
		上个小节提到的『 if .... then .... fi 』对于变量的判断中，
		是以比对的方式来分辨的，如果符合状态就进行某些行为，并且透过较多层次 ( 就是 elif ... ) 
		的方式来进行多个变量的程序代码撰写，譬如 sh08.sh 那个小程序，就是用这样的方式来的啰。
		好，那么万一我有多个既定的变量内容，例如 sh08.sh 当中，我所需要的变量就是 "hello" 及空字符串两个，
		那么我只要针对这两个变量来设定状况就好了对吧？！那么可以使用什么方式来设计呢？
		呵呵～就用 case ... in .... esac 吧～，他的语法如下：<br>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_write">case</span> $变量名称 <span class="term_write">in</span>
  "第一个变量内容"<span class="term_write">)</span>
	程序段
	<span class="term_write">;;</span>
  "第二个变量内容"<span class="term_write">)</span>
	程序段
	<span class="term_write">;;</span>
  *<span class="term_write">)</span>
	不包含第一个变量内容与第二个变量内容的其他程序执行段
	exit 1
	<span class="term_write">;;</span>
<span class="term_write">esac</span>
</pre></td></tr></tbody></table>

		要注意的是，这个语法是以 case 为开头，而以 esac 为结尾，啥？为何是 esac 呢？想一想，既然 
		if 的结尾是 fi ，那么 case 的结尾当然就是将 case 倒着写，自然就是 esac 啰～ ^_^，很好记吧～
		另外，每一个变量内容的程序段最后都需要两个分号 (;;) 来代表该程序段落的结束，这挺重要的喔！
		至于为何需要有 * 这个变量内容在最后呢？这是因为，如果用户不是输入变量内容一或二时，
		我们可以告知用户相关的信息啊！举例来说，我们如果将 sh08.sh 改写的话，
		他应该会变成这样喔！<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux scripts]# <span class="term_command">vi sh08-2.sh</span>
<span class="term_write">#!/bin/bash
# Program:
# 	Show "Hello" from $1.... by using case .... esac
# History:
# 2005/08/29	VBird	First release
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
export PATH

case $1 in
  "hello")
	echo "Hello, how are you ?"
	;;
  "")
	echo "You MUST input parameters, ex&gt; $0 someword"
	;;
  *)
	echo "Usage $0 {hello}"
	;;
esac</span>
</pre></td></tr></tbody></table>

		在上面这个 sh08-2.sh 的案例当中，如果你输入『 sh sh08-2.sh test 』来执行，
		那么屏幕上就会出现『Usage sh08-2.sh {hello}』的字样，告知执行者仅能够使用 hello 喔～
		这样的方式对于需要某些固定字符串来执行的变量内容就显的更加的方便呢？
		这种方式您真的要熟悉喔！这是因为系统的很多服务的启动 scripts 都是使用这种写法的，
		举例来说，我们 Linux 的服务启动放置目录是在 /etc/init.d/ 当中，我已经知道里头有个
		syslog 的服务，我想要重新启动这个服务，可以这样做：
		<ul><span class="text_import2">/etc/init.d/syslog restart</span></ul>
		重点是那个 restart 啦～如果您进入 /etc/init.d/syslog 就会看到他使用的是 case 语法，
		并且会规定某些既定的变量内容，你可以直接下达 /etc/init.d/syslog ，
		该 script 就会告知你有哪些后续接的变量可以使用啰～方便吧！ ^_^<br><br>

		一般来说，使用『 case $变量 in 』这个语法中，当中的那个 $变量 大致有两种取得的方式：<ul>
		<li><span class="text_import1">直接下达式</span>：例如上面提到的，利用『 script.sh variable 』
			的方式来直接给予 $1 这个变量的内容，这也是在 /etc/init.d 目录下大多数程序的设计方式。
		</li><li><span class="text_import1">交互式</span>：透过 read 这个指令来让用户输入变量的内容。</li></ul>
		这么说或许您的感受性还不高，好，我们直接写个程序来玩玩：让使用者能够输入 one, two, three ，
		并且将用户的变量显示到屏幕上，如果不是 one, two, three 时，就告知使用者仅有这三种选择。<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux scripts]# <span class="term_command">vi sh11.sh</span>
<span class="term_write">#!/bin/bash
# Program:
# 	Let user input one, two, three and show in screen.
# History:
# 2005/08/29	VBird	First release
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
export PATH

echo "This program will print your selection !"
# read -p "Input your choice: " choice
# case $choice in
case $1 in
  "one")
	echo "Your choice is ONE"
	;;
  "two")
	echo "Your choice is TWO"
	;;
  "three")
	echo "Your choice is THREE"
	;;
  *)
	echo "Usage {one|two|three}"
	;;
esac</span>
</pre></td></tr></tbody></table>

		此时，您可以使用『 sh sh11.sh two 』的方式来下达指令，就可以收到相对应的响应了。
		上面使用的是直接下达的方式，而如果使用的是交互式时，那么将上面第 10, 11 行的 "#" 拿掉，
		并将 12 行加上批注 (#)，就可以让使用者输入参数啰～这样是否很有趣啊？！<br><br>
	</div>

	<hr><a name="function"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">利用 function 功能</span><br>
	<div class="block2">
		什么是『<span class="text_import2">函数 (function)</span>』功能啊？简单的说，其实，
		函数可以在 shell script 当中做出一个类似自定义执行指令的东西，最大的功能是，
		可以简化我们很多的程序代码～举例来说，上面的 sh11.sh 当中，每个输入结果 one, two, three 
		其实输出的内容都一样啊～那么我就可以使用 function 来简化了！ function 的语法是这样的：<br>

<table class="term"><tbody><tr><td class="term"><pre>function fname() {
	程序段
}
</pre></td></tr></tbody></table>

		那个 fname 就是我们的自定义的执行指令名称～而程序段就是我们要他执行的内容了。
		要注意的是，在 shell script 当中， function 的设定一定要在程序的最前面，
		这样才能够在执行时被找到可用的程序段喔！好～我们将 sh11.sh 改写一下：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux scripts]# <span class="term_command">vi sh11-2.sh</span>
<span class="term_write">#!/bin/bash
# Program:
# 	Let user input one, two, three and show in screen.
# History:
# 2005/08/29	VBird	First release
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
export PATH

function printit(){
	echo -n "Your choice is "
}

echo "This program will print your selection !"
case $1 in
  "one")
	<b>printit</b>; echo $1 | tr 'a-z' 'A-Z'
	;;
  "two")
	<b>printit</b>; echo $1 | tr 'a-z' 'A-Z'
	;;
  "three")
	<b>printit</b>; echo $1 | tr 'a-z' 'A-Z'
	;;
  *)
	echo "Usage {one|two|three}"
	;;
esac</span>
</pre></td></tr></tbody></table>

		以上面的例子来说，我做了一个函数名称为 printit ，所以，当我在后续的程序段里面，
		只要执行 printit 的话，就表示我的 shell script 要去执行『 function printit .... 』
		里面的那几个程序段落啰！
		当然啰，上面这个例子举得太简单了，所以您不会觉得 function 有什么好厉害的，
		不过，如果某些程序代码一再地在 script 当中重复时，这个 function 可就重要的多啰～
		不但可以简化程序代码，而且可以做成类似『模块』的玩意儿，真的很棒啦！<br><br>

		另外， function 也是拥有内建变量的～他的内建变数与 shell script 很类似，
		函数名称代表示 $0 ，而后续接的变量也是以 $1, $2... 来取代的～
		这里很容易搞错喔～因为『 function fname() { 程序段 } 』内的 $0, $1... 等等与 shell script 
		的 $0 是不同的。以上面 sh11-2.sh 来说，假如我下达：『 sh sh11-2.sh one 』
		这表示在 shell script 内的 $1 为 "one" 这个字符串。但是在 printit() 内的 $1 则与这个 one 无关。
		我们将上面的例子再次的改写一下，让您更清楚！<br>


<table class="term"><tbody><tr><td class="term"><pre>[root@linux scripts]# <span class="term_command">vi sh11-3.sh</span>
<span class="term_write">#!/bin/bash
# Program:
# 	Let user input one, two, three and show in screen.
# History:
# 2005/08/29	VBird	First release
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
export PATH

function printit(){
	echo "Your choice is $1"
}

echo "This program will print your selection !"
case $1 in
  "one")
	<b>printit 1</b>
	;;
  "two")
	<b>printit 2</b>
	;;
  "three")
	<b>printit 3</b>
	;;
  *)
	echo "Usage {one|two|three}"
	;;
esac</span>
</pre></td></tr></tbody></table>

		在上面的例子当中，如果您输入『 sh sh11-3.sh one 』就会出现『 Your choice is 1 』的字样～
		为什么是 1 呢？因为在程序段落当中，我们是写了『 printit 1 』那个 1 就会成为 function 当中的 $1 喔～
		这样是否理解呢？ function 本身其实比较困难一点，如果您还想要进行其他的撰写的话。
		不过，我们仅是想要更加了解 shell script 而已，所以，这里看看即可～了解原理就好啰～ ^_^
	</div>
</div>


<hr><a name="loop"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">循环 (loop)</span><br>
<div class="block1">
	除了 if...then...fi 这种条件判断式之外，循环可能是程序当中最重要的一环了～
	<span class="text_import2">循环可以不断的执行某个程序段落，直到用户设定的条件达成为止。</span>
	所以，重点是那个『条件的达成』是什么。底下我们就来谈一谈：<br><br>

	<hr><a name="while"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">while do done, until do done</span><br>
	<div class="block2">
		一般来说，循环最常见的就是底下这两种状态了：<br>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_write">while [</span> condition <span class="term_write">]
do</span>
	程序段落
<span class="term_write">done</span>
</pre></td></tr></tbody></table>

		这种方式中， while 是『当....时』，所以，这种方式说的是『<span class="text_import1">当 condition 
		条件成立时，就进行循环，直到 condition 的条件不成立才停止</span>』的意思。<br>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_write">until [</span> condition <span class="term_write">]
do</span>
	程序段落
<span class="term_write">done</span>
</pre></td></tr></tbody></table>

		这种方式恰恰与 while 相反，它说的是『<span class="text_import1">当 condition 条件成立时，就终止循环，
		否则就持续进行循环的程序段。</span>』是否刚好相反啊～我们以 while 来做个简单的练习好了。
		假设我要让使用者输入 yes 或者是 YES 才结束程序的执行，否则就一直进行告知用户输入字符串。<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux scripts]# <span class="term_command">vi sh12.sh</span>
<span class="term_write">#!/bin/bash
# Program:
# 	Use loop to try find your input.
# History:
# 2005/08/29	VBird	First release
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
export PATH

while [ "$yn" != "yes" ] &amp;&amp; [ "$yn" != "YES" ]
do
	read -p "Please input yes/YES to stop this program: " yn
done</span>
</pre></td></tr></tbody></table>

		上面这个例题的说明是『当 $yn 这个变量不是 "yes" 且 $yn 也不是 "YES" 时，才进行循环内的程序。』
		而如果 $yn 是 "yes" 或 "YES" 时，就会离开循环啰～那如果使用 until 呢？呵呵有趣啰～
		他的条件会变成这样：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux scripts]# <span class="term_command">vi sh12-2.sh</span>
<span class="term_write">#!/bin/bash
# Program:
# 	Use loop to try find your input.
# History:
# 2005/08/29	VBird	First release
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
export PATH

until [ "$yn" == "yes" ] || [ "$yn" == "YES" ]
do
	read -p "Please input yes/YES to stop this program: " yn
done</span>
</pre></td></tr></tbody></table>

		仔细比对一下这两个东西有啥不同喔！ ^_^再来，如果我想要计算 1+2+3+....+100 这个数据呢？
		利用循环啊～他是这样的：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux scripts]# <span class="term_command">vi sh13.sh</span>
<span class="term_write">#!/bin/bash
# Program:
# 	Try to use loop to calculate the result "1+2+3...+100"
# History:
# 2005/08/29	VBird	First release
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
export PATH

s=0
i=0
while [ "$i" != "100" ]
do
	i=$(($i+1))
	s=$(($s+$i))
done
echo "The result of '1+2+3+...+100' is ==&gt; $s"</span>
</pre></td></tr></tbody></table>

		嘿嘿！当您执行了『 sh sh13.sh 』之后，就可以得到 5050 这个数据才对啊！这样瞭呼～
		那么让您自行做一下，如果想要让用户自行输入一个数字，让程序由 1+2+... 直到您输入的数字为止，
		该如何撰写呢？应该很简单吧？！答案可以参考一下习题练习里面的一题喔！<br><br>
	</div>

	<hr><a name="for"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">for...do....done</span><br>
	<div class="block2">
		相对于 while, until 的循环方式是必须要『符合某个条件』的状态， for 这种语法，则是『
		<span class="text_import2">已经知道要进行几次循环</span>』的状态！他的语法是：<br>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_write">for ((</span> 初始值<span class="term_write">;</span> 限制值<span class="term_write">;</span> 执行步阶 <span class="term_write">))
do</span>
	程序段
<span class="term_write">done</span>
</pre></td></tr></tbody></table>

		这种语法适合于数值方式的运算当中，在 for 后面的括号内的三串内容意义为：<ul><span class="text_import2">
		<li>初始值：某个变量在循环当中的起始值，直接以类似 i=1 设定好；
		</li><li>限制值：当变量的值在这个限制值的范围内，就继续进行循环。例如 i&lt;=100；
		</li><li>执行步阶：每作一次循环时，变量的变化量。例如 i=i+1。</li></span></ul>
		值得注意的是，在『执行步阶』的设定上，如果每次增加 1 ，则可以使用类似『i++』的方式，亦即是 i 
		每次循环都会增加一的意思。好，我们以这种方式来进行 1 累加到 100 的循环吧！<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux scripts]# <span class="term_command">vi sh14.sh</span>
<span class="term_write">#!/bin/bash
# Program:
# 	Try do calculate 1+2+....+100
# History:
# 2005/08/29	VBird	First release
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
export PATH

s=0
for (( i=1; i&lt;=100; i=i+1 ))
do
	s=$(($s+$i))
done
echo "The result of '1+2+3+...+100' is ==&gt; $s"</span>
</pre></td></tr></tbody></table>

		一样也是很简单吧！利用这个 for 则可以直接限制循环要进行几次呢！这么好用的东西难道只能在数值方面动作？
		当然不是啦～我们还可以利用底下的方式来进行非数字方面的循环运作喔！<br>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_write">for</span> var <span class="term_write">in</span> con1 con2 con3 ...
<span class="term_write">do</span>
	程序段
<span class="term_write">done</span>
</pre></td></tr></tbody></table>

		以上面的例子来说，这个 $var 的变量内容在循环工作时：<ol>
		<li>第一次循环时， $var 的内容为 con1 ；
		</li><li>第二次循环时， $var 的内容为 con2 ；
		</li><li>第三次循环时， $var 的内容为 con3 ；
		</li><li>....</li></ol>

		我们可以做个简单的练习。假设我有三种动物，分别是 dog, cat, elephant 三种，
		我想每一行都输出这样：『There are dogs...』之类的字样，则可以：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux scripts]# <span class="term_command">vi sh15.sh</span>
<span class="term_write">#!/bin/bash
# Program:
# 	Using for .... loop to print 3 animal 
# History:
# 2005/08/29	VBird	First release
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
export PATH

for animal in dog cat elephant
do
	echo "There are ""$animal""s.... "
done</span>
</pre></td></tr></tbody></table>

		很简单是吧！ ^_^。好了，那么如果我想要让用户输入某个目录，
		然后我找出某目录内的文件名的权限呢？又该如何是好？呵呵！可以这样做啦～<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux scripts]# <span class="term_command">vi sh16.sh</span>
<span class="term_write">#!/bin/bash
# Program:
# 	let user input a directory and find the whole file's permission.
# History:
# 2005/08/29	VBird	First release
PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin
export PATH

<span class="term_say"># 1. 先看看这个目录是否存在啊？</span>
read -p "Please input a directory: " dir
if [ "$dir" == "" ] || [ ! -d "$dir" ]; then
	echo "The $dir is NOT exist in your system."
	exit 1
fi

<span class="term_say"># 2. 开始测试档案啰～</span>
filelist=`ls $dir`
for filename in $filelist
do
	perm=""
	test -r "$dir/$filename" &amp;&amp; perm="$perm readable"
	test -w "$dir/$filename" &amp;&amp; perm="$perm writable"
	test -x "$dir/$filename" &amp;&amp; perm="$perm executable"
	echo "The file $dir/$filename's permission is $perm "
done</span>
</pre></td></tr></tbody></table>

		呵呵！很有趣的例子吧～利用这种方式，您可以很轻易的来处理一些档案的特性呢～
		我们循环就介绍到这里了～其他更多的应用，就得视您的需求来玩啰～。
	</div>
</div>


<hr><a name="debug"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">shell script 的追踪与 debug</span><br>
<div class="block1">
	scripts 在执行之前，最怕的就是出现问题了！那么我们如何
	debug 呢？有没有办法不需要透过直接执行该 scripts 就可以来判断是否有问题呢！？呵呵！
	当然是有的！我们就直接以 bash 的相关参数来进行判断吧！<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">sh [-nvx] scripts.sh</span>
<span class="term_say">参数：
-n  ：不要执行 script，仅查询语法的问题；
-v  ：再执行 sccript 前，先将 scripts 的内容输出到屏幕上；
-x  ：将使用到的 script 内容显示到屏幕上，这是很有用的参数！
范例：</span>

<span class="term_hd">范例一：测试 sh16.sh 有无语法的问题？</span>
[root@linux ~]# <span class="term_command">sh -n sh16.sh </span>
<span class="term_say"># 若语法没有问题，则不会显示任何信息！</span>

<span class="term_hd">范例二：将 sh15.sh 的执行过程全部列出来～</span>
[root@linux ~]# <span class="term_command">sh -x sh15.sh </span>
+ PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:/home/vbird/bin
+ export PATH
+ for animal in dog cat elephant
+ echo 'There are dogs.... '
There are dogs....
+ for animal in dog cat elephant
+ echo 'There are cats.... '
There are cats....
+ for animal in dog cat elephant
+ echo 'There are elephants.... '
There are elephants....
<span class="term_say"># 使用 -x 真的是追踪 script 的好方法，他可以将所有有执行的程序段在执行前列出来，
# 如果是程序段落，则输出时，最前面会加上 + 字号，表示他是程序代码而已，
# 实际的输出则与 standard output 有关啊～如上所示。</span>
</pre></td></tr></tbody></table>

	在上面的范例二当中，我们可以透过这个简单的参数 -x 来达成 debug 的目的，这可是一个不可多得的参数，
	通常如果您执行 script 却发生问题时，利用这个 -x 参数，就可以知道问题是发生在哪一行上面了！<br><br>

	熟悉 sh 的用法，将可以使您在管理 Linux 的过程中得心应手！至于在 Shell scripts
	的学习方法上面，需要『<span class="text_import2">多看、多模仿、并加以修改成自己的样式！</span>』
	是最快的学习手段了！网络上有相当多的朋友在开发一些相当有用的
	scripts ，若是您可以将对方的 scripts 拿来，并且改成适合自己主机的样子！那么学习的效果会是最快的呢！<br><br>

	另外，我们 Linux 系统本来就有很多的启动 script ，如果您想要知道每个 script 所代表的功能是什么？
	可以直接以 vi 进入该 script 去查阅一下，通常立刻就知道该 script 的目的了。
	举例来说，我们的 Linux 里头有个文件名为： /etc/init.d/portmap ，这个 script 是干嘛用的？
	利用 vi 去查阅最前面的几行字，他出现如下信息：<br>

<table class="term"><tbody><tr><td class="term"><pre># description: The portmapper manages RPC connections, which are used by \
#              protocols such as NFS and NIS. The portmap server must be \
#              running on machines which act as servers for protocols which \
#              make use of the RPC mechanism.
# processname: portmap
</pre></td></tr></tbody></table>

	简单的说，他是被用在 NFS 与 NIS 上面的一个激活 RPC 的 script ，
	然后我们再利用 http://www.google.com.tw 去搜寻一下 NFS, NIS 与 RPC ，
	立刻就能够知道这个 script 的功能啰～所以，下次您发现不明的 script 时，
	如果是系统提供的，那么利用这个检查的方式，一定可以约略了解的啦！
	加油的啰～ ^_^<br><br>

	另外，本章所有的范例都可以在 <a href="../../../linux.vbird.org/linux_basic/0340bashshell-scripts/scripts.gz" target="_blank">http://linux.vbird.org/linux_basic/0340bashshell-scripts/scripts.tgz</a>
	里头找到喔！加油～<br><br>
</div>

<hr><a name="FAQ"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">本章习题练习</span><br>
( 要看答案请将鼠标移动到『答：』底下的空白处，按下左键圈选空白处即可察看 )
<div class="block1">
<ul>
	<li>请建立一支 script ，当你执行该 script 的时候，该 script 可以显示： 1. 你目前的身份 (用 whoami )
	2. 你目前所在的目录 (用 pwd)</li>
	<div class="block2"><font color="white" size="-1">
		#!/bin/bash<br>
		echo -e "Your name is ==&gt; `whoami`"<br>
		echo -e "The current directory is ==&gt; `pwd`"<br>
	</font></div>

	<li>请自行建立一支程序，该程序可以用来计算『您还有几天可以过生日』啊？？</li>
	<div class="block2"><font color="white" size="-1">
		#!/bin/bash<br>
		read -p "Pleas input your birthday (MMDD, ex&gt; 0709): " bir<br>
		now=`date +%m%d`<br>
		if [ "$bir" == "$now" ]; then<br>
		        echo "Happy Birthday to you!!!"<br>
		elif [ "$bir" -gt "$now" ]; then<br>
		        year=`date +%Y`<br>
		        total_d=$(($((`date --date="$year$bir" +%s`-`date +%s`))/60/60/24))<br>
		        echo "Your birthday will be $total_d later"<br>
		else<br>
		        year=$((`date +%Y`+1))<br>
		        total_d=$(($((`date --date="$year$bir" +%s`-`date +%s`))/60/60/24))<br>
		        echo "Your birthday will be $total_d later"<br>
		fi<br>
	</font></div>

	<li>让用户输入一个数字，程序可以由 1+2+3... 一直累加到用户输入的数字为止。</li>
	<div class="block2"><font color="white" size="-1">
	#!/bin/bash<br>
	read -p "Please input an integer number: " number<br>
	i=0<br>
	s=0<br>
	while [ "$i" != "$number" ]<br>
	do<br>
	        i=$(($i+1))<br>
	        s=$(($s+$i))<br>
	done<br>
	echo "the result of '1+2+3+...$number' is ==&gt; $s"<br>
	</font></div>

	<li>撰写一支程序，他的作用是: 1.) 先查看一下 /root/test/logical 这个名称是否存在；
	2.) 若不存在，则建立一个档案，使用 touch 来建立，建立完成后离开；
	3.) 如果存在的话，判断该名称是否为档案，若为档案则将之删除后建立一个目录，文件名为 logical ，之后离开；
	4.) 如果存在的话，而且该名称为目录，则移除此目录！</li>
	<div class="block2"><font color="white" size="-1">
	#!/bin/bash<br>
	if [ ! -e logical ]; then<br>
	        touch logical<br>
        	echo "Just make a file logical"<br>
	        exit 1<br>
	elif [ -e logical ] &amp;&amp; [ -f logical ]; then<br>
	        rm logical<br>
	        mkdir logical<br>
	        echo "remove file ==&gt; logical"<br>
	        echo "and make directory logical"<br>
	        exit 1<br>
	elif [ -e logical ] &amp;&amp; [ -d logical ]; then<br>
	        rm -rf logical<br>
	        echo "remove directory ==&gt; logical"<br>
	        exit 1<br>
	else<br>
	        echo "Does here have anything?"<br>
	fi<br>
	</font></div>

	<li>我们知道 /etc/passwd 里面以 : 来分隔，第一栏为账号名称。请写一只程序，可以将 /etc/passwd 
	的第一栏取出，而且每一栏都以一行字符串『The 1 account is "root" 』来显示，那个 1 表示行数。</li>
	<div class="block2"><font color="white" size="-1">
	#!/bin/bash<br>
	accounts=`cat /etc/passwd | cut -d':' -f1`<br>
	for account in $accounts<br>
	do<br>
	        declare -i i=$i+1<br>
	        echo "The $i account is \"$account\" "<br>
	done<br>
	</font></div>


</ul>
</div>


<hr><span class="text_history">
2002/06/27：第一次完成<br>
2003/02/10：重新编排与加入 FAQ<br>
2005/08/29：将旧的文章移动到 <a href="http://linux.vbird.org/linux_basic/0340bashshell-scripts/0340bashshell-scripts.php">这里</a> 了。<br>
2005/08/29：呼呼～加入了一些比较有趣的练习题～比第一版要难的多～大家多多玩一玩喔～<hr>
</span>
    </td>
    <td style="width: 16px; font-size: 6px;">　</td></tr>
<tr><td style="width: 16px; height: 16px;">　</td>
    <td style="width: 688px; height: 16px;">　</td>
    <td style="width: 16px; height: 16px;">　</td></tr>
</tbody></table>

<div style="padding-top: 0px; text-align: center;">
<span style="font-size: 80%;">
	<a href="http://linux.vbird.org/" target="_top" title="前往鸟哥的首页">http://linux.vbird.org</a>
	is designed by <a href="mailto:vbird@mail.vbird.idv.tw" title="联络鸟哥(我不要广告信！)">VBird</a>
		during 2001-2011. <a href="http://www.ksu.edu.tw/" target="_blank">ksu.edu</a></span>
                ﻿<div id="apDiv4">
      <p>本网页主要以Firefox配合解析度 1024x768 作为设计依据&nbsp;&nbsp;&nbsp;&nbsp; 鸟哥自由软件整合应用研究室</p></div></div></div>
</center>
</body></html>
