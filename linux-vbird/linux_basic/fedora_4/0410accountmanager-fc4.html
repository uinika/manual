<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="zh-TW"><head>

	<meta http-equiv="Content-Type" content="text/html; charset=utf8">
	<meta name="Author" content="VBird, 鸟哥">
	<meta name="Description" content="在 Linux 系统下管理用户的身份与账号！">
	<title>鸟哥的 Linux 私房菜 -- Linux 账号管理</title>
    <script src="../../script/SpryMenuBar.js" type="text/javascript"></script>
	<script src="../../script/index.js" type="text/javascript"></script>
	<link href="../../css/SpryMenuBarHorizontal.css" rel="stylesheet" type="text/css" />
    <link href="../../css/main.css" rel="stylesheet" type="text/css" />
</head><body style="margin: 0pt; padding: 0pt;" class="table"onload="MM_preloadImages('../../index-2.html','../../index-2.html','../../index-2.html','../../index-2.html','../../index-2.html','../../index-2.html','../../index-2.html','../../index-2.html')">

<center>
<div id="apDiv5">
<div> <LINK REL="SHORTCUT ICON" HREF="../../index-2.html">
<!-- ImageReady Slices (title3.ai) -->
<table id="___01" width="898" height="81" border="0" align="center" cellpadding="0" cellspacing="0";>
	<tr>
		<td colspan="15">
			<img src="image/title/title_01.png" width="900" height="1" alt=""></td>
	</tr>
	<tr>
		<td rowspan="4" bgcolor="#182448"><p><img src="http://linux.vbird.org/cgi-bin/Count.cgi?dd=C&amp;ft=5&amp;sh=T&amp;md=8&amp;pad=Y&amp;df=vbird.dic.ksu.edu.tw.dat" width="93" align="left" title="計數器" /></p>
	    <p><font color="#FFFFFF" size="-1">since2012/04/23</font></p></td>
		<td rowspan="4" align="left" valign="top"><a href="../../index.html"><img src="image/title/title_03.png" alt="" width="263" height="79" border="0"></a></td>
		<td colspan="13">
			<img src="image/title/title_04.png" alt="" width="535" height="9" border="0"></td>
	</tr>
	<tr>
		<td rowspan="3">
			<img src="image/title/title_05.png" alt="" width="53" height="70" border="0"></td>
		<td colspan="2" align="left" valign="top"><a href="../0110whatislinux.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image51','','image/title/title_06.png',1)"><img src="image/title/title3_06.png" name="Image51" width="106" height="25" border="0" id="Image51" alt=""/></a></td>
		<td rowspan="2">
			<img src="image/title/title_07.png" alt="" width="27" height="37" border="0"></td>
		<td colspan="3" align="left" valign="top"><a href="../../linux_server/0110network_basic.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image52','','image/title/title_08.png',1)"><img src="image/title/title3_08.png" name="Image52" width="107" height="25" border="0" id="Image52" alt=""/></a></td>
		<td rowspan="2">
			<img src="image/title/title_09.png" alt="" width="37" height="37" border="0"></td>
		<td colspan="2" align="left" valign="top"><a href="../../about.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image53','','image/title/title_10.png',1)"><img src="image/title/title3_10.png" name="Image53" width="75" height="25" border="0" id="Image53" alt=""/></a></td>
		<td rowspan="3">
			<img src="image/title/title_11.png" alt="" width="35" height="70" border="0"></td>
		<td align="left" valign="top"><a href="mailto:vbird@mail.vbird.idv.tw" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image54','','image/title/title_12.png',1)"><img src="image/title/title3_12.png" name="Image54" width="74" height="25" border="0" id="Image54" alt=""/></a></td>
		<td rowspan="3">
			<img src="image/title/title_13.png" alt="" width="21" height="70" border="0"></td>
	</tr>
	<tr>
		<td colspan="2">
			<img src="image/title/title_14.png" alt="" width="106" height="12" border="0"></td>
		<td colspan="3">
			<img src="image/title/title_15.png" alt="" width="107" height="12" border="0"></td>
		<td colspan="2">
			<img src="image/title/title_16.png" width="75" height="12" alt=""></td>
		<td rowspan="2">
			<img src="image/title/title_17.png" alt="" width="74" height="45" border="0"></td>
	</tr>
	<tr>
		<td>
			<img src="image/title/title_18.png" alt="" width="15" height="33" border="0"></td>
		<td colspan="3" align="left" valign="top"><ul id="MenuBar1" class="MenuBarHorizontal">
	  <li><a href="../linux_basic.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image44','','image/title/title_19.png',1)"><img src="image/title/title3_19.png" name="Image44" width="123" height="33" border="0" id="Image44" /></a>
			    <ul>
			      <li><a href="../Mandrake9.0/mandrake9.0.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image46','','image/title/title_26.png',1)"><img src="image/title/title_23.png" name="Image46" width="120" height="26" border="0" id="Image46" alt="" /></a></li>
                  <li><a href="fc4.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image47','','image/title/title_27.png',1)"><img src="image/title/title_24.png" name="Image47" width="120" height="26" border="0" id="Image47" alt="" /></a></li>
                  <li><a href="../linux_basic.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image48','','image/title/title_28.png',1)"><img src="image/title/title_25.png" name="Image48" width="120" height="26" border="0" id="Image48" alt="" /></a></li>
                </ul>
		      </li>
		</ul></td>
		<td>
			<img src="image/title/title_20.png" alt="" width="42" height="33" border="0"></td>
		<td colspan="3" align="left" valign="top"><ul id="MenuBar2" class="MenuBarHorizontal">
	  <li><a href="../../linux_server/index.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image45','','image/title/title_21.png',1)"><img src="image/title/title3_21.png" name="Image45" width="125" height="33" border="0" id="Image45" /></a>
			    <ul>
			      <li><a href="../../linux_server/linux_redhat9/redhat9.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image43','','image/title/title_26.png',1)"><img src="image/title/title_23.png" name="Image43" width="120" height="26" border="0" id="Image43" alt=""/></a></li>
			      <li><a href="../../linux_server/centos4.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image49','','image/title/title_27.png',1)"><img src="image/title/title_24.png" name="Image49" width="120" height="26" border="0" id="Image49" alt="" /></a></li>
			      <li><a href="../../linux_server/index.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image50','','image/title/title_28.png',1)"><img src="image/title/title_25.png" name="Image50" width="120" height="26" border="0" id="Image50" alt="" /></a></li>
		        </ul>
		      </li>
		</ul></td>
		<td>
			<img src="image/title/title_22.png" alt="" width="47" height="33" border="0"></td>
	</tr>
	<tr>
		<td>
			<img src="image/title/Spacer.gif" width="101" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="263" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="53" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="15" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="91" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="27" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="5" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="42" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="60" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="37" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="28" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="47" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="35" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="74" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="22" height="1" alt=""></td>
	</tr>
</table>
<!-- End ImageReady Slices -->
<script type="text/javascript">
<!--
var MenuBar1 = new Spry.Widget.MenuBar("MenuBar1", {imgDown:"SpryAssets/SpryMenuBarDownHover.gif", imgRight:"SpryAssets/SpryMenuBarRightHover.gif"});
var MenuBar2 = new Spry.Widget.MenuBar("MenuBar2", {imgDown:"SpryAssets/SpryMenuBarDownHover.gif", imgRight:"SpryAssets/SpryMenuBarRightHover.gif"});
//-->
</script>
</div>
<table summary="本文内容的排版" style="width: 898px;" border="0" cellpadding="0" cellspacing="0">
<tbody><tr><td style="width: 16px; height: 16px;">　</td>
    <td style="width: 688px; height: 16px;">　</td>
    <td style="width: 16px; height: 16px;">　</td></tr>
<tr><td style="width: 16px; font-size: 6px;">　</td>
    <td width="688">

<!-- 本文的档头部分 -->
<div style="text-align: center;">
    <a href="http://linux.vbird.org/linux_basic/0410accountmanager/0410accountmanager.php">
    <span class="text_head0"><span class="text_head_en">Linux </span>账号与身份管理</span></a><br>
</div>
    <div style="text-align: right;">
        <span class="text_history">最近更新日期：2005/09/05</span>
    </div>

<center>本文已不再维护，更新文章请参考<a href="http://linux.vbird.org/linux_basic/0410accountmanager.php">此处</a></center>
<!-- 本文的档头部分 -->
<center><table class="head1" summary="排版：文章档头的说明"><tbody><tr><td class="head1">
	要登入 Linux 系统一定要有账号与密码才行，否则怎么登入，您说是吧？！不过，
	不同的使用者应该要拥有不同的权限才行吧？我们还可以透过 user/group 的特殊权限设定，
	来规范出不同的群组开发项目呢～在 Linux 的环境下，我们可以透过很多方式来限制用户能够使用的系统资源，
	包括 <a href="http://linux.vbird.org/linux_basic/0410accountmanager/0320bash.php">bash shell</a> 章节提到的 ulimit 限制、还有特殊权限限制，如 umask 等等。
	透过这些举动，我们可以规范出不同使用者的使用资源。另外，还记得系统管理员的账号吗？对！
	就是 root 。请问一下，除了 root 之外，是否可以有其他的系统管理员账号？
	为什么大家都要尽量避免使用数字型态的账号？如何修改用户相关的信息呢？这些我们都得要了解了解的！
</td></tr></tbody></table></center>

<!-- 本文的连结区部分 -->
<div class="block1">
<span class="text_h1">
1. <a href="#account">Linux 的账号与群组</a><br>
	<span class="text_h2">
	　　1.1 <a href="#account_id">使用者识别： UID 与 GID</a><br>
	　　1.2 <a href="#account_user">使用者账号：/etc/passwd, /etc/shadow</a><br>
	　　1.3 <a href="#account_group">关于群组</a>： <a href="#account_group_init">有效与初始群组</a>、
		<a href="#groups">groups</a>, <a href="#newgrp">newgrp</a><br>
	</span>
2. <a href="#users">账号管理：</a><br>
	<span class="text_h2">
	　　2.1 <a href="#users_adduser">新增与移除使用者</a>： <a href="#useradd">useradd</a>, 
		<a href="#users_adduser_env">相关配置文件</a>, <a href="#users_adduser_pw">passwd</a>, 
		<a href="#usermod">usermod</a>, <a href="#userdel">userdel</a><br>
	　　2.2 <a href="#normal_user">用户功能</a>：<a href="#chsh">chsh</a>, 
		<a href="#chfn">chfn</a>, <a href="#finger">finger</a>, <a href="#id">id</a><br>
	　　2.3 <a href="#group_add">新增与移除群组</a>：<a href="#groupadd">groupadd</a>, 
		<a href="#groupmod">groupmod</a>, <a href="#groupdel">groupdel</a>,
		<a href="#gpasswd">gpasswd</a>, <a href="#newgrp2">newgrp</a><br>
	　　2.4 <a href="#pwcontrol">密码管理</a>： <a href="#passwd2">passwd</a><br>
	</span>
3. <a href="#userswitch">使用者身份切换：</a><br>
	<span class="text_h2">
	　　3.1 <a href="#su">su</a><br>
	　　3.2 <a href="#sudo">sudo</a>, <a href="#visudo">visudo (/etc/sudoers)</a><br>
	</span>
4. <a href="#usershell">使用者的特殊 shell 与 PAM 模块</a><br>
	<span class="text_h2">
	　　4.1 <a href="#nologin">特殊的 shell ， /sbin/nologin</a><br>
	　　4.2 <a href="#pam">PAM 模块： /etc/nologin, /etc/securetty, /etc/security/*</a><br>
	</span>
5. <a href="#uselinux">Linux 系统上用户的对谈与 mail 的使用：</a><br>
	<span class="text_h2">
	　　4.1 <a href="#uselinux_find">查询使用者： w, who, last, lastlog</a><br>
	　　4.2 <a href="#uselinux_talk">使用者对谈： talk, mesg, wall</a><br>
	　　4.3 <a href="#mail">使用者邮件信箱： mail</a><br>
	</span>
6. <a href="#manual">手动新增使用者：</a><br>
	<span class="text_h2">
	　　5.1 <a href="#manual_tools">一些检查工具</a>：<a href="#pwck">pwck</a>, 
		<a href="#pwconv">pwconv</a>, <a href="#pwunconv">pwunconv</a>, <a href="#chpasswd">chpasswd</a><br>
	　　5.2 <a href="#manual_normal">特殊账号，如纯数字账号的建立：</a><br>
	　　5.3 <a href="#manual_pop3">不开放终端机登入的账号 (ex&gt;mail acccount)</a><br>
	　　5.4 <a href="#manual_amount">一个大量建置账号的范例：</a><br>
	</span>
7. <a href="#FAQ">本章习题练习</a><br>
<span class="text_h2">
8. <a href="http://phorum.vbird.org/viewtopic.php?t=23887" target="_blank">针对本文的建议：http://phorum.vbird.org/viewtopic.php?t=23887</a>
</span>
</span>
</div>

<!-- 本文的正式部分 -->
<hr><a name="account"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">Linux 的账号与群组</span><br>
<div class="block1">
	管理员的工作中，相当重要的一环就是『管理账号』啦！因为整个系统都是你在管理的，
	并且所有的一般用户的申请，都必须要透过你的协助才行！所以你就必须要了解一下如何管理好一个网站的账号管理啦！
	在管理 Linux 主机的账号时，我们必须先来了解一下 Linux 到底是如何辨别每一个使用者的！<br><br>

	<hr><a name="account_id"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">使用者识别： UID 与 GID</span><br>
	<div class="block2">
		虽然我们登入 Linux 主机的时候，输入的是我们的账号，但是，其实 Linux 
		主机并不会直接认识你的『账号名称』的，他仅认识 ID 啊～ID 就是一组号码啦～
		主机对于数字比较有概念的，账号只是为了让人们容易记忆而已。
		而您的 ID 与账号的对应就在 /etc/passwd 当中哩。<br>
		<div style="padding: 10pt 0pt;" align="right"><table width="90%"><tbody><tr><td><b>Tips:</b><br><span style="color: rgb(0, 144, 0);"><font size="-1">			如果你曾经以 tarball 安装过软件的话，那么应该不难发现，在解压缩之后的档案，
			档案拥有者竟然是『不明的数字』？奇怪吧？这没什么好奇怪的，因为 Linux 
			说实在话，他真的只认识代表你身份的号码而已！
		</font></span></td><td><img src="0410accountmanager-fc4_files/vbird_face.gif" alt="鸟哥的图示" title="鸟哥的图示"></td></tr></tbody></table></div>
		那么到底有几种 ID 呢？还记得我们在『<a href="http://linux.vbird.org/linux_basic/0410accountmanager/0210filepermission.php">文件属性与目录配置</a>』
		那一篇文章的时候有提到每一个档案都具有『拥有人与拥有群组』的属性吗？
		没错啦～每个登入的使用者至少都会取得两个 ID ，一个是使用者 ID (User ID ，简称 UID)、
		一个是群组 ID (Group ID ，简称 GID)。<br><br>

		那么档案如何判别他的拥有者与群组呢？其实就是利用 UID 与 GID 啦！
		每一个档案都会有所谓的拥有者 ID 与拥有群组 ID ，亦即是 UID
		与 GID ，然后系统会依据 /etc/passwd 的内容，去将该档案的拥有者与组名，
		使用账号的形式来秀出来！我们可以作个小实验，你可以以
		root 的身份 vi /etc/passwd ，然后将你的一般身份的使用者的 ID 随便改一个号码，
		然后再到你的一般身份的目录下看看原先该账号拥有的档案，你会发现该档案的拥有人变成了
		『数字了』呵呵！这样可以理解了吗？<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">vi /etc/passwd</span>
<span class="term_say">.....(前面省略).....</span>
dmtsai:x:501:501::/home/dmtsai:/bin/bash  <span class="term_note">&lt;==将原本的 501:501 改成 3000:501</span>

[root@linux ~]# <span class="term_command">ls -ld /home/</span>
drwxr-xr-x   3   <span class="term_write">501</span> dmtsai 4096 Aug 30 10:37 dmtsai
<span class="term_say"># 瞧！这里就能够知道，其实档案记录的是 UID 啦～</span>
</pre></td></tr></tbody></table>

		你一定要了解的是，上面的例子仅是在说明 UID 与账号的对应性，
		<span class="text_import2">在一部正常运作的 Linux 主机环境下，上面的动作不可随便进行</span>，
		这是因为系统上已经有很多的数据在运行了，随意修改系统上某些账号的 UID 
		很可能会导致某些程序无法进行，这将导致系统无法顺利运作的结果。
		因为权限的问题啊！所以，了解了之后，请赶快回到 /etc/passwd 里面，将数字改回来喔！<br><br>

		<li><span class="text_import1">如何登入 Linux 取得 UID/GID</span></li>
		<div class="block2">
		好了，那么我们再来谈一谈，到底我们是怎样登入 Linux 主机的呢？其实也不难啦！当我们在主机前面或者是以
		telnet 或者 ssh 登入主机时，系统会出现一个 login 的画面让你输入账号，这个时候当你输入账号与密码之后，
		Linux 会：<ol><span class="text_import2">
		<li>先找寻 /etc/passwd 里面是否有这个账号？如果没有则跳出，如果有的话则将该账号对应的
			UID ( User ID )与 GID ( Group ID )读出来，另外，该账号的家目录与 shell
			设定也一并读出；</li>
		<li>再来则是核对密码表啦！这时 Linux 会进入 /etc/shadow
			里面找出对应的账号与 UID，然后核对一下你刚刚输入的密码与里头的密码是否相符？</li>
		<li>如果一切都 OK 的话，就进入 Shell 控管的阶段啰！</li></span></ol>
		大致上的情况就像这样，所以呢，当你要登入你的 Linux 主机的时候，那个 /etc/passwd
		与 /etc/shadow 就必须要让系统读取啦，（这也是很多攻击者会将特殊账号写到
		/etc/passwd 里头去的缘故！）所以呢，如果你要备份 Linux 的系统的账号的话，
		那么这两个档案就一定需要备份才行呦！
		</div>
	</div>

	<hr><a name="account_user"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">使用者账号：/etc/passwd, 
	/etc/shadow</span><br>
	<div class="block2">
		由上面的说明您大概已经知道，嘿嘿！账号管理最重要的两个档案就是『 /etc/passwd
		与 /etc/shadow 』了！这两个档案可以说是 Linux 里头最重要的档案之一了！
		如果没有这两个档案的话，呵呵！您可是无法登入 Linux 的呦！所以，底下我们先针对这两个档案来进行说明。
		当然啰，更详细的数据您可以自行 man 5 passwd 及 man 5 shadow 的啦～<br><br>

		<hr><li><span class="text_import1">/etc/passwd</span></li>
		<div class="block2">
		这个档案的构造是这样的：<span class="text_import2">每一行都代表一个账号，
		有几行就代表有几个账号在你的系统中</span>！不过需要特别留意的是，
		里头很多账号本来就是系统中必须要的，我们可以简称他为系统账号，
		例如 bin, daemon, adm, nobody 等等，这些账号是系统正常运作时所需要的，请不要随意的杀掉他呢！
		这个档案的内容有点像这样：<br>

<table class="term"><tbody><tr><td class="term"><pre>root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
</pre></td></tr></tbody></table>

		我们先来看一下每个 Linux 系统都会有的第一行，就是 root 这个系统管理员那一行好了，
		你可以明显的看出来，每一行使用『:』分隔开，共有七个咚咚，分别是：<ol>

		<li><span class="text_import1">账号名称</span>：就是账号名称啦！对应 UID 用的！例如 
			root 就是默认的系统管理员的账号名称；</li><br>
		<li><span class="text_import1">密码</span>：早期的 Unix 系统的密码是放在这个档案中的，
			但是因为这个档案的特性是所有的程序都能够读取，所以，这样一来很容易造成数据的被窃取，
			因此后来就将这个字段的密码数据给他改放到 /etc/shadow 中了，关于 /etc/shadow 
			这一部份等一下再说。而这里你会看到一个 x ，呵呵！别担心，这表示密码已经被移动到 
			shadow 这个加密过后的档案啰；</li><br>
		<li><span class="text_import1">UID</span>：这个就是使用者标识符 (ID) 啰！通常 Linux 对于 
			UID 有几个限制需要说给您了解一下：</li>

<table width="90%" bgcolor="lightyellow" border="1" cellpadding="3" cellspacing="0">
<tbody><tr align="center" bgcolor="#182448"><td width="80"><font color="#FFFFFF">id 范围</font></td><td><font color="#FFFFFF">该 ID 使用者特性</font></td></tr>
<tr><td>0</td><td>当 UID 是 0 时，代表这个账号是『系统管理员』！所以当你要作另一个系统管理员账号时，
	你可以将该账号的 UID 改成 0 即可；这也就是说，一部系统上面的系统管理员不见得只有 root 喔！
	不过，不很建议有多个账号的 UID 是 0 啦～</td></tr>
<tr><td>1~499</td><td>保留给系统使用的 ID，其实 1~65534 之间的账号并没有不同，
	也就是<span class="text_import2">除了 0 之外，其他的 UID 并没有不一样</span>，预设 500 
	以下给系统作为保留账号只是一个习惯。这样的好处是，以有名的 DNS 服务器的启动服务『 named 
	』为例，这个程序的默认所有人 named 的账号 UID 是 25 ，当有其他的账号同样是 25 
	时，很可能会造成系统的一些小问题！为了杜绝这样的问题，建议保留 500 以前的 UID 给系统吧！<br>
	不过，一般来说， 1~99 会保留给系统默认的账号，另外 100~499 则保留给一些服务来使用。</td></tr>
<tr><td>500~65535</td><td>给一般使用者用的。事实上，目前的 linux 核心 (2.6.x 版)已经可以支持到
	4294967295 (2^32-1) 这么大的 UID 号码喔！</td></tr>
</tbody></table><br>

			上面这样说明可以了解了吗？是的， UID 为 0 的时候，就是 root 呦！所以请特别留意一下你的 
			/etc/passwd 档案！<br><br>
		<li><span class="text_import1">GID</span>：这个与 /etc/group 有关！其实 /etc/group 
			的观念与 /etc/passwd 差不多，只是他是用来规范 group 的而已！</li><br>
		<li><span class="text_import1">用户信息说明栏</span>：这个字段基本上并没有什么重要用途，
			只是用来解释这个账号的意义而已！不过，如果您提供使用 finger 的功能时，
			这个字段可以提供很多的讯息呢！底下的 chfn 可以解释一下啰！</li><br>
		<li><span class="text_import1">家目录</span>：这是用户的家目录，以上面为例， root 的家目录在 
			/root ，所以当 root 登入之后，就会立刻跑到 /root 里头啦！呵呵！
			如果你有个账号的使用空间特别的大，你想要将该账号的家目录移动到其他的硬盘去，
			没有错！可以在这里进行修改呦！默认的用户家目录在 /home/yourIDname</li><br>
		<li><span class="text_import1">Shell</span>：所谓的 shell 
			是用来沟通人类下达的指令与硬件之间真正动作的界面！我们通常使用 /bin/bash 
			这个 shell 来进行指令的下达！嘿嘿！发现了吧？我们在 <a href="http://linux.vbird.org/linux_basic/0410accountmanager/0320bash.php">bash</a> 
			章节里面提到很多次，登入 Linux 时为何预设是 bash 呢？就是这里设定的啦～
			这里比较需要注意的是，有一个 shell 可以用来替代成让账号无法登入的指令！那就是
			/sbin/nologin 这个东西！这也可以用来制作纯 pop 邮件账号者的数据呢！</li>
		</ol>
		</div>

		<hr><li><span class="text_import1">/etc/shadow</span></li>
		<div class="block2">
		上面约略提到，由于每个程序都需要取得 uid 与 gid 来判断权限的问题，所以，
		/etc/passwd 的权限必须要设定成为 -rw-r--r-- 这样的权限，在这样的情况下，
		用户的密码不就任何人都可以看到吗？即使这个档案内的密码栏是加密的，
		坏心肠的朋友也可能利用暴力破解法去 try and error 找出您的密码数据......<br><br>

		因为这样的关系，所以后来发展出将密码移动到 /etc/shadow 这个档案分隔开来的技术，
		而且还加入很多的密码限制参数在 /etc/shadow 里头呢！我们先来了解一下这个档案的构造吧！
		我的 /etc/shadow 档案有点像这样：<br>

<table class="term"><tbody><tr><td class="term"><pre>root:$1$i9Ejldjfjio389u9sjl$jljsoi45QE/:12959:0:99999:7:::
bin:*:12959:0:99999:7:::
daemon:*:12959:0:99999:7:::
adm:*:12959:0:99999:7:::
</pre></td></tr></tbody></table>

		基本上， shadow 同样以『:』作为分隔符，如果数一数，会发现共有九个字段啊，
		这九个字段的用途是这样的：<ol>

		<li><span class="text_import1">账号名称</span>：由于密码也需要与账号对应啊～因此，
			这个档案的第一栏就是账号，必须要与 /etc/passwd 相同才行！</li><br>
		<li><span class="text_import1">密码</span>：这个才是真正的密码，而且是
			<span class="text_import2">经过编码过的密码</span>啦！
			你只会看到有一些特殊符号的字母就是了！需要特别留意的是，
			虽然这些加密过的密码很难被解出来，但是『很难』不等于『不会』，所以，
			这个档案的默认属性是『-rw-------』或者是『-r--------』，亦即只有 root 
			才可以读写就是了！你得随时注意，不要不小心更动了这个档案的属性呢！另外，
			如果是在密码栏的第一个字符为『 * 』或者是『 ! 』，表示这个账号并不会被用来登入的意思。
			所以万一哪一天你的某个使用者不乖时，可以先在这个档案中，将他的密码字段的最前面多加一个 
			* ！嘿嘿！他就无法使用该账号啰！直到他变乖了，再给他启用啊！</li><br>
		<li><span class="text_import1">最近更动密码的日期</span>：这个字段记录了『更动密码的那一天』的日期，
			不过，很奇怪呀！在我的例子中怎么会是 12959 呢？呵呵，这个是因为计算 Linux 
			日期的时间是以 1970 年 1 月 1 日作为 1 ，而 1971 年 1 月 1 日则为 366 啦！
			所以这个日期是累加的呢！得注意一下这个资料呦！那么最近的 2005 年 1 月 1 日就是 12784 
			啦，了解了吗？</li><br>
		<li><span class="text_import1">密码不可被更动的天数</span>：
			第四个字段记录了这个账号的密码需要经过几天才可以被变更！如果是 0 的话，
			表示密码随时可以更动的意思。这的限制是为了怕密码被某些人一改再改而设计的！如果设定为 
			20 天的话，那么当你设定了密码之后， 20 天之内都无法改变这个密码呦！</li><br>
		<li><span class="text_import1">密码需要重新变更的天数</span>：
			由于害怕密码被某些『有心人士』窃取而危害到整个系统的安全，所以有了这个字段的设计。
			<span class="text_import2">你必须要在这个时间之内重新设定你的密码，否则这个账号将会暂时失效</span>。
			而如果像上面的 99999 的话，那就表示，呵呵，密码不需要重新输入啦！
			不过，如果是为了安全性，最好可以设定一段时间之后，严格要求用户变更密码呢！</li><br>
		<li><span class="text_import1">密码需要变更期限前的警告期限</span>：当账号的密码失效期限快要到的时候，
			就是上面那个『必须变更密码』的那个时间时，
			系统会依据这个字段的设定，发出『警告』言论给这个账号，提醒他『再过 n 
			天你的密码就要失效了，请尽快重新设定你的密码呦！』，如上面的例子，则是密码到期之前的 
			7 天之内，系统会警告该用户。</li><br>
		<li><span class="text_import1">密码过期的恕限时间</span>：如果用户过了警告期限没有重新输入密码，
			使得密码失效了，也就是说，你在『必须变更密码的期限前，并没有变更你的密码！』
			那么该组密码就称为『失效的密码』啰～怎么办？没关系，还有这个字段的天数设计啊～
			意思就是说，当密码失效后，你还可以用这个密码在 n 天内进行登入的意思。
			而如果在这个天数后还是没有变更密码，呵呵！那么您的账号就失效了！无法登入！
			</li><br>
		<li><span class="text_import1">账号失效日期</span>：这个日期跟第三个字段一样，都是使用 1970 
			年以来的总日数设定。这个字段表示：
			<span class="text_import2">这个账号在此字段规定的日期之后，将无法再使用</span>。
			这个字段会被使用通常应该是在『收费服务』的系统中，
			你可以规定一个日期让该账号不能再使用啦！</li><br>
		<li><span class="text_import1">保留</span>：最后一个字段是保留的，看以后有没有新功能加入。</li>
		</ol>

		举个例子来说好了，假如我的 dmtsai 这个用户的密码栏如下所示：<br>

<table class="term"><tbody><tr><td class="term"><pre>dmtsai:$1$8zdAKdfC$XDa8eSus2I7nQL7UjRsIy/:13025:5:60:7:2:13125:
</pre></td></tr></tbody></table>

		这表示什么呢？要注意的是， 13025 是 2005/08/30 ，所以， dmtsai 这个用户他的密码相关意义是：<ul>
		<li>最近一次更动密码的日期是 2005/08/30 (13025)；
		</li><li>能够修改密码的时间是 5 天以后，也就是 2005/09/04 以前 dmtsai 不能修改自己的密码；
			如果使用者还是尝试要更动自己的密码，系统就会出现这样的讯息：<br>
<table class="term"><tbody><tr><td class="term"><pre>You must wait longer to change your password
passwd: Authentication token manipulation error
</pre></td></tr></tbody></table>
		</li><li>使用者必须要在 2005/09/04 到 2005/10/29 之间的 60 天限制内去修改自己的密码，若 
			2005/10/29 之后还是没有变更密码时，该账号就会宣告失效；
		</li><li>如果用户一直没有更改密码，那么在 2005/10/29 之前的 7 天内，系统会警告 dmtsai 
			应该修改密码的相关信息；例如当 dmtsai 登入时，系统会主动提示如下的信息：<br>
<table class="term"><tbody><tr><td class="term"><pre>Warning: your password will expire in 5 days
</pre></td></tr></tbody></table>
		</li><li>如果该账号一直到 2005/10/29 都没有更改密码，由于还有两天的恕限时间，因此， dmtsai 
			还是可以在 2005/10/31 以前继续登入；
		</li><li>如果使用者在 2005/10/29 以前变更过密码，那么那个 13025 的日期就会跟着改变，因此，
			所有的限制日期也会跟着相对变动喔！^_^
		</li><li>无论使用者如何动作，到了 13125 ，大约是 2005/12/8 左右，该账号就失效了～</li></ul>

		透过这样的说明，您应该会比较容易理解了吧？！ ^_^

		<div style="padding: 10pt 0pt;" align="right"><table width="90%"><tbody><tr><td><b>Tips:</b><br><span style="color: rgb(0, 144, 0);"><font size="-1">		常常听到：我的密码忘记或者被更动了？怎么办？<br><br>
		有的时候会发生这样的情况，就是说，你的 root 密码忘记了！要怎么办？重新安装吗？另外，
		有的时候是被入侵了， root 的密码被更动过，该如何是好？<br><br>
		这个时候就必须要使用到 /etc/shadow 这个数据了！我们刚刚知道密码是存在这个档案中的，
		所以只要你能够以各种可行的方法开机进入 Linux ，例如单人维护模式，或者是以 live CD (KNOPPIX)
		来进入 Linux 系统。之后，将硬盘顺利挂载，然后进入 /etc/shadow 这个档案中，将 root 
		的密码这一栏全部清空！然后再登入 Linux 一次，这个时候 root 将不需要密码 
		(有的时候需要输入空格符) 就可以登入了！这个时候请赶快以 passwd 设定 root 密码即可。
		</font></span></td><td><img src="0410accountmanager-fc4_files/vbird_face.gif" alt="鸟哥的图示" title="鸟哥的图示"></td></tr></tbody></table></div>		</div>
	</div>

	<hr><a name="account_group"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">关于群组：
	有效与初始群组、groups, newgrp</span>
	<div class="block2">
		认识了账号相关的两个档案 /etc/passwd 与 /etc/shadow 之后，您或许还是会觉得奇怪，
		那么群组的配置文件在哪里？还有，在 /etc/passwd 的第四栏不是所谓的 GID 吗？那又是啥？
		呵呵～此时就需要了解 /etc/group 与 /etc/gshadow 啰～<br><br>

		<hr><li><span class="text_import1">/etc/group</span></li>
		<div class="block2">
		这个档案就是在记录 GID 与组名的对应了～我的 /etc/group 内容有点像这样：<br>

<table class="term"><tbody><tr><td class="term"><pre>root:x:0:root
bin:x:1:root,bin,daemon
daemon:x:2:root,bin,daemon
sys:x:3:root,bin,adm
</pre></td></tr></tbody></table>

		也是以冒号『:』作为字段的分隔符，共分为四栏，每一字段的意义是：<ol>
		<li><span class="text_import1">组名</span>：就是组名啦！</li><br>
		<li><span class="text_import1">群组密码</span>：通常不需要设定，因为我们很少使用到群组登入！
			不过，同样的，密码也是被纪录在 /etc/gshadow 当中啰！</li><br>
		<li><span class="text_import1">GID</span>：就是群组的 ID 啊～</li><br>
		<li><span class="text_import1">支持的账号名称</span>：加入这个群组里面的所有的账号，
			我们知道，一个使用者是可以加入多个群组的。举例来说，如果我想要让 dmtsai 
			也加入 root 这个群组，那么在第一行的最后面加上『,dmtsai』，注意不要有空格，
			使成为『 root:x:0:root,dmtsai』就可以啰～</li></ol>

		比较重要的特色在于第四栏啦，因为每个使用者都可以拥有多个支持的群组，
		这就好比在学校念书的时候，我们可以加入多个社团一样！ ^_^。
		不过这里您或许会觉得奇怪的，那就是：『<span class="text_import2">假如我同时加入多个群组，
		那么我在作业的时候，到底是以那个群组为准？</span>』底下我们就来谈一谈这个『有效群组』的概念。<br><br>
		</div>

		<hr><a name="account_group_init"></a><li><span class="text_import1">有效群组(effective 
		group)与初始群组(initial group)</span></li>
		<div class="block2">
		还记得每个使用者在他的 /etc/passwd 里面的第四栏有所谓的 GID 吧？那个 GID 就是所谓的『初始群组 (
		initial group ) 』了！也就是说，当用户一登入系统，立刻就拥有这个群组的相关权限的意思。
		举例来说，我们上面提到 dmtsai 这个使用者的 /etc/passwd 与 /etc/group 还有 /etc/gshadow 
		相关的内容如下：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">grep dmtsai /etc/passwd /etc/group /etc/gshadow</span>
/etc/passwd:dmtsai:x:501:501::/home/dmtsai:/bin/bash
/etc/group:users:x:100:dmtsai
/etc/group:dmtsai:x:501:
/etc/gshadow:users:::dmtsai
/etc/gshadow:dmtsai:!::
</pre></td></tr></tbody></table>

		仔细看到上面这个表格，在 /etc/passwd 里面，dmtsai 这个使用者所属的群组为 GID=501 ，
		也就是 /etc/group 里头 dmtsai 那个群组啦～因为这是 initial group ，所以，
		使用者一登入就会主动取得，不需要在 /etc/group 的第四个字段写入该账号的！<br><br>

		但是非 initial group 的其他群组可就不同了。举上面这个例子来说，我将 dmtsai 加入 users
		这个群组当中，由于 users 这个群组并非是 dmtsai 的初始群组，因此，
		我必须要在 /etc/group 这个档案中，找到 users 那一行，并且将 dmtsai 这个账号加入第四栏，
		这样 dmtsai 才能够支持 users 这个群组啊。<br><br>

		那么在这个例子当中，因为我的 dmtsai 这个账号同时支持 dmtsai 与 users 这两个群组，
		因此，在读取/写入/执行档案时，针对群组部分，只要是 users 与 dmtsai 这两个群组拥有的功能，
		我 dmtsai 这个使用者都能够拥有喔！这样瞭呼？不过，这是针对已经存在的档案而言，
		如果今天我要建立一个新的档案或者是新的目录，请问一下，新档案的群组是 dmtsai 还是 users ？
		呵呵！这就得要检查一下当时的有效群组了 (effective group)。<br><br>

		<a name="groups"></a>如果我以 dmtsai 这个使用者的身份登入后，该如何知道我所有支持的群组呢？
		很简单啊，直接输入 groups 就可以了！注意喔，是 groups 有加 s 呢！结果像这样：<br>

<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@linux ~]$ <span class="term_command">groups</span>
dmtsai users
</pre></td></tr></tbody></table>

		在这个输出的讯息中，我知道我同时属于 dmtsai 及 users 这个两个群组，而且，
		<span class="text_import2">第一个输出的群组即为有效群组 (effective group) 了</span>。
		也就是说，我的有效群组为 dmtsai 啦～此时，如果我以 touch 去建立一个新档，例如：
		touch test ，那么这个档案的拥有者为 dmtsai ，而且群组也是 dmtsai 的啦。
		这样是否可以了解什么是有效群组了？<br><br>

		<a name="newgrp"></a>那么如何变更有效群组呢？这个有两个方法，不论是那个方法，都是以 newgrp 达成的！
		以上面这个例子来说，因为我的 dmtsai 使用者同时拥有 dmtsai 与 users 两个群组，因此，
		dmtsai 当然可以随时切换 dmtsai/users 成为有效群组啰。所以，我可以下达：<br>

<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@linux ~]$ <span class="term_command">newgrp users</span>
[dmtsai@linux ~]$ <span class="term_command">groups</span>
users dmtsai
</pre></td></tr></tbody></table>

		此时，我的有效群组就成为 users 了。当然，要能够顺利切换有效群组的话，还需要
		/etc/gshadow 的辅助才行～这个等一下我们会说明的。好了，那么如果你开始在 /home/dmtsai 
		这个家目录底下尝试建立一个档案，例如『 touch test2 』好了，会发生什么状态呢？
		呵呵！那个档案的群组竟然变成 users 了！这样更清楚有效群组的意义了吧？！<br><br>

		我们额外的来讨论一下 newgrp 这个指令，这个指令可以变更目前用户的有效群组，
		而且是另外以一个 shell 来提供登入的喔，所以，以上面的例子来说，
		dmtsai 这个使用者目前是以另一个 shell 登入的，而且新的 shell 给予 dmtsai 有效 GID 为
		users 就是了。当直接执行『 newgrp groupname 』时，使用者的有效群组会成为 groupname ，
		此时虽然使用者的环境设定(例如环境变量等等其他数据)不会有影响，但是使用者的『权限』将会重新被计算。
		举例来说， dmtsai 此时建立的新档案群组是 users 了～<br><br>

		鸟哥的这个例子当中，要注意的是， dmtsai 这个使用者本来就属于 users 与 dmtsai 这两个群组，
		所以他可以直接使用 newgrp 来切换有效群组，而要离开新的有效群组时，输入『 exit 』即可。
		假设我的 Linux 系统当中还有另一个群组，名称为 vbird，那么 dmtsai 是否可以登入 vbird 这个群组？
		在某些前提下是可以的：<ul><span class="text_import2">
		<li>vbird 这个群组在 /etc/gshadow 的密码栏为合法的(不具有 ! 开头！)；
		</li><li>dmtsai 必须让 root 或群组管理员 (group administrator) 加入到 vbird 群组中。</li></span></ul>
		这两个大前提缺一不可喔！好了，假设我已经使用 gpasswd 建立了 vbird 这个群组的密码，
		而 dmtsai 也被加入群组成员当中了，那么当 dmtsai 输入 『newgrp vbird』时，
		嘿嘿！ dmtsai 这个使用者的有效群组就能够变成 vbird 啰～
		</div>

		<hr><li><span class="text_import1">/etc/gshadow</span></li>
		<div class="block2">
		刚刚讲了很多关于『有效群组』的概念，另外，也提到 newgrp 这个指令的用法，
		但是，如果 /etc/gshadow 这个设定没有搞懂得话，那么 newgrp 是无法动作的呢！
		我的 /etc/gshadow 的内容有点像这样：<br>

<table class="term"><tbody><tr><td class="term"><pre>root:::root
bin:::root,bin,daemon
daemon:::root,bin,daemon
sys:::root,bin,adm
</pre></td></tr></tbody></table>

		同样还是使用冒号『:』来作为字段的分隔字符，而且你会发现，这个档案几乎与 /etc/group 
		一模一样啊！是这样没错～不过，要注意的大概就是第二个字段吧～第二个字段是密码栏，
		如果密码栏上面是『!』时，表示该群组不能使用密码来登入呢！
		至于第四个字段也就是支持的账号名称啰～<ol><span class="text_import2">
		<li>组名
		</li><li>密码栏，同样的，开头为 ! 表示无法登入；
		</li><li>群组管理员的账号 (相关信息在后续介绍)
		</li><li>该群组的所属账号 (与 /etc/group 内容相同！)</li></span></ol>

		不过，就以系统的操作来说，事实上，这个 /etc/gshadow 的密码提供，最大的功能是在于『
		<span class="text_import2">让那些不在群组中的成员，临时加入该群组用的。</span> 』
		实际上使用的情况是很少的～而如果真的要操作这样的环境，那就得要熟悉 newgrp 的用法啰！
		而且还要提供某个群组的密码出来，真是不好管理。所以，若真的想要让某个使用者利用该群组的功能时，
		还是直接将对方加入群组的支持就好了！省得麻烦～
		</div>
	</div>
</div>


<hr><a name="users"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">账号管理</span><br>
<div class="block1">
	好啦！既然要管理账号，当然是由新增与移除使用者开始的啰～底下我们就分别来谈一谈如何新增、
	移除与更改用户的相关信息吧～<br><br>

	<hr><a name="users_adduser"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">新增与移除使用者： 
	useradd, 相关配置文件, passwd, usermod, userdel</span><br>
	<div class="block2">
		要如何在 Linux 的系统新增一个用户啊？呵呵～真是太简单了～直接利用 useradd 这个指令即可！
		他的指令下达方法如下：<br><br>

		<a name="useradd"></a><hr><li><span class="text_import1">useradd</span></li>
		<div class="block2">

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">useradd [-u UID] [-g initial_group] [-G other_group] \</span>
&gt; <span class="term_command"> -[Mm] [-c 说明栏] [-d home] [-s shell] username</span>
<span class="term_say">参数：
-u  ：后面接的是 UID ，是一组数字。直接指定一个特定的 UID 给这个账号；
-g  ：后面接的那个组名就是我们上面提到的 initial group 啦～
      该 group ID (GID) 会被放置到 /etc/passwd 的第四个字段内。
-G  ：后面接的组名则是这个账号还可以支持的群组。
      这个参数会修改 /etc/group 内的相关资料喔！
-M  ：强制！不要建立用户家目录
-m  ：强制！要建立用户家目录！
-c  ：这个就是 /etc/passwd 的第五栏的说明内容啦～可以随便我们设定的啦～
-d  ：指定某个目录成为家目录，而不要使用默认值；
-r  ：建立一个系统的账号，这个账号的 UID 会有限制 (/etc/login.defs)
-s  ：后面接一个 shell ，预设是 /bin/bash 的啦～
范例：</span>

<span class="term_hd">范例一：完全参考默认值建立一个用户，名称为 vbird1</span>
[root@linux ~]# <span class="term_command">useradd vbird1</span>
[root@linux ~]# <span class="term_command">ls -l /home</span>
drwxr-xr-x   3 vbird1 vbird1 4096 Aug 30 17:33 vbird1
[root@linux ~]# <span class="term_command">grep vbird1 /etc/passwd /etc/shadow /etc/group</span>
/etc/passwd:vbird1:x:502:502::/home/vbird1:/bin/bash
/etc/shadow:vbird1:!!:13025:0:99999:7:::
/etc/group:vbird1:x:502:
<span class="term_say"># 做这个范例只是想要让您了解，其实系统已经规范好了一些新增使用者时的参数了！
# 因此，当我们使用 useradd 时，系统会主动的去修改 /etc/passwd 与 /etc/shadow，
# 而这两个档案内的相关字段参考值，则会以一些配置文件的内容来规范喔！
# 同时也要注意到，使用 useradd 新增使用者时，这个使用者的 /etc/shadow
# 密码栏会是不可登入的 (以 !! 为开头)，因此还需要使用 passwd 
# 来给予 vbird1 密码后，才算新增完毕！</span>

<span class="term_hd">范例二：我知道我的系统当中有个组名为 users ，且 UID 700 并不存在，
        请用这两个参数给予 vbird2 建立一个账号！</span>
[root@linux ~]# <span class="term_command">useradd -u 700 -g users vbird2</span>
[root@linux ~]# <span class="term_command">ls -l /home</span>
drwxr-xr-x   3 vbird2 <span class="term_write">users</span>  4096 Aug 30 17:43 vbird2
[root@linux ~]# <span class="term_command">grep vbird2 /etc/passwd /etc/shadow /etc/group</span>
/etc/passwd:vbird2:x:<span class="term_write">700:100</span>::/home/vbird2:/bin/bash
/etc/shadow:vbird2:!!:13025:0:99999:7:::
<span class="term_say"># 看一下，UID 与 initial group 确实改变成我们需要的了！</span>

<span class="term_hd">范例三：建立一个系统账号，名称为 vbird3</span>
[root@linux ~]# <span class="term_command">useradd -r vbird3</span>
[root@linux ~]# <span class="term_command">grep vbird3 /etc/passwd /etc/shadow /etc/group</span>
/etc/passwd:vbird3:x:<span class="term_write">101:102</span>::/home/vbird3:/bin/bash
/etc/shadow:vbird3:!!:13025::::::
/etc/group:vbird3:x:102:
<span class="term_say"># 很重要喔！您会发现， UID 竟然是 101 ，而 GID 怎么会是 102，
# 并且与 /etc/group 有对应的关系喔！有没有加 -r 差很多ㄟ！</span>
</pre></td></tr></tbody></table>

			我的天吶！这个指令更动的档案怎么怎么多啊？对啊！你才知道啊～
			这也是为啥我们说账号管理是很复杂的啦～而且他参考的配置文件才更多哩！
			这个指令至少可能会更动到的地方有：<ul><span class="text_import2"><font face="细明体">
			<li>/etc/passwd</li><li>/etc/shadow</li><li>/etc/group</li><li>/etc/gshadow</li><li>/home/username
			</li></font></span></ul><font face="细明体"></font>
			那请教一下，您有没有想过，以上述的第一个范例一好了，为何 useradd vbird1 
			他会主动在 /home/vbird1 建立起用户的家目录？家目录内有什么数据且来自哪里？
			为何预设使用的是 /bin/bash 这个 shell ？呵呵！这就得要说明一下 useradd 
			所使用的参考档案啰！<br><br>
		</div>

		<a name="users_adduser_env"></a><hr><li><span class="text_import1">相关配置文件</span></li>
		<div class="block2">
		我们使用 useradd 去新增使用者时，一些在 /etc/passwd 当中的值会去参考『
		<span class="text_import2"><font face="细明体">/etc/default/useradd</font></span> 』
		，这个档案的内容有点像这样：<br>

<table class="term"><tbody><tr><td class="term"><pre>GROUP=100		<span class="term_note">&lt;==预设的群组</span>
HOME=/home		<span class="term_note">&lt;==默认的家目录所在目录</span>
INACTIVE=-1		<span class="term_note">&lt;==在 /etc/shadow 内的第 7 栏</span>
EXPIRE=			<span class="term_note">&lt;==在 /etc/shadow 内的第 8 栏</span>
SHELL=/bin/bash		<span class="term_note">&lt;==预设的 shell</span>
SKEL=/etc/skel		<span class="term_note">&lt;==用户家目录的内容数据参考目录</span>
</pre></td></tr></tbody></table><br>

		<span class="text_import1">关于群组的建立机制：</span><br><br>
		当我们直接使用 useradd 来新增账号时，在预设的情况下，相关的信息都是参考 
		/etc/default/useradd 这个档案内容的设定的。不过，对于使用者群组的建立机制中，
		则有两种不一样的机制存在的：<ul><span class="text_import2">
		<li>以 FC4 为代表，新建使用者时，若无指定 initial group ，
			则系统会主动建立一个与账号相同的组名，以该群组作为使用者的 initial group；</li><br>
		<li>以 SuSE 9 为代表，新建使用者时，预设不会建立新群组，而以 /etc/default/useradd
			内的 GROUP 设定值作为使用者的 initial group 。</li></span></ul>
		这应该是很容易理解才是～如果看不懂，请回去前一小节查阅一下 /etc/passwd, /etc/shadow 
		的相关内容架构。<br><br>

		<span class="text_import1">关于用户家目录的参考：/etc/skel/*</span><br><br>
		在这个档案当中，比较奇怪的是 SKEL 这个玩意儿了，他是啥？
		其实，这个咚咚就是用户家目录的参考目录啰～举我们的范例一为例，我利用 useradd vbird1 
		时，他在 /home/vbird1 这个用户家目录内的各项数据，都是由 /etc/skel 
		所复制过去的～所以呢，未来如果我想要让新增使用者时，该用户的环境变量 ~/.bashrc 
		就设定妥当的话，您可以到 /etc/skel/.bashrc 去编辑一下，也可以建立 
		/etc/skel/public_html 这个目录，那么未来新增使用者后，在他的家目录下就会有 public_html 
		那个目录了！这样瞭呼？<br><br>

		<span class="text_import1">关于使用者 UID/GID 的设定：</span><br><br>
		另外，与密码还有 UID/GID 有关的配置文件则是在 /etc/login.defs 里面，
		这个档案有点像这样：<br>

<table class="term"><tbody><tr><td class="term"><pre>MAIL_DIR        /var/spool/mail	<span class="term_note">&lt;==用户默认邮件信箱放置目录</span>

PASS_MAX_DAYS   99999		<span class="term_note">&lt;==/etc/shadow 内的第 5 栏</span>
PASS_MIN_DAYS   0		<span class="term_note">&lt;==/etc/shadow 内的第 4 栏</span>
PASS_MIN_LEN    5		<span class="term_note">&lt;==密码最短的字符长度，建议可以改到 6 以上</span>
PASS_WARN_AGE   7		<span class="term_note">&lt;==/etc/shadow 内的第 6 栏</span>

UID_MIN         500	<span class="term_note">&lt;==使用者最小的 UID，意即小于 500 的 UID 为系统保留</span>
UID_MAX       60000	<span class="term_note">&lt;==使用者能够用的最大 UID</span>
GID_MIN         500	<span class="term_note">&lt;==使用者自定义组的最小 GID，小于 500 为系统保留</span>
GID_MAX       60000	<span class="term_note">&lt;==使用者自定义组的最大 GID</span>

CREATE_HOME     yes	<span class="term_note">&lt;==在不加 -M 及 -m 时，是否主动建立用户家目录？</span>
</pre></td></tr></tbody></table>

		看到这个档案后，您应该晓得的是，为何新建的使用者的 UID 都会大于 500 了吧？
		而且某些版本的 distributions (例如 SuSE server 9) 则是将 UID_MIN 设定为 1000 ，
		所以，他的一般身份使用者的 UID 就会从 1000 起跳啰～这样了解吗？！<br><br>

		那如果我现在新增一个使用者，这个使用者的 UID 会是多少？答案是：『
		<span class="text_import2">如果 /etc/passwd 里面的账号所属的 UID 没有大于 
		/etc/login.defs 里头的 UID_MIN (在本例中是 500)时，则以 UID 500 来作为一个新账号的 UID。
		如果 /etc/passwd 已有大于 500 以上的 UID 时，则取 /etc/passwd 内最大的那个 UID + 1 
		作为新设帐号的 UID。</span>』而如果我是想要建立系统用的账号，所以使用 useradd -r sysaccount
		这个 -r 的参数时，就会找『比 500 小的最大的那个 UID + 1 』就是了。 ^_^<br><br>

		<span class="text_import1">关于家目录默认是否建立：</span><br><br>
		另外也要注意那个 CREATE_HOME 的设定值，这个设定值也很重要。一般来说，在 FC4 的环境下，
		我们使用 useradd useraccount 时，预设是会主动的建立家目录的，除非使用 -M 这个参数～
		至于 SuSE server 9 这个版本来说，嘿嘿！他默认是不建立家目录的，除非使用 -m 这个参数呢！
		因此，在这里鸟哥也要建议您，如果肯定要建立家目录的话，不论在那个版本，
		你最好还是加上 -m 这个参数来强制建立家目录吧！ ^_^<br><br>

		那么您就能知道啰， useradd 这支程序在建立 Linux 上的账号时，至少会参考：
		<ul><span class="text_import2"><font face="细明体">
		<li>/etc/default/useradd
		</li><li>/etc/login.defs
		</li><li>/etc/skel/*</li></font></span></ul><font face="细明体"></font>
		这些档案，不过，最重要的其实是建立 /etc/passwd, /etc/shadow, /etc/group, /etc/gshadow 
		还有用户家目录就是了～所以，如果您了解整个系统运作的状态，
		也是可以手动直接修改这几个档案就是了。<br><br>
		</div>

		<a name="users_adduser_pw"></a><hr><li><span class="text_import1">passwd</span></li>
		<div class="block2">
		刚刚我们讲到了，使用 useradd 建立了账号之后，在预设的情况下，该账号是暂时被封锁的，
		也就是说，该账号是无法登入的，你可以去瞧一瞧 /etc/shadow 内的第二个字段就晓得啰～
		那该如何是好？怕什么？直接给他设定新密码就好了嘛！对吧～设定密码就使用 passwd 啰！<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">passwd [useraccount]</span>

<span class="term_hd">范例一：如果 root 要帮 dmtsai 修改密码时？</span>
[root@linux ~]# <span class="term_command">passwd dmtsai</span>
Changing password for user dmtsai.
New UNIX password:  <span class="term_note">&lt;==这里直接输入新的密码，屏幕不会有任何反应</span>
BAD PASSWORD: it is based on a dictionary word  <span class="term_note">&lt;==密码太简单时的错误！</span>
Retype new UNIX password:  <span class="term_note">&lt;==再输入一次同样的密码</span>
passwd: all authentication tokens updated <span class="term_write">successfully</span>.  <span class="term_note">&lt;==竟然还是成功修改了！</span>

<span class="term_hd">范例二： dmtsai 这个用户想要修改自己的密码时</span>
[dmtsai@linux ~]$ <span class="term_command">passwd</span>
Changing password for user dmtsai.
Changing password for dmtsai
(current) UNIX password: <span class="term_note">&lt;==这里输入『原有的旧密码』</span>
New password: <span class="term_note">&lt;==这里输入新密码</span>
BAD PASSWORD: it is based on your username <span class="term_note">&lt;==密码的规范是很严格的</span>
New password:
BAD PASSWORD: it is based on your username
New password:
BAD PASSWORD: it is based on a dictionary word
passwd: Authentication token manipulation <span class="term_write">error</span>
</pre></td></tr></tbody></table>

		先来谈一谈上面的两个范例。要注意的是， passwd 这个指令由于用户的身份而有两种用法，
		如果是 root ，由于 root 具有至高无上的权力，所以 root 可以利用 passwd [username] 
		来帮用户修改他们的密码！因此，『<span class="text_import2">如果用户的密码不见了，
		root 是可以帮他们进行密码的修改，而不需要知道旧密码。</span>』另外，也只有 root 
		可以随便设定密码，即使该密码并不符合系统的密码验证要求～ @_@。例如上面的范例一，
		我帮 dmtsai 建立的密码太简单，所以其实系统是『警告』过 root 的。
		但在重复输入两次密码后，嘿嘿！您还是会看到 successfully 这个成功的字样呢！<br><br>

		那么如果是一般身份使用者，或者是 root 想要修改自己的密码时，直接输入『 passwd 』，
		就能够修改自己的密码了。一般身份用户输入的密码会经过系统的验证，
		验证的机制除了 /etc/login.defs 里头规定的最小密码字符数之外，还会受到
		/etc/pam.d/passwd 这个 PAM 模块的检验呢！一般来说，您输入的密码最好要符合底下的要求：
		<ul><span class="text_import2">
		<li>密码不能与账号相同；
		</li><li>密码尽量不要选用字典里面会出现的字符串；
		</li><li>密码需要超过 8 个字符；</li></span></ul>

		如果无法经过验证，那么该密码就不被接受，当然还是只能使用旧密码啰！
		此外，仅能接受三次密码输入，如果输入的密码都不被接受，那只好....重新执行一次 passwd 啊！而，
		经过这个 passwd [username] 的动作后，您的账号就会有密码啰，此时，
		如果察看一下 /etc/shadow ，你就会知道密码内容被改过啰～ ^_^<br><br>
		</div>

		<a name="usermod"></a><hr><li><span class="text_import1">usermod</span></li>
		<div class="block2">
		所谓这『人有失手，马有乱蹄』，您说是吧？所以啰，当然有的时候会『不小心』在 useradd 
		的时候加入了错误的设定数据。或者是，在使用 useradd 后，发现某些地方还可以进行细部修改。
		此时，当然我们可以直接到 /etc/passwd 或 /etc/shadow 去修改相对应字段的数据，
		不过，Linux 也有提供相关的指令让大家来进行账号相关数据的微调呢～那就是 usermod 啰～<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">usermod [-cdegGlsuLU] username</span>
<span class="term_say">参数：
-c  ：后面接账号的说明，即 /etc/passwd 第五栏的说明栏，可以加入一些账号的说明。
-d  ：后面接账号的家目录，即修改 /etc/passwd 的第六栏；
-e  ：后面接日期，格式是 YYYY-MM-DD 也就是在 /etc/shadow 内的第八个字段数据啦！
-g  ：后面接 group name，修改 /etc/passwd 的第四个字段，亦即是 GID 的字段！
-G  ：后面接 group name，修改这个使用者能够支持的群组，修改的是 /etc/group 啰～
-l  ：后面接账号名称。亦即是修改账号名称， /etc/passwd 的第一栏！
-s  ：后面接 Shell 的实际档案，例如 /bin/bash 或 /bin/csh 等等。
-u  ：后面接 UID 数字啦！即 /etc/passwd 第三栏的资料；
-L  ：暂时将用户的密码冻结，让他无法登入。其实仅改 /etc/shadow 的密码栏。
-U  ：将 /etc/shadow 密码栏的 ! 拿掉，解冻啦！
范例：</span>

<span class="term_hd">范例一：修改使用者 dmtsai 的说明栏，加上『VBird's test』的说明。</span>
[root@linux ~]# <span class="term_command">usermod -c "VBird's test" dmtsai</span>
[root@linux ~]# <span class="term_command">grep dmtsai /etc/passwd</span>
dmtsai:x:501:501:<span class="term_write">VBird's test</span>:/home/dmtsai:/bin/bash

<span class="term_hd">范例二：用户 dmtsai 密码在 2006/01/01 失效。</span>
[root@linux ~]# <span class="term_command">usermod -e "2006-01-01" dmtsai</span>
[root@linux ~]# <span class="term_command">grep dmtsai /etc/shadow</span>
dmtsai:$1$24ISJM4K$bbdijdreoieaVaBMAHsm6.:13026:0:99999:7::<span class="term_write">13149</span>:

<span class="term_hd">范例三：暂时冻结 dmtsai 的密码！</span>
[root@linux ~]# <span class="term_command">usermod -L dmtsai</span>
[root@linux ~]# <span class="term_command">grep dmtsai /etc/shadow</span>
dmtsai:<span class="term_write">!</span>$1$24ISJM4K$bbdijdreoieaVaBMAHsm6.:13026:0:99999:7::13149:
<span class="term_say"># 注意到，密码栏(第二栏)多了一个 ! 号！那个惊叹号会让密码无效喔！</span>
[root@linux ~]# <span class="term_command">usermod -U dmtsai</span>  <span class="term_note">&lt;==这样就解开了！</span>

<span class="term_hd">范例四：万一 dmtsai 这个家伙被建立时忘记建立家目录，该如何是好？</span>
[root@linux ~]# <span class="term_command">usermod -d /home/dmtsai2 -m dmtsai</span>
<span class="term_say"># 如果仅是 -d /home/dmtsai2 表示仅修改 /etc/passwd 第六栏的内容而已，
# 如果加上 -m 这个参数，则表示新建一个家目录的意思！
# 另外，如果原本的家目录是 /home/dmtsai ，那 -d /home/dmtsai2 -m
# 会将原本的 /home/dmtsai 更名为 /home/dmtsai2 喔！</span>
</pre></td></tr></tbody></table>

		usermod 是系统管理员 root 用来管理账号身份的相关数据的，不过，这个 usermod 
		程序的功能其实也被很多其他的指令所取代喔！例如 chfn 与 chsh 等等的～
		不过，无论如何，您还是可以用 usermod 来微调用户账号的相关资料啦！<br><br>
		</div>

		<a name="userdel"></a><hr><li><span class="text_import1">userdel</span></li>
		<div class="block2">
		这个功能就太简单了～目的在删除使用者啦～与他相关的档案有：
		<ul><span class="text_import2"><font face="细明体">
		<li>/etc/passwd</li><li>/etc/shadow</li><li>/home/username</li></font></span></ul><font face="细明体"></font>
		整个指令的语法是：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">userdel [-r] username</span>
<span class="term_say">参数：
-r  ：连同用户的家目录也一起删除
范例：</span>

<span class="term_hd">范例一：删除 vbird2 ，连同家目录一起删除</span>
[root@linux ~]# <span class="term_command">userdel -r vbird2</span>
</pre></td></tr></tbody></table>

		这个指令下达的时候要小心了！通常我们要移除一个账号的时候，你可以手动的将 
		/etc/passwd 与 /etc/shadow 里头的该账号取消即可！一般而言，如果该账号只是『
		<span class="text_import2">暂时不启用</span>』的话，那么将 /etc/shadow 
		里头最后倒数一个字段设定为 0 就可以让该账号无法使用，但是所有跟该账号相关的数据都会留下来！
		使用 userdel 的时机通常是『
		<span class="text_import2">你真的确定不要让该用户在主机上面使用任何数据了</span>！』<br><br>

		另外，其实用户如果在系统上面操作过一阵子了，那么该用户其实在系统内可能会含有其他档案的。
		举例来说，他的邮件信箱 (mail box) 或者是例行性命令 (crontab) 之类的档案。
		所以，如果想要完整的将某个账号完整的移除，最好可以在下达 userdel -r username 之前，
		先以『 find / -user username 』查出整个系统内属于 username 的档案，
		然后再加以删除吧！<br>
		</div>
	</div>

	<hr><a name="normal_user"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">用户功能：chfn, chsh</span><br>
	<div class="block2">
		不论是 useradd/usermod/userdel ，都是系统管理员所能够使用的指令，
		如果我是一般身份使用者，那么我是否除了密码之外，就无法更改其他的数据呢？
		当然不是啦！这里我们介绍两个一般身份用户常用的账号数据变更指令啰！<br><br>

		<a name="chsh"></a><hr><li><span class="text_import1">chsh</span></li>
		<div class="block2">

<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@linux ~]$ <span class="term_command">chsh [-ls]</span>
<span class="term_say">参数：
-l  ：列出目前系统上面可用的 shell ，其实就是 /etc/shells 的内容！
-s  ：设定修改自己的 Shell 啰
范例：</span>

<span class="term_hd">范例一：列出目前系统上面所以的 shell ，并且指定 csh 为自己的 shell</span>
[dmtsai@linux ~]$ <span class="term_command">chsh -l</span>
/bin/sh
/bin/bash
/sbin/nologin
/bin/ksh
/bin/tcsh
/bin/csh
/bin/zsh
[dmtsai@linux ~]$ <span class="term_command">chsh -s /bin/csh; grep dmtsai /etc/passwd</span>
Password:  <span class="term_note">&lt;==为了防止账号被乱搞～所以需要输入 dmtsai 的密码确认！</span>
Shell changed.
dmtsai:x:501:501::/home/dmtsai:<span class="term_write">/bin/csh</span>
</pre></td></tr></tbody></table>

		这个指令重点就是在更改用户的 shell 啰～如上所述，我就可以修订好 dmtsai 的 shell 啦！<br><br>
		</div>

		<a name="chfn"></a><hr><li><span class="text_import1">chfn</span></li>
		<div class="block2">
<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">chfn [-foph] </span>
<span class="term_say">参数：
-f  ：后面接完整的大名；
-o  ：您办公室的房间号码；
-p  ：办公室的电话号码；
-h  ：家里的电话号码！
范例：</span>

<span class="term_hd">范例一：我用 dmtsai 这个使用者来更改一下自己的相关信息！</span>
[dmtsai@linux ~]$ <span class="term_command">chfn</span>
Changing finger information for dmtsai.
Password: <span class="term_note">&lt;==为了防止账号被乱搞～所以需要输入 dmtsai 的密码确认！</span>
Name []: <span class="term_write">VBird' Test account</span>
Office []: <span class="term_write">Tainan office 1</span>
Office Phone []: <span class="term_write">06-1234567</span>
Home Phone []: <span class="term_write">06-7654321</span>

Finger information changed.
[dmtsai@linux ~]$ <span class="term_command">grep dmtsai /etc/passwd</span>
dmtsai:x:501:501:<span class="term_write">VBird' Test account,Tainan office 1,06-1234567,06-7654321</span>:
/home/dmtsai:/bin/bash
</pre></td></tr></tbody></table>

		这个指令说实在的，除非是你的主机有很多的用户，否则倒真是用不着这个程序！这就有点像是 bbs 
		里头更改你『个人属性』的那一个资料啦！这个程序主要都是搭配 finger 
		这支程序在运作的！不过，由于 finger 这支程序不是很安全，所以预设是没有安装他的！
		如果您想要玩一下 finger 的话，那么请先参考 RPM 套件安装内容后，在安装 finger 的 RPM 
		档案，然后再来玩吧！底下这里鸟哥还是先简单的介绍一下就好了！<br><br>

		使用 chfn 这个指令之后，程序会要求您输入许多的信息，包含了：<ul><span class="text_import2">
		<li>密码</li><li>昵称</li><li>办公室号码</li><li>办公室电话</li><li>家里电话</li></span></ul>
		不过，这些信息其实更改的都是原本的 /etc/passwd 里面的第五栏说明数据啦！
		每个信息中间都以逗号『,』分隔开来而已。如上所示， dmtsai 的说明栏救被更动过啰！ ^_^<br><br>
		</div>

		<a name="finger"></a><hr><li><span class="text_import1">finger</span></li>
		<div class="block2">
		finger 的中文字面意义是：『手指』，嘿嘿！这个 finger 可以查阅的数据可就多了！
		刚刚我们不是使用 chfn 来修改 dmtsai 这个用户的相关信息吗？那些个相关信息就可以利用
		finger 来查阅出来的！他的查询方法如下：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">finger [-s] username</span>
<span class="term_say">参数：
-s  ：使用长串数据输出格式。
范例：</span>

<span class="term_hd">范例一：将刚刚 dmtsai 建立的一些用户信息呼叫出来视察！</span>
[root@linux ~]# <span class="term_command">finger dmtsai</span>
Login: dmtsai                           Name: VBird's Test account
Directory: /home/dmtsai                 Shell: /bin/bash
Office: Tainan office 1, 06-1234567     Home Phone: 06-7654321
Last login Tue Aug 30 15:01 (CST) on tty1 from localhost
No mail.
No Plan.
</pre></td></tr></tbody></table>

		有趣吧！这个 finger 还可以用来查询别部主机的账号呢！不过，目前通常用在本机账号的查询。
		因为 finger 算是比较危险的指令，所以，有些 linux distributions 预设是不安装他的，
		不过，如果您按照鸟哥说明的方式来完全安装 FC4 的话，那就没有问题的啦！可以操作的。<br><br>

		不过，你或许会觉得有趣的是，怎么 finger 的结果最底下显示『No mail. No Plan.』呢？
		呵呵！ finger 会主动去 /var/spool/mail 查询看看有没有该账号的邮件信箱 (mailbox)，
		而且还会去查询 ~/.plan 那个档案，那就是计划档啦～比如说，我在 dmtsai 家目录底下建立
		.plan 这个档案，他的内容是『DmTsai will write something....』，结果使用 finger 时，
		嘿嘿！您可以自行看看结果会怎样啊！ ^_^<br><br>
		</div>

		<a name="id"></a><hr><li><span class="text_import1">id</span></li>
		<div class="block2">
		id 这个指令则可以查询某人或自己的相关 UID/GID 等等的信息，他的参数也不少，不过，
		都不需要记～反正使用 id 就全部都列出啰～ ^_^<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">id [username]</span>

<span class="term_hd">范例一：查阅自己的相关信息！</span>
[root@linux ~]# <span class="term_command">id</span>
uid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),4(adm),10(wheel)

<span class="term_hd">范例二：查阅一下 dmtsai 吧～</span>
[root@linux ~]# <span class="term_command">id dmtsai</span>
uid=501(dmtsai) gid=501(dmtsai) groups=501(dmtsai),100(users)
</pre></td></tr></tbody></table>

		再次强调一下，那个 groups 指的是目前该使用者所属的所有群组，但是您必须要了解什么是『
		<span class="text_import2">初始群组与有效群组</span> 』的差异喔！<br>
		</div>
	</div>

	<hr><a name="group_add"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">新增与移除群组</span><br>
	<div class="block2">
		OK！了解了账号的新增、删除、更动与查询后，再来我们可以聊一聊群组的相关内容了。
		基本上，群组的内容都与这两个档案有关：<ul><span class="text_import2">
		<li>/etc/group</li><li>/etc/gshadow</li></span></ul>

		群组的内容其实很简单，都是上面两个档案的新增、修改与移除而已，
		不过，如果再加上有效群组的概念，那么 newgrp 与 gpasswd 则不可不知呢！<br><br>

		<a name="groupadd"></a><hr><li><span class="text_import1">groupadd</span></li>
		<div class="block2">

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">groupadd [-g gid] [-r]</span>
<span class="term_say">参数：
-g  ：后面接某个特定的 GID ，用来直接给予某个 GID ～
-r  ：建立系统群组啦！与 /etc/login.defs 内的 GID_MIN 有关。
范例：</span>

<span class="term_hd">范例一：新建一个群组，名称为 group1</span>
[root@linux ~]# <span class="term_command">groupadd group1</span>
[root@linux ~]# <span class="term_command">grep group1 /etc/group /etc/gshadow</span>
/etc/group:group1:x:<span class="term_write">502</span>:
/etc/gshadow:group1:<span class="term_write">!</span>::
<span class="term_say"># 注意注意！在 /etc/gshadow 里面可以发现，密码是不许登入的喔！</span>

<span class="term_hd">范例二：新建一个系统群组，名称为 group2</span>
[root@linux ~]# <span class="term_command">groupadd -r group2</span>
[root@linux ~]# <span class="term_command">grep group2 /etc/group /etc/gshadow</span>
/etc/group:group2:x:<span class="term_write">101</span>:
/etc/gshadow:group2:!::
</pre></td></tr></tbody></table>

		了解 -r 有没有的差异了吗？！是的～结果会跟 /etc/login.defs 里面的设定有关喔！
		而且以 groupadd 新增的账号，默认都不能使用密码的方式登入的～
		也就是说，预设是私有群组，并无法使用 newgrp 来登入的呢！<br><br>
		</div>

		<a name="groupmod"></a><hr><li><span class="text_import1">groupmod</span></li>
		<div class="block2">
		跟 usermod 类似的，这个指令仅是在进行 group 相关参数的修改而已。<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">groupmod [-g gid] [-n group_name]</span>
<span class="term_say">参数：
-g  ：修改既有的 GID 数字；
-n  ：修改既有的组名
范例：</span>

<span class="term_hd">范例一：将刚刚上个指令建立的 group2 名称改为 groupname ， GID 为 103</span>
[root@linux ~]# <span class="term_command">groupmod -g 103 -n groupname group2</span>
[root@linux ~]# <span class="term_command">grep groupname /etc/group /etc/gshadow</span>
/etc/group:groupname:x:103:
/etc/gshadow:groupname:!::
</pre></td></tr></tbody></table>

		不过，还是那句老话，不要随意的更动 GID ，容易造成系统资源的错乱喔！<br><br>
		</div>

		<a name="groupdel"></a><hr><li><span class="text_import1">groupdel</span></li>
		<div class="block2">
		呼呼！ groupdel 自然就是在删除群组的啰～用法很简单：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">groupdel [groupname]</span>

<span class="term_hd">范例一：将刚刚的 groupname 删除！</span>
[root@linux ~]# <span class="term_command">groupdel groupname</span>

<span class="term_hd">范例二：若要删除 dmtsai 这个群组的话？？</span>
[root@linux ~]# <span class="term_command">groupdel dmtsai</span>
groupdel: cannot remove user's primary group.
</pre></td></tr></tbody></table>

		为什么 groupname 可以删除，但是 dmtsai 就不能删除呢？原因很简单，
		『<span class="text_import2">有某个账号 (/etc/passwd) 的 initial group 使用该群组！</span>』
		如果查阅一下，你会发现在 /etc/passwd 内的 dmtsai 第四栏的 GID 就是 /etc/group 内的 dmtsai
		那个群组的 GID ，所以啰，当然无法删除～否则 dmtsai 这个用户登入系统后，
		就会找不到 GID ，那可是会造成很大的困扰的！那么如果要删除 dmtsai 这个群组呢？
		你『<span class="text_import2">必须要确认 /etc/passwd 内的账号没有任何人使用该群组作为
		initial group </span>』才行喔！所以，你可以：<ul>
		<li>修改 dmtsai 的 GID ，或者是：
		</li><li>删除 dmtsai 这个使用者。</li></ul>
		</div>

		<a name="gpasswd"></a><hr><li><span class="text_import1">gpasswd</span></li>
		<div class="block2">
		除了设定群组之外，我们还可以针对系统上面有的群组进行一些『密码』的给予喔！
		这个密码给予之后，该群组就能够让某些人登入成为有效群组呢！挺有趣的。
		另外，如果系统管理员太忙了，无法针对每个群组来管理，那么『
		<span class="text_import2">系统管理员还可以将某位使用者设定成为该群组的团长喔</span>！』
		很有趣吧～虽然目前比较少人这么玩了，不过，鸟哥在这里还是跟大家介绍介绍吧！<br>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">关于系统管理员(root)做的动作：</span>
[root@linux ~]# <span class="term_command">gpasswd groupname</span>
[root@linux ~]# <span class="term_command">gpasswd [-A user1,...] [-M user3,user4...] groupname</span>
[root@linux ~]# <span class="term_command">gpasswd [-rR] groupname</span>
<span class="term_say">参数：
    ：若没有任何参数时，表示给予 groupname 一个密码(/etc/gshadow)
-A  ：将 groupname 的主控权交由后面的使用者管理(该群组的管理员)
-M  ：将某些账号加入这个群组当中！
-r  ：将 groupname 的密码移除
-R  ：让 groupname 的密码栏失效，所以 newgrp 就不能使用了！</span>

<span class="term_hd">关于群组管理员(Group administrator)做的动作：</span>
[someone@linux ~]$ <span class="term_command">gpasswd [-ad] user groupname</span>
<span class="term_say">参数：
-a  ：将某位使用者加入到 groupname 这个群组当中！
-d  ：将某位使用者移除出 groupname 这个群组当中。</span>

<span class="term_hd">范例一：建立一个新群组，名称为 testgroup 且群组交由 dmtsai 管理：</span>
[root@linux ~]# <span class="term_command">groupadd testgroup</span>
[root@linux ~]# <span class="term_command">gpasswd testgroup</span>
Changing the password for group testgroup
New Password:
Re-enter new password:
<span class="term_say"># 输入两次密码就对了！</span>
[root@linux ~]# <span class="term_command">gpasswd -A dmtsai -M dmtsai,vbird testgroup</span>
[root@linux ~]# <span class="term_command">grep testgroup /etc/group /etc/gshadow</span>
/etc/group:testgroup:x:502:<span class="term_write">dmtsai,vbird</span>
/etc/gshadow:testgroup:1CEVbrcjxO6Ps:<span class="term_write">dmtsai:dmtsai,vbird</span>
<span class="term_say"># 很有趣吧！此时 dmtsai 则拥有 testgroup 的主控权喔！若以我们讨论区 (
# <a href="http://phorum.vbird.org/" target="_blank">http://phorum.vbird.org</a> 的概念来说，群组管理员有点像『版主』啦！</span>

<span class="term_hd">范例二：以 dmtsai 登入系统，并且让他加入 vbird1 成为 testgroup 成员之一：</span>
[dmtsai@linux ~]$ <span class="term_command">gpasswd -a vbird1 testgroup</span>
Adding user vbird1 to group testgroup
</pre></td></tr></tbody></table>

			很有趣的一个小实验吧！我们可以让 testgroup 成为一个可以公开的群组，
			然后建立起群组管理员，群组管理员可以有多个。在这个案例中，
			我将他设定为 dmtsai ，所以， dmtsai 就可以自行增加群组成员啰～
			呼呼！然后，该群组成员就能够使用 newgrp 啰～<br><br>
		</div>

		<a name="newgrp2"></a><hr><li><span class="text_import1">newgrp</span></li>
		<div class="block2">
		还有印象吗？我们前面谈到 /etc/gshadow 时就提过这个指令了！
		『<span class="text_import2">newgrp 会额外以另一个 login 来提供使用者登入到另一个 shell 中，
		并且将有效群组改为 newgrp 后面接的那个群组，若没有接群组，则预设群组为 initial group </span>』
		</div>
	</div>

	<hr><a name="pwcontrol"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">密码管理： passwd</span><br>
	<div class="block2">
		再来跟大家提一提那个重要的密码概念！您得要特别留意的是，今天，您的主机若是遭到入侵，
		对方的第一个入侵点自然就是您主机上面账号的『密码』了，所以，
		如果您的密码定义的比较严格的话，那么自然对方就不容易猜到你的密码，自然就会比较有保障啦！<br><br>

		目前一些 Cracker 较常使用的密码破解软件，大抵是『<span class="text_import2">字典攻击法</span>』
		及所谓的『<span class="text_import2">暴力破解法</span>』，就字面上的意义来说，
		『字典攻击法』是将字典里面所查的到的任何单字或词组都输入的程序中，
		然后使用该程序一个一个的去尝试破解你的密码，不要觉得这样的速度似乎很慢，实际上，
		现今的计算机指令周期太高了，字典攻击法的操作效率基本上是很高的！另一个『
		<span class="text_import2">暴力破解法</span>』就是直接使用键盘上面任何可以使用的按键，然后依照组合，以
		1 个, 2 个, 3 个…. 密码组合的方式去破解你的密码！这个方式就真的比较慢一点，如果你的密码组合是
		6~8 个字符以上，那么暴力攻击法还是需要好长一段时间才能够破解的了的！<br><br>

		由上面的『字典攻击法』与『暴力破解法』猜测你的密码的方式来说，您知道如何设定一个好的密码了吗？
		是的，您的密码最好需要底下几个特性：<ul><span class="text_import2">
		<li>密码中含有数个特殊字符，例如 $#@^&amp;* 及数字键等等：如同上面提到的，
			您的按键越奇怪，那么对方就越不容易使用既有的软件来破解！
		</li><li>英文字母大小写混合使用；
		</li><li>密码长度至少要到 6 ~ 8 个以上才好；
		</li><li>没有特殊意义的字母或数字组合，并且夹着很多的特殊字符！</li></span></ul>

		这种密码真的很不容易被破解，但是很不幸的，也很容易被你我忘记！^_^。所以呢，
		建议您常常使用一些对别人来说是没有意义，但是对您确有特殊涵意的字眼！
		例如鸟哥常常提到的，我爱我老婆！『
		I&amp;Mywife*^』之类的密码！不容易被猜，也挺容易被你自己记住的！
		那么有没有『很要命的密码』呢？有的，底下几种密码就很要命：
		<ul><span class="text_import2">
		<li>常用的英文单字：例如 party, park, andyliu, linux,
			paper 等等，都不好！容易被字典攻击法破解！
		</li><li>身边人物的名字，例如配偶、小孩的名字等等， Tom, andy,
			eric 等等，都不好！
		</li><li>单纯的日期：例如您的生日啦！等等的，都不够好！
		</li><li>任何与您相关的数字或其他信息，例如身份证号、银行账号等；</li></span></ul>

		VBird 曾经见过直接以账号做为密码的状况！真是要命～太好猜了！<br><br>

		好了！知道了密码的重要性，与基本的设定之后，接着下来我们谈一谈如何手动设定密码吧！基本上，
		root 可以设定『任何样式的密码』，而且， root 也可以帮助 user 订定他们的密码！至于
		user 仅能修改自己的密码！那么修改密码使用什么命令？就是 passwd 
		这个命令啦！咦！这里突然给他想到几个重要信息，大家赶紧复习一下：
		<ul>
		<li>如何寻找 passwd 这个指令？<br><span class="text_import2">使用 which passwd 即可</span></li><br>
		<li>如何察看 passwd 这个档案的属性？并请说明他的属性为何？<br>
			<span class="text_import2">使用 ls -l `which passwd` 即可！他具有 SUID 的属性！</span></li><br>
		<li>什么是 SUID ？<br>
			<span class="text_import2">就是该程序在被执行的过程中，具有程序拥有者的权限！</span></li><br>
		<li>我该如何查询 /etc/passwd 与 /usr/bin/passwd 的用法与架构？<br>
			<span class="text_import2">分别使用 man passwd 及 man 5 passwd</span></li></ul>

		这些指令与意义如果都还没有忘记！恭喜您了！真是不错！好了，还记得我们密码放在哪里吗？对啦！就是
		/etc/shadow 里面，那个档案的权限是 -rw------- 所以只有 root 可以修改，因此，
		passwd 必需要具有 SUID 才能让一般用户修改他们的密码啰！关于 passwd 的用法，
		我们前面已经稍微提过一些啰，在底下我们则针对 root 谈一下 passwd 还有什么好功能？？<br><br>

		<hr><a name="passwd2"></a><li><span class="text_import1">passwd</span></li>
		<div class="block2">
<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">passwd [-lunxwS] username</span>
<span class="term_say">参数：
-l  ：将 username 这个账号的密码锁住 (lock)，在 /etc/shadow 内的密码栏修订～
-u  ：将 -l 的 lock 解开！
-n  ：后面接天数 (数字) ，最短天数；亦即是 /etc/shadow 内的第四栏；
-x  ：后面接天数 (数字) ，最长天数；亦即是 /etc/shadow 内的第五栏；
-w  ：后面接天数 (数字) ，警告天数；亦即是 /etc/shadow 内的第六栏；
-S  ：显示目前这个 username 的相关信息。
范例：</span>

<span class="term_hd">范例一：将 dmtsai 这个用户的密码冻结，并观察他！</span>
[root@linux ~]# <span class="term_command">passwd -l dmtsai</span>
Locking password for user dmtsai.
passwd: Success
[root@linux ~]# <span class="term_command">passwd -S dmtsai</span>
Password locked.
[root@linux ~]# <span class="term_command">grep dmtsai /etc/shadow</span>
dmtsai:<span class="term_write">!!</span>$1$TDy6D7eg$jVJV/FMaQn14v5Kl7sqw6/:13026:0:99999:7::13149:

<span class="term_hd">范例二：将上述密码冻结解开</span>
[root@linux ~]# <span class="term_command">passwd -u dmtsai</span>
</pre></td></tr></tbody></table>

			其实这个 passwd 指令还挺多用的～尤其很多功能仅有 root 才能执行。
			您可以使用 passwd -l 及 passwd -u 来强制让一个使用者『暂时』无法使用该账号，
			很方便的啦！ ^_^
		</div>
	</div>
</div>


<hr><a name="userswitch"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">使用者身份切换：</span><br>
<div class="block1">
	什么？在 Linux 系统当中还要作身份的变换？这是为啥？<ul>

	<li><span class="text_import1">系统平日操作的好习惯：</span><br>
	事实上，为了安全的缘故，
	我们大家都会建议您，操作 Linux 时，尽量以一般身份使用者来操作，等到需要设定系统环境时，
	才变换身份成为 root 来进行系统管理，相对比较安全啦！避免作错一些严重的指令～～<br><br>

	</li><li><span class="text_import1">用较低权限启动系统服务</span><br>
	相对于系统安全，有的时候，我们必须要以某些系统账号来进行程序的进行。
	举例来说， Linux 主机上面的一套软件，名称为 apache ，我们可以额外建立一个名为 apache 
	的使用者来启动 apache 啊，如此一来，如果这个程序被攻破，至少系统还不至于就损毁了～<br><br>

	</li><li><span class="text_import1">软件本身的限制</span><br>
	这里有个很有趣的问题要来跟大家分享一下，还记得在古老的年代里面，还没有
	ssh 的时候，我们都是使用 telnet 登入系统的，偏偏系统默认是不开启 root 以
	telnet 登入，那么好了！我们要怎样远程操控我们的 Linux 主机呀！？
	因为由前面的介绍我们不难发现，系统当中最特殊的账号就是
	UID 为 0 的使用者了，他具有至高无上的权力！而且是系统管理员必须要具备的身份，
	否则怎样操控主机呢？您说是吧！好了，那么
	telnet 将 root 的登入权限关掉了，而如果我们在制作一个使用者，并将其 UID
	变为 0 的话又如何？嘿嘿！很抱歉， telnet 就是认 UID 的，所以肯定还是进不了系统，
	这个时候要怎么办呀！？就是变换身份呀！将一般使用者的身份变成了 root 就行了！
	</li></ul>

	但是怎样变换身份呀？怎么说呢？就是说，一般而言，我们都不希望以
	root 的身份登入主机，以避免被怪客入侵了！但是一部主机又不可能完全不进行修补或者是设定等动作！
	这个时候要如何将一般使用者的身份变成
	root 呢？主要有两种方式，分别是：<ul>
	<li>以 su 直接将身份变成 root 即可，但是这个指令却需要 root 的密码，也就是说，如果你要以 
		su 变成 root 的话，你的一般使用者就必须要有 root 的密码才行；<br><br>
	</li><li>所以当有很多人同时管理一部主机的时候，那么 root 的密码不就很多人知道了？不是很好吧?所以，如果不想要将
		root 的密码流出去呢？呵呵！可以使用 sudo 来进行工作呦！</li></ul>

	底下我们就来说一说 su 跟 sudo 的用法啦！<br><br>

	<hr><a name="su"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">su</span><br>
	<div class="block2">

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">su [-lcm] [username]</span>
<span class="term_say">参数：
-   ：如果执行 su - 时，表示该使用者想要变换身份成为 root ，且使用 root 的
      环境设定参数档，如 /root/.bash_profile 等等。
-l  ：后面可以接使用者，例如 su -l dmtsai ，这个 -l 好处是，可使用欲变换身份者
      他的所有相关环境配置文件。
-m  ：-m 与 -p 是一样的，表示『使用目前的环境设定，而不重新读取新使用者的配置文件。』
-c  ：仅进行一次指令，所以 -c 后面可以加上指令喔！
范例：</span>

<span class="term_hd">范例一：由原本的 dmtsai 这个使用者，变换身份成为 root 。</span>
[dmtsai@linux ~]$ <span class="term_command">su</span>
Password: <span class="term_note">&lt;==这里输入 root 的密码喔！</span>
[root@linux ~]# <span class="term_command">env</span>
USER=dmtsai
USERNAME=root
MAIL=/var/spool/mail/dmtsai
LOGNAME=dmtsai
<span class="term_say"># 注意到了吗？如果使用 su 没有加上 - 的话，那么很多原本使用者的相关设定会继续存在，
# 这也会造成后来的 root 身份在执行时的困扰。最常见的就是 PATH 这个变量的问题！</span>

[root@linux ~]# <span class="term_command">exit</span>  <span class="term_note">&lt;==这样可以离开 su 的环境！</span>
[dmtsai@linux ~]$ <span class="term_command">su -</span>
Password: <span class="term_note">&lt;==这里输入 root 的密码喔！</span>
[root@linux ~]# <span class="term_command">env</span>
USER=root
MAIL=/var/spool/mail/root
LOGNAME=root
<span class="term_say"># 了解差异了吧？！所以，下次在变换成为 root 时，记得最好使用 su - 喔！</span>

<span class="term_hd">范例二：使用 root 的身份，执行 head -n 3 /etc/shadow</span>
[dmtsai@linux ~]$ <span class="term_command">su - -c "head -n 3 /etc/shadow"</span>
Password: <span class="term_note">&lt;==这里输入 root 的密码喔！</span>
root:$1$jaldj9843u29jlj9u839jljlcghjlE/:12959:0:99999:7:::
bin:*:12959:0:99999:7:::
daemon:*:12959:0:99999:7:::

<span class="term_hd">范例三：原本是 dmtsai 这个使用者，想要变换身份成为 vbird 时？</span>
[dmtsai@linux ~]$ <span class="term_command">su -l vbird</span>
Password: <span class="term_note">&lt;==这里输入 vbird 的密码喔！</span>
</pre></td></tr></tbody></table>

		这个 su 指令可以让你在不同的使用者之间切换身份，当 su 后面没有加上使用者账号时，
		那么预设就是以 root 作为你切换的那个身份啦！其实，这个指令最大的用途也是在这里！
		就是让一般使用者变成 root 啦！而要特别留意的则是 su 的使用方式上，
		由于『<span class="text_import2">是否读入欲切换的身份者的环境参数档案</span>』的不同，
		所以您必须要留意喔！<ul>

		<li>如果只是想要使用 root 的身份来操作系统，但是原有的环境参数并不想要改变，
			那么可以使用『 su 』直接切换身份成为 root ，例如上面的范例一所示。
			此时， MAIL/PATH/USER 等环境变量都还是原来那位登入者喔！所以要特别留意例如
			PATH 这个可能影响到执行指令进行的变量才行！<br><br>
		</li><li>如果您想要保留原有的环境参数，那么环境变量当中，最麻烦的当属 PATH 这个东西，
			由于为了避免一般使用者使用了 root 的管理指令，所以通常 Linux 
			都会将指令分类放在两个主要的目录，分别是 /bin 与 /sbin ！那个 /sbin 大多是 super 
			user 就是 root 用来管理系统的指令啦！所以，可能的话，将你习惯操作的那个账号的 PATH 
			重新设定成为 root 的 PATH ，这样也比较方便呀！<br><br>
		</li><li>无论如何，还是建议您如果要切换成为某个身份，使用『 su - 』或者是『 su -l usename 』
			会比较好一点～否则容易造成环境变量的差异～<br><br>
		</li><li>另外，如果仅想要执行一次 root 的指令，那么可以参考 -c "command" 这种 su 
			的使用方式喔！<br><br>
		</li><li>当 root 使用 su 切换身份时，他并不需要输入密码喔！</li></ul>

		虽然使用 su 很方便啦～不过，缺点是当我有很多管理员时，那么是否每个人都需要知道 root 的密码？
		这样很危险ㄟ！ root 的密码可能会外流～怎么办？没关系，我们可以使用 sudo 来取代 su 喔。<br><br>
	</div>

	<hr><a name="sudo"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">sudo</span><br>
	<div class="block2">
		使用 su 切换身份真的是很简单啦～不过， <span class="text_import2">su 却有一个很严重的问题，
		那就是.....我们必须要知道想要变成的那个人的登入密码～</span>
		举例来说，如果我想要变成 root ，那么就必须要知道 root 的密码才行，
		如果我想要变成 dmtsai 来工作，那么除非我是 root ，否则就必须要知道 dmtsai 
		这个用户的密码才行～而众所皆知的，如果多人管理一部主机的话，
		大家都知道 root 的密码，那......挺危险的，不是吗？！<br><br>

		这个时候， sudo 就派的上用场啰～那么 sudo 是怎样工作的呢？<ul><span class="text_import2">
		<li>当用户执行 sudo 时，系统会主动的去寻找 /etc/sudoers 档案，判断该使用者是否有执行 sudo 的权限；
		</li><li>若使用者具有可执行 sudo 的权限后，便让使用者『输入用户自己的密码』来确认；
		</li><li>若密码输入成功，便开始进行 sudo 后续接的指令；
		</li><li>不过， root 执行 sudo 时，不需要输入密码；
		</li><li>若欲切换的身份与执行者身份相同，那也不需要输入密码。</li></span></ul>

		要注意的是，使用者『输入的是自己的密码，而不是欲切换成为他的那个身份的密码！』
		举例来说，假设 dmtsai 具有执行 sudo 的权限，那么当他以 sudo 执行 root 的工作时，
		他需要输入的是 dmtsai 自己的密码，而不是 root 的密码！嘿嘿！很棒吧！ ^_^
		如此一来，大家可以使用自己的密码执行 root 的工作，而不必知道 root 的密码，安全多了。
		此外，<span class="text_import2">用户能够执行的指令是可以被限制的！</span>
		所以，我们可以设定 dmtsai 仅能进行 shutdown 的工作，或者是其他一些简单的指令，
		嘿嘿！是否很棒啊！<br><br>

		不过，由上面的说明当中，您也会了解，是否具有 sudo 的执行权限是很重要的，
		而 sudo 的执行权限与 /etc/sudoers 这的档案有关。<span class="text_import2">在预设的情况下，只有 root
		才能够使用 sudo 呢！</span>至于编辑 /etc/sudoers 则需要 visudo 这个指令。好了，
		底下我们就来看一看 sudo 的语法先。<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">sudo [-u [username|#uid]] command</span>
<span class="term_say">参数：
-u  ：后面可以接使用者账号名称，或者是 UID。例如 UID 是 500 的身份，可以：
      -u #500 来作为切换到 UID 为 500 的那位使用者。
范例：</span>

<span class="term_hd">范例一：一般身份用户使用 sudo 在 /root 底下建立目录：</span>
[dmtsai@linux ~]$ <span class="term_command">sudo mkdir /root/testing</span>
We trust you have received the usual lecture from the local System
Administrator. It usually boils down to these three things:

    #1) Respect the privacy of others.
    #2) Think before you type.
    #3) With great power comes great responsibility.

Password: <span class="term_note">&lt;==这里输入 dmtsai 自己的密码</span>
dmtsai is not in the sudoers file.  This incident will be reported.
<span class="term_say"># 瞧！因为 dmtsai 不在 /etc/sudoers ，所以他就无法执行 sudo 喔！</span>

<span class="term_hd">范例二：假设 dmtsai 已经具有 sudo 的执行权限，如何在 /root 底下建立目录？</span>
[dmtsai@linux ~]$ <span class="term_command">sudo mkdir /root/testing</span>
Password: <span class="term_note">&lt;==这里输入 dmtsai 自己的密码</span>

<span class="term_hd">范例三：如何将 sudo 与 su 搭配使用？</span>
[dmtsai@linux ~]$ <span class="term_command">sudo su -</span>

<span class="term_hd">范例四：dmtsai 想要切换身份成为 vbird 来进行 touch 时？</span>
[dmtsai@linux ~]$ <span class="term_command">sudo -u vbird touch /home/vbird/test</span>
</pre></td></tr></tbody></table>

		<a name="20080426"></a>上面我进行了四个范例，不过，要注意的是，若我是以 dmtsai 来进行的，
		那么在接下来的五分钟内，如果你持续使用 sudo 来工作时，那就不需要再次的输入密码。
		这是因为系统相信你在五分钟内不会离开而有第二个人跑来操作系统啊！
		呼呼！真是很人性化的设计啊～ ^_^。不过如果两次 sudo 
		操作的间隔超过 5 分钟，那就得要重新输入一次你的密码了。
		而且要注意的是，因为使用一般账号时，理论上不会使用到 /sbin, /usr/sbin 等目录内的指令，
		所以 $PATH 变量不会含有这些目录，因此很多管理指令需要使用绝对路径来下达比较妥当喔！
		或者直接修改您自己的 PATH 变量吧！<br><br>

		<a name="visudo"></a>上面这四个范例我都是以 dmtsai 这个使用者来进行的，但是，在预设的情况中，
		您的使用者应该是不能使用 sudo 的～这是因为我们上面提到的啊，还没有去设定 /etc/sudoers 嘛！
		所以啰，如果您要测试上面的范例之前，是需要将 /etc/sudoers 动动手脚的。
		不过，因为 /etc/sudoers 需要一些比较特别的语法，因此，如果你直接以 vi 去编辑他时，
		如果输入的字句错误，可能会造成无法启用 sudo 的困扰，因此，建议您一定要使用 visudo 
		去编辑 /etc/sudoers 喔！(注： visudo 必须要使用 root 的身份来执行！)<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">visudo</span>
# sudoers file.
# This file MUST be edited with the 'visudo' command as root.
# See the sudoers man page for the details on how to write a sudoers file.
#
# Host alias specification
# User alias specification
# Cmnd alias specification
# Defaults specification
# Runas alias specification
# User privilege specification
root    ALL=(ALL) ALL
<span class="term_write">dmtsai  ALL=(ALL) ALL</span>   <span class="term_note">&lt;==这里将 dmtsai 制作成完全可用！</span>

# Uncomment to allow people in group wheel to run all commands
# %wheel        ALL=(ALL)       ALL
# Same thing without a password
# %wheel        ALL=(ALL)       NOPASSWD: ALL
# Samples
# %users  ALL=/sbin/mount /cdrom,/sbin/umount /cdrom
# %users  localhost=/sbin/shutdown -h now
</pre></td></tr></tbody></table>

		使用 visudo 之后，其实就会出现一个 vi 的画面啦！他就是以 vi 来开启 /etc/sudoers ，
		不过，当我们储存离开时， visudo 会额外去检查 /etc/sudoers 内部的语法，
		以避免用户输入错误的信息了。我上面只有加入一行，就是让那个 dmtsai 成为可以随意使用 sudo 
		的身份而已。基本上， /etc/sudoers 的结构您可以使用 man sudoers 去查阅，
		该说明内容说的很清楚，而且还有一些范例呢！鸟哥在这里仅作一些简单的说明就是了。
		那一行『 dmtsai ALL=(ALL) ALL 』代表的意义是：<ul><span class="text_import1">
		用户账号  登入的主机 = (可以变换的身份) 可以下达的指令</span></ul>
		因此，我上面这一行的意义是：『 <span class="text_import2">dmtsai 这个使用者，不论来自何方，
		他可以变换成任何 Linux 本机上面有的所有账号，并执行所有的指令</span>』的意思啦！
		假如您的系统里面，有个 Web 的软件是以 www 这个使用者来进行编辑的，
		您想要让 vbird2 这个使用者可以用 www 这个账号进行编辑，那么就应该写成：
		<ul><span class="text_import1">vbird2 ALL = (www) ALL</span></ul>
		如果错写成：
		<ul><span class="text_import1">vbird2 ALL = ALL</span></ul>
		亦即没有加上身份宣告的话，那么『预设是仅能进行 root 的身份切换』而已喔！ ^_^
		这可是很重要的一个观念呢！另外，如果想要以使用者的群组来进行规范的话，那么在
		『使用者账号』的字段，前面加上『 % 』时，就代表是群组 (group) 的身份了。
		举例来说，我想要让系统里面所有属于 wheel 这个群组的使用者都能够进行 sudo 时，可以这样写：
		<ul><span class="text_import1">%wheel  ALL = (ALL) ALL</span></ul>
		而如果你还想要让这个群组内的使用者在使用 sudo 时，不需要输入密码，
		那么可以在『可以下达的指令』那个字段内多加入一个参数，名为『NOPASSWD:』即可，亦即：
		<ul><span class="text_import1">%wheel  ALL = (ALL) NOPASSWD: ALL</span></ul>
		另外，除了单一个人或单一群组之外，我们还可以额外指定一些『帐户别名、主机别名、指令别名』
		等等的数据来相互套用喔！真是好棒啊！不过，关于别名的使用上，『必须要使用大写字符』才行喔！
		好了，我们来做一些练习，让您可以很清楚的知道如何进行 visudo 的设定吧！<br><br>

<table width="95%" border="1" cellpadding="5" cellspacing="0"><tbody><tr><td>
例题：我想要建立一个可以帮忙系统管理员变更用户密码的群组，名称为 ADMPW 
( 注意，在 sudoers 内，这个别名的名称一定要是大写字符才行！)但是这个群组不能修改 root 的密码喔！
且他们执行 sudo 时，不需要密码验证。<br>
答：<ul>我以 root 的身份使用 visudo ，进入编辑画面后，去设定成底下的模样：<span class="text_import2"><pre>User_Alias ADMPW = vbird, dmtsai, vbird1, vbird3
ADMPW ALL = NOPASSWD: !/usr/bin/passwd, /usr/bin/passwd [A-Za-z]*, \
                      !/usr/bin/passwd root
</pre></span>
上面的意思是说，我的系统上面有四个账号，分别是 vbird, vbird1, vbird3 与 dmtsai 
这四个账号加入 sudo 内的 ADMPW 群组中，这四个账号可以使用 sudo 进行『 /usr/bin/passwd * 』
密码的更改动作，但是不能 (在指令前面加入 ! 代表不可) 使用 /usr/bin/passwd 或 /usr/bin/passwd root
，如此一来，就让该 ADMPW 可以更改用户的密码，但是不能变更 root 的密码啰！ ^_^</ul>
</td></tr></tbody></table><br>

		在 /etc/sudoers 里头加入别名有很多的好处，举例来说，以上面的例子来讲，
		假设未来我有其他的用户要加入该密码管理的群组时，直接将账号加入 ADMPW
		那个群组中就好了，很简单的使用吧！ ^_^。再看看下一题：<br><br>

<table width="95%" border="1" cellpadding="5" cellspacing="0"><tbody><tr><td>
例题：我的系统中有 DNS 服务，他的启动指令在 /etc/init.d/named ，如果我想要建立一个 DNSMASTER
的群组来管理他时？如何是好？<br>
答：<ul>我以 root 的身份使用 visudo ，进入编辑画面后，去设定成底下的模样：<span class="text_import2"><pre>User_Alias DNSMASTER = vbird, dmtsai
Cmnd_Alias DNSCMD = /etc/init.d/named, /usr/bin/vim /var/named/*
DNSMASTER ALL = DNSCMD
</pre></span>
看的懂吗？嘿嘿！因为 DNS 的配置文件大多在 /var/named 里面，所以，我也允许相关账号用 vi 
去处理 DNS 的配置文件啦！很简单对吧！ ^_^
</ul></td></tr></tbody></table><br>

		好了，我们知道 sudo 可以搭配 su 来进行一堆系统的工作对吧！
		因为 sudo 仅能进行一次指令，很麻烦，如果我能够将 sudo 与 su 搭配在一起，不就很棒了吗？
		这个时候，我可以利用上面已经建立好的 ADMPW 群组来新增这一行：
		<ul><span class="text_import1">ADMPW ALL = /bin/su</span></ul>
		如此一来，在 ADMPW 内的使用者，就可以利用『 sudo su - 』来切换身份成为 root 啰～
		真是棒得不得了啊！ ^_^
	</div>
</div>


<hr><a name="usershell"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">使用者的特殊 shell 与 PAM 模块</span><br>
<div class="block1">
	我们前面一直谈到的大多是一般身份用户与系统管理员 (root) 的相关操作，
	而且大多是讨论关于可登入系统的账号来说。那么换个角度想，如果我今天想要建立的，
	是一个『仅能使用 mail server 相关邮件服务的账号，而该账号并不能登入 Linux 主机』呢？
	如果不能给予该账号一个密码，那么该账号就无法使用系统的各项资源，当然也包括 mail 的资源，
	而如果给予一个密码，那么该账号就可能可以登入 Linux 主机啊！呵呵～伤脑筋吧～
	所以，底下让我们来谈一谈这些有趣的话题啰！<br><br>

	<hr><a name="nologin"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">特殊的 shell, /sbin/nologin</span><br>
	<div class="block2">
		如果你曾经仔细的看过 /etc/shells 这个系统可用的 shell 档案，以及
		/etc/passwd 这个档案的内容时，你应该会发现，嘿嘿！怎么有个怪怪的 /sbin/nologin 啊！
		这是什么 shell 呢？呵呵！赶紧利用 man nologin 就可以知道啦～<br><br>

		其实，这个 shell 通常是给系统账号使用的，因为这个 /sbin/nologin 事实上并无法给予账号实际登入，
		如果你利用 usermod 修改了 dmtsai 这个使用者的 shell 成为 /sbin/nologin 之后，
		再次想要以 dmtsai 重新登入系统时，他在屏幕上会出现这样的讯息：<br>

<table class="term"><tbody><tr><td class="term"><pre>This account is currently not available.
</pre></td></tr></tbody></table>

		嘿嘿！它说的是『这个账号并不能被允许登入啦！』不过，这个账号却可以进行其他的工作喔！
		举例来说，各个系统账号，打印作业由 lp 这个账号在管理， WWW 服务由 apache 这个账号在管理，
		他们都可以进行系统程序的工作，但是『就是无法登入主机』而已啦！^_^<br><br>

		换个角度来想，如果我的 Linux 主机提供的是邮件服务，所以说，在这部 Linux 主机上面的账号，
		其实大部分都是用来收受主机的信件而已，并不需要登入主机的呢！
		这个时候，我们就可以考虑让单纯使用 mail 的账号以 /sbin/nologin 做为他们的 shell ，
		这样，最起码当我的主机被尝试想要登入系统时，可以拒绝该账号呢！<br><br>

		另外，如果我想要让某个具有 /sbin/nologin 的使用者知道，他们不能登入主机时，
		其实我可以建立『 <span class="text_import2">/etc/nologin.txt</span> 』这个档案，
		并且在这个档案内说明不能登入的原因，那么下次当这个用户想要登入系统时，
		屏幕上出现的就会是 /etc/nologin.txt 这个档案的内容，而不是预设的内容了！<br><br>
	</div>

	<hr><a name="pam"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">PAM 模块：/etc/nologin, /etc/securetty</span><br>
	<div class="block2">
		当一个用户想要登入 Linux 主机时，他受到什么限制呢？我们说，
		他除了必须要通过 /etc/passwd 及 /etc/shadow 的验证并取得相关的权限资料，
		最后获得一个 shell 之外，事实上，他在登入系统之前，就得要通过 PAM (Pluggable Authentication 
		Modules, 嵌入式模块) 的验证才行。<br><br>

		PAM 模块的用途非常的多，除了可以在使用者登入时进行身份的验证之外，
		也可以辅助一些应用程序的验证之用喔！举例来说，我们前面提到的密码修改程序『 passwd 』
		，当我们执行密码修订的时候，这个程序不是会告诉我们您输入的密码是否合于规范吗？
		如果是记录在字典当中的密码，或者是与账号相同的密码，那么就会被 PAM 模块打回票，
		也就无法通过验证了！<br><br>

		那么 PAM 怎么运作呢？我们同样以 /usr/bin/passwd 这支程序来作为简单的说明好了：
		<ol><span class="text_import2">
		<li>用户开始执行 /usr/bin/passwd 这支程序，并输入密码；
		</li><li>passwd 开始呼叫 PAM 模块，PAM 模块会搜寻 passwd 程序的 PAM 相关配置文件案，
			这个配置文件一般是在 /etc/pam.d/ 里面的与程序同名的档案，所以，在本例中，
			PAM 会去搜寻 /etc/pam.d/passwd 这个配置文件；
		</li><li>经由 /etc/pam.d/passwd 配置文件的数据，取用 PAM 所提供的相关模块来进行验证；
		</li><li>将验证结果回传给 passwd 这支程序，而 passwd 这支程序会根据 PAM 回传的结果决定下一个动作
			(重新输入新密码或者通过验证！)</li></span></ol>

		这个过程提供我们几个重要的信息： 
		<ul><span class="text_import2">
		<li>PAM 的配置文件放置在 /etc/pam.d/ 这个目录中；
		</li><li>至于更多的环境相关设定则放置在 /etc/security/* 内；
		</li><li>PAM 是透过自己提供的相关模块来进行验证，模块放置在 /lib/security/* 内。</li></span></ul>

		至于 PAM 相关模块的运作，有兴趣的话，您可以前往您 Linux 主机的： /usr/share/doc/pam* 
		目录去瞧一瞧，里面有相当多丰富的信息可以提供给你参考。
		我们这里仅就用户登入相关的模块来进行一些简单的说明而已喔。<br><br>

		<hr><li><span class="text_import1">PAM 的配置文件设定范例：</span></li>
		<div class="block2">
			反正 PAM 模块就是让程序呼叫用的，而当程序呼叫时，
			PAM 就会利用相对应的配置文件来进行一些验证就是了。我们还是举 passwd 为例好了，
			如果你去观察一下 /etc/pam.d/passwd 的内容时，他是这样的：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">cat /etc/pam.d/passwd</span>
#%PAM-1.0
auth       required     pam_stack.so service=system-auth
account    required     pam_stack.so service=system-auth
password   required     pam_stack.so service=system-auth
</pre></td></tr></tbody></table>

			基本上，在这个档案内，每一行都是一个动作，而每个动作都分为四个字段，分别是：
			<ul><span class="text_import2">验证的类别 　 验证的控制标准 　 使用的PAM模块 　 该模块的能使用的参数
			</span></ul>
			验证的类别 (Module type) 共分为四种类，分别说明：<ul>
			<li><span class="text_import1">auth</span><br>
			这种类别主要用来检验使用者的身份验证，所以这种类别通常是需要密码来检验的。</li><br>
			<li><span class="text_import1">account</span><br>
			这种类别则主要在检验使用者是否具有正确的权限，举例来说，当你使用一个过期的密码来登入时，
			当然就无法正确的登入了。</li><br>
			<li><span class="text_import1">session</span><br>
			这种类别主要在管理当用户正确的使用该程序时的环境设定。举例来说，我们登入 Linux 
			其实使用的是 /bin/login 这个程序的相关功能的，所以，当实际登入后，在操作 shell 
			的过程中，都是受 session 这种类别的设定所控制的喔！另外，如果使用 session 这种类别时，
			则该程序在正式使用之前与使用结束之后，都会有相关纪录被记到登录文件当中喔！</li><br>
			<li><span class="text_import1">password</span><br>
			至于这种类别，则主要在提供验证的修订工作，举例来说，就是修改/变更密码啦！</li>
			</ul>

			那么『验证的控制标准(control flag)』又是什么？简单的说，他就是『验证通过的标准』啦！
			总共也有四种方式，分别是：<ul>
			<li><span class="text_import1">required</span><br>
			当模块设定为这种控制标准时，该模块的验证必须要成功，否则就会回传一个 failure 的讯息。
			不过，不论此一动作的模块是否成功，接下去的模块都还会继续动作！
			而若有 failure 的讯息时，也会在后续的动作都进行完毕之后，才会回传给原程序。
			比底下的 requisite 还要优秀的地方，在于该模块底下的动作可能具有登录文件纪录 (log)
			的举动，则错误的讯息才会被纪录起来喔！<br><br>
			</li><li><span class="text_import1">requisite</span><br>
			当模块设定为 requisite 时，该模块的认证要求同样的需要成功才行。
			不过，如果该模块没有通过验证，那么 PAM 会『立刻』回报程序一个 failure 的值，
			也就是说，若该次动作的模块后续还有其他模块时，其他模块的动作将不会被启用。<br><br>
			</li><li><span class="text_import1">optional</span><br>
			这个模块控件目大多是在显示讯息而已，并不是用在验证方面的。<br><br>
			</li><li><span class="text_import1">sufficient</span><br>
			这个模块控制标准也挺有趣的，相对于 requisite 是『发生错误时，立刻回报原执行程序 failure ，
			并且中断 PAM 的运作』， sufficient 则是『顺利通过验证时，立刻回报原程序通过的讯息，
			并且中断 PAM 的运作』。呵呵！完全相反喔！<br>
			</li></ul>

			至于 PAM 的模块方面，目前我们的 FC4 提供的 PAM 模块真的够多了，
			这些模块实际上都放置在 /lib/security/ 目录中，FC4 相关的 PAM 说明文件则放置在
			/usr/share/doc/pam-*/* 里面，您可以根据每个不同的模块去讨论他的用途，
			鸟哥在这里仅针对我们登入时所使用的 login 这个程序的 PAM 配置文件，也就是 /etc/pam.d/login
			这个档案的内容来稍做说明：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">cat /etc/pam.d/login</span>
#%PAM-1.0
<span class="term_write">auth       required	pam_securetty.so</span>
auth       required	pam_stack.so service=system-auth
<span class="term_write">auth       required	pam_nologin.so</span>
account    required	pam_stack.so service=system-auth
password   required	pam_stack.so service=system-auth
# pam_selinux.so close should be the first session rule
session    required	pam_selinux.so close
session    required	pam_stack.so service=system-auth
session    optional	pam_console.so
# pam_selinux.so open should be the last session rule
session    required	pam_selinux.so multiple open
</pre></td></tr></tbody></table>

			在我们登入 Linux 的时候，使用到的 login 这个程序时，他使用的 PAM 配置文件大多是
			required 的控制标准，所以必须要通过上述的几个 PAM 模块的验证后，才能够判定是否登入 Linux 。
			需要留意的是，我们会看到 session 的模块类型，这表示我们在实际使用 Linux
			的资源之前，以及注销 Linux 主机后，相关的数据都会被纪录到登录文件当中。
			嘿嘿！所以啰，如果您仔细的看过 /var/log/messages 与 /var/log/secure ，
			就能够发现你的一举一动其实是有被纪录下来的喔！ ^_^<br><br>

			另外，在上面表格当中的模块中，比较有趣的是被鸟哥注明特殊字体的部分，
			这两个模块： pam_securetty.so 及 pam_nologin 是挺有趣的喔！
			我们就额外来谈一谈这两个关于登入环境的验证模块吧！<br><br>
		</div>

		<hr><li><span class="text_import1">/etc/securetty</span></li>
		<div class="block2">
			这个 pam_securetty 模块是干嘛用的？其实他最主要的功能就是在预防不安全的登入环境啦！
			而且主要是针对 root 这个使用者的身份喔！
			这个模块在被启用时，会去读取 /etc/securetty 这个档案，
			我们『<span class="text_import2">可以将被认定是安全的终端机 (terminal) 环境写入这个档案中，
			则 root 仅可以在那几个终端机环境下登入</span>』的啦！<br><br>

			一般来说，我们会认定在主机前面的环境是安全的，而使用网络登录的环境则比较危险。
			因此，一般 /etc/securetty 的内容大多是这样：<br>

<table class="term"><tbody><tr><td class="term"><pre>tty1
tty2
tty3
tty4
...
</pre></td></tr></tbody></table>

			而没有 pts/0 这类的网络登录的终端界面。这也就是说， root 仅能经由 tty1 
			这种终端机登入的啦！支持 login 程序的软件有 telnet 服务与本机前面的 tty1~tty6 的 login，
			这也是我们提到的，为何使用传统的 telnet 联机主机联机到 Linux 时，预设无法使用
			root 身份登入的主要原因啰。<br><br>

			那么如何克服呢？其实也很简单啦，就将这个模块的验证移除即可！
			主要有两种方式：<ul><span class="text_import2">
			<li>将 /etc/pam.d/login 内，关于 pam_securetty.so 模块的那一行批注掉；
			</li><li>将 /etc/securetty 这个档案移除。</li></span></ul>

			如此一来，当我们使用 telnet 联机到 Linux 主机时，就能够直接使用 root 的身份登入了。
			不过，鸟哥不建议这么做喔！不过或许您又会问啦，那为什么我使用 ssh 联机时，
			就可以直接使用 root 登入呢？呵呵！这是因为 ssh 没有用到这个模块ㄇㄟ！
			不相信吗？仔细自己去查阅一下 /etc/pam.d/sshd 就知道啦！ ^_^。<br><br>
		</div>

		<hr><li><span class="text_import1">/etc/nologin</span></li>
		<div class="block2">
			那么 pam_nologin 又是在搞什么咚咚啊？其实，这个模块也是在控制用户登入用的。
			不过，<span class="text_import2">这个模块只针对一般身份用户有效，对
			root 是没有效果的。</span>这个模块必须要与 /etc/nologin 
			搭配使用，注意喔，是 /etc/nologin ，而不是 /etc/nologin.txt ，
			这两个档案的用途是不相同的喔！ ^_^。<br><br>

			<span class="text_import2">当 /etc/nologin 档案存在时，则任何一个一般身份账号在尝试登入时，
			都仅会获得 /etc/nologin 内容的信息，而无法登入主机。</span>举例来说，当我建立
			/etc/nologin ，并且内容设定为『This Linux server is maintaining....』，
			那么任何人尝试登入时，都仅会看到上面提到的这段讯息，而且无法登入喔！
			一直要到 /etc/nologin 被移除后，一般身份使用者才能够再次的登入啊！<br><br>
		</div>

		<hr><li><span class="text_import1">/etc/security/*</span></li>
		<div class="block2">
			事实上，更多的 PAM 模块设定信息您可以参考 /etc/security/* 里面的档案设定，
			尤其是针对用户利用 Linux 系统资源的 limits.conf 以及时间的 time.conf 。
			我们知道用户利用系统资源的指令是 ulimit ，那么假如我想要让 dmtsai 
			仅能存取 10MBytes (10240KBytes) 的档案大小，那么我可以这样做：<br>
<a name="20070415"></a>
<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">vi /etc/security/limits.conf</span>
<span class="term_say"># 新增这两行</span>
dmtsai          hard    fsize   10240
@users          hard    fsize   10240
<span class="term_say"># 注意到，账号前面加上 @ 表示为『群组！』</span>
</pre></td></tr></tbody></table>

			那么下次 dmtsai 或者是属于 users 的群组的使用者登入这个 Linux 主机时，
			你可以利用 ulimit -a 去察看一下，嘿嘿！他们能用的资源就减小很多了！
			更多的用法您可以自行参考一下该档案内的说明啊！ ^_^
			(记得测试完毕要将资料改回来～否则....以后就麻烦了！)
		</div>
	</div>
</div>


<hr><a name="uselinux"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">Linux 系统上用户的对谈与 mail 的使用：</span><br>
<div class="block1">
	谈了这么多的系统账号问题，总是该要谈一谈，那么如何针对系统上面的用户进行查询吧？！
	想几个状态，如果你在 Linux 上面操作时，刚好有其他的用户也登入主机，你想要跟他对谈，该如何是好？
	你想要知道某个账号的相关信息，该如何查阅？呼呼！底下我们就来聊一聊～<br><br>

	<hr><a name="uselinux_find"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">查询使用者： 
	w, who, last, lastlog</span><br>
	<div class="block2">
		如何查询一个用户的相关数据呢？这还不简单，我们之前就提过了 w, who, finger 等指令了，
		都可以让您了解到一个用户的相关信息啦！那么想要知道使用者到底啥时候登入呢？
		最简单可以使用 last 检查啊！这个玩意儿我们也在 bash shell 那个章节提过了，
		您可以自行前往参考啊！简单的很。不过， last 仅有列出这个月份的资料而已喔。<br><br>

		另外，如果您想要知道每个账号的最近登入的时间，则可以使用 lastlog 这个指令喔！
		lastlog 会去读取 /var/log/lastlog 档案，结果将数据输出，如下表：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">lastlog</span>
Username         Port     From             Latest
root             tty1                      Tue Aug 16 18:06:20 +0800 2005
bin                                        **Never logged in**
daemon                                     **Never logged in**
<span class="term_say">....以下省略.....</span>
</pre></td></tr></tbody></table>

		这样就能够知道每个账号的最近登入的时间啰～ ^_^<br><br>
	</div>

	<hr><a name="uselinux_talk"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">使用者对谈： talk, mesg, wall</span><br>
	<div class="block2">
		那么我是否可以跟系统上面的用户谈天说地呢？当然可以啦！
		利用 talk 这个指令即可！不过， talk 需要额外的启动一些网络服务，
		对于目前的 Linux distribution 以及网络环境，嘿嘿！咱们还是不要玩这个东西啦～
		如果您确定想要玩这个玩意儿，那么请自行 man talk ，
		同时考虑启动 ntalk 这个服务看看啰～<br><br>

		除了直接在线对谈 (talk) 之外，有没有其他讯息传送的功能啊？
		有啊！利用 write 是不错的方式啦！他可以直接将讯息传给接收者啰！
		举例来说，我们的 Linux 目前有 vbird 与 dmtsai 两个人在在线：<br>

<table class="term"><tbody><tr><td class="term"><pre>[vbird@linux ~]$ <span class="term_command">w</span>
 16:50:39  up  1:58,  2 users,  load average: 0.00, 0.00, 0.00
USER     TTY      FROM      LOGIN@   IDLE   JCPU   PCPU  WHAT
vbird    pts/0    vbird     4:37pm  0.00s  0.06s  0.01s  w
dmtsai   pts/1    dmtsai    4:38pm  1:51   0.07s  0.01s  man write
</pre></td></tr></tbody></table>

		我以 vbird 传送一个讯息给 dmtsai 时，可以这样做：<br>

<table class="term"><tbody><tr><td class="term"><pre>[vbird@linux ~]$ <span class="term_command">write dmtsai</span>
<span class="term_write">Hi, How are you doing today....
Nothing.... just say hello to you!</span>
<span class="term_note">&lt;==这里按下 [ctrl]+d</span>
</pre></td></tr></tbody></table>

		此时，另一端的 dmtsai 在他的终端接口上就会出现如下所示：<br>

<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@linux ~]$ 
Hi, How are you doing today....
Nothing.... just say hello to you!
EOF
</pre></td></tr></tbody></table>

		怪怪～立刻会有讯息响应给 dmtsai ㄟ！不过......当时 dmtsai 正在查资料，哇！
		这些讯息会立刻打断 dmtsai 原本的工作喔！所以，如果 dmtsai 这个人不想要接受任何讯息，
		直接下达这个动作：<br>

<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@linux ~]$ <span class="term_command">mesg n</span>
</pre></td></tr></tbody></table>

		所以，当 vbird 再次下达 write 时，就会出现：<br>

<table class="term"><tbody><tr><td class="term"><pre>[vbird@linux ~]$ <span class="term_command">write dmtsai</span>
write: dmtsai has messages disabled
</pre></td></tr></tbody></table>

		呼呼！了解乎？而如果想要解开的话，再次下达『 mesg y 』就好啦！想要知道目前的 mesg 
		状态，直接下达『 mesg 』即可！瞭呼？<br><br>

		相对于 write 是仅针对一个使用者来传『简讯』，我们还可以『对所有系统上面的用户传送简讯』哩～
		如何下达？呼呼！用 wall 即可啊！他的语法也是很简单的喔！<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">wall "I will shutdown the linux server about 5m later.
&gt; If you still have to login, please tell me.
&gt; Or I will do it....."</span>
</pre></td></tr></tbody></table>

		那么除非您的 mesg 状态是 n ，否则，嘿嘿！就能够收到这个广播消息啰！ ^_^<br><br>
	</div>

	<hr><a name="mail"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">使用者邮件信箱： mail</span><br>
	<div class="block2">
		使用 wall, write 毕竟要等到使用者在在线才能够进行，有没有其他方式来联络啊？
		不是说每个 Linux 主机上面的用户都具有一个 mailbox 吗？
		我们可否寄信给使用者啊！呵呵！当然可以啊！我们可以寄、收 mailbox 内的信件呢！
		一般来说， mailbox 都会放置在 /var/spool/mail 里面，一个账号一个 mailbox (档案)。
		举例来说，我的 dmtsai 就具有 /var/spool/mail/dmtsai 这个 mailbox 喔！<br><br>

		那么我该如何寄出信件呢？嗯！就直接使用 mail 这个指令即可！
		这个指令的用法很简单的，直接这样下达：『 
		<span class="text_import2">mail username@localhost -s "邮件标题"</span> 』即可！
		一般来说，如果是寄给本机上的使用者，基本上，连『 @localhost 』都不用写啦！
		举例来说，我以 vbird 寄信给 dmtsai ，信件标题是『 nice to meet you 』，则：<br>

<table class="term"><tbody><tr><td class="term"><pre>[vbird@linux ~]$ <span class="term_command">mail dmtsai -s "nice to meet you"</span>
<span class="term_write">Hello, D.M. Tsai
Nice to meet you in the network.
You are so nice.  byebye!
.</span>   <span class="term_note">&lt;==这里很重要喔，结束时，最后一行输入小数点 . 即可！</span>
Cc:  <span class="term_note">&lt;==这里是所谓的『副本』，不需要寄给其他人，所以直接 [Enter]</span>
[vbird@linux ~]$  <span class="term_note">&lt;==出现提示字符，表示输入完毕了！</span>
</pre></td></tr></tbody></table>

		呼呼！如此一来，你就已经寄出一封信给 dmtsai 这位使用者啰，而且，该信件标题为：
		nice to meet you，信件内容就如同上面提到的。不过，你或许会觉得 mail 这个程序不好用～
		因为在信件编写的过程中，如果写错字而按下 Enter 进入次行，前一行的数据很难删除ㄟ！
		那怎么办？没关系啦！我们使用数据流重导向啊！呵呵！利用那个小于的符号 ( &lt; )
		就可以达到取代键盘输入的要求了。也就是说，你可以先用 vi 将信件内容编好，
		然后再以 mail dmtsai -s "nice to meet you" &lt; filename 来将档案内容传输即可。<br><br>

<table width="90%" border="1" cellpadding="5" cellspacing="0"><tbody><tr><td>
例题：请将你的家目录下的环境变量文件 (~/.bashrc) 寄给自己！<br>
答：<ul>mail -s "bashrc file content" vbird &lt; ~/.bashrc </ul>
</td></tr></tbody></table><br>

		刚刚上面提到的是关于『寄信』的问题，那么如果是要收信呢？呵呵！同样的使用 mail 啊！
		假设我以 dmtsai 的身份登入主机，然后输入 mail 后，会得到什么？<br>

<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@linux ~]$ <span class="term_command">mail</span>
Mail version 8.1 6/6/93.  Type ? for help.
"/var/spool/mail/dmtsai": 1 message 1 new
&gt;N  1 vbird@linux.site  Fri Sep  2 23:53  16/552   "nice to meet you"
&amp;  <span class="term_note">&lt;==这里可以输入很多的指令，如果要查阅，输入 ? 即可！</span>
</pre></td></tr></tbody></table>

		在 mail 当中的提示字符是 &amp; 符号喔，别搞错了～输入 mail 之后，我可以看到我有一封信件，
		这封信件的前面那个 &gt; 代表目前处理的信件，而在大于符号的左边那个 N 代表该封信件尚未读过，
		如果我想要知道这个 mail 内部的指令有哪些，可以在 &amp; 之后输入『 ? 』，就可以看到如下的画面：<br>

<table class="term"><tbody><tr><td class="term"><pre>&amp; <span class="term_command">?</span>
    Mail   Commands
t &lt;message list&gt;                type messages
n                               goto and type next message
e &lt;message list&gt;                edit messages
f &lt;message list&gt;                give head lines of messages
d &lt;message list&gt;                delete messages
s &lt;message list&gt; file           append messages to file
u &lt;message list&gt;                undelete messages
R &lt;message list&gt;                reply to message senders
r &lt;message list&gt;                reply to message senders and all recipients
pre &lt;message list&gt;              make messages go back to /usr/spool/mail
m &lt;user list&gt;                   mail to specific users
q                               quit, saving unresolved messages in mbox
x                               quit, do not remove system mailbox
h                               print out active message headers
!                               shell escape
cd [directory]                  chdir to directory or home if none given
</pre></td></tr></tbody></table>

		&lt;message list&gt; 指的是每封邮件的左边那个数字啦！而几个比较常见的指令是：<br><br>

<table width="95%" bgcolor="lightyellow" border="1" cellpadding="3" cellspacing="0">
<tbody><tr align="center" bgcolor="#182448"><td width="50"><font color="#FFFFFF">指令</font></td><td><font color="#FFFFFF">意义</font></td></tr>
<tr><td align="center">h</td><td>将信件的标题栏出来。如果想要查阅 40 封信件左右处的所有信件标头，可以输入『 h 40 』</td></tr>
<tr><td align="center">d</td><td>删除啦～假设我要删除第10封信，可以『 d10 』，假如我想要删除 20-40 封信，可以『 d20-40 』，
不过，这个动作要生效的话，必须要配合 q 这个指令才行(参考底下说明)！</td></tr>
<tr><td align="center">s</td><td>将信件储存成为档案。举例来说，我要将第 5 封信件的内容存成 ~/mail.file 的话，可以：
『 s 5 ~/mail.file 』喔！</td></tr>
<tr><td align="center">x</td><td>或者输入 exit 都可以。这个是『不作任何动作离开 mail 程序』的意思。
不论你刚刚删除了什么信件，或者读过什么，使用 exit 都会直接离开 mail，所以刚刚进行的删除与阅读工作都会无效。
如果您只是查阅一下邮件而已的话，一般来说，建议使用这个离开啦！除非你真的要删除某些信件。</td></tr>
<tr><td align="center">q</td><td>相对于 exit 是不动作离开， q 则会进行两项动作： 1. 将刚刚删除的信件移出 
mailbox 之外； 2. 将刚刚有阅读过的信件存入 ~/mbox ，且移出 mailbox 之外。鸟哥通常不很喜欢使用 q 离开，
因为，很容易忘记读过什么咚咚～导致信件给他移出 mailbox 说～</td></tr>
</tbody></table><br>

		mail 这个指令内容还有很多可以玩的，不过，我们这里仅是介绍给您如何让一般身份使用者来使用
		mail 而已，所以就介绍到此啰～ ^_^<br>
	</div>
</div>


<hr><a name="manual"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">手动增加使用者：</span><br>
<div class="block1">
	一般来说，我们不很建议大家使用手动的方式来新增使用者，为什么呢？
	因为使用者的建立涉及到 GID/UID 等权限的关系，而且，与档案/目录的权限也有关系，
	使用 useradd 可以帮我们自动设定好 UID/GID 家目录以及家目录相关的权限设定，
	但是，手动来增加的时候，有可能会忘东忘西，结果导致一些困扰的发生。<br><br>

	不过，要了解整个系统，最好还是手动来修改过比较好，至少我们的账号问题可以完全依照自己的意思去修订，
	而不必迁就于系统的默认值啊！但是，还是要告诫一下朋友们，要手动设定账号时，
	您必须要真的很了解自己在作什么，尤其是与权限有关的设定方面喔！
	好吧！底下就让我们来玩一玩啰～ ^_^<br><br>

	<hr><a name="manual_tools"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">一些检查工具</span><br>
	<div class="block2">
		既然要手动修改账号的相关配置文件，那么一些检查群组、账号相关的指令就不可不知道啊～
		尤其是那个密码转换的 pwconv 及 pwuconv 这两个玩意～可重要的很呢！
		底下我们稍微介绍一下这些指令吧！<br><br>

		<a name="pwck"></a><hr><li><span class="text_import1">pwck</span></li>
		<div class="block2">
			pwck 这个指令在检查 /etc/passwd 这个账号配置文件内的信息，与实际的家目录是否存在等信息，
			还可以比对 /etc/passwd /etc/shadow 的信息是否一致，另外，
			如果 /etc/passwd 内的数据字段错误时，会提示使用者修订。
			一般来说，我只是利用这个玩意儿来检查我的输入是否正确就是了。<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">pwck</span>
user adm: directory /var/adm does not exist
user news: directory /etc/news does not exist
user uucp: directory /var/spool/uucp does not exist
</pre></td></tr></tbody></table>

			瞧！上面仅是告知我，这些账号并没有家目录，由于那些账号绝大部分都是系统账号，
			确实也不需要家目录的，所以，那是『正常的错误！』呵呵！不理他。 ^_^。
			相对应的群组检查可以使用 grpck 这个指令的啦！<br><br>
		</div>


		<a name="pwconv"></a><hr><li><span class="text_import1">pwconv</span></li>
		<div class="block2">
			这个指令主要的目的是在『将 /etc/passwd 内的账号与密码，移动到 /etc/shadow 当中！』
			早期的 Unix 系统当中并没有 /etc/shadow 呢，所以，用户的登入密码早期是在 /etc/passwd
			的第二栏，后来为了系统安全，才将密码数据移动到 /etc/shadow 内的。
			使用 pwconv 后，可以：<ul>
			<li>比对 /etc/passwd 及 /etc/shadow ，若 /etc/passwd 内存在的账号并没有对应的
			/etc/shadow 密码时，则 pwconv 会去 /etc/login.defs 取用相关的密码数据，并建立该账号的 
			/etc/shadow 资料；
			</li><li>若 /etc/passwd 内存在加密后的密码数据时，则 pwconv 会将该密码栏移动到
			/etc/shadow 内，并将原本的 /etc/passwd 内相对应的密码栏变成 x ！</li></ul>
			一般来说，如果您正常使用 useradd 增加使用者时，使用 pwconv 
			并不会有任何的动作，因为 /etc/passwd 与 /etc/shadow 并不会有上述两点问题啊！ ^_^。
			不过，如果手动设定账号，这个 pwconv 就很重要啰！<br><br>
		</div>

		<a name="pwunconv"></a><hr><li><span class="text_import1">pwunconv</span></li>
		<div class="block2">
			相对于 pwconv ， pwunconv 则是『将 /etc/shadow 内的密码栏数据写回 /etc/passwd 当中，
			并且删除 /etc/shadow 档案。』这个指令说实在的，最好不要使用啦！
			因为他会将你的 /etc/shadow 删除喔！如果你忘记备份，又不会使用 pwconv 的话，
			粉严重呢！<br><br>
		</div>

		<a name="chpasswd"></a><hr><li><span class="text_import1">chpasswd</span></li>
		<div class="block2">
			chpasswd 是个挺有趣的指令，他可以『读入未加密前的密码，并且经过加密后，
			将加密后的密码写入 /etc/shadow 当中。』这个指令很常被使用在大量建置账号的情况中喔！
			他可以由 Standard input 读入数据，每笔数据的格式是『 username:password 』。
			举例来说，我的系统当中有个用户账号为 dmtsai ，我想要更新他的密码 (update) ，
			假如他的密码是 abcdefg 的话，那么我可以这样做：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">echo "dmtsai:abcdefg" | chpasswd</span>
</pre></td></tr></tbody></table>

			神奇吧！这样就可以更新了呢！在预设的情况中， chpasswd 使用的是 DES 加密方法来加密，
			我们可以使用 chpasswd -m 来使用 FC4 预设的 MD5 加密方法，不过，
			FC4 似乎怪怪的，我老是无法使用 -m 来达成这个指令。无论如何，
			还是可以直接使用 chpasswd 来应用 DES 加密喔！
			使用 DES 方法加密后，在 /etc/shadow 的密码栏内，他的密码位数为 13 位，
			瞭乎？？
		</div>
	</div>

	<hr><a name="manual_normal"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">特殊账号，如纯数字账号的建立</span><br>
	<div class="block2">
		在我们了解了 UID/GID 与账号的关系之后，基本上，您应该了解了，为啥我们不建议使用纯数字的账号了！
		因为很多时候，系统会搞不清楚那组数字是『账号』还是『UID』，这不是很好啦～
		也因此，在早期某些版本底下，是没有办法使用数字来建立账号的。例如在 Red Hat 9 的环境中，
		使用『 useradd 1234 』他会显示『 useradd: invalid user name '1234' 』呼呼！了解了吗？！
		(<span class="text_vbird">不过，这个问题在 FC4 却不存在！因为 FC4 可以建立纯数字的账号说～</span>)<br><br>

		不过，有的时候，长官的命令难为啊～有时还是得要建立这方面的账号的，那该如何是好？
		呵呵！当然可以手动来建立这样的账号啦！不过，为了系统安全起见，鸟哥还是不建议使用纯数字的账号的啦！
		因此，底下的范例当中，我们使用手动的方式来建立一个名为 normaluser 的账号，
		而且这个账号属于 normalgroup 这个群组。OK！那么整个步骤该如何是好呢？
		由前面的说明来看，您应该了解了账号与群组是与 /etc/group, /etc/shadow, /etc/passwd, /etc/gshadow 
		有关，因此，整个动作是这样的：<ol><span class="text_import2">
		<li>先建立所需要的群组 ( vi /etc/group )；
		</li><li>将 /etc/group 与 /etc/gshadow 同步化 ( grpconv )；
		</li><li>建立账号的各个属性 ( vi /etc/passwd )；
		</li><li>将 /etc/passwd 与 /etc/shadow 同步化 ( pwconv )；
		</li><li>建立该账号的密码 ( passwd accountname )；
		</li><li>建立用户家目录 ( cp -a /etc/skel /home/accountname )；
		</li><li>更改用户家目录的属性 ( chown -R accountname.group /home/accountname )。
		</li></span></ol>
		够简单的咯吧！让我们来玩一玩啰～<br>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">1. 建立群组 normalgroup ，假设 520 这个 GID 没有被使用！并且同步化 gshadow</span>
[root@linux ~]# <span class="term_command">vi /etc/group</span>
<span class="term_say"># 在最后一行加入底下这一行！</span>
<span class="term_write">normalgroup:x:520:</span>
[root@linux ~]# <span class="term_command">grpconv</span>
[root@linux ~]# <span class="term_command">grep 'normalgroup' /etc/group /etc/gshadow</span>
/etc/group:normalgroup:x:520:
/etc/gshadow:normalgroup:x::
<span class="term_say"># 简单！搞定群组啰！ ^_^</span>

<span class="term_hd">2. 建立 normaluser 这个账号，假设 UID 700 没被使用掉！</span>
[root@linux ~]# <span class="term_command">vi /etc/passwd</span>
<span class="term_say"># 在最后一行加入底下这一行！</span>
<span class="term_write">normaluser:x:700:520::/home/normaluser:/bin/bash</span>

<span class="term_hd">3. 同步化密码，并且建立该用户的密码</span>
[root@linux ~]# <span class="term_command">pwconv</span>
[root@linux ~]# <span class="term_command">grep 'normaluser' /etc/passwd /etc/shadow</span>
/etc/passwd:normaluser:x:700:520::/home/normaluser:/bin/bash
/etc/shadow:normaluser:x:13030:0:99999:7:::
<span class="term_say"># 呵呵！没错没错！已经建立妥当啰～但是密码还不对～</span>
[root@linux ~]# <span class="term_command">passwd normaluser</span>
Changing password for user normaluser.
New UNIX password:
Retype new UNIX password:
passwd: all authentication tokens updated successfully.

<span class="term_hd">4. 建立用户家目录，并且修订权限！</span>
[root@linux ~]# <span class="term_command">cp -a /etc/skel /home/normaluser</span>
[root@linux ~]# <span class="term_command">chown -R normaluser:normalgroup /home/normaluser</span>
</pre></td></tr></tbody></table>

		别怀疑！这样就搞定了一个账号的设定了！
		从此以后，你可以建立任何名称的账号啰～不过，还是不建议您设定一些很怪很怪的账号名称啦！<br><br>
	</div>

	<hr><a name="manual_pop3"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">不开放终端机登入的账号 
	(ex&gt;mail acccount)</span><br>
	<div class="block2">
		刚刚我们上面建立的这个账号是『可以登入系统的账号』，如果想要建立一个不能登入系统的账号，
		例如单纯使用邮件收发信件而已的账号，那么又该如何设定呢？很简单啦～
		你可以这样想：<ul><span class="text_import2">
		<li>因为不需要登入系统，所以建议 shell 字段给予 /sbin/nologin ；
		</li><li>因为不需要登入，所以家目录也可以先不建立。</li></span></ul>

		也就是说，其实所有的步骤与刚刚上头提到的动作都一样，不过，少掉了很多与家目录有关的设定行为就是了。
		底下我假设我的系统里面有个叫做 mail 的群组 (/etc/group) ，他的 GID 是 12 (以 FC4 为例)，
		另外，这个使用者的账号为 popuser ，假设 UID 为 720 ，那么该如何建立呢？<br>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">1. 修改账号属性</span>
[root@linux ~]# <span class="term_command">vi /etc/passwd</span>
<span class="term_write">popuser:x:720:12::/home/popuser:/sbin/nologin</span>

<span class="term_hd">2. 密码同步，并且给予密码！</span>
[root@linux ~]# <span class="term_command">pwconv</span>
[root@linux ~]# <span class="term_command">passwd popuser</span>
</pre></td></tr></tbody></table>

		这样就又 OK 了～哇！真是太简单了杰克～....<br><br>

		那么又该如何删除这些账号呢？啊！还是建议利用 userdel 啦～简单～干脆又利落～
		如果想要暂时移除而已的话，那么利用 passwd -l 及 passwd -u 吧！ ^_^。
		如果真的那么想要手动来移除这个账号的话，就这样做：<ol><span class="text_import2">
		<li>先以 find / -user account 找出所有的账号档案，并将他删除；
		</li><li>将 /etc/passwd 与 /etc/shadow 的相关资料删除；
		</li><li>将 /etc/group 及 /etc/gshadow 相关资料删除；
		</li><li>将 /home 底下关于该账号的目录删除；
		</li><li>到 /var/spool/mail 以及 /var/spool/cron 里面将相关的使用者档案删除。</li></span></ol>
		这样就手动删除啦～<br><br>
	</div>

	<hr><a name="manual_amount"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">一个大量建置账号的范例</span><br>
	<div class="block2">
		不要怀疑，很多时候，我们都可能需要大量的建置账号的，
		举例来说，学校要帮同学建立他们的账号，那就很可能需要啦～
		一般来说，建立账号要进行的前制工作很多，包括要建立账号名称与该账号的密码对应表～
		这个是最讨厌的啦～而且还要决定需要使用哪一个群组～呼呼～好讨厌的感觉那～<br><br>

		目前很多网站都有提供大量建立账号的工具，例如台南县网中心的卧龙大师：<ul>
		<a href="http://linux.tnc.edu.tw/techdoc/howto/howtouse_cmpwd.htm" target="_blank">http://linux.tnc.edu.tw/techdoc/howto/howtouse_cmpwd.htm</a></ul>
		提供的好用的 cmpwd 程序，
		不过，其实我们也可以利用简单的 script 来帮我们达成喔！例如底下这支程序，
		他的执行结果与卧龙大师提供的程序差不多啦～
		但是因为我是直接以 useradd 来新增的，
		所以，即使不了解 UID ，也是可以适用的啦～<br><br>

		整支程序的特色是：<ul>
		<li>默认不允许使用纯数字方式建立账号；
		</li><li>可加入年级来区分账号；
		</li><li>可设定账号的起始号码与账号数量；
		</li><li>有两种密码建立方式，可以与账号相同或程序自行以随机数建立密码文件。</li></ul>
		执行方法也简单的要命～请自行参考的啦！不再多说～
		使用时请注意，不要在公家使用的主机上面进行测试，因为.....
		这支程序会大量建立账号嘛！^_^<br>

<table class="term"><tbody><tr><td class="term"><pre>#!/bin/bash
#
# 这支程序主要在帮您建立大量的账号之用，
# 更多的使用方法请参考：
# http://linux.vbird.org/linux_basic/0410accountmanager.php#manual_amount
#
# 本程序为鸟哥自行开发，在 FC4 上使用没有问题，
# 但不保证绝不会发生错误！使用时，请自行负担风险～
#
# History:
# 2005/09/05    VBird   刚刚才写完，使用看看先～
PATH=/sbin:/usr/sbin:/bin:/usr/bin; export PATH
accountfile="user.passwd"

# 1. 进行账号相关的输入先！
read -p "账号开头代码 ( Input title name, ex&gt; std )======&gt; " username_start
read -p "账号层级或年级 ( Input degree, ex&gt; 1 or enter )=&gt; " username_degree
read -p "起始号码 ( Input start number, ex&gt; 520 )========&gt; " nu_start
read -p "账号数量 ( Input amount of users, ex&gt; 100 )=====&gt; " nu_amount
read -p "密码标准 1) 与账号相同 2)随机数自定义 ==============&gt; " pwm
if [ "$username_start" == "" ]; then
        echo "没有输入开头的代码，不给你执行哩！" ; exit 1
fi
testing1=`echo $nu_amount | grep '[^0-9]' `
testing2=`echo $nu_start  | grep '[^0-9]' `
if [ "$testing1" != "" ] || [ "$testing2" != "" ]; then
        echo "输入的号码不对啦！有非为数字的内容！" ; exit 1
fi
if [ "$pwm" != "1" ]; then
        pwm="2"
fi

# 2. 开始输出账号与密码档案！
[ -f "$accountfile" ] &amp;&amp; mv $accountfile "$accountfile"`date +%Y%m%d`
nu_end=$(($nu_start+$nu_amount-1))
for (( i=$nu_start; i&lt;=$nu_end; i++ ))
do
        account=$username_start$username_degree$i
        if [ "$pwm" == "1" ]; then
                password="$account"
        else
                password=""
                test_nu=0
                until [ "$test_nu" == "8" ]
                do
                        temp_nu=$(($RANDOM*50/32767+30))
                        until [ "$temp_nu" != "60" ]
                        do
                                temp_nu=$(($RANDOM*50/32767+30))
                        done
                        test_nu=$(($test_nu+1))
                        temp_ch=`printf "\x$temp_nu"`
                        password=$password$temp_ch
                done
        fi
        echo "$account":"$password" | tee -a "$accountfile"
done

# 3. 开始建立账号与密码！
        cat "$accountfile" | cut -d':' -f1 | xargs -n 1 useradd -m
        chpasswd &lt; "$accountfile"
        pwconv
	echo "OK！建立完成！"
</pre></td></tr></tbody></table>

		这支程序可以在底下链接下载：
		<ul><a href="http://linux.vbird.org/download/index.php?action=download&amp;fileid=70" target="_blank">http://linux.vbird.org/download/index.php?action=download&amp;fileid=70</a></ul>

	</div>
</div>


<hr><a name="FAQ"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">本章习题练习</span><br>
( 要看答案请将鼠标移动到『答：』底下的空白处，按下左键圈选空白处即可察看 )
<div class="block1">
<ul>
	<li>root 的 UID 与 GID 是多少？而基于这个理由，我要让 test 这个账号具有 root 的权限，应该怎么作？</li>
	<div class="block2"><font color="white" size="-1">
		root 的 UID 与 GID 均为 0 ，所以要让 test 变成 root 的权限，那么就将 /etc/passwd 里面， 
		test 的 UID 与 GID 字段变成 0 即可！
	</font></div>

	<li>假设我是一个系统管理员，我有一个用户最近不乖，所以我想暂时将他的账号停掉，
	让他近期无法进行任何动作，等到未来他乖一点之后，我再将他的账号启用，请问：我可以怎么作比较好？？</li>
	<div class="block2"><font color="white" size="-1">
		由于这个账号是暂时失效的，所以不能使用 userdel
		来删除，否则很麻烦！那么应该如何设定呢？再回去瞧一瞧 /etc/shadow 
		的架构，可以知道有这几个可使用的方法：</font><ul>
<font color="white" size="-1">		<li>将 /etc/passwd 的 shell 字段写成 /sbin/nologin ，即可让该账号暂时无法登入主机；
		</li><li>&gt;将 /etc/shadow 内的密码字段，增加一个 * 号在最前面，这样该账号亦无法登入！
		</li><li>&gt;将 /etc/shadow 的第八个字段关于账号取消日期的那个，设定小于目前日期的数字，那么他就无法登入系统了！
		</li></font></ul>
<font color="white" size="-1">	</font></div>

	<li>在设定密码的时候，是否可以随便设定呢？</li>
	<div class="block2"><font color="white" size="-1">
		最好不要随便设定密码！最好可以仔细的参考一下本章内容提到的部分！
	</font></div>

	<li>我在使用 useradd 的时候，新增的账号里面的 UID, GID 还有其他相关的密码控制，都是在哪几个档案里面设定的？</li>
	<div class="block2"><font color="white" size="-1">
		在 /etc/login.defs 还有 /etc/default/useradd 里面规定好的！
	</font></div>

	<li>我希望我在设定每个账号的时候( 使用 useradd )，预设情况中，他们的家目录就含有一个名称为
	www 的子目录，我应该怎么作比较好？</li>
	<div class="block2"><font color="white" size="-1">
		由于使用 useradd 的时候，会自动以 /etc/skel 做为默认的家目录，所以，我可以在
		/etc/skel 里面新增加一个名称为 www 的目录即可！
	</font></div>

	<li>pwconv 这个指令有什么功能呢？</li>
	<div class="block2"><font color="white" size="-1">
		pwconf 可以让 passwd 里面的账号，设定一份密码到 /etc/shadow 当中！
	</font></div>

	<li>简单说明系统账号与一般用户账号的差别？</li>
	<div class="block2"><font color="white" size="-1">
		一般而言，为了让系统能够顺利以较小的权限运作，系统会有很多账号，
		例如 mail, bin, adm 等等。而为了确保这些账号能够在系统上面具有独一无二的权限，
		一般来说 Linux 都会保留一些 UID 给系统使用。在 FC4 上面，小于 500 
		以下的账号 (UID) 即是所谓的 System account。
	</font></div>

	<li>简单说明，为何 FC4 建立使用者时，他会主动的帮使用者建立一个群组，而不是使用 /etc/default/useradd 的设定？</li>
	<div class="block2"><font color="white" size="-1">
		不同的 linux distributions 对于使用者 group 的建立机制并不相同。主要的机制分为：</font><ul>
<font color="white" size="-1">		<li>Public group schemes: 用户将会直接给予一个系统指定的群组，一般来说即是 users ，
			可以 SuSE Server 9 为代表；
		</li><li>Private group schemes: 系统会建立一个与账号一样的组名！以 FC4 为例！</li></font></ul>
<font color="white" size="-1">	</font></div>

	<li>如何建立一个使用者名称 alex, 他所属群组为 alexgroup, 预计使用 csh, 他的全名为 "Alex Tsai"，
	且他还得要加入 users 群组当中！</li>
	<div class="block2"><font color="white" size="-1">
		groupadd alexgroup<br>
		useradd -c "Alex Tsai" -g alexgroup -G users -m alex<br>
		务必先建立群组，才能够建立使用者喔！
	</font></div>

	<li>由于种种因素，导致你的用户家目录以后都需要被放置到 /account 这个目录下。
	请问，我该如何作，可以让使用 useradd 时，默认的家目录就指向 /account ？</li>
	<div class="block2"><font color="white" size="-1">
		最简单的方法，编辑 /etc/default/useradd ，将里头的 HOME=/home 改成 HOME=/account 即可。
	</font></div>

	<li>我想要让 dmtsai 这个使用者，加入 vbird1, vbird2, vbird3 这三个群组，该如何动作？</li>
	<div class="block2"><font color="white" size="-1">
		usermod -G vbird1,vbird2,vbird3 dmtsai
	</font></div>
</ul>
</div>

<hr><span class="text_history">
2002/05/15：第一次完成<br>
2003/02/10：重新编排与加入 FAQ<br>
2005/08/25：加入一个大量建置账号的实例，简单说明一下而已！<br>
2005/08/29：将原本的旧文放置到 <a href="http://linux.vbird.org/linux_basic/0410accountmanager/0410accountmanager.php">此处</a><br>
2005/08/31：因为 <a href="http://linux.vbird.org/linux_basic/0410accountmanager/0410accountmanager.php#userconf">userconf</a> 
	    已经不再这么好用了，使用指令模式比较简单，所以，将他拿掉了～<br>
2005/09/05：终于将大量建置账号的那支程序写完了～真是高兴啊！<br>
2006/03/02：更新用户 UID 号码，由 65535 升级到 2^32-1 这么大！<br>
2007/04/15：原本写的 /etc/pam.d/limits.conf 错了！应该是 <a href="#20070415">/etc/security/limits.conf</a> 才对！<br>
2008/04/28：sudo 关于密码重新输入的部分写错了！已经更新，在<a href="#20080426">这里</a>查阅看看。感谢网友 superpmo 的告知！<br>
hint：请加入 ACL ，并将篇名改为『Linux 账号管理与进阶权限设定』含 SELinux 与 ACL 的处理吧！<hr>
</span>
    </td>
    <td style="width: 16px; font-size: 6px;">　</td></tr>
<tr><td style="width: 16px; height: 16px;">　</td>
    <td style="width: 688px; height: 16px;">　</td>
    <td style="width: 16px; height: 16px;">　</td></tr>
</tbody></table>

<div style="padding-top: 0px; text-align: center;">
<span style="font-size: 80%;">
	<a href="http://linux.vbird.org/" target="_top" title="前往鸟哥的首页">http://linux.vbird.org</a>
	is designed by <a href="mailto:vbird@mail.vbird.idv.tw" title="联络鸟哥(我不要广告信！)">VBird</a>
		during 2001-2011. <a href="http://www.ksu.edu.tw/" target="_blank">ksu.edu</a></span>
                ﻿<div id="apDiv4">
      <p>本网页主要以Firefox配合解析度 1024x768 作为设计依据&nbsp;&nbsp;&nbsp;&nbsp; 鸟哥自由软件整合应用研究室</p></div></div></div>
</center>
</body></html>
