<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="zh-TW"><head>


	<meta http-equiv="Content-Type" content="text/html; charset=utf8">
	<meta name="Author" content="VBird, 鸟哥">
	<meta name="Description" content="介绍正规表示法的应用与相关技巧">
	<title>鸟哥的 Linux 私房菜 -- 正规表示法</title>
    <script src="../../script/SpryMenuBar.js" type="text/javascript"></script>
	<script src="../../script/index.js" type="text/javascript"></script>
	<link href="../../css/SpryMenuBarHorizontal.css" rel="stylesheet" type="text/css" />
    <link href="../../css/main.css" rel="stylesheet" type="text/css" />
</head><body style="margin: 0pt; padding: 0pt;" class="table"onload="MM_preloadImages('../../index-2.html','../../index-2.html','../../index-2.html','../../index-2.html','../../index-2.html','../../index-2.html','../../index-2.html','../../index-2.html')">

<center>
<div id="apDiv5">
<div> <LINK REL="SHORTCUT ICON" HREF="../../index-2.html">
<!-- ImageReady Slices (title3.ai) -->
<table id="___01" width="898" height="81" border="0" align="center" cellpadding="0" cellspacing="0";>
	<tr>
		<td colspan="15">
			<img src="image/title/title_01.png" width="900" height="1" alt=""></td>
	</tr>
	<tr>
		<td rowspan="4" bgcolor="#182448"><p><img src="http://linux.vbird.org/cgi-bin/Count.cgi?dd=C&amp;ft=5&amp;sh=T&amp;md=8&amp;pad=Y&amp;df=vbird.dic.ksu.edu.tw.dat" width="93" align="left" title="計數器" /></p>
	    <p><font color="#FFFFFF" size="-1">since2012/04/23</font></p></td>
		<td rowspan="4" align="left" valign="top"><a href="../../index.html"><img src="image/title/title_03.png" alt="" width="263" height="79" border="0"></a></td>
		<td colspan="13">
			<img src="image/title/title_04.png" alt="" width="535" height="9" border="0"></td>
	</tr>
	<tr>
		<td rowspan="3">
			<img src="image/title/title_05.png" alt="" width="53" height="70" border="0"></td>
		<td colspan="2" align="left" valign="top"><a href="../0110whatislinux.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image51','','image/title/title_06.png',1)"><img src="image/title/title3_06.png" name="Image51" width="106" height="25" border="0" id="Image51" alt=""/></a></td>
		<td rowspan="2">
			<img src="image/title/title_07.png" alt="" width="27" height="37" border="0"></td>
		<td colspan="3" align="left" valign="top"><a href="../../linux_server/0110network_basic.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image52','','image/title/title_08.png',1)"><img src="image/title/title3_08.png" name="Image52" width="107" height="25" border="0" id="Image52" alt=""/></a></td>
		<td rowspan="2">
			<img src="image/title/title_09.png" alt="" width="37" height="37" border="0"></td>
		<td colspan="2" align="left" valign="top"><a href="../../about.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image53','','image/title/title_10.png',1)"><img src="image/title/title3_10.png" name="Image53" width="75" height="25" border="0" id="Image53" alt=""/></a></td>
		<td rowspan="3">
			<img src="image/title/title_11.png" alt="" width="35" height="70" border="0"></td>
		<td align="left" valign="top"><a href="mailto:vbird@mail.vbird.idv.tw" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image54','','image/title/title_12.png',1)"><img src="image/title/title3_12.png" name="Image54" width="74" height="25" border="0" id="Image54" alt=""/></a></td>
		<td rowspan="3">
			<img src="image/title/title_13.png" alt="" width="21" height="70" border="0"></td>
	</tr>
	<tr>
		<td colspan="2">
			<img src="image/title/title_14.png" alt="" width="106" height="12" border="0"></td>
		<td colspan="3">
			<img src="image/title/title_15.png" alt="" width="107" height="12" border="0"></td>
		<td colspan="2">
			<img src="image/title/title_16.png" width="75" height="12" alt=""></td>
		<td rowspan="2">
			<img src="image/title/title_17.png" alt="" width="74" height="45" border="0"></td>
	</tr>
	<tr>
		<td>
			<img src="image/title/title_18.png" alt="" width="15" height="33" border="0"></td>
		<td colspan="3" align="left" valign="top"><ul id="MenuBar1" class="MenuBarHorizontal">
	  <li><a href="../linux_basic.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image44','','image/title/title_19.png',1)"><img src="image/title/title3_19.png" name="Image44" width="123" height="33" border="0" id="Image44" /></a>
			    <ul>
			      <li><a href="../Mandrake9.0/mandrake9.0.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image46','','image/title/title_26.png',1)"><img src="image/title/title_23.png" name="Image46" width="120" height="26" border="0" id="Image46" alt="" /></a></li>
                  <li><a href="fc4.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image47','','image/title/title_27.png',1)"><img src="image/title/title_24.png" name="Image47" width="120" height="26" border="0" id="Image47" alt="" /></a></li>
                  <li><a href="../linux_basic.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image48','','image/title/title_28.png',1)"><img src="image/title/title_25.png" name="Image48" width="120" height="26" border="0" id="Image48" alt="" /></a></li>
                </ul>
		      </li>
		</ul></td>
		<td>
			<img src="image/title/title_20.png" alt="" width="42" height="33" border="0"></td>
		<td colspan="3" align="left" valign="top"><ul id="MenuBar2" class="MenuBarHorizontal">
	  <li><a href="../../linux_server/index.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image45','','image/title/title_21.png',1)"><img src="image/title/title3_21.png" name="Image45" width="125" height="33" border="0" id="Image45" /></a>
			    <ul>
			      <li><a href="../../linux_server/linux_redhat9/redhat9.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image43','','image/title/title_26.png',1)"><img src="image/title/title_23.png" name="Image43" width="120" height="26" border="0" id="Image43" alt=""/></a></li>
			      <li><a href="../../linux_server/centos4.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image49','','image/title/title_27.png',1)"><img src="image/title/title_24.png" name="Image49" width="120" height="26" border="0" id="Image49" alt="" /></a></li>
			      <li><a href="../../linux_server/index.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image50','','image/title/title_28.png',1)"><img src="image/title/title_25.png" name="Image50" width="120" height="26" border="0" id="Image50" alt="" /></a></li>
		        </ul>
		      </li>
		</ul></td>
		<td>
			<img src="image/title/title_22.png" alt="" width="47" height="33" border="0"></td>
	</tr>
	<tr>
		<td>
			<img src="image/title/Spacer.gif" width="101" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="263" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="53" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="15" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="91" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="27" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="5" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="42" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="60" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="37" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="28" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="47" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="35" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="74" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="22" height="1" alt=""></td>
	</tr>
</table>
<!-- End ImageReady Slices -->
<script type="text/javascript">
<!--
var MenuBar1 = new Spry.Widget.MenuBar("MenuBar1", {imgDown:"SpryAssets/SpryMenuBarDownHover.gif", imgRight:"SpryAssets/SpryMenuBarRightHover.gif"});
var MenuBar2 = new Spry.Widget.MenuBar("MenuBar2", {imgDown:"SpryAssets/SpryMenuBarDownHover.gif", imgRight:"SpryAssets/SpryMenuBarRightHover.gif"});
//-->
</script>
</div>
<table summary="本文内容的排版" style="width: 898px;" border="0" cellpadding="0" cellspacing="0">
<tbody><tr><td style="width: 16px; height: 16px;">　</td>
    <td style="width: 866px; height: 16px;">　</td>
    <td style="width: 16px; height: 16px;">　</td></tr>
<tr><td style="width: 16px; font-size: 6px;">　</td>
    <td width="866">

<!-- 本文的档头部分 -->
<div style="text-align: center;">
    <a href="http://linux.vbird.org/linux_basic/0330regularex/0330regularex-fc4.php">
    <span class="text_head0">正规表示法<span class="text_head_en"> Regular Expression, RE</span></span></a><br>
</div>
    <div style="text-align: right;">
        <span class="text_history">最近更新日期：2006/10/05</span>
    </div>

<center>本文已不再维护，更新文章请参考<a href="http://linux.vbird.org/linux_basic/0330regularex.php">此处</a></center>
<!-- 本文的档头部分 -->
<center><table class="head1" summary="排版：文章档头的说明"><tbody><tr><td class="head1">
	正规表示法(或称为常规表示法)是透过一些特殊字符的排列，用以 搜寻/取代/删除 一列或多列文字字符串，
	简单的说，正规表示法就是用在字符串的处理上面的一项『表示式』。正规表示法并不是一个工具程序，
	而是一个字符串处理的标准依据，如果您想要以正规表示法的方式处理字符串，就得要使用支持正规表示法的工具程序才行，
	这类的工具程序很多，例如 vi, sed, awk 等等。<br><br>

	正规表示法对于系统管理员来说，实在是很重要。因为系统会产生很多的讯息，这些讯息有的重要，有的仅是告知，
	此时，管理员可以透过正规表示法的功能来将重要讯息撷取出来，并产生便于查阅的报表，简化管理流程。此外，
	很多的软件包也都支持正规表示法的分析，例如邮件服务器的过滤机制(过滤垃圾信件)就是很重要的一个例子。
	所以，您最好要了解正规表示法的相关技能，在未来管理主机时，才能够更精简处理您的日常事务！<br><br>

	注：本章节使用者需要多加练习，因为目前很多的套件都是使用正规表示法来达成其『过滤、分析』的目的，
	为了未来主机管理的便利性，使用者至少要能看的懂正规表示法的意义！
</td></tr></tbody></table></center>

<!-- 本文的连结区部分 -->
<div class="block1">
<span class="text_h1">
1. <a href="#before">前言：</a><br>
2. <a href="#basic_regexp">基础正规表示法：</a><br>
	<span class="text_h2">
	　　2.1 <a href="#grep">以 grep 撷取字符串</a><br>
	　　2.2 <a href="#basic_regexp_char">重要特殊字符(characters)</a><br>
	</span>
3. <a href="#extend">延伸正规表示法：</a><br>
4. <a href="#printf">格式化打印： printf</a><br>
5. <a href="#sed">sed 工具简介</a><br>
6. <a href="#awk">awk 工具简介</a><br>
7. <a href="#doc">文件数据比对与打印的相关功能</a><br>
	<span class="text_h2">
	　　7.1 <a href="#doc_compare">档案比对：</a> <a href="#diff">diff</a>, <a href="#cmp">cmp</a>, 
		<a href="#patch">patch</a><br>
	　　7.2 <a href="#pr">档案打印准备： pr</a><br>
	</span>
8. <a href="#important">重点回顾</a><br>
9. <a href="#reference">参考资源</a><br>
10.<a href="#FAQ">本章习题练习</a><br>
<span class="text_h2">
11. <a href="http://phorum.vbird.org/viewtopic.php?t=23885" target="_blank">针对本文的建议：http://phorum.vbird.org/viewtopic.php?t=23885</a>
</span>
</span>
</div>

<!-- 本文的正式部分 -->
<hr><a name="before"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">前言</span><br>
<div class="block1">
	约略了解了 Linux 的基本指令 ( <a href="http://linux.vbird.org/linux_basic/0330regularex/0320bash.php">Shell</a> ) 并且熟悉了
	<a href="http://linux.vbird.org/linux_basic/0330regularex/0310vi.php">vi</a> 之后，相信您对于敲击键盘与指令比较不陌生了吧？？
	接下来，底下要开始介绍一个很重要的观念，那就是所谓的『<span class="text_import2">正规表示法</span>』啰！<br><br>

	<hr><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">什么是正规表示法</span><br>
	<div class="block2">
		任何一个有经验的系统管理员，都会告诉您：『<span class="text_import2">正规表示法真是挺重要的</span>！』
		为什么很重要呢？因为日常生活就使用的到啊！举个例子来说，
		在您日常处理文书作业时，应该会常常使用到『搜寻/取代』等等的功能吧？
		这些举动要作的漂亮，就是正规表示法的工作了！<br><br>

		<span class="text_import2">简单的说，正规表示法就是处理字符串的方法，他是以行为单位，
		来进行字符串的处理行为，他透过一些特殊符号的辅助，可以让使用者轻易的达到 搜寻/取代
		某特定字符串的处理程序！</span><br><br>

		举例来说，我要找到 VBird 或 Vbird 这个字样，但是不要其他的字符串，该如何办理？
		如果在没有正规表示法的环境中(例如 MS word)，您或许就得要使用忽略大小写的办法，
		或者是分别以 VBird 及 Vbird 搜寻两遍。但是，忽略大小写可能会搜寻到 VBIRD/vbird/VbIrD 
		等等的不需要的字符串，而造成用户的困扰。<br><br>

		再举个系统常见的例子好了，假设妳发现系统在开机的时候，老是会出现一个关于 mail 程序的错误，
		而开机过程的相关程序都是在 /etc/rc.d/ 底下，也就是说，在该目录底下的某个档案内具有 mail 
		这个关键词，好了，此时，您怎么找出来含有这个关键词的档案？？您当然可以一个档案一个档案的开启，
		然后去搜寻 mail 这个关键词，只是.....该目录底下的档案可能不止 100 个说～
		如果了解正规表示法的相关技巧，那么只要一行指令就找出来啦！ 『grep 'mail' /etc/rc.d/*』
		那个 grep 就是支持正规表示法的工具程序之一！如何～很简单吧！ ^_^y<br><br>

		谈到这里就得要进一步说明了，正规表示法基本上是一种『表示法』，
		只要工具程序支持这种表示法，那么该工具程序就可以用来作为正规表示法的字符串处理之用。
		也就是说，例如 vi, grep, awk ,sed 等等工具，因为她们有支持正规表示法，
		所以，这些工具就可以使用正规表示法的特殊字符来进行字符串的处理。
	</div>

	<hr><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">正规表示法对于系统管理员的用途</span><br>
	<div class="block2">
		那么为何我需要学习正规表示法呢？对于一般使用者来说，由于使用到正规表示法的机会可能不怎么多，
		因此感受不到他的魅力，不过，对于身为系统管理员的您来说，
		<span class="text_import2">正规表示法则是一个『不可不学的好东西！</span>』
		怎么说呢？由于系统如果在繁忙的情况之下，每天产生的讯息信息会多到你无法想象的地步，
		而我们也都知道，系统的『<a href="http://linux.vbird.org/linux_basic/0330regularex/0570syslog.php">错误讯息登录档案</a>』
		的内容(这部份我们在第五篇会详谈)记载了系统产生的所有讯息，当然，
		这包含你的系统是否被『入侵』的纪录数据。<br><br>

		但是系统的数据量太大了，要身为系统管理员的你每天去看这么多的讯息数据，
		从千百行的资料里面找出一行有问题的讯息，呵呵～光是用肉眼去看，想不疯掉都很难！
		这个时候，我们就可以透过『正规表示法』的功能，将这些登录的信息进行处理，
		仅取出『有问题』的信息来进行分析，哈哈！如此一来，你的系统管理工作将会
		『快乐得不得了』啊！当然，正规表示法的优点还不止于此，等您有一定程度的了解之后，您会爱上他喔！
	</div>

	<hr><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">正规表示法的广泛用途</span><br>
	<div class="block2">
		正规表示法除了可以让系统管理员管理主机更为便利之外，事实上，
		由于正规表示法强大的字符串处理能力，目前一堆软件都支持正规表示法呢！
		最常见的就是『邮件服务器』啦！<br><br>

		如果您留意因特网上的消息，那么应该不能发现，目前造成网络大塞车的主因之一就是『垃圾/广告信件』了，
		而如果我们可以在主机端，就将这些问题邮件剔除的话，客户端就会减少很多不必要的带宽耗损了。
		那么如何剔除广告信件呢？由于广告信件几乎都有一定的标题或者是内容，因此，
		只要每次有来信时，都先将来信的标题与内容进行特殊字符串的比对，发现有不良信件就予以剔除！
		嘿！这个工作怎么达到啊？就使用正规表示法啊！目前两大邮件服务器软件 sendmail 与 postfix 
		以及支持邮件服务器的相关分析套件，都支持正规表示法的比对功能！<br><br>

		当然还不止于此啦，很多的服务器软件、以及套件都支持正规表示法呢！当然，
		虽然各家软件都支持他，不过，这些『字符串』的比对还是需要系统管理员来加入比对规则的，
		所以啦！身为系统管理员的你，为了自身的工作以及客户端的需求，
		正规表示法实在是很需要也很值得学习的一项工具呢！
	</div>

	<hr><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">正规表示法与 Shell 在 Linux 当中的角色定位</span><br>
	<div class="block2">
		说实在的，我们在学数学的时候，一个很重要、但是粉难的东西是一定要『背』的，
		那就是九九表，背成功了之后，未来在数学应用的路途上，真是一帆风顺啊！
		这个九九表我们在小学的时候几乎背了一整年才背下来，并不是这么好背的呢！
		但他却是基础当中的基础！您现在一定受惠相当的多呢 ^_^！

		而我们谈到的这个正规表示法，与前一章的 <a href="http://linux.vbird.org/linux_basic/0330regularex/0320bash.php">BASH shell</a> 
		就有点像是数学的九九表一样，是 Linux 基础当中的基础，虽然也是最难的部分，
		不过，如果学成了之后，一定是『大大的有帮助』的！这就好像是金庸小说里面的学武难关，
		任督二脉，打通任督二脉之后，武功立刻成倍成长！所以啦，
		不论是对于系统的认识与系统的管理部分，他都有很棒的辅助啊！请好好的学习这个基础吧！ ^_^
	</div>

	<hr><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">延伸的正规表示法</span><br>
	<div class="block2">
		正规表示法除了简单的一组字符串处理之外，还可以作群组的字符串处理，
		例如进行搜寻 VBird 或 netman 或 lman 的搜寻，注意，是『或(or)』而不是『和(and)』的处理，
		此时就需要延伸正规表示法的帮助啦！藉由特殊的 ( 与 | 等字符的协助，
		就能够达到这样的目的！好啦！清清脑门，咱们用功去啰！
	</div>

	<div style="padding: 10pt 0pt;" align="right"><table width="90%"><tbody><tr><td><b>Tips:</b><br><span style="color: rgb(0, 144, 0);"><font size="-1">		有一点要向大家报告的，那就是：『<b>正规表示法与通配符是不一样的东西！</b>』
		这很重要喔！因为通配符 (wildcard) 所代表的意义与正规表示法并不相同～
		要分的很清楚才行喔！所以，学习本章，请将前一章 bash 的通配符意义先忘掉吧！
	</font></span></td><td><img src="0330regularex-fc4_files/vbird_face.gif" alt="鸟哥的图示" title="鸟哥的图示"></td></tr></tbody></table></div></div>

<hr><a name="basic_regexp"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">基础正规表示法</span><br>
<div class="block1">
	既然正规表示法是处理字符串的一个标准表示方式，他需要支持的工具程序来辅助，
	所以，我们这里就先介绍一个最简单的字符串撷取功能的工具程序，那就是 grep 啰！
	在介绍完 grep 的基本功能之后，就进入正规表示法的特殊字符的处理能力了。<br><br>

	<hr><a name="grep"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">以 grep 撷取字符串</span><br>
	<div class="block2">
		既然要使用 grep 当然就得要先了解一下 grep 的语法啰～<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@test root]# <span class="term_command">grep [-acinv] '搜寻字符串' filename</span>
<span class="term_say">参数说明：</span>
<span class="term_say">-a ：将 binary 档案以 text 档案的方式搜寻数据
-c ：计算找到 '搜寻字符串' 的次数
-i ：忽略大小写的不同，所以大小写视为相同
-n ：顺便输出行号
-v ：反向选择，亦即显示出没有 '搜寻字符串' 内容的那一行！
--color=auto 可将正确的那个撷取数据列出颜色</span>
<span class="term_say">范例：</span>
[root@test root]# <span class="term_command">grep 'root' /var/log/secure</span>
<span class="term_say">将 /var/log/secure 这个档案中有 root 的那一行秀出来</span>

[root@test root]# <span class="term_command">grep -v 'root' /var/log/secure</span>
<span class="term_say">若该行没有 root 才将数据秀出来到屏幕上！</span>

[root@test root]# <span class="term_command">last | grep root</span>
<span class="term_say">若该行有 root 才将数据秀出来到屏幕上！</span>
</pre></td></tr></tbody></table>

		grep 是一个很常见也很常用的指令，他最重要的功能就是进行字符串数据的比对，
		然后将符合用户需求的字符串打印出来。
		需要说明的是『<span class="text_import2">grep 在资料中查寻一个字符串时，是以 "整行"
		为单位来进行数据的撷取的！</span>』也就是说，假如一个档案内有 10 
		行，其中有两行具有你所搜寻的字符串，则将那两行显示在屏幕上，其他的就丢弃了！<br><br>

		而 grep 除了可以进行档案的资料搜寻之外，也常常被应用在 input/output 
		的数据处理当中，例如常见的 <a href="http://linux.vbird.org/linux_basic/0330regularex/0320bash.php#pipe">管线命令 ( pipe )</a> 就可以常常见到他的踪影！
		以上面表格中的例子来看，我们可以发现前两个例子是查寻档案的内容，有没有加上 -v 
		所显示出来的结果是『相反的！』，而第三个例子则是以 pipe 的功能进行数据的处理的喔！<br><br>

		好了，我们就开始以 grep 来进行正规表示法的简易说明吧！我们先以底下这个档案来作为范例：<br>

<table class="term"><tbody><tr><td class="term">
[root@test root]# <span class="term_command">vi regular_express.txt</span><br>
"Open Source" is a good mechanism to develop programs.<br>
apple is my favorite food.<br>
Football game is not use feet only.<br>
this dress doesn't fit me.<br>
However, this dress is about $ 3183 dollars.
<br>
GNU is free air not free beer.
<br>
Her hair is very beauty.
<br>
I can’t finish the test.
<br>
Oh! The soup taste good.
<br>
motorcycle is cheap than car.<br>
This window is clear.<br>
the symbol '*' is represented as start.<br>
Oh!	My god!<br>
The gd software is a library for drafting programs.
<br>
You are the best is mean you are the no. 1.<br>
The world <happy> is the same with "glad".<br>
I like dog.<br>
google is the best tools for search keyword.<br>
goooooogle yes!<br>
go! go! Let's go.<br>
# I am VBird<br>
<br>
</happy></td></tr></tbody></table>

		需要特别注意的是，上面这个档案鸟哥是在 Windows 的环境下编辑的，
		并且经过特殊处理过，因此，他虽然是纯文本档，但是内含一些 Windows 
		环境下的软件常常自行加入的一些特殊字符，例如断行字符(^M)就是一例！
		所以，您可以直接将上面的文字以 vi 储存成 regular_express.txt 这个档案，
		不过，比较建议直接点底下的连结下载：<ul>
		<a href="http://linux.vbird.org/linux_basic/0330regularex/0330regularex/regular_express.txt">http://linux.vbird.org/linux_basic/0330regularex/regular_express.txt</a></ul>
		此外，因为不同的语系编码是不一样的，所以，您必须要将语系改成英文语系，
		才能够进行底下的测试，否则，可能会有显示的内容与底下的输出不符的状况喔！
		修改语系的方法为：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@test root]# <span class="term_command">LANG=en</span>
[root@test root]# <span class="term_command">export LANG</span>
</pre></td></tr></tbody></table>

好了，现在开始我们一个案例一个案例的来介绍吧！<br>
		<ul>

		<li><span class="text_import1">例题一、搜寻特定字符串：</span><br>
			搜寻特定字符串很简单吧？假设我们要从刚刚的档案当中取得 the 这个特定字符串，
			最简单的方式就是这样：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@test root]# <span class="term_command">grep -n 'the' regular_express.txt</span>
8:I can't finish <span class="term_note_b">the</span> test.
12:<span class="term_note_b">the</span> symbol '*' is represented as start.
15:You are <span class="term_note_b">the</span> best is mean you are the no. 1.
16:The world <happy> is <span class="term_note_b">the</span> same with "glad".
18:google is <span class="term_note_b">the</span> best tools for search keyword.
</happy></pre></td></tr></tbody></table>

			那如果想要『<span class="text_import2">反向选择</span>』呢？也就是说，当该行没有 
			'the' 这个字符串时，才显示在屏幕上，那就直接使用：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@test root]# <span class="term_command">grep -vn 'the' regular_express.txt</span>
</pre></td></tr></tbody></table>

			您会发现，屏幕上出现的行列为除了 8,12,15,16,18 五行之外的其他行列！
			接下来，如果您想要取得不论大小写的 the 这个字符串，则：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@test root]# <span class="term_command">grep -in 'the' regular_express.txt</span>
8:I can't finish <span class="term_note_b">the</span> test.
9:Oh! <span class="term_note_b">The</span> soup taste good.
12:<span class="term_note_b">the</span> symbol '*' is represented as start.
14:<span class="term_note_b">The</span> gd software is a library for drafting programs.
15:You are <span class="term_note_b">the</span> best is mean you are the no. 1.
16:<span class="term_note_b">The</span> world <happy> is <span class="term_note_b">the</span> same with "glad".
18:google is <span class="term_note_b">the</span> best tools for search keyword.
</happy></pre></td></tr></tbody></table>
		</li><br>

		<li><span class="text_import1">例题二、利用 [] 来搜寻集合字符</span><br>
			如果我想要搜寻 test 或 taste 这两个单字时，可以发现到，其实她们有共通的 't?st'
			存在～这个时候，我可以这样来搜寻：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@test root]# <span class="term_command">grep -n 't[ae]st' regular_express.txt</span>
8:I can't finish the <span class="term_note_b">test</span>.
9:Oh! The soup <span class="term_note_b">tast</span>e good.
</pre></td></tr></tbody></table>

			了解了吧？<span class="text_import2">其实 []
			里面不论有几个字符，他都谨代表某『一个』字符</span>，
			所以，上面的例子说明了，我需要的字符串是『tast』或『test』两个字符串而已！
			而如果想要搜寻到有 oo 的字符时，则使用：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@test root]# <span class="term_command">grep -n 'oo' regular_express.txt</span>
1:"Open Source" is a g<span class="term_note_b">oo</span>d mechanism to develop programs.
2:apple is my favorite f<span class="term_note_b">oo</span>d.
3:F<span class="term_note_b">oo</span>tball game is not use feet only.
9:Oh! The soup taste g<span class="term_note_b">oo</span>d.
18:g<span class="term_note_b">oo</span>gle is the best tools for search keyword.
19:g<span class="term_note_b">oo</span>oooogle yes!
</pre></td></tr></tbody></table>

			但是，如果我不想要 oo 前面有 g 的话呢？此时，可以利用在集合字符的反向选择 [^] 来达成<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@test root]# <span class="term_command">grep -n '[^g]oo' regular_express.txt</span>
2:apple is my favorite <span class="term_note_b">foo</span>d.
3:<span class="term_note_b">Foo</span>tball game is not use feet only.
18:google is the best <span class="term_note_b">too</span>ls for search keyword.
19:go<span class="term_note_b">ooo</span>oogle yes!
</pre></td></tr></tbody></table>

			意思就是说，我需要的是 oo ，但是 oo 前面不能是 g 就是了！
			仔细比较上面两个表格，妳会发现，第 1,9 行不见了，因为 oo 前面出现了 g 所致！
			第 2,3 行没有疑问，因为 foo 与 Foo 均可被接受！但是第 18 行明明有 google 的 goo 啊～
			别忘记了，因为该行后面出现了 tool 的 too 啊！所以该行也被列出来～
			也就是说， 18 行里面虽然出现了我们所不要的项目 (goo) 但是由于有需要的项目 (too) ，
			因此，是符合字符串搜寻的喔！<br><br>

			至于第 19 行，同样的，因为 goooooogle 里面的 oo 前面可能是 o ，例如：
			go(ooo)oogle ，所以，这一行也是符合需求的！<br><br>

			再来，假设我 oo 前面不想要有小写字符，所以，我可以这样写 [^abcd....z]oo ，
			但是这样似乎不怎么方便，由于小写字符的 ASCII 上编码的顺序是连续的，
			因此，我们可以将之简化为底下这样：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@test root]# <span class="term_command">grep -n '[^a-z]oo' regular_express.txt</span>
3:<span class="term_note_b">Foo</span>tball game is not use feet only.
</pre></td></tr></tbody></table>

			也就是说，当我们在一组集合字符中，如果该字符组是连续的，例如大写英文/小写英文/数字等等，
			就可以使用[a-z],[A-Z],[0-9]等方式来书写，那么如果我们的要求字符串是数字与英文呢？
			呵呵！就将他全部写在一起，变成：[a-zA-Z0-9]<br><br>

			例如，我们要取得有数字的那一行，就这样：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@test root]# <span class="term_command">grep -n '[0-9]' regular_express.txt</span>
5:However, this dress is about $ <span class="term_note_b">3183</span> dollars.
15:You are the best is mean you are the no. <span class="term_note_b">1</span>.
</pre></td></tr></tbody></table>

			这样对于 [] 以及 [^] 以及 [] 当中的 - 有了解了吗？！ ^_^y
		</li><br>

		<li><span class="text_import1">例题三、行首与行尾字符 ^ $：</span><br>
			我们在例题一当中，可以查询到一行字符串里面有 the 的，那如果我想要让 the 只在行首列出呢？
			这个时候就得要使用制表符了！我们可以这样做：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@test root]# <span class="term_command">grep -n '^the' regular_express.txt</span>
12:<span class="term_note_b">the</span> symbol '*' is represented as start.
</pre></td></tr></tbody></table>

			此时，就只剩下第 12 行，因为只有第 12 行的行首是 the 开头啊～此外，
			如果我想要开头是小写字符的那一行就列出呢？可以这样：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@test root]# <span class="term_command">grep -n '^[a-z]' regular_express.txt</span>
2:<span class="term_note_b">a</span>pple is my favorite food.
4:<span class="term_note_b">t</span>his dress doesn't fit me.
10:<span class="term_note_b">m</span>otorcycle is cheap than car.
12:<span class="term_note_b">t</span>he symbol '*' is represented as start.
18:<span class="term_note_b">g</span>oogle is the best tools for search keyword.
19:<span class="term_note_b">g</span>oooooogle yes!
</pre></td></tr></tbody></table>

			如果我不想要开头是英文字母，则可以是这样：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@test root]# <span class="term_command">grep -n '^[^a-zA-Z]' regular_express.txt</span>
1:<span class="term_note_b">"</span>Open Source" is a good mechanism to develop programs.
20:<span class="term_note_b">#</span> I am VBird
</pre></td></tr></tbody></table>

			注意到了吧？那个 ^ 符号，在字符集合符号(括号[])之内与之外是不同的！
			在 [] 内代表『反向选择』，在 [] 之外则代表定位在行首的意义！要分清楚喔！<br><br>

			那如果我想要找出来，行尾结束为小数点 (.) 的那一行，该如何处理：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@test root]# <span class="term_command">grep -n '\.$' regular_express.txt</span>
1:"Open Source" is a good mechanism to develop programs<span class="term_note_b">.</span>
2:apple is my favorite food<span class="term_note_b">.</span>
3:Football game is not use feet only<span class="term_note_b">.</span>
4:this dress doesn't fit me<span class="term_note_b">.</span>
10:motorcycle is cheap than car<span class="term_note_b">.</span>
11:This window is clear<span class="term_note_b">.</span>
12:the symbol '*' is represented as start<span class="term_note_b">.</span>
15:You are the best is mean you are the no. 1<span class="term_note_b">.</span>
16:The world <happy> is the same with "glad"<span class="term_note_b">.</span>
17:I like dog<span class="term_note_b">.</span>
18:google is the best tools for search keyword<span class="term_note_b">.</span>
</happy></pre></td></tr></tbody></table>

			特别注意到，因为小数点具有其他意义(底下会介绍)，所以必须要使用跳脱字符(\)来加以解除其特殊意义！
			不过，您或许会觉得奇怪，但是第 5~9 行最后面也是 . 啊～怎么无法打印出来？？
			这里就牵涉到 Windows 平台的软件对于断行字符的判断问题了！我们使用 cat -A 将第五行拿出来看，
			您会发现：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@test root]# <span class="term_command">cat -A regular_express.txt</span>
However, this dress is about $ 3183 dollars.<span class="term_note_b">^M</span>$
</pre></td></tr></tbody></table>

			注意到了没？最后面的断行字符应该是 $ 才对，但是，因为 Windows 的 nodepad 会主动加上 ^M
			作为断行的判断，因此，那个 . 自然就不是紧接在 $ 之前喔！这样可以了解 ^ 与 $ 的意义吗？
			好了，先不要看底下的解答，自己想一想，那么如果我想要找出来，哪一行是『空白行』，
			也就是说，该行并没有输入任何数据，该如何搜寻？？<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@test root]# <span class="term_command">grep -n '^$' regular_express.txt</span>
21:
</pre></td></tr></tbody></table>

			因为只有行首跟行尾( ^$ )，所以，这样就可以找出空白行啦！再来，
			假设您已经知道在一个批次脚本 (shell script) 或者是配置文件当中，
			空白行与开头为 # 的那一行是批注，因此如果您要将数据列出给别人参考时，
			可以将这些数据省略掉，以节省保贵的纸张，那么，您可以怎么作呢？
			我们以 /etc/syslog.conf 这个档案来作范例，您可以自行参考一下输出的结果：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@test root]# <span class="term_command">cat /etc/syslog.conf</span>
[root@test root]# <span class="term_command">grep -v '^$' /etc/syslog.conf | grep -v '^#'</span>
</pre></td></tr></tbody></table>

			是否节省很多版面啊？？
		</li><br>

		<li><span class="text_import1">例题四、任意一个字符 . 与重复字符 *</span><br>
			在 bash 的章节当中，我们知道通配符 * 可以用来代表任意(0或多个)字符，
			但是<span class="text_import2">正规表示法并不是通配符</span>，两者之间是不相同的！
			至于正规表示法当中的『 . 』则代表『绝对有一个任意字符』的意思！这样讲不好懂，
			我们直接做个练习吧！假设我需要找出 g??d 的字符串，亦即共有四个字符，
			起头是 g 而结束是 d ，我可以这样做：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@test root]# <span class="term_command">grep -n 'g..d' regular_express.txt</span>
1:"Open Source" is a <span class="term_note_b">good</span> mechanism to develop programs.
9:Oh! The soup taste <span class="term_note_b">good</span>.
16:The world <happy> is the same with "<span class="term_note_b">glad</span>".
</happy></pre></td></tr></tbody></table>

			因为强调 g 与 d 之间一定要存在两个字符，因此，第 13 行的 god 与第 14 行的 gd 
			就不会被列出来啦！再来，如果我想要列出有 oo, ooo, oooo 等等的资料，
			也就是说，至少要有两个 o 以上，该如何是好？？是 o* 还是 oo* 还是 ooo* 呢？
			虽然您可以试看看结果， 不过结果太占版面了 @_@ ，所以，我这里就直接说明。<br><br>

			因为 * 代表的是『<span class="text_import2">重复 0 个或多个前面的 RE 字符</span>』的意义，
			因此，<span class="text_import2">『o*』代表的是：『拥有空字符或一个 o 以上的字符』</span>，
			特别注意，因为允许空字符(就是有没有字符都可以的意思)，因此， <span class="text_import1">
			grep -n 'o*' regular_express.txt</span>
			将会把所有的数据都打印出来屏幕上！<br><br>

			那如果是『oo*』呢？则第一个 o 肯定必须要存在，第二个 o 则是可有可无的多个 o ，
			所以，凡是含有 o, oo, ooo, oooo 等等，都可以被列出来～<br><br>

			同理，当我们需要『至少两个 o 以上的字符串』时，就需要 ooo* ，亦即是：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@test root]# <span class="term_command">grep -n 'ooo*' regular_express.txt</span>
1:"Open Source" is a g<span class="term_note_b">oo</span>d mechanism to develop programs.
2:apple is my favorite f<span class="term_note_b">oo</span>d.
3:F<span class="term_note_b">oo</span>tball game is not use feet only.
9:Oh! The soup taste g<span class="term_note_b">oo</span>d.
18:g<span class="term_note_b">oo</span>gle is the best t<span class="term_note_b">oo</span>ls for search keyword.
19:g<span class="term_note_b">oooooo</span>gle yes!
</pre></td></tr></tbody></table>

			这样理解 * 的意义了吗？！好了，现在出个练习，如果我想要字符串开头与结尾都是 g，
			但是两个 g 之间仅能存在至少一个 o ，亦即是 gog, goog, gooog.... 等等，
			那该如何？<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@test root]# <span class="term_command">grep -n 'goo*g' regular_express.txt</span>
18:<span class="term_note_b">goog</span>le is the best tools for search keyword.
19:<span class="term_note_b">goooooog</span>le yes!
</pre></td></tr></tbody></table>

			如此了解了吗？好，再来一题，如果我想要找出 g 开头与 g 结尾的字符串，
			当中的字符可有可无，那该如何是好？是『g*g』吗？<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@test root]# <span class="term_command">grep -n 'g*g' regular_express.txt</span>
1:"Open Source" is a good mechanism to develop programs.
3:Football game is not use feet only.
9:Oh! The soup taste good.
13:Oh!  My god!
14:The gd software is a library for drafting programs.
16:The world <happy> is the same with "glad".
17:I like dog.
18:google is the best tools for search keyword.
19:goooooogle yes!
</happy></pre></td></tr></tbody></table>

			但测试的结果竟然出现这么多行？？太诡异了吧？
			其实一点也不诡异，因为 g*g 里面的 g* 代表『空字符或一个以上的 g』
			在加上后面的 g ，因此，整个 RE 的内容就是 g, gg, ggg, gggg ，
			因此，只要该行当中拥有一个以上的 g 就符合所需了！<br><br>

			那该如何得到我们的 g....g 的需求呢？呵呵！就利用任意一个字符『.』啊！
			亦即是：『g.*g』的作法，因为 * 可以是 0 或多个重复前面的字符，而 . 是任意字符，所以：
			『<span class="text_import1">.* 就代表零个或多个任意字符</span>』的意思啦！<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@test root]# <span class="term_command">grep -n 'g.*g' regular_express.txt</span>
1:"Open Source" is a <span class="term_note_b">good mechanism to develop prog</span>rams.
14:The <span class="term_note_b">gd software is a library for drafting prog</span>rams.
18:<span class="term_note_b">goog</span>le is the best tools for search keyword.
19:<span class="term_note_b">goooooog</span>le yes!
</pre></td></tr></tbody></table>

			因为是代表 g 开头与 g 结尾，中间任意字符均可接受，所以，第 1 与第 14 行是可接受的喔！
			这个 .* 的 RE 表示任意字符是很常见的，希望大家能够理解并且熟悉！<br><br>

			再出一题，如果我想要找出『任意数字』的行列呢？因为仅有数字，所以就成为：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@test root]# <span class="term_command">grep -n '[0-9][0-9]*' regular_express.txt</span>
5:However, this dress is about $ <span class="term_note_b">3183</span> dollars.
15:You are the best is mean you are the no. <span class="term_note_b">1</span>.
</pre></td></tr></tbody></table>

			虽然使用 grep -n '[0-9]' regular_express.txt 也可以得到相同的结果，
			但鸟哥希望大家能够理解上面指令当中 RE 表示法的意义才好！<br><br>
		</li><br>

		<li><span class="text_import1">例题五、限定连续 RE 字符范围 {}</span><br>
			在上个例题当中，我们可以利用 . 与 RE 字符及 * 来设定 0 个到无限多个重复字符，
			那如果我想要限制一个范围区间内的重复字符数呢？举例来说，我想要找出两个到五个 o 
			的连续字符串，该如何作？这时候就得要使用到限定范围的字符 {} 了。
			但因为 { 与 } 的符号在 shell 是有特殊意义的，因此，
			我们必须要使用跳脱字符 \ 来让他失去特殊意义才行。<br><br>

			至于 {} 的语法是这样的，假设我要找到两个 o 的字符串，可以是：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@test root]# <span class="term_command">grep -n 'o\{2\}' regular_express.txt</span>
1:"Open Source" is a g<span class="term_note_b">oo</span>d mechanism to develop programs.
2:apple is my favorite f<span class="term_note_b">oo</span>d.
3:F<span class="term_note_b">oo</span>tball game is not use feet only.
9:Oh! The soup taste g<span class="term_note_b">oo</span>d.
18:g<span class="term_note_b">oo</span>gle is the best t<span class="term_note_b">oo</span>ls for search keyword.
19:go<span class="term_note_b">oo</span>ooogle yes!
</pre></td></tr></tbody></table>

			这样看似乎与 ooo* 的字符没有什么差异啊？因为第 19 行有多个 o 依旧也出现了！
			好，那么换个搜寻的字符串，假设我们要找出 g 后面接 2 到 5 个 o ，然后再接一个 g 的字符串，
			他会是这样：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@test root]# <span class="term_command">grep -n 'go\{2,5\}g' regular_express.txt</span>
18:<span class="term_note_b">goog</span>le is the best tools for search keyword.
</pre></td></tr></tbody></table>

			嗯！很好！第 19 行终于没有被取用了(因为 19 行有 6 个 o 啊！)。
			那么，如果我想要的是 2 个 o 以上的 goooo....g 呢？除了可以是 gooo*g ，也可以是：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@test root]# <span class="term_command">grep -n 'go\{2,\}g' regular_express.txt</span>
18:<span class="term_note_b">goog</span>le is the best tools for search keyword.
19:<span class="term_note_b">goooooog</span>le yes!
</pre></td></tr></tbody></table>

			呵呵！就可以找出来啦～
		</li>
		</ul>
	</div>

	<hr><a name="basic_regexp_char"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">重要特殊字符(characters) </span><br>
	<div class="block2">
		经过了上面的几个简单的范例，我们可以将基础的正规表示法特殊字符汇整如下：<br><br>

		<table width="90%" border="1" cellpadding="0" cellspacing="0">
		<tbody><tr align="center" bgcolor="#182448"><td width="20%"><font color="#FFFFFF">RE 字符</font></td><td><font color="#FFFFFF">意义与范例</font></td></tr>
		<tr><td rowspan="2" align="center">^word</td><td>待搜寻的字符串(word)在行首！</td></tr>
		<tr><td>范例：<font color="#000088" face="细明体"><b>grep -n '^#' regular_express.txt</b></font><br>
			<font color="#00aa00">搜寻行首为 # 开始的那一行！</font></td></tr>
		<tr><td rowspan="2" align="center">word$</td><td>待搜寻的字符串(word)在行尾！</td></tr>
		<tr><td>范例：<font color="#000088" face="细明体"><b>grep -n '!$' regular_express.txt</b></font><br>
			<font color="#00aa00">将行尾为 ! 的那一行打印出来！</font></td></tr>
		<tr><td rowspan="2" align="center">.</td><td>代表『任意一个』字符，一定是一个任意字符！</td></tr>
		<tr><td>范例：<font color="#000088" face="细明体"><b>grep -n 'e.e' regular_express.txt</b></font><br>
			<font color="#00aa00">搜寻的字符串可以是 (eve) (eae) (eee) (e e)， 但不能仅有 (ee) ！亦即 e 与 
			e 中间『一定』仅有一个字符，而空格符也是字符！</font></td></tr>
		<tr><td rowspan="2" align="center">\</td><td>跳脱字符，将特殊符号的特殊意义去除！</td></tr>
		<tr><td>范例：<font color="#000088" face="细明体"><b>grep -n \' regular_express.txt</b></font><br>
			<font color="#00aa00">搜寻含有单引号 ' 的那一行！</font></td></tr>
		<tr><td rowspan="2" align="center">*</td><td>重复零个或多个的前一个 RE 字符</td></tr>
		<tr><td>范例：<font color="#000088" face="细明体"><b>grep -n 'ess*' regular_express.txt</b></font><br>
			<font color="#00aa00">找出含有 (es) (ess) (esss) 等等的字符串，注意，因为 * 可以是 0 个，所以 es 
			也是符合带搜寻字符串。另外，因为 * 为重复『前一个 RE 字符』的符号，
			因此，在 * 之前必须要紧接着一个 RE 字符喔！例如任意字符则为 『.*』 ！</font></td></tr>
		<tr><td rowspan="2" align="center">\{n,m\}</td><td>连续 n 到 m 个的『前一个 RE 字符』<br>
			若为 \{n\} 则是连续 n 个的前一个 RE 字符，<br>
			若是 \{n,\} 则是连续 n 个以上的前一个 RE 字符！</td></tr>
		<tr><td>范例：<font color="#000088" face="细明体"><b>grep -n 'go\{2,3\}g' regular_express.txt</b></font><br>
			<font color="#00aa00">在 g 与 g 之间有 2 个到 3 个的 o 存在的字符串，亦即 (goog)(gooog)</font></td></tr>
		<tr><td rowspan="2" align="center">[]</td><td>字符集合的 RE 特殊字符的符号</td></tr>
		<tr><td><font face="细明体">[list]<br>
			范例：<font color="#000088" face="细明体"><b>grep -n 'g[ld]' regular_express.txt</b></font><br>
			<font color="#00aa00">搜寻含有 (gl) 或 (gd) 的那一行～<br>
			需要特别留意的是，在 [] 当中『谨代表一个待搜寻的字符』，<br>
			例如： a[afl]y 代表搜寻的字符串可以是 aay, afy, aly <br>
			亦即 [afl] 代表 a 或 f 或 l 的意思！</font><br><br>
			<font face="细明体">[ch1-ch2]<br>
			范例：<font color="#000088" face="细明体"><b>grep -n '[0-9]' regular_express.txt</b></font><br>
			<font color="#00aa00">搜寻含有任意数字的那一行！需特别留意，在字符集合 [] 中的减号 - 
			是有特殊意义的，他代表两个字符之间的所有连续字符！但这个连续与否与 ASCII 编码有关，
			因此，您的编码需要设定正确(在 bash 当中，需要确定 LANG 与 LANGUAGE 的变量是否正确！)
			例如所有大写字符则为 [A-Z]</font><br><br>
			<font face="细明体">[^]<br>
			范例：<font color="#000088" face="细明体"><b>grep -n 'oo[^t]' regular_express.txt</b></font><br>
			<font color="#00aa00">搜寻的字符串可以是 (oog) (ood) 但不能是 (oot) ，那个 ^ 在 [] 内时，
			代表的意义是『反向选择』的意思～例如，我不要大写字符，则为 [^A-Z] ～
			但是，需要特别注意的是，如果以 grep -n [^A-Z] regular_express.txt 来搜寻，
			却发现该档案内的所有行都被列出，为什么？因为这个 [^A-Z] 是『非大写字符』的意思，
			因为每一行均有非大写字符，例如第一行的 "Open Source" 就有 p,e,n,o.... 等等的小写字符，
			以及双引号 (") 等字符，所以当然符合 [^A-Z] 的搜寻！
			</font></font></font></font></td></tr>
		</tbody></table><br>

		请特别留意的是，『<span class="text_import1">正规表示法的特殊字符</span>』
		与一般在指令列输入指令的『<span class="text_import1">通配符</span>』并不相同，
		例如，在通配符当中，* 代表的是 0 ~ 无限多个字符的意思，但是在正规表示法当中，
		* 则是重复 0 到多个的前一个 RE 字符的意思～使用的意义并不相同，不要搞混了！
		(鸟哥我一开始摸正规表示法时就很容易搞混！因为这里是新手最容易搞错的地方，特别小心啊！)<br><br>

		举例来说，不支持正规表示法的 ls 这个工具中，若我们使用 『ls -l * 』
		代表的是任意档名的档案，而 『ls -l a* 』代表的是以 a 为开头的任何档名的档案，
		但在正规表示法中，我们要找到含有以 a 为开头的档案，则必须要这样：(需搭配支持正规表示法的工具)<ul>
		<font face="细明体"><b>ls | grep -n '^a.*' </b></font></ul>

		另外，例如通配符的反向选择，为 [!range] ，至于正规表示法则是 [^range] 。
		这样是否了解正规表示法与通配符的差异啦？？<br>
	</div>
</div>


<hr><a name="extend"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">延伸正规表示法</span><br>
<div class="block1">
	事实上，一般读者只要了解基础型的正规表示法大概就已经相当足够了，不过，某些时刻，
	为了要简化整个指令操作，了解一下使用范围更广的延伸型正规表示法的表示式，会更方便呢！
	举个简单的例子好了，在上节的例题三的最后一个例子中，我们要去除空白行与行首为 # 的行列，
	使用的是
	<ul>grep -v '^$' regular_express.txt | grep -v '^#'</ul>
	需要使用到管线命令来搜寻两次！
	那么如果使用延伸型的正规表示法，我们可以简化为：
	<ul>egrep -v '^$|^#' regular_express.txt</ul>
	利用支持延伸型正规表示法的 egrep 与特殊字符 | 来区隔两组字符串，如此一来，是否方便很多呢？<br><br>

	这里必须要特别强调， grep 支持的是基础型的正规表示法，而 egrep 支持延伸正规表示法。
	事实上， egrep 是 grep -E 的命令别名，为了方便使用，我们还是以 egrep 来跟 grep 区分吧！<br><br>

	熟悉了正规表示法之后，到这个延伸型的正规表示法，您应该也会想到，
	不就是多几个重要的特殊符号吗？ ^_^y 是的～所以，我们就直接来说明一下，延伸型正规表示法有哪几个特殊符号？<br><br>

	<table width="90%" border="1" cellpadding="0" cellspacing="0">
	<tbody><tr align="center" bgcolor="#182448"><td width="20%"><font color="#FFFFFF">RE 字符</font></td><td><font color="#FFFFFF">意义与范例</font></td></tr>
	<tr><td rowspan="2" align="center">+</td><td>重复『一个或一个以上』的前一个 RE 字符</td></tr>
	<tr><td>范例：<font color="#000088" face="细明体"><b>egrep -n 'go+d' regular_express.txt</b></font><br>
		<font color="#00aa00">搜寻 (god) (good) (goood)... 等等的字符串。
		那个 o+ 代表『一个以上的 o 』所以，上面的执行成果会将第 1, 9, 13 行列出来。</font></td></tr>
	<tr><td rowspan="2" align="center">?</td><td>『零个或一个』的前一个 RE 字符</td></tr>
	<tr><td>范例：<font color="#000088" face="细明体"><b>egrep -n 'go?d' regular_express.txt</b></font><br>
		<font color="#00aa00">搜寻 (gd) (god) 这两个字符串。
		那个 o? 代表『空的或 1 个 o 』所以，上面的执行成果会将第 13, 14 行列出来。<br>
		有没有发现到，这两个案例( 'go+d' 与 'go?d' )的结果集合与 'go*d' 相同？
		想想看，这是为什么喔！ ^_^</font></td></tr>
	<tr><td rowspan="2" align="center">|</td><td>用或( or )的方式找出数个字符串</td></tr>
	<tr><td>范例：<font color="#000088" face="细明体"><b>egrep -n 'gd|good' regular_express.txt</b></font><br>
		<font color="#00aa00">搜寻 gd <b>或</b> good 这两个字符串，注意，是『或』！
		所以，第 1,9,14 这三行都可以被打印出来喔！那如果还想要找出 dog 呢？就这样啊：<br>
		egrep -n 'gd|good|dog' regular_express.txt</font></td></tr>
	<tr><td rowspan="2" align="center">( )</td><td>找出『群组』字符串</td></tr>
	<tr><td>范例：<font color="#000088" face="细明体"><b>egrep -n 'g(la|oo)d' regular_express.txt</b></font><br>
		<font color="#00aa00">搜寻 (glad) 或 (good) 这两个字符串，因为 g 与 d 是重复的，所以，
		我就可以将 la 与 oo 列于 ( ) 当中，并以 | 来分隔开来，就可以啦！<br>
		此外，这个功能还可以用来作为『多个重复群组』的判别喔！举例来说：<br>
		<font color="#000088" face="细明体"><b>echo 'AxyzxyzxyzxyzC'  | egrep 'A(xyz)+C'</b></font><br>
		上面的例子当中，意思是说，我要找开头是 A 结尾是 C ，中间有一个以上的
		"xyz" 字符串的意思～</font></td><td></td></tr>
	</tbody></table><br>

	以上这些就是延伸型的正规表示法的特殊字符。另外，要特别强调的是，那个 ! 在正规表示法当中并不是特殊字符，
	所以，如果您想要查出来档案中含有 ! 与 &gt; 的字行时，可以这样：

	<ul><font face="细明体">grep -n '[!&gt;]' regular_express.txt</font></ul>

	这样可以了解了吗？！常常看到有陷阱的题目写：『反向选择这样对否？ '[!a-z]'？』，
	呵呵！是错的呦～要 '[^a-z] 才是对的！
</div>
　

<hr><a name="printf"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">格式化打印： printf</span><br>
<div class="block1">
	在很多时候，我们可能需要将输出的数据给他格式化输出的～
	举例来说，考试卷分数的输出，姓名与科目及分数之间，总是可以稍微作个比较漂亮的版面配置吧？
	例如我想要输出底下的样式：<br>

<table class="term"><tbody><tr><td class="term"><pre>Name     Chinese   English   Math    Average
DmTsai        80        60     92      77.33
VBird         75        55     80      70.00
Ken           60        90     70      73.33
</pre></td></tr></tbody></table>

	分成五个字段，各个字段分配到正确的位置去！但是因为每个字段的原始数据其实并非是如此固定的，
	而我就是想要如此表示出这些数据，此时，就得需要打印格式管理员 printf 的帮忙了！
	printf 可以帮我们将资料输出的结果格式化，而且而支持一些特殊的字符～底下我们就来看看！<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">printf '打印格式' 实际内容</span>
<span class="term_say">参数：
关于格式方面的几个特殊样式：
       \a    警告声音输出
       \b    退格键(backspace)
       \f    清除屏幕 (form feed)
       \n    输出新的一行
       \r    亦即 Enter 按键
       \t    水平的 [tab] 按键
       \v    垂直的 [tabl] 按键
       \xNN  NN 为两位数的数字，可以转换数字成为字符。
关于 C 程序语言内，常见的变数格式
       %ns   那个 n 是数字， s 代表 string ，亦即多少个字符；
       %ni   那个 n 是数字， i 代表 integer ，亦即多少整数字数；
       %N.nf 那个 n 与 N 都是数字， f 代表 floating (浮点)，如果有小数字数，
             假设我共要十个位数，但小数点有两位，即为 %10.2f 啰！
范例：</span>

<span class="term_hd">范例一：将刚刚上头的数据变成档案，仅列出姓名与成绩：(用 [tab] 分隔</span>
[root@linux ~]# <span class="term_command">printf '%s\t %s\t %s\t %s\t %s\t \n' `cat printf.txt`</span>
Name     Chinese         English         Math    Average
DmTsai   80      60      92      77.33
VBird    75      55      80      70.00
Ken      60      90      70      73.33
<span class="term_say"># 假设我将上面的档案存成 printf.txt 档案档名，则可利用上面的案例，
# 将每个单字中间以 [tab] 按键隔开。由上面的输出来看，虽然第二行以后是 OK 的，
# 但是第一行则因为某些单字长度较长，所以就无法对齐了！而 %s 表示以字符串 (string)
# 的方式来展现该内容。而每个内容则以 \t 即 [tab] 来隔开啊！</span>

<span class="term_hd">范例二：将上述资料关于第二行以后，分别以字符串、整数、小数点来显示：</span>
[root@linux ~]# <span class="term_command">printf '%10s %5i %5i %5i %8.2f \n' `cat printf.txt |\</span>
&gt; <span class="term_command">grep -v Name`</span>
    DmTsai    80    60    92    77.33
     VBird    75    55    80    70.00
       Ken    60    90    70    73.33
<span class="term_say"># 这个时候的输出可就有趣了！我将几个内容分成不同的数据格式来输出，
# 最有趣的应该是 %8.2f 这个项目了！我可以针对不同的小数字数来进行格式输出，
# 例如变成底下的样子时，您自己试看看，会是输出什么结果喔！
# printf '%10s %5i %5i %5i %8.1f \n' `cat printf.txt | grep -v Name`</span>

<span class="term_hd">范例三：列出数值 45 代表的字符为何？</span>
[root@linux ~]# <span class="term_command">printf '\x45\n'</span>
E
<span class="term_say"># 这东西也很好玩～他可以将数值转换成为字符，如果您会写 script 的话，
# 可以自行测试一下，由 20~80 之间的数值代表的字符是啥喔！ ^_^</span>
</pre></td></tr></tbody></table>

	printf 的使用相当的广泛喔！包括等一下后面会提到的 awk 以及在 C 程序语言当中使用的屏幕输出，
	都是利用 printf 呢！鸟哥这里也只是列出一些可能会用到的格式而已，
	有兴趣的话，可以自行多作一些测试与练习喔！ ^_^<br>

	<div style="padding: 10pt 0pt;" align="right"><table width="90%"><tbody><tr><td><b>Tips:</b><br><span style="color: rgb(0, 144, 0);"><font size="-1">		打印格式化这个 printf 指令，乍看之下好像也没有什么很重要的～
		不过，如果您需要自行撰写一些软件，需要将一些数据在屏幕上头漂漂亮亮的输出的话，
		那么 printf 可也是一个很棒的工具喔！
	</font></span></td><td><img src="0330regularex-fc4_files/vbird_face.gif" alt="鸟哥的图示" title="鸟哥的图示"></td></tr></tbody></table></div></div>


<hr><a name="sed"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">sed 工具简介</span><br>
<div class="block1">
	在了解了一些正规表示法的基础应用之后，再来呢？呵呵～两个东西可以玩一玩的，那就是 sed 跟 awk 了！
	这两个家伙可是相当的有用的啊！举例来说，鸟哥写的 logfile.sh 分析登录文件的小程序，
	绝大部分分析关键词的取用、统计等等，就是用这两个宝贝蛋来帮我完成的！
	那么你说，要不要玩一玩啊？！ ^_^<br><br>

	我们先来谈一谈 sed 好了，基本上， sed 可以分析 Standard Input (STDIN) 的数据，
	然后将数据经过处理后，再将他输出到 standrad out (STDOUT) 的一个工具。
	至于处理呢？可以进行取代、删除、新增、撷取特定行等等的功能呢！很不错吧～
	我们先来了解一下 sed 的用法，再来聊他的用途好了！<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">sed [-nefr] [动作]</span>
<span class="term_say">参数：
-n  ：使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN 
      的数据一般都会被列出到屏幕上。但如果加上 -n 参数后，则只有经过
      sed 特殊处理的那一行(或者动作)才会被列出来。
-e  ：直接在指令列模式上进行 sed 的动作编辑；
-f  ：直接将 sed 的动作写在一个档案内， -f filename 则可以执行 filename 内的 
      sed 动作；
-r  ：sed 的动作支持的是延伸型正规表示法的语法。(预设是基础正规表示法语法)
-i  ：直接修改读取的档案内容，而不是由屏幕输出。

动作说明：  [n1[,n2]]function
n1, n2 ：不见得会存在，一般代表『选择进行动作的行数』，举例来说，如果我的动作
         是需要在 10 到 20 行之间进行的，则『 10,20[动作行为] 』

function 有底下这些咚咚：
a   ：新增， a 的后面可以接字符串，而这些字符串会在新的一行出现(目前的下一行)～
c   ：取代， c 的后面可以接字符串，这些字符串可以取代 n1,n2 之间的行！
d   ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；
i   ：插入， i 的后面可以接字符串，而这些字符串会在新的一行出现(目前的上一行)；
p   ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运作～
s   ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配
      正规表示法！例如 1,20s/old/new/g 就是啦！
范例：</span>

<span class="term_hd">范例一：将 /etc/passwd 的内容列出，并且我需要打印行号，同时，请将第 2~5 行删除！</span>
[root@linux ~]# <span class="term_command">nl /etc/passwd | sed '2,5d'</span>
     1  root:x:0:0:root:/root:/bin/bash
     6  sync:x:5:0:sync:/sbin:/bin/sync
     7  shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
<span class="term_say">.....(后面省略).....</span>
<span class="term_say"># 看到了吧？因为 2-5 行给他删除了，所以显示的数据中，就没有 2-5 行啰～
# 另外，注意一下，原本应该是要下达 sed -e 才对，没有 -e 也行啦！
# 同时也要注意的是， sed 后面接的动作，请务必以 '' 两个单引号括住喔！
# 而，如果只要删除第 2 行，可以使用 nl /etc/passwd | sed '2d' 来达成，
# 至于第 3 到最后一行，则是 nl /etc/passwd | sed '3,$d' 的啦！ </span>

<span class="term_hd">范例二：承上题，在第二行后(亦即是加在第三行)加上『drink tea?』字样！</span>
[root@linux ~]# <span class="term_command">nl /etc/passwd | sed '2a drink tea'</span>
     1  root:x:0:0:root:/root:/bin/bash
     2  bin:x:1:1:bin:/bin:/sbin/nologin
drink tea
     3  daemon:x:2:2:daemon:/sbin:/sbin/nologin
<span class="term_say"># 嘿嘿！在 a 后面加上的字符串就已将出现在第二行后面啰！那如果是要在第二行前呢？
# nl /etc/passwd | sed '2i drink tea' 就对啦！</span>

<span class="term_hd">范例三：在第二行后面加入两行字，例如『Drink tea or .....』『drink beer?』</span>
[root@linux ~]# <span class="term_command">nl /etc/passwd | sed '2a Drink tea or ......\</span>
&gt; <span class="term_command">drink beer ?'</span>
     1  root:x:0:0:root:/root:/bin/bash
     2  bin:x:1:1:bin:/bin:/sbin/nologin
Drink tea or ......
drink beer ?
     3  daemon:x:2:2:daemon:/sbin:/sbin/nologin
<span class="term_say"># 这个范例的重点是，我们可以新增不只一行喔！可以新增好几行～
# 但是每一行之间都必须要以反斜杠 \ 来进行新行的增加喔！所以，上面的例子中，
# 我们可以发现在第一行的最后面就有 \ 存在啦！那是一定要的喔！</span>

<span class="term_hd">范例四：我想将第2-5行的内容取代成为『No 2-5 number』呢？</span>
[root@linux ~]# <span class="term_command">nl /etc/passwd | sed '2,5c No 2-5 number'</span>
     1  root:x:0:0:root:/root:/bin/bash
No 2-5 number
     6  sync:x:5:0:sync:/sbin:/bin/sync
<span class="term_say"># 没有了 2-5 行，嘿嘿嘿嘿！我们要的数据就出现啦！</span>

<span class="term_hd">范例五：仅列出第 5-7 行</span>
[root@linux ~]# <span class="term_command">nl /etc/passwd | sed -n '5,7p'</span>
     5  lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
     6  sync:x:5:0:sync:/sbin:/bin/sync
     7  shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
<span class="term_say"># 为什么要加 -n 的参数呢？您可以自行下达 sed '5,7p' 就知道了！(5-7行会重复输出)
# 有没有加上 -n 的参数时，输出的数据可是差很多的喔！</span>

<span class="term_hd">范例六：我们可以使用 ifconfig 来列出 IP ，若仅要 eth0 的 IP 时？</span>
[root@linux ~]# <span class="term_command">ifconfig eth0</span>
eth0      Link encap:Ethernet  HWaddr 00:51:FD:52:9A:CA
<span class="term_write">          inet addr:192.168.1.12  Bcast:192.168.1.255  Mask:255.255.255.0</span>
          inet6 addr: fe80::250:fcff:fe22:9acb/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
<span class="term_say">.....(以下省略).....
# 其实，我们要的只是那个 inet addr:..那一行而已，所以啰，利用 grep 与 sed 来捉</span>
[root@linux ~]# <span class="term_command">ifconfig eth0 | grep 'inet ' | sed 's/^.*addr://g' | \</span>
&gt; <span class="term_command">sed 's/Bcast.*$//g'</span>
<span class="term_say"># 您可以将每个管线 (|) 的过程都分开来执行，就会晓得原因啰！
# 去头去尾之后，就会得到我们所需要的 IP 亦即是 192.168.1.12 啰～</span>

<span class="term_hd">范例七：将 /etc/man.config 档案的内容中，有 MAN 的设定就取出来，但不要说明内容。</span>
[root@linux ~]# <span class="term_command">cat /etc/man.config | grep 'MAN'| sed 's/#.*$//g' | \</span>
&gt; <span class="term_command">sed '/^$/d'</span>
<span class="term_say"># 每一行当中，若有 # 表示该行为批注，但是要注意的是，有时候，
# 批注并不是写在第一个字符，亦即是写在某个指令后方，如底下的模样：
# 『shutdown -h now # 这个是关机的指令』，批注 # 就在指令的后方了。
# 因此，我们才会使用到将 #.*$ 这个正规表示法！</span>

<span class="term_hd">范例八：利用 sed 直接在 ~/.bashrc 最后一行加入『# This is a test』</span>
[root@linux ~]# <span class="term_command">sed -i '$a # This is a test'  ~/.bashrc</span>
<span class="term_say"># 上头的 -i 参数可以让你的 sed 直接去修改后面接的档案内容喔！而不是由屏幕输出。
# 至于那个 $a  则代表最后一行才新增的意思。</span>
</pre></td></tr></tbody></table>

	总之，这个 sed 不错用啦！而且很多的 shell script 都会使用到这个指令的功能～
	sed 可以帮助系统管理员管理好日常的工作喔！要仔细的学习呢！<br><br>
</div>


<hr><a name="awk"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">awk 工具简介</span><br>
<div class="block1">
	相较于 sed 常常作用于一整个行的处理， awk 则比较倾向于一行当中分成数个『字段』来处理。
	因此，awk 相当的适合处理小型的数据数据处理呢！awk 通常运作的模式是这样的：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">awk '条件类型1{动作1} 条件类型2{动作2} ...' filename</span>
</pre></td></tr></tbody></table>

	awk 可以处理后续接的档案，也可以读取来自前个指令的 standard output 。
	但如前面说的， awk 主要是处理『每一行的字段内的数据』，而默认的『字段的分隔符为
	"空格键" 或 "[tab]键" 』！举例来说，我们用 last 可以将登入者的数据取出来，
	结果如下所示：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">last</span>
dmtsai   pts/0        192.168.1.12     Mon Aug 22 09:40   still logged in
root     tty1                          Mon Aug 15 11:38 - 11:39  (00:01)
reboot   system boot  2.6.11           Sun Aug 14 18:18         (7+15:41)
dmtsai   pts/0        192.168.1.12     Fri Aug 12 12:07 - 12:08  (00:01)
</pre></td></tr></tbody></table>

	若我想要取出账号与登入者的 IP ，且账号与 IP 之间以 [tab] 隔开，则会变成这样：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">last | awk '{print $1 "\t" $3}'</span>
dmtsai  192.168.1.12
root    Mon
reboot  boot
dmtsai  192.168.1.12
</pre></td></tr></tbody></table>

	因为不论哪一行我都要处理，因此，就不需要有 "条件类型" 的限制！我所想要的是第一栏以及第三栏，
	但是，第二行及第三行的内容怪怪的～这是因为数据格式的问题啊！所以啰～使用 awk
	的时候，请先确认一下您的数据当中，如果是连续性的数据，请不要有空格或 [tab] 
	在内，否则，就会像这个例子这样，会发生误判喔！<br><br>

	另外，由上面这个例子您也会知道，在每一行的每个字段都是有变量名称的，那就是 $1, $2... 
	等变量名称，以上面的例子来说， dmtsai 是 $1 ，因为他是第一栏嘛！至于 192.168.1.12 是第三栏，
	所以他就是 $3 啦！后面以此类推～呵呵！还有个变数喔！那就是 $0 ，$0 代表『一整列资料』的意思～
	以上面的例子来说，第一行的 $0 代表的就是『dmtsai   pts/0.... 』那一行啊！
	由此可知，刚刚上面四行当中，整个 awk 的处理流程是：<ol><span class="text_import2">
	<li>读入第一行，并将第一行的资料填入 $0, $1, $2.... 等变数当中；
	</li><li>依据 "条件类型" 的限制，判断是否需要进行后面的 "动作"；
	</li><li>做完所有的动作与条件类型；
	</li><li>若还有后续的『行』的数据，则重复上面 1~3 的步骤，直到所有的数据都读完为止。</li></span></ol>
	经过这样的步骤，您会晓得， awk 是『<span class="text_import2">以行为一次处理的单位</span>』，
	而『<span class="text_import2">以字段为最小的处理单位</span>』。好了，那么 awk 
	怎么知道我到底这个数据有几行？有几栏呢？这就需要 awk 的内建变量的帮忙啦～<br><br>

<table width="65%" bgcolor="lightyellow" border="1" cellpadding="3" cellspacing="0">
<tbody><tr align="center" bgcolor="#182448"><td><font color="#FFFFFF">变量名称</font></td><td><font color="#FFFFFF">代表意义</font></td></tr>
<tr><td>NF</td><td>每一行 ($0) 拥有的字段总数</td></tr>
<tr><td>NR</td><td>目前 awk 所处理的是『第几行』数据</td></tr>
<tr><td>FS</td><td>目前的分隔字符，默认是空格键</td></tr>
</tbody></table><br>

	我们继续以上面例子来做说明，如果我想要列出每一行的账号，并且列出目前处理的行数，
	并且说明，该行有多少字段，则可以这样 (<span class="text_vbird">注意， awk 后续的所有动作以 ' 括住，
	所以，内容如果想要以 print 打印时，记得，非变量的文字部分，包含上一小节 
	<a href="#printf">printf</a> 提到的格式中，都需要使用双引号来定义出来喔！</span>)<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">last | awk '{print $1 "\t lines: " NR "\t columes: " NF}'</span>
dmtsai   lines: 1        columes: 10
root     lines: 2        columes: 9
reboot   lines: 3        columes: 9
dmtsai   lines: 4        columes: 10
</pre></td></tr></tbody></table>

	这样可以了解 NR 与 NF 的差别了吧？好了，底下来谈一谈所谓的 "条件类型" 了吧！<br><br>

	<hr><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">awk 的逻辑运算字符</span><br>
	<div class="block2">
		既然有需要用到 "条件" 的类别，自然就需要一些逻辑运算啰～例如底下这些：<br><br>

<table width="75%" bgcolor="lightyellow" border="1" cellpadding="3" cellspacing="0">
<tbody><tr align="center" bgcolor="#182448"><td><font color="#FFFFFF">运算单元</font></td><td><font color="#FFFFFF">代表意义</font></td></tr>
<tr align="center"><td><font face="细明体">&gt;    </font></td><td>大于</td></tr>
<tr align="center"><td><font face="细明体">&lt; </font></td><td>小于</td></tr>
<tr align="center"><td><font face="细明体">&gt;=   </font></td><td>大于或等于</td></tr>
<tr align="center"><td><font face="细明体">&lt;=</font></td><td>小于或等于</td></tr>
<tr align="center"><td><font face="细明体">==   </font></td><td>等于</td></tr>
<tr align="center"><td><font face="细明体">!=   </font></td><td>不等于</td></tr>
</tbody></table><br>

		值得注意的是那个 <font face="细明体">==</font> 的符号，因为在『逻辑运算』上面，
		就是所谓的大于、小于、等于等等的判断式上面，我们习惯上是以 <font face="细明体">==</font>
		来表示，而如果是直接给予一个值，例如变量设定时，就直接使用 = 而已。
		好了，我们实际来运用一下逻辑判断吧！举例来说，在 /etc/passwd 当中是以冒号 ":" 
		来作为字段的分隔，那假设我要查阅，第三栏小于 10 以下的数据，并且仅列出账号与第三栏，
		那么可以这样做：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">cat /etc/passwd | \</span>
&gt; <span class="term_command">awk '{FS=":"} $3 &lt; 10 {print $1 "\t " $3}'</span>
root:x:0:0:root:/root:/bin/bash
bin      1
daemon   2
<span class="term_say">......(以下省略)......</span>
</pre></td></tr></tbody></table>

		有趣吧！不过，怎么第一行没有正确的显示出来呢？这是因为我们读入第一行的时候，
		那些变数 $1, $2... 默认还是以空格键为分隔的，所以虽然我们定义了 FS=":" 了，
		但是却仅能在第二行后才开始生效。那么怎么办呢？我们可以预先设定 awk 的变量啊！
		利用 BEGIN 这个关键词喔！这样做：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">cat /etc/passwd | \</span>
&gt; <span class="term_command">awk 'BEGIN {FS=":"} $3 &lt; 10 {print $1 "\t " $3}'</span>
root     0
bin      1
daemon   2
<span class="term_say">......(以下省略)......</span>
</pre></td></tr></tbody></table>

		很有趣吧！而除了 BEGIN 之外，我们还有 END 呢！另外，如果要用 awk 
		来进行『计算功能』呢？以底下的例子来看，
		假设我有一个薪资数据表，内容是这样的：<br>

<table class="term"><tbody><tr><td class="term"><pre>Name    1st     2nd     3th
VBird   23000   24000   25000
DMTsai  21000   20000   23000
Bird2   43000   42000   41000
</pre></td></tr></tbody></table>

		如何帮我计算每个人的总额呢？而且我还想要格式化输出喔！
		你可以将上面的数据储存成一个名称为 pay.txt 的档案，则：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">cat pay.txt | \</span>
&gt; <span class="term_command">awk 'NR==1{printf "%10s %10s %10s %10s %10s\n",$1,$2,$3,$4,"Total" }
NR&gt;=2{total = $2 + $3 + $4
printf "%10s %10d %10d %10d %10.2f\n", $1, $2, $3, $4, total}'</span>
      Name        1st        2nd        3th      Total
     VBird      23000      24000      25000   72000.00
    DMTsai      21000      20000      23000   64000.00
     Bird2      43000      42000      41000  126000.00
</pre></td></tr></tbody></table>

		上面的例子有几个重要事项应该要先说明的：<ul><span class="text_import2">
		<li>所有的动作，亦即在 {} 内的动作，如果有需要多个指令辅助时，可利用分号『;』间隔，
			或者直接以 [Enter] 按键来隔开每个指令，例如上面的 NR&gt;=2 后面接的动作，
			利用 total = ... 那个指令来指定加总，而后续则以 printf 来格式化输出！
		</li><li>逻辑运算当中，如果是『等于』的情况，则务必使用两个等号『==』！
		</li><li>格式化输出时，在 printf 的格式设定当中，务必加上 \n ，才能进行分行！
		</li><li>与 bash shell 的变量不同，在 awk 当中，变量可以直接使用，不需加上 $ 符号。
		</li></span></ul>
		利用 awk 这个玩意儿，就可以帮我们处理很多日常工作了呢！真是好用的很～
		此外， awk 的输出格式当中，常常会以 <a href="#printf">printf</a> 来辅助，所以，
		最好您对 printf 也稍微熟悉一下比较好啦！另外， awk 的动作内 {} 也是支持 if (条件) 的喔！
		举例来说，上面的指令可以修订成为这样：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">cat pay.txt | \</span>
&gt; <span class="term_command">awk '{if(NR==1) printf "%10s %10s %10s %10s %10s\n",$1,$2,$3,$4,"Total"}
NR&gt;=2{total = $2 + $3 + $4
printf "%10s %10d %10d %10d %10.2f\n", $1, $2, $3, $4, total}'</span>
</pre></td></tr></tbody></table>

		你可以仔细的比对一下上面两个输入有啥不同～从中去了解两种语法吧！
		我个人是比较倾向于使用第一种语法，因为会比较有统一性啊！ ^_^ <br><br>

		除此之外， awk 还可以帮我们进行循环计算喔！真是相当的好用！
		不过，那属于比较进阶的单独课程了，我们这里就不再多加介绍。如果您有兴趣的话，
		可以到中研院的网站查询喔：<a href="http://phi.sinica.edu.tw/aspac/reports/94/94011/" target="_blank">http://phi.sinica.edu.tw/aspac/reports/94/94011/</a>，鸟哥这里也有一份 
		pdf 档的备份： <a href="http://linux.vbird.org/linux_basic/0330regularex/awk.pdf" target="_blank">http://linux.vbird.org/linux_basic/0330regularex/awk.pdf</a>。
		您可以自行参阅一下该文章的内容，里头可以好好的查阅一下关于数组与循环方面的介绍，
		我认为该文章写的很棒喔！该介绍的都介绍了！很好～我喜欢～ ^_^
	</div>
</div>

<hr><a name="doc"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">文件数据比对与打印的相关功能</span><br>
<div class="block1">
	正规表示法是相当有用的工具，当然，那个 sed 还有 awk 也是很棒的工具程序，
	不过，除此之外，我们其实还有很多可以使用的工作来处理文件数据喔！
	举例来说，假如我有两个档案，一个档案是原始档，一个则是经过一些时间累积处理后的档案，
	我想要知道这两个档案之间的差别，该如何运用正规表示法？呼呼～可能要透过所谓的循环来一行一行比对检查呢～
	但是，我们可以透过 Linux 提供的 diff 及 cmp 指令来进行比对即可喔！很棒的啊！<br><br>

	<hr><a name="doc_compare"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">档案比对</span><br>
	<div class="block2">
		什么时候会用到档案的比对啊？通常是『同一个软件包的不同版本之间，比较配置文件与原始档的差异』，
		所以啰，很多时候所谓的档案比对，通常是用在 ASCII 纯文本档的比对上的！
		那么比对档案的指令有哪些？最常见的就是 diff 啰！<br><br>

		<hr><a name="diff"></a><li><span class="text_import1">diff</span></li>
		<div class="block2">
		diff 就是用在比对两个档案之间的差异的，一般是用在 ASCII 纯文本档的比对上。
		我们先预处理一下一个档案好了。假设我要将 /etc/passwd 的内容，将第四行删除，
		第六行则取代成为『no six line』，新的档案放置到 /tmp/test 里面，
		那么应该怎么做？<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">mkdir -p /tmp/test</span>
[root@linux ~]# <span class="term_command">cat /etc/passwd | \</span>
&gt; <span class="term_command">sed -e '4d' -e '6c no six line' &gt; /tmp/test/passwd</span>
<span class="term_say"># 注意一下， sed 后面如果要接超过两个以上的动作时，每个动作前面得加 -e 才行！</span>
</pre></td></tr></tbody></table>

		接下来讨论一下关于 diff 的用法吧！<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">diff [-bBi] from-file to-file</span>
<span class="term_say">参数：
from-file ：一个档名，作为原始比对档案的档名；
to-file   ：一个档名，作为目的比对档案的档名；
注意，from-file 或 to-file 可以 - 取代，那个 - 代表『Standard input』之意。

-b  ：忽略一行当中，仅有多个空白的差异(例如 "about me" 与 "about     me" 视为相同
-B  ：忽略空白行的差异。
-i  ：忽略大小写的不同。
范例：</span>

<span class="term_hd">范例一：比对 /tmp/test/passwd 与 /etc/passwd 的差异：</span>
[root@linux ~]# <span class="term_command">diff /etc/passwd /tmp/test/passwd</span>
4d3    <span class="term_note">&lt;==这里是说，左边档案(/etc/passwd)第四行被删除 (d)</span>
&lt; adm:x:3:4:adm:/var/adm:/sbin/nologin
6c5    <span class="term_note">&lt;==这里是说，左边档案的第六行被取代成右边档案(/tmp/test/passwd)的第五行</span>
&lt; sync:x:5:0:sync:/sbin:/bin/sync
---
&gt; no six line
<span class="term_say"># 很聪明吧！用 diff 就把我们刚刚的处理给比对完毕了！</span>
</pre></td></tr></tbody></table>

		用 diff 比对档案真的是很简单喔！另外， diff 也可以比对整个目录下的差异喔！
		举例来说，我们将两个目录比对一下：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">diff /etc /tmp/test</span>
<span class="term_say">......(前面省略).....</span>
Only in /etc: paper.config
<span class="term_write">diff /etc/passwd /tmp/test/passwd
4d3
&lt; adm:x:3:4:adm:/var/adm:/sbin/nologin
6c5
&lt; sync:x:5:0:sync:/sbin:/bin/sync
---
&gt; no six line</span>
Only in /etc: passwd-
<span class="term_say">......(后面省略).....</span>
</pre></td></tr></tbody></table>

		我们的 diff 很聪明吧！还可以比对不同目录下的相同文件名的内容，
		这样真的很方便喔～<br><br>
		</div>

		<hr><a name="cmp"></a><li><span class="text_import1">cmp</span></li>
		<div class="block2">
		相对于 diff 的广泛用途， cmp 似乎就用的没有这么多了～
		cmp 主要也是在比对两个档案，他主要利用『位』单位去比对，因此，
		当然也可以比对 binary file 啰～(还是要再提醒喔， diff 主要是以『行』为单位比对，
		cmp 则是以『位』为单位去比对，这并不相同！)<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">cmp [-s] file1 file2</span>
<span class="term_say">参数：
-s  ：将所有的不同点的位处都列出来。因为 cmp 预设仅会输出第一个发现的不同点。
范例：</span>

<span class="term_hd">范例一：用 cmp 比较一下 /etc/passwd 与 /tmp/test/passwd </span>
[root@linux ~]# <span class="term_command">cmp /etc/passwd /tmp/test/passwd</span>
/etc/passwd /tmp/test/passwd differ: byte 106, line 4
</pre></td></tr></tbody></table>

		看到了吗？第一个发现的不同点在第四行，而且位数是在第 106 个位处！
		这个 cmp 也可以用来比对 binary 啦！ ^_^<br><br>
		</div>

		<hr><a name="patch"></a><li><span class="text_import1">patch</span></li>
		<div class="block2">
		patch 这个指令与 diff 可是有密不可分的关系啊！我们前面提到，
		diff 可以用来分辨两个版本之间的差异，举例来说，刚刚我们所建立的 /tmp/test/passwd
		与 /etc/passwd 就是两个不同版本之间的档案。那么，如果要『升级』呢？
		就是『将旧的档案升级成为新的档案』时，应该要怎么做呢？
		举例来说，我们可以这样做测试：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">mkdir /tmp/old; cp /etc/passwd /tmp/old</span>
[root@linux ~]# <span class="term_command">mkdir /tmp/new; cp /tmp/test/passwd /tmp/new</span>
[root@linux ~]# <span class="term_command">cd /tmp ; diff -Naur old/ new/ &gt; test.patch</span>
</pre></td></tr></tbody></table>

		此时，在 /tmp/test.patch 档案之中，就记录了新旧的档案之间的差异，
		对了！您必须要了解的是，用 diff 制作这个档案时，旧的档案必须是在前面，亦即是
		diff oldfile newfile 才行喔！此外，新旧档案的『相对目录位置』最好也是一样比较好喔！
		OK！那么如何将旧的内容 (/tmp/old/passwd) 更新到新版 (/tmp/new/passwd) 的内容呢？
		简单的说，可以用这样：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">patch -pN &lt; patch_file</span>
<span class="term_say">参数：
-p  ：后面可以接『取消几层目录』的意思。
范例：</span>

<span class="term_hd">范例一：将刚刚制作出来的 patch file 用来更新旧版数据</span>
[root@linux ~]# <span class="term_command">cd /tmp/old</span>
[root@linux ~]# <span class="term_command">patch -p1 &lt; /tmp/test.patch</span>
patching file passwd
<span class="term_say"># 为什么这里会使用 -p1 呢？因为我们在比对新旧版的数据时，是在 /tmp 底下，
# 而实际的数据是在 /tmp/old 里面，因此，当我们进入到 /tmp/old 时，
# 再查阅 /tmp/test.patch 的第一行如下：
# diff -Naur old/passwd new/passwd (用 head -n 1 /tmp/test.patch)
# 发现到，我们所在的目录其实是 old 里面，所以，就必须要减去一层目录。</span>
</pre></td></tr></tbody></table>

		更详细的 patch 用法我们会在后续的第五章跟大家介绍，
		这里仅是介绍给您，呵呵！我们可以利用 diff 来比对两个档案之间的差异，
		更可进一步利用这个功能来制作修补档案 (patch file) ，让大家更容易进行比对与升级呢！
		很不赖吧！ ^_^
		</div>
	</div>

	<hr><a name="pr"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">档案打印准备： pr</span><br>
	<div class="block2">
		如果您曾经使用过一些图形接口的文字处理软件的话，那么很容易发现，
		当我们在打印的时候，可以同时选择与设定每一页打印时的标头吧！
		也可以设定页码呢！那么，如果我是在 Linux 底下打印纯文本档呢
		可不可以具有标题啊？可不可以加入页码啊？呵呵！当然可以啊！
		使用 pr 就能够达到这个功能了。不过， pr 的参数实在太多了，
		我也说不完，一般来说，我都仅使用最简单的方式来处理而已。
		举例来说，如果想要打印 /etc/man.config 呢？<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">pr /etc/man.config</span>


<span class="term_write">2003-02-10 23:20                 /etc/man.config                  Page 1</span>


#
# Generated automatically from man.conf.in by the
# configure script.
<span class="term_say">.....以下省略......</span>
</pre></td></tr></tbody></table>

		上面特殊字体那一行呢，其实就是使用 pr 处理后所造成的标题啦～
		标题中会有『档案时间』、『档案档名』及『页码』三大项目。
		更多的 pr 使用，请参考 pr 的说明啊！ ^_^
	</div>
</div>


<hr><a name="important"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">重点回顾</span><br>
<div class="block1">
<ul>
<li>使用 grep 或其他工具进行正规表示法的字符串比对时，因为编码的问题会有不同的状态，因此，
    您最好将 LANG 及 LANGUAGE 等变量设定为 C 或者是 en 等英文语系！</li>
<li>
正规表示法 ( Regular Expression ) 的用途主要是用来做为『搜寻』字符串之用，还可以用来过滤特殊讯息等用途；</li>

<li>
由于严谨度的不同，正规表示法之上还有更严谨的延伸正规表示法；</li>

<li>
正规表示法的处理方式，经常是以『整行』或称为『整段』来进行处理的；</li>

<li>
grep 与 egrep 在正规表示法里面是很常见的两支程序，其中， egrep 支持更严谨的正规表示法的语法；</li>

</ul>
</div>

<hr><a name="reference"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">参考资源</span><br>
<div class="block1">
<ul>
	<li>洪朝贵老师的网页：<a href="http://www.cyut.edu.tw/~ckhung/olbook/gnulinux/regexp.shtml" target="_blank">http://www.cyut.edu.tw/~ckhung/olbook/gnulinux/regexp.shtml</a></li>
	<li>PCRE 官方网站：<a href="http://www.perldoc.com/perl5.8.0/pod/perlre.html" target="_blank">http://www.perldoc.com/perl5.8.0/pod/perlre.html</a></li>
	<li>龙门少尉的窝：<a href="http://main.rtfiber.com.tw/~changyj/" target="_blank">http://main.rtfiber.com.tw/~changyj/</a></li>
	<li>Study Area：<a href="http://www.study-area.org/linux/system/linux_shell.htm" target="_blank">http://www.study-area.org/linux/system/linux_shell.htm</a></li>
	<li>中研院计算中心 ASPAC 计划之 awk 程序介绍：<a href="http://phi.sinica.edu.tw/aspac/reports/94/94011/" target="_blank">http://phi.sinica.edu.tw/aspac/reports/94/94011/</a><br>
		鸟哥备份：<a href="http://linux.vbird.org/linux_basic/0330regularex/awk.pdf" target="_blank">http://linux.vbird.org/linux_basic/0330regularex/awk.pdf</a></li>
	<li>中研院计算中心 ASPAC 计划之 sed 程序介绍：<a href="http://phi.sinica.edu.tw/aspac/reports/96/96005/" target="_blank">http://phi.sinica.edu.tw/aspac/reports/96/96005/</a></li>
</ul>
</div>

<hr><a name="FAQ"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">本章习题练习</span><br>
( 要看答案请将鼠标移动到『答：』底下的空白处，按下左键圈选空白处即可察看 )
<div class="block1">
<ul>
	<li>我想要知道某个档案里面含有 boot 的字眼，而这个档案在 /etc/ 底下，我要如何找出这个档案？</li>
	<div class="block2"><font color="white" size="-1">
		既然知道有这个字眼那就好办了！可以直接下达：<ul>grep boot /etc/*</ul>
	</font></div>

	<li>我想要知道，在 /etc 底下，只要含有 XYZ 三个字符的任何一个字符的那一行就列出来，要怎样进行？</li>
	<div class="block2"><font color="white" size="-1">
		『只要』含有 X 或 Y 或 Z 就将该行列出来，因此，我们的范围很很广啦！这个时候就必需要使用到
		[] 这个咚咚！还记得中括号的用途吗？那就是『在中括号里面谨代表一个字符而已！』
		而这个中括号是一个『代表』，可以是一串字也可以是几个不连续的字！这里我们仅需要
		XYZ 其中任何一个，所以可以这样写：<ul>grep [XYZ] /etc/*</ul>
		则只要在每一行当中，只要发现 X 或 Y 或 Z 任何一个，就会将他印出来！这个与
		grep XYZ /etc/* 是『完全不一样』的！请仔细的思考一下ㄟ！
	</font></div>

	<li>我想要找出在 /etc 底下，档案内容含有 * 的文件名？</li>
	<div class="block2"><font color="white" size="-1">
		由于 * 是特殊字符，在变量的订定法则里面曾经提过要将特殊字符移除，需要使用跳脱字符，亦即是
		\ 符号，所以我可以这样下达指令：<ul>grep \* /etc/*</ul>
	</font></div>
</ul>
</div>

<hr><span class="text_history">
2002/07/29：第一次完成；<br>
2003/02/10：重新编排与加入 FAQ ；<br>
2005/01/28：重新汇整基础正规表示法的内容！重点在 regular_express.txt 的处理与练习上！<br>
2005/03/30：修订了 grep -n 'goo*g' regular_express.txt 这一段<br>
2005/05/23：修订了 grep -n '^[a-z]' regular_express.txt 所要撷取的是小写，之前写成大写，错了！<br>
2005/08/22：加入了 awk, sed 等工具的介绍，还有 diff 与 cmp 等指令的说明！<br>
2005/09/05：加入 printf 内，关于 \xNN 的说明！<br>
2006/03/10：将原本的 sed 内的动作(action)中， s 由『搜寻』改成『取代』了！<br>
2006/10/05：在 sed 当中多了一个 -i 的参数说明，也多了一个范例八可以参考。感谢讨论区的thyme兄！<br>
2008/10/08：加入 grep 内的 --color=auto 说明！<hr>
</span>
    </td>
    <td style="width: 16px; font-size: 6px;">　</td></tr>
<tr><td style="width: 16px; height: 16px;">　</td>
    <td style="width: 866px; height: 16px;">　</td>
    <td style="width: 16px; height: 16px;">　</td></tr>
</tbody></table>

<div style="padding-top: 0px; text-align: center;">
<span style="font-size: 80%;">
	<a href="http://linux.vbird.org/" target="_top" title="前往鸟哥的首页">http://linux.vbird.org</a>
	is designed by <a href="mailto:vbird@mail.vbird.idv.tw" title="联络鸟哥(我不要广告信！)">VBird</a>
		during 2001-2011. <a href="http://www.ksu.edu.tw/" target="_blank">ksu.edu</a></span>
                ﻿<div id="apDiv4">
      <p>本网页主要以Firefox配合解析度 1024x768 作为设计依据&nbsp;&nbsp;&nbsp;&nbsp; 鸟哥自由软件整合应用研究室</p></div></div></div>
</center>
</body></html>
