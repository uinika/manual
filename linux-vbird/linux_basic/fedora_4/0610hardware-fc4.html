<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html lang="zh-TW"><head>


	<meta http-equiv="Content-Type" content="text/html; charset=utf8">
	<meta name="Author" content="VBird, 鸟哥">
	<meta name="Description" content="在 Linux 系统上面侦测、维护、变更硬件的方法">
	<title>鸟哥的 Linux 私房菜 -- Linux 硬件侦测与维护</title>
    <script src="../../script/SpryMenuBar.js" type="text/javascript"></script>
	<script src="../../script/index.js" type="text/javascript"></script>
	<link href="../../css/SpryMenuBarHorizontal.css" rel="stylesheet" type="text/css" />
    <link href="../../css/main.css" rel="stylesheet" type="text/css" />
</head><body style="margin: 0pt; padding: 0pt;" class="table"onload="MM_preloadImages('../../index-2.html','../../index-2.html','../../index-2.html','../../index-2.html','../../index-2.html','../../index-2.html','../../index-2.html','../../index-2.html')">

<center>
<div id="apDiv5">
<div> <LINK REL="SHORTCUT ICON" HREF="../../index-2.html">
<!-- ImageReady Slices (title3.ai) -->
<table id="___01" width="898" height="81" border="0" align="center" cellpadding="0" cellspacing="0";>
	<tr>
		<td colspan="15">
			<img src="image/title/title_01.png" width="900" height="1" alt=""></td>
	</tr>
	<tr>
		<td rowspan="4" bgcolor="#182448"><p><img src="http://linux.vbird.org/cgi-bin/Count.cgi?dd=C&amp;ft=5&amp;sh=T&amp;md=8&amp;pad=Y&amp;df=vbird.dic.ksu.edu.tw.dat" width="93" align="left" title="計數器" /></p>
	    <p><font color="#FFFFFF" size="-1">since2012/04/23</font></p></td>
		<td rowspan="4" align="left" valign="top"><a href="../../index.html"><img src="image/title/title_03.png" alt="" width="263" height="79" border="0"></a></td>
		<td colspan="13">
			<img src="image/title/title_04.png" alt="" width="535" height="9" border="0"></td>
	</tr>
	<tr>
		<td rowspan="3">
			<img src="image/title/title_05.png" alt="" width="53" height="70" border="0"></td>
		<td colspan="2" align="left" valign="top"><a href="../0110whatislinux.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image51','','image/title/title_06.png',1)"><img src="image/title/title3_06.png" name="Image51" width="106" height="25" border="0" id="Image51" alt=""/></a></td>
		<td rowspan="2">
			<img src="image/title/title_07.png" alt="" width="27" height="37" border="0"></td>
		<td colspan="3" align="left" valign="top"><a href="../../linux_server/0110network_basic.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image52','','image/title/title_08.png',1)"><img src="image/title/title3_08.png" name="Image52" width="107" height="25" border="0" id="Image52" alt=""/></a></td>
		<td rowspan="2">
			<img src="image/title/title_09.png" alt="" width="37" height="37" border="0"></td>
		<td colspan="2" align="left" valign="top"><a href="../../about.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image53','','image/title/title_10.png',1)"><img src="image/title/title3_10.png" name="Image53" width="75" height="25" border="0" id="Image53" alt=""/></a></td>
		<td rowspan="3">
			<img src="image/title/title_11.png" alt="" width="35" height="70" border="0"></td>
		<td align="left" valign="top"><a href="mailto:vbird@mail.vbird.idv.tw" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image54','','image/title/title_12.png',1)"><img src="image/title/title3_12.png" name="Image54" width="74" height="25" border="0" id="Image54" alt=""/></a></td>
		<td rowspan="3">
			<img src="image/title/title_13.png" alt="" width="21" height="70" border="0"></td>
	</tr>
	<tr>
		<td colspan="2">
			<img src="image/title/title_14.png" alt="" width="106" height="12" border="0"></td>
		<td colspan="3">
			<img src="image/title/title_15.png" alt="" width="107" height="12" border="0"></td>
		<td colspan="2">
			<img src="image/title/title_16.png" width="75" height="12" alt=""></td>
		<td rowspan="2">
			<img src="image/title/title_17.png" alt="" width="74" height="45" border="0"></td>
	</tr>
	<tr>
		<td>
			<img src="image/title/title_18.png" alt="" width="15" height="33" border="0"></td>
		<td colspan="3" align="left" valign="top"><ul id="MenuBar1" class="MenuBarHorizontal">
	  <li><a href="../linux_basic.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image44','','image/title/title_19.png',1)"><img src="image/title/title3_19.png" name="Image44" width="123" height="33" border="0" id="Image44" /></a>
			    <ul>
			      <li><a href="../Mandrake9.0/mandrake9.0.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image46','','image/title/title_26.png',1)"><img src="image/title/title_23.png" name="Image46" width="120" height="26" border="0" id="Image46" alt="" /></a></li>
                  <li><a href="fc4.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image47','','image/title/title_27.png',1)"><img src="image/title/title_24.png" name="Image47" width="120" height="26" border="0" id="Image47" alt="" /></a></li>
                  <li><a href="../linux_basic.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image48','','image/title/title_28.png',1)"><img src="image/title/title_25.png" name="Image48" width="120" height="26" border="0" id="Image48" alt="" /></a></li>
                </ul>
		      </li>
		</ul></td>
		<td>
			<img src="image/title/title_20.png" alt="" width="42" height="33" border="0"></td>
		<td colspan="3" align="left" valign="top"><ul id="MenuBar2" class="MenuBarHorizontal">
	  <li><a href="../../linux_server/index.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image45','','image/title/title_21.png',1)"><img src="image/title/title3_21.png" name="Image45" width="125" height="33" border="0" id="Image45" /></a>
			    <ul>
			      <li><a href="../../linux_server/linux_redhat9/redhat9.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image43','','image/title/title_26.png',1)"><img src="image/title/title_23.png" name="Image43" width="120" height="26" border="0" id="Image43" alt=""/></a></li>
			      <li><a href="../../linux_server/centos4.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image49','','image/title/title_27.png',1)"><img src="image/title/title_24.png" name="Image49" width="120" height="26" border="0" id="Image49" alt="" /></a></li>
			      <li><a href="../../linux_server/index.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image50','','image/title/title_28.png',1)"><img src="image/title/title_25.png" name="Image50" width="120" height="26" border="0" id="Image50" alt="" /></a></li>
		        </ul>
		      </li>
		</ul></td>
		<td>
			<img src="image/title/title_22.png" alt="" width="47" height="33" border="0"></td>
	</tr>
	<tr>
		<td>
			<img src="image/title/Spacer.gif" width="101" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="263" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="53" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="15" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="91" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="27" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="5" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="42" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="60" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="37" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="28" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="47" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="35" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="74" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="22" height="1" alt=""></td>
	</tr>
</table>
<!-- End ImageReady Slices -->
<script type="text/javascript">
<!--
var MenuBar1 = new Spry.Widget.MenuBar("MenuBar1", {imgDown:"SpryAssets/SpryMenuBarDownHover.gif", imgRight:"SpryAssets/SpryMenuBarRightHover.gif"});
var MenuBar2 = new Spry.Widget.MenuBar("MenuBar2", {imgDown:"SpryAssets/SpryMenuBarDownHover.gif", imgRight:"SpryAssets/SpryMenuBarRightHover.gif"});
//-->
</script>
</div>
<table summary="本文内容的排版" style="width: 898px;" border="0" cellpadding="0" cellspacing="0">
<tbody><tr><td style="width: 16px; height: 16px;">　</td>
    <td style="width: 866px; height: 16px;">　</td>
    <td style="width: 16px; height: 16px;">　</td></tr>
<tr><td style="width: 16px; font-size: 6px;">　</td>
    <td width="866">

<!-- 本文的档头部分 -->
<div style="text-align: center;">
    <a href="http://linux.vbird.org/linux_basic/0610hardware/0610hardware.php">
    <span class="text_head0"><span class="text_head_en">Linux </span>硬件侦测与维护</span></a><br>
</div>
    <div style="text-align: right;">
        <span class="text_history">最近更新日期：2005/11/25</span>
    </div>


<center>本文已不再维护，更新文章请参考<a href="http://linux.vbird.org/linux_basic/0610hardware.php">此处</a></center>
<!-- 本文的档头部分 -->
<center><table class="head1" summary="排版：文章档头的说明"><tbody><tr><td class="head1">
	谈完了 Linux 的系统操作，再来得要了解一下若您的主机硬件更换，或者是想要进行主机的温度侦测时，
	应该要怎么作？在这个章节当中，我们会谈到如何以 Linux kernel 里面的 lm_sensor 功能，
	以及利用 LVM 来制作一个大型的硬盘，让您的 filesystem 容量更具有弹性喔！
	当然啦，在 Linux 系统上面接上您的打印机，也是一个很好玩的工作喔！那就来读一读吧！
</td></tr></tbody></table></center>

<!-- 本文的连结区部分 -->
<div class="block1">
<span class="text_h1">
1. <a href="#hw_pre">准备好你的硬件：</a><br>
	<span class="text_h2">
	　　1.1 <a href="#hw_pre_find">硬件信息的收集</a>： <a href="#lspci">lspci</a>, 
		<a href="#iostat">iostat...</a><br>
	　　1.2 <a href="#hw_pre_usb">驱动 USB 装置：</a><br>
	　　1.3 <a href="#hw_pre_lm">使用 lm_sensors 取得温度、电压等信息：</a><br>
	</span>
2. <a href="#fc_setup">FC4 的系统操作： setup 功能</a><br>
3. <a href="#cups">利用 CUPS 架构您的打印机：</a><br>
4. <a href="#lvm">特殊的 filesystem： LVM</a><br>
	<span class="text_h2">
	　　4.1 <a href="#lvm_whatis">什么是 LVM： PV, PE, VG, LV</a><br>
	　　4.2 <a href="#lvm_flow">制作一个可使用的 LVM 磁盘流程</a><br>
	　　4.3 <a href="#lvm_large">让原有的 LVM 磁盘加大的方法： resize2fs</a><br>
	　　4.4 <a href="#lvm_note">注意事项：</a><br>
	</span>
5. <a href="#raid">额外的储存设备 iSCSI 协议的磁盘阵列：</a><br>
	<span class="text_h2">
	　　5.1 <a href="#raid_raid">什么是磁盘阵列</a><br>
	　　5.2 <a href="#raid_iscsi">iSCSI 磁盘阵列的架设与使用</a><br>
	</span>
6. <a href="#reference">参考数据</a><br>
<span class="text_h2">
7. <a href="http://phorum.vbird.org/viewtopic.php?t=23898" target="_blank">针对本文的建议：http://phorum.vbird.org/viewtopic.php?t=23898</a>
</span>
</span>
</div>

<!-- 本文的正式部分 -->
<hr><a name="hw_pre"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">准备好你的硬件：</span><br>
<div class="block1">
	我们这个章节的主要目的在于更深入的了解我们 Linux 主机的硬件，并进一步的将这些硬件信息汇整，
	最好是还能够进行一些侦测与控管啦！这样才可以在最短的时间内了解我们 Linux 主机是否可能发生问题啊！
	这包括主机的电压值是否正确？主机与 CPU 温度是否过高等等。而为了这些目的，当然啦，
	我们就得要先准备好自己的 Linux 主机的硬件啊，至少得要先了解你的 Linux 主机是啥硬件配备啊，
	否则，假如你的硬件本身就是不支持温度侦测，那花再多时间在温度数值的取得，嘿嘿！是没有意义的啦！
	来给他进行下去啰！ ^_^<br><br>

	<hr><a name="hw_pre_find"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">硬件信息的收集： lspci, iostat...</span><br>
	<div class="block2">
		还记得我们在 <a href="http://linux.vbird.org/linux_basic/0610hardware/0510osloader.php">开机与关机流程分析</a> 当中提到的核心功能吧？
		我们的 Linux kernel 会在开机时，以核心内建的功能去侦测主机的种种硬件，
		并尝试加载适当的驱动程序 (模块, modules) 来让硬件正确的启动与运作。
		而核心所侦测到的各项硬件装置，后来就会被记录在 /proc 当中了。
		包括 /proc/cpuinfo, /proc/partitions, /proc/interrupts 等等。
		更多的 /proc 内容介绍，先回到 <a href="http://linux.vbird.org/linux_basic/0610hardware/0440processcontrol.php#proc">程序与资源管理</a> 
		那一篇去瞧一瞧先！<br>

		<div style="padding: 10pt 0pt;" align="right"><table width="90%"><tbody><tr><td><b>Tips:</b><br><span style="color: rgb(0, 144, 0);"><font size="-1">			当然还是得要再提到，核心所侦测到的硬件可能并非完全正确喔！
			他仅是『使用最适当的模块来驱动这个硬件』而已，所以有时候难免会误判啦！
			所以啰，如果你对于系统的稳定性是斤斤计较的，那么或者重新编译一次你的核心，
			应该也是个不错的主意。但是，一般来说，我们没有很建议你一定要重新编译核心就是了。
			关于核心的编译，瞧一瞧下个章节吧！ ^_^
		</font></span></td><td><img src="0610hardware-fc4_files/vbird_face.gif" alt="鸟哥的图示" title="鸟哥的图示"></td></tr></tbody></table></div>
		我们的 Linux 基本上有提供几个简单的指令来将核心所侦测到的硬件叫出来的～
		这包括我们之前提到的：
		<ul><span class="text_import2">
		<li><a href="http://linux.vbird.org/linux_basic/0610hardware/0230filesystem.php#hdparm">hdparm</a>：观察硬盘的种种信息；
		</li><li>lspci：检查整个系统 PCI 接口的各项装置！很有用的指令；
		</li><li><a href="http://linux.vbird.org/linux_basic/0610hardware/0440processcontrol.php#dmesg">dmesg</a>：观察核心运作过程当中所显示的各项讯息记录；
		</li><li>iostat：检查整个 CPU 与接口设备的 Input/Output 状态。
		</li></span></ul>

		无论如何，那个 lspci 真的是一个很不错用的指令，他可以直接将 /proc 底下的关于 PCI 
		接口的各项数据一口气的将他完整的呈现在你面前，可以让您很快速的了解到核心所侦测到的你的主机硬件呢！
		那么就赶紧来看一看你的主机硬件配备吧！ ^_^<br><br>

		基本上，想要知道您 Linux 主机的硬件配备，最好的方法还是直接拆开机壳去察看上面的信息，
		如果环境因素导致您无法直接拆开主机的话，那么直接 lspci 是很棒的一的方法：<br><br>

		<hr><a name="lspci"></a><li><span class="text_import1">lspci</span></li>
		<div class="block2">

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">lspci [-vvn]</span>
<span class="term_say">参数：
-v  ：观察更多的 PCI 装置的信息；
-vv ：比 -v 还要更详细的细部信息；
-n  ：直接观察 PCI 的 ID 而不是厂商名称
范例：</span>

<span class="term_hd">范例一：查阅您系统内的 PCI 装置：</span>
[root@linux ~]# <span class="term_command">lspci</span>
<span style="font: 8pt '细明体';">00:00.0 Host bridge: VIA Technologies, Inc. VT82C693A/694x [Apollo PRO133x] (rev c4)
00:01.0 PCI bridge: VIA Technologies, Inc. VT82C598/694x [Apollo MVP3/Pro133x AGP]
<span class="term_say">.....(中间省略).....</span>
00:0c.0 Ethernet controller: Realtek Semiconductor Co., Ltd. RTL-8139/8139C/8139C+ (rev 10)
01:00.0 VGA compatible controller: nVidia Corporation NV17 [GeForce4 MX 440] (rev a3)</span>
<span class="term_say"># 不必加任何的参数，就能够显示出目前主机上面的各个 PCI 接口的装置呢！
# 从上面的数据可以看出我的显示适配器是 Nvidia 的，主机芯片则是 VIA 的，
# 网络卡则是 Realtek 的 8139 (亦即是螃蟹卡啊！)。</span>
</pre></td></tr></tbody></table>

			基本上，我们可以由 lspci 立刻得到主机上面的各项设备，如果还想要知道他所占用的
			IRQ 与 I/O port 时，可以加上『 lspci -vv 』来查阅啊！简单得不得了吧！
			另外，您会发现上表当中的每一行最前面都有一组怪怪的数字，那是什么？
			其实那就是我们的硬件侦测的数据啦！您可以对照着底下这个档案来查阅：
			<ul><span class="text_import2"><li>/usr/share/hwdata/pci.ids</li></span></ul>
			那个就是 PCI 的标准 ID 与厂牌名称的对应表啦！
			此外，刚刚我们使用 lspci 时，其实所有的数据都是由 /proc/bus/pci/ 
			目录下的数据所取出的呢！了解了吧！ ^_^<br><br>
		</div>

		<hr><a name="iostat"></a><li><span class="text_import1">iostat</span></li>
		<div class="block2">
			刚刚那个 lspci 找到的是目前主机上面的硬件配备，那么整部机器的储存设备，
			主要是硬盘对吧！请问，您硬盘由开机到现在，已经存、取多少数据呢？
			这个时候就得要 iostat 这个指令的帮忙了！<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">iostat [-c|-d] [-k] [-t] [间隔秒数] [侦测次数]</span>
<span class="term_say">参数：
-c  ：仅显示 CPU 的状态；
-d  ：仅显示储存设备的状态，不可与 -c 一起用；
-k  ：默认显示的是 block ，这里可以改成 K bytes 的大小来显示；
-t  ：显示日期出来；
范例：</span>

<span class="term_hd">范例一：显示一下目前整个系统的 CPU 与储存设备的状态</span>
[root@linux ~]# <span class="term_command">iostat</span>
Linux 2.6.12-1.1456_FC4 (localhost.localdomain)    10/27/05

avg-cpu:  %user   %nice    %sys %iowait   %idle
           0.34    0.01    0.34    0.20   99.11

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
hda               0.55         2.64         3.28    6631507    8230880
hdb               0.21         4.52         9.10   11342022   22855752
<span class="term_say"># 瞧！上面数据总共分为上下两部分，上半部显示的是 CPU 的当下信息；
# 下面数据则是显示储存装置 /dev/hda, /dev/hdb 的相关数据，他的数据意义：
# tps       ：平均每秒钟的传送次数！与数据传输『次数』有关，非容量！
# kB_read/s ：开机到现在平均的读取单位；
# kB_wrtn/s ：开机到现在平均的写入单位；
# kB_read   ：开机到现在，总共读出来的档案单位；
# kB_wrtn   ：开机到现在，总共写入的档案单位；</span>

<span class="term_hd">范例二：每两秒钟侦测一次，并且共侦测三次储存装置</span>
[root@linux ~]# <span class="term_command">iostat -d 2 3</span>
Linux 2.6.12-1.1456_FC4 (localhost.localdomain)    10/27/05

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
hda               0.55         2.64         3.28    6631507    8231496
hdb               0.21         4.51         9.10   11342022   22855752

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
hda               0.00         0.00         0.00          0          0
hdb               0.00         0.00         0.00          0          0

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
hda               0.00         0.00         0.00          0          0
hdb               0.00         0.00         0.00          0          0
<span class="term_say"># 仔细看一下，如果是有侦测次数的情况，那么第二次以后所显示的数据，
# 则代表两次侦测之间的系统传输值！举例来说，上面的信息当中，
# 第二次显示的数据，则是两秒钟内(本案例)系统的总传输量与平均值。</span>
</pre></td></tr></tbody></table>

			透过 lspci 及 iostat 可以约略的了解到目前系统的状态啊！
			还有目前的主机硬件数据呢！知道这些信息后，我们就可以来玩一些比较不一样的东西啰！ ^_^
		</div>
	</div>

	<hr><a name="hw_pre_usb"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">驱动 USB 装置：</span><br>
	<div class="block2">
		在现在的计算机里面，你或许真的无法想象没有 USB 接口装置的主机～
		因为不论我们的键盘、鼠标、打印机、扫描仪、随身碟等等，几乎都是使用到 USB 来作为传输的接口的。
		所谓这 USB (Universal Serial Bus) 最早是在 1994 年被发展出来，
		到 1996 年前后发展出 version 1.0 ，当时的速度大约在 12Mbit/second，
		到了 1999 年发展出 version 2.0 ，这一版的速度则提高到 480Mbit/second。<br><br>

		USB 有很多的优点啦，包括他是可以延伸的，每个 USB port 都可以最多接到 127 个装置！
		速度又快，又具有 Plug and Play (即插即用) 
		的优点，所以近期以来被用来作为携带式装置的主要数据传输接口呢！<br><br>

		<li><span class="text_import1">关于 USB 的芯片版本：</span></li>
		<div class="block2">
		目前 USB 的控制器主要有两种规格，分别是：<ul><span class="text_import2">
		<li>OHCI (Open Host Controller Interface)：主要由 Compaq 所发展，包括 Compaq, SiS, ALi 
			等等厂商发展的芯片都是用这个模块；
		</li><li>UHCI (Universal Host Controller Interface)：主要由 Intel 所发展，
			包括 Intel, VIA 等等厂商发展的芯片都是使用这个模块。</li></span></ul>
		但不论是哪一种 USB 的装置，这两种芯片都能够启动并且支持的。
		不过，以使用上来说， UHCI 比较容易使用，但是他的驱动程序比较复杂一些，
		可能也会消耗比较多的 CPU 资源就是了。<br><br>
		</div>

		也就是说，基本上，如果你使用 lsmod 时，会发现到 (O|U)HCI 之类的模块时，
		那就表示您的 Linux 主机已经有加载 USB 的驱动程序了啦！
		这也是目前 FC4 默认加载的模块之一啊！不过，如果您的 USB 装置比较多，
		包括键盘、鼠标、游戏杆等等的 USB 装置时，那么可能还需要加载 USB Human Interface Device (HID)
		模块才行呢！以鸟哥的 FC4 测试机来说，我的主机是 Intel 815 芯片的 (P-III 的 CPU)，
		由于没有提供 USB 2.0 ，所以，鸟哥自己买了一张 USB 2.0 的扩充卡。然后，使用 lsmod 
		出现如下的画面啰！<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">lsmod</span>
Module                  Size  Used by
uhci_hcd               43345  0
ehci_hcd               48333  0
<span class="term_say"># 我仅列出这两个模块而已～上面的是 UHCI 模块，底下则是 USB 增强模块。</span>

[root@linux ~]# <span class="term_command">modinfo ehci_hcd</span>
<span class="term_say">....省略.....</span>
description:    10 Dec 2004 USB 2.0 'Enhanced' Host Controller (EHCI) Driver
author:         David Brownell
license:        GPL
<span class="term_say">....省略.....
# 很有趣吧！说的是 Enhanced Host Controller 呢！</span>
</pre></td></tr></tbody></table>

		<div style="padding: 10pt 0pt;" align="right"><table width="90%"><tbody><tr><td><b>Tips:</b><br><span style="color: rgb(0, 144, 0);"><font size="-1">			事实上，更多的 USB 装置的信息都放置到 hotplug 这个套件里面呢～
			你可以到 /etc/hotplug.d/ 目录下去查阅一下相关的说明喔！
		</font></span></td><td><img src="0610hardware-fc4_files/vbird_face.gif" alt="鸟哥的图示" title="鸟哥的图示"></td></tr></tbody></table></div>
		<li><span class="text_import1">启动 USB 随身碟：</span></li>
		<div class="block2">
			我们之前谈过 USB 的磁盘代号是： /dev/sd[a-p] 之类的，类似 SCSI 硬盘的代号，
			这是因为 USB 的磁盘装置使用 SCSI 相关的装置代号，因此，如果您要使用 USB
			随身碟的话，嘿嘿！那么您的 Linux 主机就得要支持 SCSI 装置才行～<br><br>

			此外，为了让 USB 磁盘装置顺利的被使用，因此，有时候还得要启动 usb-storage 模块才行～
			所以啰，光是有 USB 的 uhci 模块还不行，还得要配合 usb-storage 啦～
			而一般 USB 的装置都会被主动的侦测，核心也会主动的加载 USB 装置的驱动模块，
			所以您应该不需要手动加载 usb-storage 才是。不过，如果老是无法驱动时，
			那么不妨手动加载 usb-storage 试看看。<br><br>

			顺利加载各个需要的模块之后，直接下达 fdisk -l 应该就可以看到您的 USB 
			随身碟的装置代号才是！一般来说，如果是第一个 USB 磁盘装置的话，
			应该可以看到一个名为 /dev/sda1 的装置，使用 mount  将他挂载起来即可啊！
			详细的挂载 (mount) 与挂载点还有文件系统格式 (filesystem) 鸟哥在这里就不谈了，
			翻翻第二篇的内容去！ ^_^<br><br>
		</div>

		<li><span class="text_import1">启动 USB 打印机：</span></li>
		<div class="block2">
			要驱动 USB  打印机也很简单啊！
			只要做好 USB 打印机的装置代号即可！反正我们的 usb 模块已经加载了嘛！
			要建立 USB 打印机的装置代号得使用 mknod 这个指令才行。
			此外， USB 打印机装置的 major, minor 代号分别是 180 0，
			所以，建立的方法为：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">mkdir -p /dev/usb</span>
[root@linux ~]# <span class="term_command">mknod /dev/usb/lp0 c 180 0</span>
[root@linux ~]# <span class="term_command">chown root:lp /dev/usb/lp0</span>
[root@linux ~]# <span class="term_command">chmod 660 /dev/usb/lp0</span>
[root@linux ~]# <span class="term_command">ls -l /dev/usb/lp0</span>
crw-rw----  1 root lp 180, 0 Nov  7 16:03 /dev/usb/lp0
[root@linux ~]# <span class="term_command">echo "testing" &gt; /dev/usb/lp0</span>
</pre></td></tr></tbody></table>

			鸟哥这里是以 FC4 为范例，要注意， /dev/usb/lp0 的权限必须要与 /dev/lp0 相同，
			所以，我这里还得要使用  chown  与  chmod 来变换该装置档案的权限才行。
			建立好之后，就可以使用 cups 之类的软件来管理这一部打印机啰！ ^_^。
			事实上，除了比较早期的 Linux distributions 之外，较新的 distributions
			已经帮我们建立好 /dev/usb/lp0 等档案装置了呢！真是方便！<br><br>
		</div>

		在我们一般的生活当中，最常见的两种 USB 装置，就是随身碟与打印机了，
		所以鸟哥在这里仅就这两种装置来介绍启动的方法，如果您还有其他的 USB 装置要驱动的话，
		请参考底下这一篇的内容啊！
		<ul><li><a href="http://www.linux-usb.org/USB-guide/book1.html" target="_blank">http://www.linux-usb.org/USB-guide/book1.html</a></li></ul>
		至于 USB 打印机的实际驱动，我们还得要继续 CUPS 章节的内容才行喔！<br><br>
	</div>

	<hr><a name="hw_pre_lm"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">使用 lm_sensors 取得温度、电压等信息</span><br>
	<div class="block2">
		玩计算机硬件的朋友们一定都听过所谓的『超频』这玩意儿，所谓的『超频』就是让系统原有的运作频率增加，
		让 CPU/PCI/AGI 前端总线速度提升到非正规的频率，以取得较高的计算机效能。
		这在早期对于单价还是很贵的计算机来说，可以让我们花比较少的钱去获得比较高效能的计算机哩！
		不过，超频要注意的地方可不少，包括电压不可高出 CPU 的负荷、CPU 风扇必须要强有力，
		避免因为温度过高导致系统当机等等。<br><br>

		不过现今的计算机速度已经够快了，我们的 Linux 主机也实在不建议您超频，
		因为整体效能可能增加不了多少，但是却会让您的主机寿命减少、系统不稳定呢！
		而由早期超频的『技术培养』过程当中，我们知道『<span class="text_import2">CPU 的温度、系统的相关电压</span>』
		是影响主机是否稳定的一项重要指标喔！所以啰，如果能够随时掌握温度、电压，
		其实对于系统还是有一定程度的监控啦。<br><br>

		其实各大主要主板商与芯片组，都会有温度、压力的侦测器在主机内，
		这个我们可以在主板操作手册或者是在 BIOS 内的『 Monitor 』项目找到相关的温度、压力数据。
		在 Windows 系统当中，厂商有推出相关的软件来侦测，那么在 Linux 当中呢？呵呵！也是有啊！那就是
		lm_sensors 这套好用的东西了！<br><br>

		与之前版本不同的是，FC4 已经内建了这个 lm_sensors 套件了，所以我们不需要手动去安装他！
		真是好高兴啊～检查看看您的主机是否有这个玩意儿吧！<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">rpm -qa | grep lm_sensors</span>
lm_sensors-2.9.1-3.FC4.2
</pre></td></tr></tbody></table>

		如果您的 Linux distributions 是比较早期的版本，那么就只好请您自行前往
		<a href="http://www2.lm-sensors.nu/~lm78/" target="_blank">http://www2.lm-sensors.nu/~lm78/</a> 官方网站直接下载 tarball
		并且安装他啰～如果您使用的是 FC3 或 FC4 ，那么我们就直接来处理吧！<br><br>

		由于 lm_sensors 主要是依据『主板芯片组的型号，带入相关的模块后，再侦测其温度、压力』的，
		如果该主板芯片组并不是 lm_sensors 所支持的模块，那自然就无法找出该芯片组的温压啰～
		所以啦，我们在使用 lm_sensors 之前，必须要确定主板是有提供温度、电压的，
		再来，必须要加载主板的驱动模块，然后才有办法使用 lm_sensors 来进行侦测。<br><br>

		而，好消息是， lm_sensors 本来就提供我们一个不错的主板芯片组侦测程序，
		那就是 sensors-detect 这个指令。侦测到主板芯片组后，将该信息写入配置文件当中，
		就可以使用 sensors 指令直接读取目前的 CPU、机壳、电源、风扇等等的信息了！
		直接来作看看吧！<br>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">1. 先侦测主板的芯片组啊！</span>
[root@linux ~]# <span class="term_command">sensors-detect</span>
<span class="term_say"># 开头会有一些简单的说明，看看就好！</span>
It is generally safe and recommended to accept the default answers to all
questions, unless you know what you're doing.

 We can start with probing for (PCI) I2C or SMBus adapters.
 You do not need any special privileges for this.
 Do you want to probe now? (YES/no): <span class="term_write">y</span>
Probing for PCI bus adapters...
Use driver `rivatv' for device 01:00.0: GeForce2 MX
Use driver `i2c-viapro' for device 00:07.4: VIA Technologies VT82C686 Apollo ACPI
Probe succesfully concluded.
<span class="term_say"># 接下来的行为当中，反正你就一直按 Enter  就可以了！让他自动去侦测！</span>

 I will now generate the commands needed to load the I2C modules.
 Sometimes, a chip is available both through the ISA bus and an I2C bus.
 ISA bus access is faster, but you need to load an additional driver module
 for it. If you have the choice, do you want to use the ISA bus or the
 I2C/SMBus (ISA/smbus)?

To make the sensors modules behave correctly, add these lines to
/etc/modules.conf:

<span class="term_write">#----cut here----
# I2C module options
alias char-major-89 i2c-dev
#----cut here----

To load everything that is needed, add this to some /etc/rc* file:

#----cut here----
# I2C adapter drivers
modprobe i2c-viapro
modprobe i2c-isa
# I2C chip drivers
modprobe eeprom
modprobe via686a
# sleep 2 # optional
/usr/bin/sensors -s # recommended
#----cut here----</span>
<span class="term_say"># 上面的关键是重点！告诉你要如何加载模块的一个简单的范例啊！</span>

Do you want to generate /etc/sysconfig/lm_sensors? (YES/no):
Copy prog/init/lm_sensors.init to /etc/rc.d/init.d/lm_sensors
for initialization at boot time.

<span class="term_say"># 如果想要确认一下 sensors-detect 侦测到的结果是否正确，
# 可以使用 lspci 查阅一下喔！鸟哥的例子当中，是这样的：</span>
[root@linux ~]# <span class="term_command">lspci</span>
00:00.0 Host bridge: VIA Technologies, Inc. VT82C693A/694x [Apollo PRO133x] (rev c4)
00:01.0 PCI bridge: VIA Technologies, Inc. VT82C598/694x [Apollo MVP3/Pro133x AGP]
00:07.0 ISA bridge: VIA Technologies, Inc. VT82C686 [Apollo Super South] (rev 22)
<span class="term_say"># 确实找到的是 VIA 的芯片！没有问题！</span>


<span class="term_hd">2. 开始加载模块与修改一些设定数据文件啊！</span>
[root@linux ~]# <span class="term_command">vi /etc/modprobe.conf</span>
<span class="term_write">alias char-major-89 i2c-dev</span>
<span class="term_say"># 将刚刚侦测到的模块给他写入到这个档案当中！这是 kernel 2.6 版的！
# 如果是早期的 kernel 2.4 核心，那就写到 /etc/modules.conf 当中！</span>

[root@linux ~]# <span class="term_command">vi /etc/rc.d/rc.local</span>
<span class="term_write"># Adding the sensor for VIA 686A Chip
/sbin/modprobe i2c-isa
/sbin/modprobe via686a
sleep 2
/usr/bin/sensors -s</span>
<span class="term_say"># 虽然 sensors-detect 希望我可以加载四个模块，不过，鸟哥分析的结果，
# 发现我只要两个模块加载即可～所以，这里我有省去两个 modules 的载入喔！
# 当然啦！建议你还要看一看 /etc/sysconfig/lm_sensors 档案的内容，就比较更清楚了！</span>

[root@linux ~]# <span class="term_command">sync; sync; reboot</span>
<span class="term_say"># 虽然可以直接利用上述的指令在 bash 当中直接处理，不过我不喜欢这样，所以啰，
# 直接给他重新启动系统，就 OK 啦！另外，观察一下是否开机即启动 lm_sensors？</span>
[root@linux ~]# <span class="term_command">chkconfig --list | grep lm_sensors</span>
lm_sensors      0:off   1:off   2:on    3:on    4:on    5:on    6:off


<span class="term_hd">3. 测试侦测主机的状况！</span>
[root@linux ~]# <span class="term_command">sensors</span>
via686a-isa-6000
Adapter: ISA adapter
CPU1 core: +1.73 V  (min =  +1.65 V, max =  +1.90 V)
CPU2 core: +1.73 V  (min =  +1.65 V, max =  +1.90 V)
I/O:       +3.42 V  (min =  +3.12 V, max =  +3.45 V)
+5V:       +5.18 V  (min =  +4.73 V, max =  +5.20 V)
+12V:     +12.24 V  (min = +11.35 V, max = +12.48 V)
CPU1 Fan: 4963 RPM  (min = 3000 RPM, div = 2)
CPU2 Fan: 5232 RPM  (min = 3000 RPM, div = 2)
CPU1 Temp: +39.7°C  (high =   +65°C, hyst =   +55°C)
CPU2 Temp: +40.4°C  (high =   +65°C, hyst =   +55°C)
SBr Temp:  +23.3°C  (high =   +65°C, hyst =   +60°C)
<span class="term_say"># 呵呵呵呵！不但可以看到温度、电压，还有风扇转速，实在太完美了！
# 咦！怎么会是双 CPU 啊！呵呵！因为鸟哥的主板 (这个测试的平台) 是双 CPU 平台，
# 但是 lm_sensors 并没有帮我主动的分出双 CPU ，所以，鸟哥是自行进入配置文件，
# 亦即是 /etc/sensors.conf 去进行修订的工作！</span>
</pre></td></tr></tbody></table>

		基本上，只要这样的步骤，您的主机就可以主动的侦测温度与电压，还有风扇转速等等信息。
		不过，事实上，由于主板设计的不同，所以侦测的结果很有可能是有误差的。以鸟哥的情况来说，
		VIA 694D 是适用双 CPU 的主板，但是 lm_sensors 假定则是仅有单颗 CPU 的显示状况，
		所以，显示的结果与实际的数据是有差异的～此时或许就需要进行调校了。
		调校的步骤很简单，先确定使用 sensors 显示的结果每个项目代表的意义 (可以参考 BIOS 
		硬件侦测结果的顺序来排列) ，然后进入 /etc/sensors.conf 进行修改即可。
		鸟哥以自己的 via686a 这个芯片组来说明！<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">vi /etc/sensors.conf</span>
<span class="term_say"># 在这个档案当中，先找到你的主板芯片组，参考其内容喔！
# 至于除了 chip 后面接的是芯片组外，其他的则以底下的格式来书写的：
# label  '实际侦测的输出或者是代号'  '使用 lm_sensors 输出的信息'
# 举例来说，第一颗 CPU 的侦测项目其实是 "2.0V" ，那个是实际存在
# 主板当中的一个项目，至于后面的 CPU1 core 则是我们自己加上去的，
# 这样才可以在使用 sensors 时，看到输出的结果啊！因此，
# 那个 "2.0V" 不要动～动的是那个 "CPU1 core" 喔！</span>

chip "via686a-*"
    label "2.0V" "CPU1 core"
    label "2.5V" "CPU2 core"
    label "3.3V" "I/O"
    label "5.0V" "+5V"
    label "12V" "+12V"
    label fan1  "CPU1 Fan"
    label fan2  "CPU2 Fan"
    label temp1 "CPU1 Temp"
    label temp2 "CPU2 Temp"
    label temp3 "SBr Temp"

<span class="term_say"># 至于底下的 set 则是在设定『最大、最小限制值』就是了～
# 其中，底下那个 in0 及 in1 分别代表第一、第二个 label 的意思，亦即是
# CPU1 core 及 CPU2 core 啦～再来，则是 temp1~3 ，
# 注意，如果项目不是 "2.0V" 这种以双引号取出的，则必须要使用原本的名称，
# 亦如 fan1, fan2 等等，这个务必了解才行！</span>
    set in0_min 1.65
    set in0_max 1.90
    set in1_min 1.65
    set in1_max 1.90
    set temp1_hyst 55
    set temp1_over 65
    set temp2_hyst 55
    set temp2_over 65
    set temp3_hyst 60
    set temp3_over 65
    set fan1_min 3000
    set fan2_min 3000
</pre></td></tr></tbody></table>

		修改完毕之后，就可以准备准备加入更新啰～那就是使用：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">sensors -s</span>
</pre></td></tr></tbody></table>

		确定更新了这个信息之后，再下达 sensors ，嘿嘿嘿嘿！就可以顺利的取得属于正确的信息啦！
		当然，如果想要以图表输出的话，那么不妨搭配 MRTG 来进行网页绘图～
		这部分网络上面文章就比较多一点，也可以先参考鸟哥的一篇旧文章：
		<ul><li><a href="http://linux.vbird.org/linux_security/old/04mrtg.php" target="_blank">http://linux.vbird.org/linux_security/old/04mrtg.php</a></li></ul>
		加油啰！ ^_^
	</div>
</div>


<hr><a name="fc_setup"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">FC4 的系统操作： setup 功能</span><br>
<div class="block1">
	我们在基础篇谈到很多的概念问题，包括整个开机流程其实看的是 /etc/inittab 的规定项目，
	每个服务启动的 scripts 是放在 /etc/init.d/scriptname 里面，但是启动配置文件则可能会包含在 /etc/sysconfig 内。
	举例来说，刚刚上面提到的 lm_sensors ，他的模块名称就放置在 /etc/sysconfig/lm_sensors 呢～
	当然，您也可以自行更改 /etc/init.d/lm_sensors 的内容，让他不要去读取 /etc/sysconfig/lm_sensors，
	但毕竟是系统默认的状态比较好控制啊～<br><br>

	在我们了解到这些基本的设定信息后，呵呵～终于可以用一下系统提供给我们的简单的操作接口啦～
	在 Fedora 里面，有个 Red Hat 系统总是有提供的工具，套件名称为 setuptool ，
	整个执行的过程则直接下达 setup 就能够处理哩～真是好方便吶！
	有点类似窗口就是了。不过，没有很建议您使用，因为其实直接使用指令或 vi 也可以达成 setup 
	所提供的功能啦！ ^_^。当你以 root 的身份下达『 setup 』后，会出现这样的咚咚：(
	<span class="text_vbird">当然啦！您必须要安装 setuptool 套件才行！
	而且，我是使用 LANG=en_US 来进行画面撷取的，如果您是在可以显示中文的环境下，
	可以使用 zh_TW.big5 </span> )<br><br>

	<center><img src="0610hardware-fc4_files/setup.jpg" title="Red Hat 系统的 setup 指令" alt="Red Hat 系统的 setup 指令" border="1"><br>
		图、Red Hat 系统的 setup 指令</center><br>

	主要的项目其实就是底下这些数据啦：<ul>
	<li>Authentication configuration：<br>
		这是与使用者认证机制较有相关的设定数据，
		包括认证来源的主机确认与本机数据的决定等等；</li><br>
	<li>Firewall configuration ：<br>
		这个是关于系统的防火墙设定。一般来说，手动设定比较好，用这个东西设定，
		常常会搞不懂他到底在哪些地方作了哪些事情～不容易搞定啦！</li><br>
	<li>Keyboard configuration ：<br>
		包括键盘的形式与最重要的键盘的按键对应表。注意，
		这个设定仅与 tty 接口有关，至于 X Window 则不是以这个为设定值。</li><br>
	<li>Mouse configuration ：<br>
		设定鼠标的型态的地方啦；</li><br>
	<li>Network configuration ：<br>
		设定网络参数的地方，包括 IP, network, netmask, dns 等等，不过，
		还需要看完服务器篇关于网络基础的介绍后，才能够比较了解设定值的意义啦！</li><br>
	<li>System services ：<br>
		其实就是使用 ntsysv 的内容喔～亦即设定一些系统服务的地方；</li><br>
	<li>Printer configuration ：<br>
		设定打印机啰；</li><br>
	<li>Sound card configuration ：<br>
		若您的主机上面有声卡，这个项目才会出现！就是设定声卡啦！
	</li><li>Timezone configuration ：<br>
		设定时区；</li><br>
	<li>X configuration ：<br>
		设定 X-Window 相关的硬件配置！亦即是设定 X server 啦！
		也可以手动修改 /etc/X11/xorg.conf 或 XF86Config 啊！</li></ul>
	底下我们就一个一个来介绍这玩意儿吧！并且请注意，你可以利用 &lt;tab&gt; 按键移动，
	也可以利用上下按键移动，利用空格键或者是 [enter] 按键来决定是否需要！<br><br>

	<hr><li><span class="text_import1">Authentication configuration</span></li>
	<div class="block2">
		在按下了 Authentication configuration 后，会出现如下画面：<br><br>
		<center><img src="0610hardware-fc4_files/setup_auth.jpg" title="Setup 的认证机制部分" alt="Setup 的认证机制部分" border="1"><br>
			图、Setup 的认证机制部分</center><br>
		关于使用者身份认证上面，Linux 提供了相当多的机制喔！包括 Linux 本机系统上面的
		MD5 密码编码，以及利用 shadow 将密码移动到 /etc/shadow 档案当中等等。当然啦，
		我们也可以利用网络上面的身份认证主机，包括 NIS, LDAP 以及 Windows 系统提供的认证主机等等，
		只不过这些网络主机提供的服务呢，我们都得要进行客户端联机的设定，并不是启动就会生效的！
		所以啦，我们仅有本机密码档案而已，当然只要选择这两个数据就够了。另外，
		这个设定数据主要是修改 <span class="text_import2">/etc/sysconfig/authconfig</span> 档案哩！
		你也可以自行手动修改该档案即可。<br><br>
	</div>

	<hr><li><span class="text_import1">Firewall configuration</span></li>
	<div class="block2">
		按下 Firewall configuration  后，会出现如下画面：<br><br>
		<center><img src="0610hardware-fc4_files/setup_fire_1.jpg" title="Setup 的防火墙部分" alt="Setup 的防火墙部分" border="1"><br>
			图、Setup 的防火墙部分</center><br>
		注意一下，由于我们在安装的时候，并没有选择防火墙，因此，这里预设会是 (Disabled) 那一项，
		如果你想要启动防火墙，那么就得要先选择 Enabled 后，将光标移动到 Customize 后，
		才能够决定你想要服务项目。按下 Customize 后，会出现如下画面：<br><br>
		<center><img src="0610hardware-fc4_files/setup_fire_2.jpg" title="Setup 的防火墙部分" alt="Setup 的防火墙部分" border="1"><br>
			图、Setup 的防火墙部分</center><br>
		这个地方不是三言两语讲的完的！包括信任网域，以及允许进入的服务器封包～
		很是麻烦。基本上，你只要这样想就好了：<ul>
		<li><span class="text_import2">Trusted Devices</span>：这是信任网域，
			如果你有两张网络卡，一张是 eth0 对内，一张是对外，假设是 eth1 ，那么如果你想要让
			eth0 的进出封包都是为信任，那么这里就可以将 eth0 勾选。不过，要非常非常注意，
			接到外部网域 (Internet) 的那张网络卡，千万不能勾选，否则就挂了！</li><br>

		<li><span class="text_import2">MASQUERADE Devices</span>：这个是『封包伪装』的功能，
			亦即是进行 IP 分享器的功能啦！如果你的 Linux 主机是作为类似 IP 分享器的功能，
			那么对外那张网络卡就得要启动 MASQUERADE 才行！以上面的例子来说，就是勾选 eth1 啦！</li><br>

		<li><span class="text_import2">Allow incoming</span>：这里提到的就是各个服务的内部项目，
			举例来说，你的 Linux 有提供 WWW 服务，又希望大家都能够来查阅，
			那么这个时候就可以在 WWW 那个项目前面勾选啦！</li></ul>
		基本上，这个动作仅是在建立 <span class="text_import2">/etc/sysconfig/iptables</span> 这个档案而已。
		而这个档案预设是不存在的 (因为我们没有启动防火墙啊！) 。
		这里你先有个概念即可，因为，我们未来会介绍以 shell script 的方式建立属于您自己的防火墙系统，
		细节我们会在服务器篇慢慢作介绍的啊！<br><br>
	</div>

	<hr><li><span class="text_import1">Keyboard configuration</span></li>
	<div class="block2">
		这个画面如下：基本上，其实就是选择键盘按钮的对应表而已啦！
		这个设定会修改 <span class="text_import2">/etc/sysconfig/keyboard</span> 就是了。<br><br>
		<center><img src="0610hardware-fc4_files/setup_keyb.jpg" title="Setup 的键盘选择部分" alt="Setup 的键盘选择部分" border="1"><br>
			图、Setup 的键盘选择部分</center><br>
	</div>

	<hr><li><span class="text_import1">Mouse configuration</span></li>
	<div class="block2">
		请选择您的鼠标类型啊！其实直接修改 /etc/sysconfig/mouse 也是可以啦！<br><br>
		<center><img src="0610hardware-fc4_files/setup_mouse.jpg" title="Setup 的鼠标选择部分" alt="Setup 的鼠标选择部分" border="1"><br>
			图、Setup 的鼠标选择部分</center><br>
	</div>

	<hr><li><span class="text_import1">Network configuration</span></li>
	<div class="block2">
		在网络的部分，由于我们的 Linux 支持的网络联机方式众多，而我们台湾地区比较常使用以太网络
		(Ethernet) 的架构，如果你有网络卡，那么别怀疑，当然是选择 Ethernet 啰～
		如下图所示啦！<br><br>
		<center><img src="0610hardware-fc4_files/setup_net_1.jpg" title="Setup 的网络选择部分" alt="Setup 的网络选择部分" border="1"><br>
			图、Setup 的网络选择部分</center><br>
		选择完毕之后，会出现如下窗口，这个就比较麻烦了～基本上，仅有两种格式。
		第一种，你可以直接勾选『Use DHCP』那个项目，让类似 IP 分享器自动的帮你设定好 IP；
		另一种，就如同下列图样，不要勾选 DHCP，直接给予一个 IP 以及相关网络参数即可。
		这些网络参数的设定我们会在服务器篇再介绍的啦！<br><br>
		<center><img src="0610hardware-fc4_files/setup_net_2.jpg" title="Setup 的网络选择部分" alt="Setup 的网络选择部分" border="1"><br>
			图、Setup 的网络选择部分</center><br>
	</div>

	<hr><li><span class="text_import1">Printer configuration</span></li>
	<div class="block2">
		这个项目在决定你的打印机类型啦！基本上，他更动的就是 FC4 提供的 CUPS 打印机队列相关信息～
		而且我们等一下整个设定的项目，其实都会写入 /etc/cups/ 目录下的许多档案当中哩～
		这个功能对于建立打印机的动作来说，实在是相当的不错喔！
		整个动作很繁琐，我们一个一个来说明吧！按下 printer configuration 后，出现这样：<br><br>

		<center><img src="0610hardware-fc4_files/setup_printer_1.jpg" title="Setup 的 Printer 选择部分" alt="Setup 的 Printer 选择部分" border="1"><br>
			图、Setup 的 Printer 选择部分</center><br>

		由于我们需要新增打印机，因此，当然选择那个 new  啊～这里请注意一下，
		我们仅是作个测试而已，所以设定错误也没关系的啦～我这里假设我有一部 HP 2300 Laserjet 的打印机，
		而且是接在本机上面的 USB port ，所以就进行这个动作：<br><br>
		<center><img src="0610hardware-fc4_files/setup_printer_2.jpg" title="Setup 的 Printer 选择部分" alt="Setup 的 Printer 选择部分" border="1"><br>
			图、Setup 的 Printer 选择部分</center><br>

		上面的动作仅是在设定一个打印机的命名而已，那个 hp2300 是随便自己命名的，
		无所谓，但是下方那五个选项就重要了！由于我们使用的是本机装置，因此，就得选 LOCAL 那一项才行。
		如果你有特殊需求，那么才自行设定吧！万一是网络打印机呢？有 IP 的打印机，
		那么这里依旧选择 LOCAL 喔！不要搞错了～<br><br>

		接下来，按下 Next 之后，出现底下的画面，事实上，如果 Linux 主机核心有侦测到打印机，
		那么底下画面的中间部分就会显示出该打印机的相关装置项目。不过，我们是测试嘛！
		当然也会侦测不到啊！因此，这里我们要选择 Custom 那个项目(自定义的意思)。<br><br>
		<center><img src="0610hardware-fc4_files/setup_printer_3.jpg" title="Setup 的 Printer 选择部分" alt="Setup 的 Printer 选择部分" border="1"><br>
			图、Setup 的 Printer 选择部分</center><br>

		然后就是填写打印机接在主机的那个端口上头啦！我这里假设是 USB 打印机，所以自然就是
		/dev/usb/lp0 ，如果是 25 针串行端口的打印机，就填 /dev/lp0 。如果你没有 /dev/usb/lp0 这个装置档案，
		参考上面我们提到的 USB 的装置建立方法吧！<br><br>
		<center><img src="0610hardware-fc4_files/setup_printer_4.jpg" title="Setup 的 Printer 选择部分" alt="Setup 的 Printer 选择部分" border="1"><br>
			图、Setup 的 Printer 选择部分</center><br>

		接下来才是选择打印机的型号啊！你可以按上下键，配合 enter 按键来选择到你的打印机。
		我们这里使用 Postscript 打印格式来做为打印机的主要打印模式啊！<br><br>
		<center><img src="0610hardware-fc4_files/setup_printer_5.jpg" title="Setup 的 Printer 选择部分" alt="Setup 的 Printer 选择部分" border="1"><br>
			图、Setup 的 Printer 选择部分</center><br>

		最后有个总结的部分，看看就好～最后就会得到一个名为 hp2300 的打印机了！<br><br>
		<center><img src="0610hardware-fc4_files/setup_printer_6.jpg" title="Setup 的 Printer 选择部分" alt="Setup 的 Printer 选择部分" border="1"><br>
			图、Setup 的 Printer 选择部分</center><br>

		<center><img src="0610hardware-fc4_files/setup_printer_7.jpg" title="Setup 的 Printer 选择部分" alt="Setup 的 Printer 选择部分" border="1"><br>
			图、Setup 的 Printer 选择部分</center><br>

		最后，当你要离开打印机的设定时，他会显示是否要储存的动作，当然选择『Yes』啊！
		不然设定可不会被记录下来的喔！<br><br>
		<center><img src="0610hardware-fc4_files/setup_printer_8.jpg" title="Setup 的 Printer 选择部分" alt="Setup 的 Printer 选择部分" border="1"><br>
			图、Setup 的 Printer 选择部分</center><br>

		其实打印机在 Linux 上面设定是挺麻烦的，尤其是您必须要清楚的了解到打印机使用的模块为何？
		所以，基本上，使用这个项目来设定好你的打印机，实在是一个不错的方法。
		而刚刚的动作做完后，其实会有几个数据被更动，分别是：<ul><span class="text_import2">
		<li>/etc/cups/printers.conf：主要是打印机的相关设定项目；
		</li><li>/etc/cups/cupsd.conf：使用 printer 权限的设定项目；
		</li><li>/etc/cups/ppd/hp2300.ppd：就是刚刚我们选择的打印机型号的模块。</li></span></ul>

		更多与打印机有相关的数据，我们在底下的 CUPS 章节再来讨论啰～<br><br>
	</div>

	<hr><li><span class="text_import1">System services</span></li>
	<div class="block2">
		基本上，这个就是 ntsysv 啦～这个我们已经在 <a href="http://linux.vbird.org/linux_basic/0610hardware/0560daemons.php#ntsysv">认识系统服务</a>
		当中提过了，所以就不再浪费章节啦！<br><br>
	</div>

	<hr><li><span class="text_import1">Timezone configuration</span></li>
	<div class="block2">
		时区的设定，其实就是找出与 /etc/sysconfig/clock 有关的设定项目而已。
		实际上，下面图示出现的咚咚，就是在 /usr/share/zoneinfo/ 有关而已。<br><br>
		<center><img src="0610hardware-fc4_files/setup_time.jpg" title="Setup 的时区选择部分" alt="Setup 的时区选择部分" border="1"><br>
			图、Setup 的时区选择部分</center><br>



	</div>

	<hr><li><span class="text_import1">X configuration</span></li>
	<div class="block2">
		说穿了，其实就是直接设定 X Server 的配置文件，在 Xorg 就是 /etc/X11/xorg.conf 啦！
		至于整个结果有没有成功，还得要观察 <span class="text_import2">/var/log/Xorg.setup.log</span>
		这个档案的输出结果才能了解喔！<br><br>
	</div>

	鸟哥个人认为，这个 setup 的工具是很好用的～只是，如果能够完全清楚整个系统架构的话，
	再来玩这个小程序会比较好啦！ ^_^。当然啰，打印机的工具实在很不错～
	可以提供给您参考参考！<br><br>
</div>


<hr><a name="cups"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">利用 CUPS 架构您的打印机：</span><br>
<div class="block1">
	打印机对于日常生活来说，很重要吧！呵呵～没错啊！尤其我们的 Linux 主机如果未来还要作为
	Printer server 的话，那么自然就得要先建立好打印机的联机啦！刚刚前一个小节我们仅是简单的利用
	setup 来建立一部不存在的打印机而已～基本上，你必须要了解到整个 Linux 针对打印的动作是如何，
	才能够清楚的了解到我们要如何管理打印机啊！ ^_^<br><br>

	<hr><li><span class="text_import1">BIOS 当中，针对打印机的设定项目：</span></li>
	<div class="block2">
		在打印机的设定当中，鸟哥曾经发生过一件相当糗的事情，我拼了老命的设定 
		LPRng 以及 CUPS 就是无法设定好 Printer ，虽然已经连上打印机了，但是就是印出来都是乱码，
		很伤脑筋～等到我花了一整天去恶搞之后，最后竟然发现，错误的地方在于『BIOS 的并行端口设定』唉！
		伤脑筋的很～还记得每次开机的时候系统都会去读取 BIOS 的设定吗？一般来说，按下 DEL 
		按键后，会进入 BIOS 的设定画面，在该画面当中，选择相关的设定参数，与 Parallel 
		有关的项目，将『模块』改成 EPP/SPP 吧！这样就可以支持您的打印机了！天吶！
		就因为这个设定值，让鸟哥花了一两天的时间，还差一点将主机砸掉....<br><br>
	</div>

	<hr><li><span class="text_import1">Linux printer 的打印作业之进行：</span></li>
	<div class="block2">
		在 Linux 环境下，如何开始一个打印作业呢？基本上，打印作业当然是由程序所产生的啦～
		不论是 Open Office  之类的办公软件，或者是直接以 lpr 来进行打印的工作，反正，总是需要有打印的指令后，
		产生一些信息，交给打印机来处理就是了。在进入打印机的实际打印之前，
		Linux 会先将该项打印作业放置到队列 (queue) 当中，而每一项工作都会被分为两个档案，
		分别是实际要打印的数据，以及该打印作业的权限啊！。
		最后由 Linux 所支持的打印模式 (LPRng 或 CUPS) 来将该数据转成打印机认识的格式后，
		就可以由打印机输出了。等到打印完毕，该工作就会被 queue  所移除。<br><br>

		就是因为如此，因此，我们虽然建立了一个不存在，或者是打印机暂时无法使用的情况下，
		依旧是可以使用打印软件来打印数据的，只是该打印作业会被暂时存放在 queue 当中就是了。
		另外，那个打印模式是很重要的一个概念喔！
		打印机通常仅认识自己的数据格式，所以，我们必须要让 Linux 将数据处理成打印机能够读取的数据格式啊！
		一般来说，Linux  里面有个很通用的打印信息，亦即是 Postscript 打印格式，
		但是您的打印机可不见得会支持这种格式。果真如此时，就得要使用所谓的滤镜 (filter)
		来处理数据成为打印机认识的格式了。<br><br>

		由于 postscript 的打印比较好，因此，实在很建议您，
		直接购买支持 postscript 打印格式的打印机就好了。那么如何得知您的打印机是否支持该格式？
		建议您可以前往这里查阅一下啰：
		<ul><li><a href="http://www.linuxprinting.org/" target="_blank">http://www.linuxprinting.org/</a></li></ul>
		举例来说，我们研究室使用的是 HP Laserjet 2300 的机型，所以鸟哥选择了上面网页当中的 
		Printer list，亦即是：<a href="http://www.linuxprinting.org/printer_list.cgi" target="_blank">http://www.linuxprinting.org/printer_list.cgi</a> ，然后选择
		『HP』与『LaserJet 2300』后，出现如下网页的连结：
		<a href="http://www.linuxprinting.org/show_printer.cgi?recnum=HP-LaserJet_2300" target="_blank">http://www.linuxprinting.org/show_printer.cgi?recnum=HP-LaserJet_2300</a> ，
		在该网页当中，他有提到 Postscript 的格式在这部打印机上面可是工作的很完美喔！
		呵呵！这样就对啦！ ^_^<br><br>
	</div>

	<hr><li><span class="text_import1">Linux Printer 的 daemon</span></li>
	<div class="block2">
		Linux 管理打印机的 daemon 主要分为两种，一种是 LPRng ，一种则是较新的 CUPS
		( Common Unix Printing System )。我们这里仅就 CUPS 来进行说明啰。<br><br>

		刚刚提到，我们的打印作业是由程序达成的，例如 lpr 等指令。
		而打印作业被建立后，则被放置到队列当中等待 Linux print daemon 的分析与转换。
		这个 CUPS 的 daemon 就是在进行这个数据转换的工作啦！<br><br>

		CUPS 除了可以利用 /etc/cups/mime.types 辨识待转换打印数据的格式之外，
		他还可以使用不同的滤镜 (filter) 来转换格式，相关的滤镜都放置到 /usr/lib/cups/filter/ 目录下。
		当然啦，我们提到有个 postscript 打印格式吧，是否为 postscript 格式有不同的转换方法喔：
		<ul>
		<li><span class="text_import2">Postscript 格式</span><br>
		由于 Linux 对于打印机格式最熟悉的就是 postscript 了，因此，如果是 postscript 
		的打印机，那么打印数据将会被 /etc/cups/mime.conves 及 /usr/lib/cups/filter/pstops
		转换与分析页数，然后直接交给打印机将数据输出！</li><br>

		<li><span class="text_import2">非 postscript 格式</span><br>
		当您的打印机对 postscript 格式并不支持时，那么该数据便会以其他的滤镜进行数据格式的转换。
		转换的数据可能是 Ghostscript 格式，或者是直接以打印机的格式来直接打印。
		无论如何，您还是得要了解一下打印机的打印格式才行啊！
		</li></ul>

		为了要让数据变成 postscript ，好让打印机能够顺利的打印，因此，
		我们的 cups 会去参照所谓的 Postscript Printer Discription (PPD)，
		亦即是 postscript 的打印机描述定义数据，并且依据该定义来将数据转换成为 
		postscript 的格式啊！<br><br>

		事实上， CUPS 已经帮我们建立了很多 PPD 定义档了，透过这些 PPD 档案的描述，
		我们的 CUPS 可以自行取得适用的滤镜，不再需要像以前的 LPRng ，还得要自行测试滤镜是否工作成功说！
		这些适用的 PPD 都被放置到底下的目录当中了：
		<ul><span class="text_import2"><li>/usr/share/cups/model</li></span></ul>

		但是，由于这些定义数据都可能一直在更新，因此，我们的 FC4 使用的是利用 foomatic 
		这个套件来辅助进行在线驱动程序的下载呢！所以啊，如果您的 Linux 
		没有连接上 Internet 的话，那么可能就无法取得最正确的打印机描述定义文件 (PPD) 了。
		另外，在鸟哥看过的 Distributions 当中， SuSE server 9 就直接将整个打印机的 PPD 由
		<a href="http://www.linuxprinting.org/download/PPD/" target="_blank">http://www.linuxprinting.org/download/PPD/</a> 捉下来，
		呵呵！也是可以啦！所以说，如果您想要自行下载最新的打印格式定义档案，
		那就自行到 http://www.linuxprinting.org/ 去搜寻属于您的打印机 ppd 档案，
		然后将他放置到 /usr/share/cups/model/ 当中即可！<br><br>
	</div>

	<hr><li><span class="text_import1">CUPS 支持的联机模式</span></li>
	<div class="block2">
		在一般内部局域网络当中，较常见的打印机链接方式与分享方式有底下这几种：<ul>

		<li><span class="text_import2">socket</span><br>
			数据透过 internet socket(端口口)来传送，一般为 port 9100 或 35。
			如果想要进行数据的传输与打印，可以透过在浏览器上面输入：
			socket://host-printer:9100/ 来进行。不过，这种模式不常用就是了。</li><br>
		<li><span class="text_import2">LPD (Line Pritner Daemon)</span><br>
			就是我们之前提到的 LPRng 所支持的主要 daemon 啦～他是较早的打印协议啊，
			主要是利用串行端口来达成打印的需求，打印机名称就是 LPT1/LPT2... 等等。
			目前还是可以在比较早期的 Linux distributions 看到这种打印方式。</li><br>
		<li><span class="text_import2">IPP (Internet Printing Protocol)</span><br>
			这是目前比较流行的打印机打印协议，我们的 CUPS 预设也是支持这种协议啊！
			当启动 IPP 时，打印机会启动 port 631 ，打印的数据就是透过这个
			port 来进行传送的。另外，如果您的打印机或者 Linux 主机启动了 ipp 之后，
			嘿嘿！你可以直接使用浏览器，输入： ipp://printer_IP/printername
			就能够直接在线处理打印机的设定了！方便的很啊！</li><br>
		<li><span class="text_import2">SMB (Standard Message Block)</span><br>
			也有称为 Server Message Block 的，那是什么啊？说穿了，不就是网络上的芳邻吗？
			没错啦！就是利用网芳提供的打印机来进行打印的意思！
			协议使用的是： smb://user:password@host/printer 。</li></ul>

		我们 FC4 预设的 CUPS 使用的就是 IPP 这个协议说～也就是说，我们的 Linux 如果能够顺利的接上 printer 的话，
		那么他就是一部网络打印机了啦！就这么简单啊～那么我们的 CUPS 预设可以支持哪些连接接口呢？
		有底下这些啦：<ul>
		<li>parallel ：平行串行端口啊，就是 25 针那种玩意儿！他是连接到 /dev/lp[0-2] 等装置。
			在 CUPS 里面的装置使用格式为： <span class="text_import2">parallel:/dev/lp0</span>；
		</li><li>Network Printer ：网络打印机，例如 HP LaserJet 2300 就内建有网络卡，
			也就是说，这个打印机是具有 IP 的，那么在 CUPS 内的使用格式为：
			<span class="text_import2">ipp://hostname_or_ip/printername</span>；
		</li><li>USB ：一般越来越常见的 USB 打印机啊！ CUPS 使用的格式为： 
			<span class="text_import2">usb:/dev/usb/lp0</span> 。</li></ul>
	</div>

	<hr><li><span class="text_import1">在 FC4 下启动 Printer </span></li>
	<div class="block2">
		在 FC4 底下要启动打印机的话，相当的简单啊！其实只要照着刚刚我们上面提到的
		<a href="#fc_setup">setup</a> 指令内的 printer configuration 
		的步骤，一步一步的给他设定下去，就 OK 了啦～但如果你的系统并不是 FC4 的话，
		怎么办啊？没关系～我们可以手动来建立 CUPS 所需要的所有资料啊～
		更多的详细信息可以参考 cups 套件提供的 documents 或者是 man page 说～
		( rpm -ql cups ) 。<br><br>

		在底下，鸟哥以我们研究室的 HP LaserJet 2300 这一部打印机作为介绍，
		这部打印机本身具有网络卡，他的 IP 假定为 192.168.10.119 ，
		接下来，就开始来设定吧！
		<ol>
		<hr><li><span class="text_import1">下载适合的 ppd 定义档：</span><br><br>
			前往 <a href="http://www.linuxprinting.org/printer_list.cgi" target="_blank">http://www.linuxprinting.org/printer_list.cgi</a> 输入打印机的型号，
			然后在出现的画面当中，选择『Recommended driver: Postscript (Home page, custom PPD)』
			里面的那个『custom PPD』，给他点下去，将那个档案捉到 /usr/share/cups/model 里面去就对了！
			以鸟哥的情况来看，刚刚利用我查到的网页链接数据，可以这样做：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">cd /usr/share/cups/model</span>
[root@linux model]# <span class="term_command">wget http://www.linuxprinting.org/foomatic-db/db/
source/PPD/HP/mono_laser/hp_LaserJet_2300.ppd</span>
[root@linux model]# <span class="term_command">ls -l</span>
-rw-r--r--  1 root root 55288 Oct 24 00:52 hp_LaserJet_2300.ppd
</pre></td></tr></tbody></table>

			这就是等一下我们要使用的模块。请注意，在 cups 使用的模块上面，
			都是被放置到 /usr/share/cups/model 内！不要随便摆放～因为我们后面要使用的指令，
			会主动读取这个目录内的主要 PPD 定义档啊！</li><br>

		<hr><li><span class="text_import1">确定 CUPS 及打印机已启动：</span><br><br>
			这个设定很简单啊！这样做就对了：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">/etc/init.d/cups start</span>
[root@linux ~]# <span class="term_command">netstat -tlunp | grep 631</span>
tcp  0  0 127.0.0.1:631   0.0.0.0:*   LISTEN   7228/cupsd
udp  0  0 0.0.0.0:631     0.0.0.0:*            7228/cupsd
[root@linux ~]# <span class="term_command">nmap 192.168.10.119</span>
Starting nmap 3.70 ( http://www.insecure.org/nmap/ ) at 2005-11-11 14:15 CST
Interesting ports on hp2300 (192.168.10.119):
(The 1652 ports scanned but not shown below are in state: closed)
PORT     STATE SERVICE
21/tcp   open  ftp
23/tcp   open  telnet
80/tcp   open  http
280/tcp  open  http-mgmt
443/tcp  open  https
515/tcp  open  printer
<span class="term_write">631/tcp  open  ipp
9100/tcp open  jetdirect</span>
<span class="term_say"># 嘿嘿！远程的 Printer 确实是有提供 631 这个 port 的！
# 假如您具有 USB 打印机的话，那么应该就要变成这样：</span>

[root@linux ~]# <span class="term_command">echo "Testing printer" &gt; /dev/usb/lp0</span>
<span class="term_say"># 如果打印机有数据输出，那么就表示联机没有问题啊！</span>
</pre></td></tr></tbody></table>

			由于不同的打印机联机模式会产生不一样的测试方法，
			所以啰，如果是接在本机上面的，直接使用最简单的数据流重导向就可以测试了！
			如果是网络打印机，那就直接测试网络联机与使用 nmap  来进行测试啦～
			那个 nmap 我们会在服务器篇在好好的谈～现在只要知道他可以用来侦测某部主机的开启的 port，
			算是一个简单的黑客软件～所以，<span class="text_import2">不要拿 nmap 
			来侦测别人的主机！会有司法问题喔！</span><br><br>

		<hr></li><li><span class="text_import1">开始加入打印机到 CUPS 当中：</span><br><br>
			要加入打印机让 CUPS 来管理，可以使用刚刚提到的 <a href="#fc_setup">setup</a> 
			，不过，这个工具似乎无法加入网络打印机的样子！
			所以，如果像鸟哥这种网络打印机的话，可能就不可以使用 setup  啦～这个时候，就使用那个好用的 
			lpadmin 来进行管理啰！<br>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">1. 加入打印机到 CUPS 当中：</span>
[root@linux ~]# <span class="term_command">lpadmin -p [pritner队列] -v [装置代号] -m [model] -E</span>
<span class="term_say">参数：
-p  ：后面接打印机的名称，注意，这个名称是你自定义的，可以随便取一个你记得住的名字
-v  ：后面接的是装置代号，可以是本机的串行端口或者是 USB ，当然也可以是网络打印机
      串行端口    ：   parallel:/dev/lp0
      USB       ：   usb:/dev/usb/lp0
      网络打印机：   ipp://192.168.10.119/
-m  ：就是刚刚提到的那个 ppd 定义档。这个档案必须要被放置到
      /usr/share/cups/model 当中，然后以该目录作为相对路径来书写文件名喔！
-E  ：作为接受 (enable) 打印作业的意思</span>

<span class="term_hd">2. 设定默认或删除打印机</span>
[root@linux ~]# <span class="term_command">lpadmin [-xd] [printer队列]</span>
<span class="term_say">参数：
注意， -x 与 -d 不能同时使用，另外， printer队列 必须是已存在的打印机名称
-x  ：删除一个在 CUPS 管理的打印机
-d  ：若有多部打印机存在 CUPS 当中，使用 -d 可以指定一部默认的打印机。
      则当我们在打印时，忘记选择打印机型式，则以此部默认打印机来打印。</span>

<span class="term_hd">范例一：在本例中，加入一部网络打印机，我的打印机队列填入 laserjet2300</span>
[root@linux ~]# <span class="term_command">lpadmin -p laserjet2300 -v \</span>
&gt; <span class="term_command">ipp://192.168.10.119/ -m hp_LaserJet_2300.ppd -E</span>
<span class="term_say"># 那个 laserjet2300 是自己设定的，怎么设定都没关系啦！
# 至于 hp_LaserJet_2300.ppd 则是我们刚刚由网站下载的档案，
# 注意，一定要放在 /usr/share/cups/model/ 目录当中喔！注意注意！</span>

<span class="term_hd">范例二：加入一个 usb 的打印机喔！</span>
[root@linux ~]# <span class="term_command">lpadmin -p laserjet2300 -v \</span>
&gt; <span class="term_command">/dev/usb/lp0 -m hp_LaserJet_2300.ppd -E</span>

<span class="term_hd">范例三：让 laserjet2300 这部打印机成为默认打印机！</span>
[root@linux ~]# <span class="term_command">lpadmin -d laserjet2300 </span>

<span class="term_hd">范例四：删除 laserjet2300 这部打印机：</span>
[root@linux ~]# <span class="term_command">lpadmin -x laserjet2300 </span>
</pre></td></tr></tbody></table>

			其实刚刚这个 lpadmin 的动作，只是在更新 /etc/cups/ 目录里面的两个数据而已，
			一个是 /etc/cups/printers.conf ，这个档案主要是规范了打印机的相关装置、是否接受打印作业、
			打印机的队列名称、页面的限制等等，反正就是整个打印机的规范就是了。
			至于这个打印机相关的 PPD 档案则是以打印机的队列名称链接到 /etc/cups/ppd/ 目录下，
			以上表的范例一中，我们定义出 laserjet2300 这个队列，使用的是 hp_LaserJet_2300.ppd
			这个定义档，则你会发现， /etc/cups/ppd/laserjet2300 与 /usr/share/cups/model/hp_LaserJet_2300.ppd
			是相同的喔！因为只是要作为一个队列打印机的对应之用嘛！<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">cat /etc/cups/printers.conf</span>
# Printer configuration file for CUPS v1.1.22rc1
# Written by cupsd on Fri 11 Nov 2005 02:40:01 PM CST
&lt;DefaultPrinter laserjet2300&gt;
Info laserjet2300
DeviceURI ipp://192.168.10.119/
State Idle
Accepting Yes
JobSheets none none
QuotaPeriod 0
PageLimit 0
KLimit 0
&lt;/Printer&gt;
<span class="term_say"># 看到否？刚刚我们使用 lpadmin ，增加的信息都在这里啊！
# 重点其实是那个 DeviceURI 及 Info 这两个玩意儿啦！重要的很！</span>
</pre></td></tr></tbody></table><br>

		<hr></li><li><span class="text_import1">开始打印测试</span><br><br>
			我们可以使用 lp 或者是 lpr 来进行打印的工作～试看看先！<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">lpr [-E] -P [printer队列] -# [打印份数] -U [username] file</span>
<span class="term_say">参数：
-E  ：是否加密的意思～一般不需要这个参数；
-P  ：如果你有两部以上的打印机，想要在不同的打印机上面打印，
      就需要使用 -P 来选择啊！
-#  ：如果你要一次打印多份文件，用这个 -# 加上份数就对了！
-U  ：有些打印机有限至用户，此时就得要使用这个参数；
范例：</span>

<span class="term_hd">范例一：</span>
[root@linux ~]# <span class="term_command">lpr -P laserjet2300 /etc/passwd</span>
</pre></td></tr></tbody></table>

			能不能打印除了 cups 的设定之外，打印机是否有设定防火墙也是有关系的喔！
			鸟哥最近一次在进行测试时，不知道为了什么，打印机突然无法接受我 Linux 端的封包要求，
			鸟哥就给 Printer 整个重新启动，咦！突然又好了～
			可能是....打印机也需要休息吧？？ @_@<br><br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">lp -d [printer队列] -n [打印份数] file</span>
<span class="term_say">参数：
-d  ：后面接的是打印机的队列名称。如果有多部打印机才需要指定；
-n  ：就是打印的份数啊！
范例：</span>

<span class="term_hd">范例一：打印出 2 份 /etc/issue 数据</span>
[root@linux ~]# <span class="term_command">lp -d laserjet2300 -n 2 /etc/issue</span>
</pre></td></tr></tbody></table>

			如果想要了解整个打印的信息，与整个打印机的状态，可以使用底下的指令啊～<br>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">1. 了解打印机的目前状态</span>
[root@linux ~]# <span class="term_command">lpstat [-adprt]</span>
<span class="term_say">参数：
-a  ：列出目前可以接受打印作业的打印机队列名称；
-d  ：列出目前系统的默认打印机；
-p  ：列出每部打印机的接受工作的状态，包含工作的 ID；
-r  ：列出目前 CUPS 是否有在运作？
-t  ：列出较为详细的打印机信息啊！
范例：</span>

<span class="term_hd">范例一：目前的默认打印机，与系统上面可以接受打印的打印机为：</span>
[root@linux ~]# <span class="term_command">lpstat -a</span>
laserjet2300 accepting requests since Jan 01 00:00
[root@linux ~]# <span class="term_command">lpstat -d</span>
system default destination: laserjet2300

<span class="term_hd">范例二：列出目前系统上面所有与打印机有关的信息？</span>
[root@linux ~]# <span class="term_command">lpstat -t</span>
scheduler is running
system default destination: laserjet2300
device for laserjet2300: ipp://192.168.10.119/
laserjet2300 accepting requests since Jan 01 00:00
printer laserjet2300 is idle.  enabled since Jan 01 00:00
        Print file accepted - job ID 3.


<span class="term_hd">2. 打印作业的观察</span>
[root@linux ~]# <span class="term_command">lpq [-al]</span>
<span class="term_say">参数：
-a  ：列出所有打印机上面在队列当中的工作情况；
-l  ：用其他较长格式来输出打印的相关信息 (拥有者与档案大小等等)
范例：</span>

<span class="term_hd">范例三：显示出目前所有打印机的工作队列状况</span>
[root@linux ~]# <span class="term_command">lpq -a</span>
Rank    Owner   Job     File(s)                         Total Size
1st     root    3       passwd                          4096 bytes
<span class="term_say"># 上面的意思是，有一份工作，该工作是打印出 passwd 那个档案，
# 这个工作的号码是 3 号  (Job) ，该工作的建立者为 root 。
# 这是个很重要的地方，因为该项目仅有 root 可以控制～
# 一般身份使用者，当然不能删除该项工作啦！</span>


<span class="term_hd">3. 删除在队列当中的打印作业</span>
[root@linux ~]# <span class="term_command">lprm -P [printer队列] job_id</span>
<span class="term_say">参数：
-P  ：后面直接指定某部打印机的某个工作号码。注意，那个 job_id
      就是刚刚我们使用 lpq 查看到的那个 Job 的号码啦！</span>

<span class="term_hd">范例四：将刚刚的看到的那个 job 3 工作删除！</span>
[root@linux ~]# <span class="term_command">lprm 3</span>
[root@linux ~]# <span class="term_command">lpq -a</span>
no entries
<span class="term_say"># 瞧！当然不见去啦！因为工作被我删除了嘛！</span>

<span class="term_hd">4. 以 cancel 删除在队列当中的打印作业</span>
[root@linux ~]# <span class="term_command">cancel [-a] job_id</span>
<span class="term_say">参数：
-a  ：不论队列里面有多少等待打印的工作，全部移除！</span>
[root@linux ~]# <span class="term_command">cancel 3</span>
[root@linux ~]# <span class="term_command">cancel -a</span>
</pre></td></tr></tbody></table>

			其实，整个 Linux 本机上面的打印信息，到这个时候就已经完成啦！
			不过，如果你还想要作额外的控制，或者是想要进行网络分享这部打印机时，嘿嘿！
			还得额外的加工，作一些手脚才行喔！底下就告诉你怎么作吧！<br><br>

		<hr></li><li><span class="text_import1">权限控制 (打印分享啦！)</span><br><br>
			我们前面提到的几个指令都可以直接在 CUPS 上面将打印的任务栏印出来～
			不过，有的时候我们由于在进行打印机维护的作业，可能暂时不允许人家使用我们的打印机，
			又不想让人家发现打印机目前有问题～怎么办？呵呵！这个就与 disable 这个指令有关啦！<br>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">1. 暂时关闭/启动打印机是否开始打印(但一定都可以接受工作到队列)</span>
[root@linux ~]# <span class="term_command">/usr/bin/disable [-c] [printer队列]</span>
[root@linux ~]# <span class="term_command">/usr/bin/enable [printer队列]</span>
<span class="term_say">参数：
-c  ：将后面接的那个打印机队列所等待的工作，全部都删除。一般不会加上这个参数！
disable = cupsdisable
enable  = cupsenable
范例：</span>

<span class="term_hd">范例一：暂时取消刚刚建立的 laserjet2300 这部打印机的打印作业</span>
[root@linux ~]# <span class="term_command">disable laserjet2300</span>
[root@linux ~]# <span class="term_command">lpstat -t</span>
scheduler is running
system default destination: laserjet2300
device for laserjet2300: ipp://192.168.10.119/
laserjet2300 accepting requests since Jan 01 00:00
printer laserjet2300 <span class="term_write">disabled</span> since Jan 01 00:00 -
        Paused
<span class="term_say"># 发现否？目前的工作是暂停的！不过， scheduler 依旧是在进行！
# 所以，当然还可以继续接受队列的需求喔！让我们来测试看看！</span>

[root@linux ~]# <span class="term_command">lpr /etc/passwd</span>
[root@linux ~]# <span class="term_command">lpq</span>
laserjet2300 is <span class="term_write">not ready</span>
Rank    Owner   Job     File(s)                         Total Size
1st     root    5       passwd                          4096 bytes
<span class="term_say"># 嘿嘿嘿嘿！是 not ready ～还没有准备好嘛！</span>
[root@linux ~]# <span class="term_command">cancel 5</span>

<span class="term_hd">范例二：开始重新让 laserjet2300 可以开始打印啊！</span>
[root@linux ~]# <span class="term_command">/usr/bin/enable laserjet2300</span>
[root@linux ~]# <span class="term_command">lpstat -t</span>
scheduler is running
system default destination: laserjet2300
device for laserjet2300: ipp://192.168.10.119/
laserjet2300 accepting requests since Jan 01 00:00
printer laserjet2300 is idle.  enabled since Jan 01 00:00
<span class="term_say"># 注意一下，因为 bash 本身就含有一个 enable 的内部指令，
# 所以，建议您输入绝对路径来执行 enable ，或者直接改以 cupsenable 来执行！</span>
</pre></td></tr></tbody></table>

			这个 cupsdisable 与 cupsenable 可以支持让管理员拥有一段打印机维护的时间，
			同时又还可以继续接受来自使用者的打印需求，真是不错啊！不过，
			万一我就是明确的不要接受来自使用者的打印作业呢？也就是说，我连等待的工作都不开放，
			只要有打印作业需求时，就回报『不能使用』。呵呵！就是 accept/reject 的工作啦！<br>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">2. 暂时停止/开启打印机队列的功能</span>
[root@linux ~]# <span class="term_command">reject [printer队列]</span>
[root@linux ~]# <span class="term_command">accept [printer队列]</span>

<span class="term_hd">范例一：暂时关闭 laserjet2300 吧！</span>
[root@linux ~]# <span class="term_command">reject laserjet2300</span>
[root@linux ~]# <span class="term_command">lpstat -t</span>
scheduler is running
system default destination: laserjet2300
device for laserjet2300: ipp://192.168.10.119/
laserjet2300 <span class="term_write">not accepting</span> requests since Jan 01 00:00 -
        Rejecting Jobs
printer laserjet2300 is idle.  enabled since Jan 01 00:00
        Rejecting Jobs

[root@linux ~]# <span class="term_command">lp /etc/passwd</span>
lp: unable to print file: server-error-not-accepting-jobs
<span class="term_say"># 了解了吗？如此一来，连工作进入打印等待都不行喔！</span>

<span class="term_hd">范例二：启动 laserjet2300 吧！</span>
[root@linux ~]# <span class="term_command">accept laserjet2300</span>
</pre></td></tr></tbody></table>

			很好玩吧！透过这四个小东西，我们就可以拥有一段管理维护打印机的时间啦～ ^_^<br><br>
		</li></ol>

		透过这些简单的指令，还有一些简单的编辑动作，您的打印机就可以在 Linux 上头顺利的运作了呢！
		而且还可以支持多部打印机同时存在，真是好方便啊！^_^<br><br>
	</div>

	<hr><li><span class="text_import1">一个简单的练习</span></li>
	<div class="block2">
		假设你目前的 FC4 主机上面接着一台 USB 接口的打印机，
		你的系统并不允许使用 setup 的 Printer configuration 设定，
		这台 USB 接口的打印机是 Samsung 的 ML-1210 打印机，
		请问，您可以如何在 FC4 上面安装这部打印机？
		<ul>
		<li>先下载 PPD 定义档，档名为： Samsung-ML-1210-gdi.ppd 到 /usr/share/cups/model/ 当中；
		</li><li>加入打印机，使用下列方法：<br>
<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">lpadmin -p samsung -v usb:/dev/usb/lp0 \</span>
&gt; <span class="term_command">-m Samsung-ML-1210-gdi.ppd -E</span>
</pre></td></tr></tbody></table>
		</li><li>开始给他测试练习一下：『 lp /etc/passwd 』如果有东西印出来，那就是 OK 啦！
		</li></ul>

		<div style="padding: 10pt 0pt;" align="right"><table width="90%"><tbody><tr><td><b>Tips:</b><br><span style="color: rgb(0, 144, 0);"><font size="-1">			事实上，并不是所有的打印机厂商都有针对 Linux 操作系统释出相关的驱动程序，
			所以，如果您想要购买能够让 Linux 使用的打印机时，还是建议您先前往上面提到的
			http://www.linuxprinting.org/printer_list.cgi 这个网页进行查询～
			比如， HP 等大厂的打印机对于 Linux 的支持度就很不错～而如果您有旧的打印机，
			例如鸟哥的 Lexmark X6150 这部机器，呵呵～那就不要想太多了～安装上面，实在很麻烦～ @_@
			但这并不是 Linux 的问题，您可以发起一人一信，寄信给打印机开发商，让他们重视 Linux
			使用者群吧！
		</font></span></td><td><img src="0610hardware-fc4_files/vbird_face.gif" alt="鸟哥的图示" title="鸟哥的图示"></td></tr></tbody></table></div>
		另外，如果老是看到屏幕前面显示：『 Printer not connected; will retry in 30 seconds...』，
		很有可能是因为我们的装置代号输入错误，请使用『 lpstat -t 』查阅一下是否正确的设定好了？
		基本上，安装一部 Linux 有支持的打印机，真的是快速啦！<br><br>
	</div>

	<hr><li><span class="text_import1">利用 web 接口管理 CUPS 打印机</span></li>
	<div class="block2">
		除了使用手动的方式增加打印机之外，其实，我们还可以透过 web 接口来管理这部打印机喔！
		其实是管理 CUPS 这个 daemon 啦！如果您是在 Linux 本机前面使用 X Window 的话，
		那么什么都不必想，直接在 X Window 当中的浏览器输入『 http://localhost:631 』
		就可以进入管理画面了。如果像鸟哥一样，我的 Linux 主机都是不开 X Window 的，
		那就得要作一些手脚啦！<br><br>

		首先，我们必须要让 CUPS 接受来自内部网段的 Client 端管理，假设我的内部网段是
		192.168.1.0/24 ，那么我就得要这样做：<br>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">1. 修改 /etc/cups/cupsd.conf 的权限控制</span>
[root@linux ~]# <span class="term_command">vi /etc/cups/cupsd.conf</span>
<span class="term_say"># 找到底下的字眼，新增特殊字体的部分！</span>
<span class="term_write">Port 631</span> <span class="term_note">&lt;==确定一下，大约在 434 行左右，会有这个段落</span>

&lt;Location /&gt;         <span class="term_note">&lt;==这个大约在 773 行左右</span>
Order Deny,Allow
Deny From All
Allow From 127.0.0.1
<span class="term_write">Allow From 192.168.1.0/24</span> <span class="term_note">&lt;==加入这一行吧！</span>
&lt;/Location&gt;

&lt;Location /admin&gt;  <span class="term_note">&lt;==这个大约是在 831 行左右。</span>
AuthType <span class="term_write">Digest</span>   <span class="term_note">&lt;==把这里作个修改！</span>
AuthClass System
Order Deny,Allow
Deny From All
Allow From 127.0.0.1
<span class="term_write">Allow From 192.168.1.0/24</span>  <span class="term_note">&lt;==加入这一行吧！</span>
&lt;/Location&gt;

<span class="term_say"># 如果你曾经使用 seutp 内的 Printer configuration 设定过打印机的话，
# 那应该会看到底下这些字眼，注意，<span class="term_note_b">将这些资料通通删除！</span></span>
&lt;Location /printers/lexmark&gt;
Order Deny,Allow
Deny From All
Allow From 127.0.0.1
AuthType None
&lt;/Location&gt;
# Lines below are automatically generated - DO NOT EDIT
Browsing On
BrowseProtocols cups
BrowseOrder Deny,Allow
BrowseAllow from @LOCAL
Listen 127.0.0.1:631
<span class="term_say"># 例如上面这 13 行字，全部通通删除吧！否则会造成问题！</span>


<span class="term_hd">2. 重新启动 cups 吧！</span>
[root@linux ~]# <span class="term_command">/etc/init.d/cups restart</span>

[root@linux ~]# <span class="term_command">netstat -tlnp</span>
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address  Foreign Address State  PID/Program name
tcp        0      0 <span class="term_write">0.0.0.0</span>:631    0.0.0.0:*       LISTEN 28018/cupsd
<span class="term_say"># 注意啊！您开启的监听网域，必须要是 0.0.0.0 才对，如果出现 127.0.0.1 ，
# 那就表示您的 cupsd.conf 设定错误啦！</span>


<span class="term_hd">3. 设定管理打印机的管理员账号密码</span>
[root@linux ~]# <span class="term_command">lppasswd [-a] [-x] [username]</span>
<span class="term_say">参数：
-a  ：新增一个管理打印机的账号
-x  ：删除该账号
注意，该账号是我们可以随意取的，不一定要在 /etc/passwd 里面！</span>

[root@linux ~]# <span class="term_command">lppasswd -a printermaster</span>
Enter password:
Enter password again:

[root@linux ~]# <span class="term_command">cat /etc/cups/passwd.md5</span>
printermaster:sys:a22ad518d345467ae72d3eb2cf4cdcc1
<span class="term_say"># 这就是我们利用 lppasswd 建立起来的密码数据啊！</span>
</pre></td></tr></tbody></table>

		接下来呢？呵呵！直接到区域内的任何一部计算机上面，启动浏览器，直接输入：『
		http://192.168.1.2:631 』假定我的 Linux 主机为 192.168.1.2 ，那就会看到如下画面：<br><br>

		<center><img src="0610hardware-fc4_files/cups_web_01.jpg" title="利用 CUPS 的 Web 接口管理打印机" alt="利用 CUPS 的 Web 接口管理打印机"><br>
			图、利用 CUPS 的 Web 接口管理打印机</center><br>

		共有六大选项，我们比较经常使用的应该是 Printers 以及 Administration 这两项而已。
		在按下了 Printer 项目之后，就会出现如下的画面：<br><br>

		<center><img src="0610hardware-fc4_files/cups_web_02.jpg" title="利用 CUPS 的 Web 接口管理打印机" alt="利用 CUPS 的 Web 接口管理打印机"><br>
			图、利用 CUPS 的 Web 接口管理打印机</center><br>

		看到了吗？刚刚我们设定成功的打印机已经在上头啦！
		而且还可以看到各部分详细的数据，很不错吧！如果想要进行一些额外的参数设定，
		例如按下上图当中，左下角的 Add Printer ，就会出现如下的认证窗口：<br><br>

		<center><img src="0610hardware-fc4_files/cups_web_03.jpg" title="利用 CUPS 的 Web 接口管理打印机" alt="利用 CUPS 的 Web 接口管理打印机"><br>
			图、利用 CUPS 的 Web 接口管理打印机</center><br>

		输入刚刚我们才以 lppasswd 建立的账号与密码，那么立刻就会出现如下的画面了：<br><br>

		<center><img src="0610hardware-fc4_files/cups_web_04.jpg" title="利用 CUPS 的 Web 接口管理打印机" alt="利用 CUPS 的 Web 接口管理打印机"><br>
			图、利用 CUPS 的 Web 接口管理打印机</center><br>

		上图的画面其实与 setup 里面的新增打印机过程差不多，
		只是上面的画面是以图形接口显示出来的而已啊！ ^_^。更多的使用方式，
		就有待您自己去发掘啰！ ^_^<br><br>

		另外，如果你老是试不出来认证的话，那么干脆把 /etc/cups/cupsd.conf 里面的『AuthType 与 AuthClass』
		这两个参数关掉，如此一来，就不会要求你输入账号密码，会直接让您进入打印机管理员的管理接口喔！<br>
	</div>
</div>


<hr><a name="lvm"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">特殊的 filesystem： LVM</span><br>
<div class="block1">
	在第二篇的内容里面，我们主要谈到了磁盘文件系统，也晓得了，如果在安装初期，
	没有做好整个硬盘的规划时，那么未来要新增磁盘空间，会很麻烦～～不过，这个问题在 LVM 面前，
	似乎影响就不大了！为什么呢？因为 <span class="text_import2">LVM 可以整合多个实体 partition 在一起，
	让这些 partitions 看起来就像是一个磁盘一样！而且，还可以在未来新增其他的实体 partition
	到这个 LVM 管理的磁盘当中。</span> 如此一来，整个磁盘空间的使用上，实在是相当的具有弹性啊！<br><br>

	<hr><a name="lvm_whatis"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">什么是 LVM： PV, PE, VG, LV</span><br>
	<div class="block2">
		既然要玩 LVM 的话，那就得对 LVM 有点了解才行啊！事实上， LVM 其实就是将几个实体的 partitions
		透过软件组合成一块看起来像是独立的大磁盘，而要用这块大磁盘，就得要再将他分割成为可以使用的 
		partition 才行！而我们知道每个 partition 上面的 filesystem 因为 block 大小的不同而有限制，
		同样的， LVM 的大磁盘大小也是有限制的，主要是一个称为 PE 的咚咚。我们先来作一些简单的解释吧！
		<ul>
		<li><span class="text_import1">Physical Volume, 简称 PV：</span><br>
			这个就是实体磁盘啦！我们必须要将原本的磁盘，例如 /dev/hda5, /dev/hda6 等等的 partition
			，利用 fdisk 等软件，将他们的 ID 改为 LVM (8e) ，并且修改磁盘的相关信息，
			让他成为 LVM 可以使用的磁盘才行。什么是 ID 啊？还记得使用 fdisk -l 看到的数据吧？
			ID 83 是 Linux 的 partition ， 82 则是 Swap 的代号！这样瞭了吧？
			一块磁盘变成 PV 后， LVM 才能够利用该 partition 喔！重要重要！</li><br>

		<li><span class="text_import1">Volume Group, 简称 VG：</span><br>
			其实我们 LVM 主要的目的就是要建立这个 VG 啦！他主要就是将刚刚的一个或多个 PV
			组合成为一个大磁盘～这个大磁盘可以作为后续的分割之用喔！
			那么这个大磁盘的容量最大可到多大呢？最大容量的值与底下的 PE 有关，
			如果完全使用 LVM 的预设参数时，那么一个最大的 LVM 磁盘可达到 256 GBytes。</li><br>

		<li><span class="text_import1">Physical Extend, 简称 PE：</span><br>
			在建立 VG 的时候，我们同时需要指定 PE 这个数值！如果不指定的话，他预设是 4MB 的大小。
			当 PE 为 4MB  时， VG 最大的容量就是 256 GBytes 啦！那么这个 PE 是什么玩意儿？？
			我们在 <a href="http://linux.vbird.org/linux_basic/0610hardware/0230filesystem.php">磁盘文件系统</a> 那个章节当中提到的
			<a href="http://linux.vbird.org/linux_basic/0610hardware/0230filesystem.php#harddisk-inode">inode, block 与 filesystem 大小</a>的相关性当中，
			有提到在 ext2/ext3 文件系统的格式化过程中，不同的 block 大小将会影响到整个 filesystem 
			大小的支援度。<span class="text_import2">那这个 PE 其实就有点像是 VG 的 block 啦！</span>
			所以他的大小将会影响到 VG 的最大值喔！如果你想要让你的 VG 大于预设的 256 GB 时，
			记得要修改这个数值！(其实，一个 VG 最大可以容许 65534 个 PE ，
			所以，修改 PE 值，当然就会影响到最大的 VG 容量啦！ )</li><br>

		<li><span class="text_import1">Logical Volume, 简称 LV：</span><br>
			这个 LV 就是最后被挂载到文件系统的 partition 啰～这个 LV 是由 VG 分割来的啦～
			他会建立一个装置代号，例如 /dev/vgname/lvname 在您的系统当中啊！
		</li></ul>

		透过 PV, VG, LV 的规划之后，再利用 mkfs (mke2fs -j) 等等就可以将您的多个 partition 整合成为一个大磁盘，
		再利用这个大磁盘来分割与格式化，就 OK 的啦！而且，这个大磁盘可以进行增加、减少容量的变化，
		也就是说，这个 VG 大磁盘可以抽换 PV 哩！并且原有的数据，理论上，并不会被影响喔！是否很棒啊！
		整个 LVM 的处理流程与各组件之间的相关性，我们直接以下图来看看吧！<br><br>

		<center><img src="0610hardware-fc4_files/lvm.jpg" title="LVM 各组件之间的相关性" alt="LVM 各组件之间的相关性"><br>
			图、LVM 各组件之间的相关性</center><br>

		如此一来，我们就可以利用 LV 这个玩意儿来进行系统的挂载了。不过，您应该会觉得奇怪的是，
		<span class="text_import2">那么我的资料写入这个 LV 时，到底他是怎么写入硬盘当中的？</span>
		呵呵！好问题～其实，依据写入机制的不同，而有两种方式：<ul>
		<li>线性模式 (linear)：假如我将 /dev/hda1, /dev/hdb1 这两个 partition 加入到 VG 当中，并且整个 VG 
			只有一个 LV 时，那么所谓的线性模式就是：当 /dev/hda1 的容量用完之后，
			/dev/hdb1 的硬盘才会被使用到。</li><br>
		<li>交错模式 (triped)：那什么是交错模式？很简单啊，就是我将一笔数据拆成两部分，
			分别写入 /dev/hda1 与 /dev/hdb1 的意思。如此一来，一份数据用两颗硬盘来写入，
			理论上，读写的效能会比较好。</li></ul>

		基本上，<span class="text_import2">LVM 最主要的用处是在制造产生一个大磁盘，
		而不是在建立一个效能为主的磁盘上</span>，所以，我们应该利用的是 LVM 可以弹性管理整个 partition 
		大小的用途上，而不是着眼在效能上的。因此， LVM 默认的读写模式是线性模式啦！
		如果您使用 triped 模式，要注意，当任何一个 partition 『归天』时，所有的数据都会『损毁』的！
		所以啦，不是很适合使用这种模式啦！如果要强调效能与备份，那么就直接使用 RAID 即可，
		不需要用到 LVM 啊！这样说，应该可以接受吧！<br><br>

		总之，鸟哥认为，整个 LVM 最大的用途即是在弹性管理磁盘的容量，让你的磁盘可以随时放大或缩小，
		方便您将剩余的磁盘空间作一个较为良好的应用！<br><br>
	</div>

	<hr><a name="lvm_flow"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">制作一个可使用的 LVM 磁盘流程</span><br>
	<div class="block2">
		要让你的 Linux 使用 LVM 的功能，除了核心必须要有支持之外，
		你也必须要安装 lvm2 这个套件才行啊！好在， FC4 与其他较新的 distributions 
		目前的预设核心都有支持 LVM 的，这个就不需要担心了～呵呵。另外， lvm2 似乎也是预设安装的，
		也不需要担心！真是好棒啊！ ^_^<br><br>

		整个 LVM 的制作流程，就跟我们上个小节提到的那张图一样，先制作 PV，再产生 VG，
		最后分割出 LV 后，就可以格式化与挂载啰！OK！那我们底下就一步一步来实作看看吧！
		先说明一下鸟哥的环境，我的环境是 FC4 ，有一个 30 GB 的硬盘放在 /dev/hdb ，
		这颗硬盘原本就已经被分割成为三个 partition ，分别为 /dev/hdb1, /dev/hdb2, /dev/hdb3，
		各大约有 10GB 左右的容量。如果查阅一下系统，他会这样显示：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">fdisk -l /dev/hdb</span>
Disk /dev/hdb: 30.7 GB, 30738677760 bytes
16 heads, 63 sectors/track, 59560 cylinders
Units = cylinders of 1008 * 512 = 516096 bytes

   Device Boot      Start         End      Blocks   Id  System
/dev/hdb1               1       19377     9765976+  83  Linux
/dev/hdb2           19378       38754     9766008   83  Linux
/dev/hdb3           38755       59560    10486224   83  Linux
</pre></td></tr></tbody></table>

		现在，我想要制作一个 LVM 的磁盘出来，首先，我想要将 /dev/hdb1, /dev/hdb2 这两个 
		partition 加入这个 LVM 当中，来谈一谈怎么制作吧！ ^_^<br><br>

		<hr><li><span class="text_import1">建立 PV 与 PV 的查询：</span></li>
		<div class="block2">
			要建立 PV 其实很简单，只要直接使用 pvcreate 即可！我们来谈一谈与 PV 有关的指令吧！
			<ul>
			<li>pvcreate ：将实体 partition 建立成为 PV ；
			</li><li>pvscan ：搜寻目前系统里面任何具有 PV 的磁盘；
			</li><li>pvdisplay ：显示出目前系统上面的 PV 状态；
			</li><li>pvremove ：将 PV 属性移除，让该 partition 不具有 PV 属性。
			</li><li>partprobe ：这个指令可以让核心立刻读入最新的 partition table 而不必 reboot。</li></ul>
			那就直接来瞧一瞧吧！<br>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">1. 先建立磁盘成为 ID 为 8e 吧！</span>
[root@linux ~]# <span class="term_command">fdisk /dev/hdb</span>
Command (m for help): <span class="term_command">p</span>

Disk /dev/hdb: 30.7 GB, 30738677760 bytes
16 heads, 63 sectors/track, 59560 cylinders
Units = cylinders of 1008 * 512 = 516096 bytes

   Device Boot      Start         End      Blocks   Id  System
/dev/hdb1               1       19377     9765976+  83  Linux
/dev/hdb2           19378       38754     9766008   83  Linux
/dev/hdb3           38755       59560    10486224   83  Linux

Command (m for help): <span class="term_command">t</span>
Partition number (1-4): <span class="term_command">1</span>
Hex code (type L to list codes): <span class="term_command">8e</span>
Changed system type of partition 1 to 8e (Linux LVM)

Command (m for help): <span class="term_command">t</span>
Partition number (1-4): <span class="term_command">2</span>
Hex code (type L to list codes): <span class="term_command">8e</span>
Changed system type of partition 2 to 8e (Linux LVM)

Command (m for help): <span class="term_command">p</span>

Disk /dev/hdb: 30.7 GB, 30738677760 bytes
16 heads, 63 sectors/track, 59560 cylinders
Units = cylinders of 1008 * 512 = 516096 bytes

   Device Boot      Start         End      Blocks   Id  System
/dev/hdb1               1       19377     9765976+  <span class="term_write">8e</span>  Linux LVM
/dev/hdb2           19378       38754     9766008   <span class="term_write">8e</span>  Linux LVM
/dev/hdb3           38755       59560    10486224   83  Linux

Command (m for help): <span class="term_command">w</span>
The partition table has been altered!
<span class="term_say"># 瞧到了吗？没错！整个 ID 被更改了！</span>

[root@linux ~]# <span class="term_command">partprobe</span>
<span class="term_say"># 这个指令有趣了！他可以让核心立刻读取最新的 partition table 
# ，而不需要重新启动喔！</span>


<span class="term_hd">2. 开始将原本的磁盘制作成为 PV 的格式喔！</span>
[root@linux ~]# <span class="term_command">pvscan</span>
  No matching physical volumes found
[root@linux ~]# <span class="term_command">pvcreate /dev/hdb1</span>
  Physical volume "/dev/hdb1" successfully created
[root@linux ~]# <span class="term_command">pvcreate /dev/hdb2</span>
  Physical volume "/dev/hdb2" successfully created
[root@linux ~]# <span class="term_command">pvscan</span>
  PV /dev/hdb1         lvm2 [9.31 GB]
  PV /dev/hdb2         lvm2 [9.31 GB]
  Total: 2 [18.63 GB] / in use: 0 [0   ] / in no VG: 2 [18.63 GB]
<span class="term_say"># 刚刚我们将整个 partition 改成为 PV 格式后，利用 pvscan
# 就可以看到整体的 PV 状态了。如果要看的更详细，那就如下所示：</span>
[root@linux ~]# <span class="term_command">pvdisplay</span>
  --- NEW Physical volume ---
  PV Name               /dev/hdb1
  VG Name
  PV Size               9.31 GB
  Allocatable           NO
  PE Size (KByte)       0
  Total PE              0
  Free PE               0
  Allocated PE          0
  PV UUID               CW7uAt-ZJa3-BMxe-tfti-16WU-OfNV-BQM6d8

  --- NEW Physical volume ---
  PV Name               /dev/hdb2
  VG Name
  PV Size               9.31 GB
  Allocatable           NO
  PE Size (KByte)       0
  Total PE              0
  Free PE               0
  Allocated PE          0
  PV UUID               1lc2SK-tfGN-ReOr-3mNi-nDAp-mpmb-lHUQFG
<span class="term_say"># 没错吧！确实建立起来了！基本上， PV 的名称与实际的 partition 刚好相同！
# 不过， VG 可就不是这么回事了。由于我们尚未对这两个 PV 分配 VG，
# 所以上面显示的 VG Name 就没有任何资料啊！</span>
</pre></td></tr></tbody></table>

			讲是很难，作是很简单！这样就将 PV 建立了两个啰！简单到不行吧！ ^_^<br><br>
		</div>

		<hr><li><span class="text_import1">开始建立 VG ：</span></li>
		<div class="block2">
			建立 VG 及 VG 相关的指令也不少，我们来看看：<ul>
			<li>vgcreate ：就是主要建立 VG 的指令啦！他的参数比较多，等一下介绍。
			</li><li>vgscan ：搜寻系统上面是否有 VG 存在？
			</li><li>vgdisplay ：显示目前系统上面的 VG 状态；
			</li><li>vgextend ：在 VG 内增加额外的 PV ；
			</li><li>vgreduce ：在 VG 内移除 PV；
			</li><li>vgchange ：设定 VG 是否启动 (active)；
			</li><li>vgremove ：删除一个 VG 啊！
			</li></ul>
			与 PV 不同的是， VG 的名称是自定义的！我们知道 PV 的名称其实就是 partition 的装置代号，
			但是这个 VG 名称，则是可以随便你自己取啊！在底下的例子当中，
			我将 VG 名称取名为 vbirdvg ，所以建立这个 VG 的流程是这样的：<br>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">1. 先建立 VG 吧！</span>
[root@linux ~]# <span class="term_command">vgcreate vbirdvg /dev/hdb1 /dev/hdb2</span>
  Volume group "vbirdvg" successfully created
<span class="term_say"># 整个 vgcreate 的语法很简单，就是利用 vgcreate VGname PVname1 PVname2..
# 不过，如果想要修改前面提到的 PE 参数时，就得要加入 -s PE 数值了！</span>

[root@linux ~]# <span class="term_command">vgscan</span>
  Reading all physical volumes.  This may take a while...
  Found volume group "vbirdvg" using metadata type lvm2

[root@linux ~]# <span class="term_command">vgdisplay</span>
  --- Volume group ---
  VG Name               vbirdvg
  System ID
  Format                lvm2
  Metadata Areas        2
  Metadata Sequence No  1
  VG Access             read/write
  VG Status             resizable
  MAX LV                0
  Cur LV                0
  Open LV               0
  Max PV                0
  Cur PV                2
  Act PV                2
  VG Size               18.62 GB
  <span class="term_write">PE Size               4.00 MB</span>
  Total PE              4768
  Alloc PE / Size       0 / 0
  Free  PE / Size       4768 / 18.62 GB
  VG UUID               AZRSJx-FWYF-UIlH-NCh5-NqKS-f4gx-ZR049N


<span class="term_hd">2. 尝试抽换一下 PV 吧！</span>
[root@linux ~]# <span class="term_command">vgreduce vbirdvg /dev/hdb2</span>
  Removed "/dev/hdb2" from volume group "vbirdvg"
[root@linux ~]# <span class="term_command">vgdisplay</span>
  --- Volume group ---
  VG Name               vbirdvg
  System ID
  Format                lvm2
  Metadata Areas        1
  Metadata Sequence No  2
  VG Access             read/write
  VG Status             resizable
  MAX LV                0
  Cur LV                0
  Open LV               0
  Max PV                0
  Cur PV                1
  Act PV                1
  <span class="term_write">VG Size               9.31 GB</span>
  PE Size               4.00 MB
  Total PE              2384
  Alloc PE / Size       0 / 0
  Free  PE / Size       2384 / 9.31 GB
  VG UUID               AZRSJx-FWYF-UIlH-NCh5-NqKS-f4gx-ZR049N

[root@linux ~]# <span class="term_command">vgextend vbirdvg /dev/hdb2</span>
  Volume group "vbirdvg" successfully extended
<span class="term_say"># 基本上，不难吧！这样就可以抽换整个 VG 的大小啊！
# 另外，可以使用 pvscan 看一下 PV 与 VG 的相关性喔！</span>

[root@linux ~]# <span class="term_command">pvscan</span>
  PV /dev/hdb1   VG vbirdvg   lvm2 [9.31 GB / 9.31 GB free]
  PV /dev/hdb2   VG vbirdvg   lvm2 [9.31 GB / 9.31 GB free]
  Total: 2 [18.62 GB] / in use: 2 [18.62 GB] / in no VG: 0 [0   ]
</pre></td></tr></tbody></table>

			如此一来，我们就建立了一个好大好大的磁盘，他是整合了 /dev/hdb1 及 /dev/hdb2 啦！
			由于 VG 的最大容量与 PE 有关，PE 最多限制在 65534 个，但每个 PE 的大小则不固定。
			预设 PE 是 4 MB ，如果你想要改成 16MB 的话，那就得要这样建立：
			<ul><span class="text_import2"><font face="细明体">vgcreate -s 16M vbirdvg /dev/hdb1 
			/dev/hdb2</font></span></ul>
			那么最大 VG 的容量就会由 256GB 增加为 1TB 啦！详细说明请参考 man vgcreate 喔！<br><br>
		</div>

		<hr><li><span class="text_import1">建立 LV 吧！</span></li>
		<div class="block2">
			创造出 VG 这个大磁盘之后，再来就是要建立分割区啦！
			这个分割区就是所谓的 LV 啰！假设我要将刚刚那个 vbirdvg 磁盘，分割成为 vbirdlv ，
			整个 VG 都被分配到 vbirdlv 里面去！先来看看能使用的指令后，
			就直接工作了先！<ul>
			<li>lvcreate ：建立 LV 啦！
			</li><li>lvscan ：查询系统上面的 LV ；
			</li><li>lvdisplay ：显示系统上面的 LV 状态啊！
			</li><li>lvextend ：在 LV 里面增加容量！
			</li><li>lvreduce ：在 LV 里面减少容量；
			</li><li>lvremove ：删除一个 LV ！
			</li><li>lvresize ：对 LV 进行容量大小的调整！
			</li></ul>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">1. 将整个 vbirdvg 通通分配给 vbirdlv 啊！</span>
[root@linux ~]# <span class="term_command">lvcreate -L [sizeMG] -n [LVname] VGname</span>
<span class="term_say">参数：
-L  ：后面接容量，容量的单位可以是 M, G 等等；
-n  ：后面接的就是 LV 的名称啦！
更多的说明应该可以自行查阅吧！ man lvcreate </span>

[root@linux ~]# <span class="term_command">lvcreate -L 18.62G -n vbirdlv vbirdvg</span>
  Rounding up size to full physical extent 18.62 GB
  Logical volume "vbirdlv" created
[root@linux ~]# <span class="term_command">ll /dev/vbirdvg/vbirdlv</span>
lrwxrwxrwx  1 root root 27 Nov 14 21:10 /dev/vbirdvg/vbirdlv -&gt; 
/dev/mapper/vbirdvg-vbirdlv
<span class="term_say"># 看见了没有啊！？这就是我们最重要的一个玩意儿了！
# 未来所有要挂载的数据，通通是透过这个装置的！</span>

[root@linux ~]# <span class="term_command">lvscan</span>
  ACTIVE            '/dev/vbirdvg/vbirdlv' [18.62 GB] inherit
[root@linux ~]# <span class="term_command">lvdisplay</span>
  --- Logical volume ---
  LV Name                /dev/vbirdvg/vbirdlv
  VG Name                vbirdvg
  LV UUID                B6kSrg-9LMG-gqVy-jjz8-x0gM-ya9S-XLFcZN
  LV Write Access        read/write
  LV Status              available
  # open                 0
  LV Size                18.62 GB
  Current LE             4767
  Segments               2
  Allocation             inherit
  Read ahead sectors     0
  Block device           253:0
</pre></td></tr></tbody></table>

			如此一来，整个 partition 也准备好啦！<br><br>
		</div>

		<hr><li><span class="text_import1">partition 的格式化与挂载！</span></li>
		<div class="block2">
			这个部分鸟哥我就不再多加解释了！直接来进行吧！<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">mke2fs -j /dev/vbirdvg/vbirdlv</span>
[root@linux ~]# <span class="term_command">mkdir /mnt/lvm</span>
[root@linux ~]# <span class="term_command">mount -t ext3 /dev/vbirdvg/vbirdlv /mnt/lvm</span>
[root@linux ~]# <span class="term_command">df</span>
Filesystem           1K-blocks      Used Available Use% Mounted on
/dev/hda2              9920624   3029712   6378844  33% /
/dev/hda1               101086     16524     79343  18% /boot
/dev/hda5             19236308    190776  18068380   2% /disk1
/dev/hda6            161836268     94272 153521136   1% /models
/dev/shm                192528         0    192528   0% /dev/shm
/dev/mapper/vbirdvg-vbirdlv
                      19219156    176288  18066588   1% /mnt/lvm
[root@linux ~]# <span class="term_command">fdisk -l /dev/hdb</span>
Disk /dev/hdb: 30.7 GB, 30738677760 bytes
16 heads, 63 sectors/track, 59560 cylinders
Units = cylinders of 1008 * 512 = 516096 bytes

   Device Boot      Start         End      Blocks   Id  System
/dev/hdb1               1       19377     9765976+  8e  Linux LVM
/dev/hdb2           19378       38754     9766008   8e  Linux LVM
/dev/hdb3           38755       59560    10486224   83  Linux
</pre></td></tr></tbody></table>

			知道那边不同了吗？没错！原始的 partition 还存在，但是我们却可以使用额外的 LVM
			功能，将来自不同的 partition 的容量整个整合在一起，实在是给他相当的有趣啊！ ^_^
		</div>
	</div>

	<hr><a name="lvm_large"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">让原有的 LVM 磁盘加大的方法：
	resize2fs</span><br>
	<div class="block2">
		好了，了解了如何制作 LVM 之后，接下来则是比较进阶的使用啦！我们知道 vbirdvg 已经有两个 PV，
		但是实际上，我们还有个 /dev/hdb3 的实体 partition 啊！那么如何将这个 /dev/hdb3
		加入到 vbirdvg ，且让 vbirdlv 增加呢？其实也不难啦！你必须要：
		<ol><span class="text_import2">
		<li>将欲处理的 LV 卸除；
		</li><li>建立 PV；
		</li><li>将建立的 PV 以 vgextend 增加到 VG 当中；
		</li><li>利用 lvextend 增加刚刚 VG 所增加的容量；
		</li><li>利用 resize2fs 将 LV 的容量确实增加！
		</li></span></ol>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">umount /mnt/lvm</span>

[root@linux ~]# <span class="term_command">fdisk /dev/hdb</span>
Command (m for help): <span class="term_command">t</span>
Partition number (1-4): <span class="term_command">3</span>
Hex code (type L to list codes): <span class="term_command">8e</span>
Changed system type of partition 3 to 8e (Linux LVM)

Command (m for help): <span class="term_command">w</span>
The partition table has been altered!

[root@linux ~]# <span class="term_command">partprobe</span>
[root@linux ~]# <span class="term_command">pvcreate /dev/hdb3</span>
  Physical volume "/dev/hdb3" successfully created

[root@linux ~]# <span class="term_command">vgextend vbirdvg /dev/hdb3</span>
  Volume group "vbirdvg" successfully extended
[root@linux ~]# <span class="term_command">vgdisplay</span>
  --- Volume group ---
  VG Name               vbirdvg
  System ID
  Format                lvm2
  Metadata Areas        3
  Metadata Sequence No  5
  VG Access             read/write
  VG Status             resizable
  MAX LV                0
  Cur LV                1
  Open LV               1
  Max PV                0
  Cur PV                3
  Act PV                3
  <span class="term_write">VG Size               28.62 GB</span>
  PE Size               4.00 MB
  Total PE              7327
  <span class="term_write">Alloc PE / Size       4767 / 18.62 GB</span>
  Free  PE / Size       2560 / 10.00 GB
  VG UUID               AZRSJx-FWYF-UIlH-NCh5-NqKS-f4gx-ZR049N
<span class="term_say"># 没错的！是增加了！也可以使用 pvscan 查阅喔！
# 而且剩余的没有使用的 VG 容量是 10.00 GB 喔！看清楚这个地方！ ^_^</span>

[root@linux ~]# <span class="term_command">pvscan</span>
  PV /dev/hdb1   VG vbirdvg   lvm2 [9.31 GB / 0    free]
  PV /dev/hdb2   VG vbirdvg   lvm2 [9.31 GB / 0    free]
  PV /dev/hdb3   VG vbirdvg   lvm2 [10.00 GB / 10.00 GB free]
  Total: 3 [28.62 GB] / in use: 3 [28.62 GB] / in no VG: 0 [0   ]

[root@linux ~]# <span class="term_command">lvextend -L +10G /dev/vbirdvg/vbirdlv</span>
  Extending logical volume vbirdlv to 28.62 GB
  Logical volume vbirdlv successfully resized

[root@linux ~]# <span class="term_command">lvdisplay</span>
  --- Logical volume ---
  LV Name                /dev/vbirdvg/vbirdlv
  VG Name                vbirdvg
  LV UUID                B6kSrg-9LMG-gqVy-jjz8-x0gM-ya9S-XLFcZN
  LV Write Access        read/write
  LV Status              available
  # open                 1
  LV Size                28.62 GB
  Current LE             7327
  Segments               3
  Allocation             inherit
  Read ahead sectors     0
  Block device           253:0

[root@linux ~]# <span class="term_command">mount -t ext3 /dev/vbirdvg/vbirdlv /mnt/lvm</span>
[root@linux ~]# <span class="term_command">df /mnt/lvm</span>
Filesystem           1K-blocks      Used Available Use% Mounted on
/dev/mapper/vbirdvg-vbirdlv
                      19219156    176288  18066588   1% /mnt/lvm
</pre></td></tr></tbody></table>

		看到了吧？？真是伤脑筋～怎么会 lv 已经增加了，但是 /dev/vbirdvg/vbirdlv 却没有加大呢？
		这是因为我们的 ext3 主要信息在最初规划时，就已经写入 super block ，
		同时 inode 与 block 数量又是固定的，所以，这个容量大小当然不会有变化！那怎么办？
		没关系，我们可以使用 ext2/ext3 的工具程序来处理！<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">resize2fs [-f] [device] [size]</span>
<span class="term_say">参数：
-f      ：强制进行 resize 的动作！
[device]：装置代号啊！
[size]  ：可以加也可以不加。如果加上 size 的话，那么就必须要给予一个单位，
          譬如 M, G 等等。如果没有 size 的话，那么预设使用『整个 partition』
          的容量来处理！</span>

[root@linux ~]# <span class="term_command">umount /mnt/lvm</span>
[root@linux ~]# <span class="term_command">resize2fs -f /dev/vbirdvg/vbirdlv</span>
resize2fs 1.38 (30-Jun-2005)
Resizing the filesystem on /dev/vbirdvg/vbirdlv to 7502848 (4k) blocks.
The filesystem on /dev/vbirdvg/vbirdlv is now 7502848 blocks long.

[root@linux ~]# <span class="term_command">mount -t ext3 /dev/vbirdvg/vbirdlv /mnt/lvm</span>
[root@linux ~]# <span class="term_command">df /mnt/lvm</span>
Filesystem           1K-blocks      Used Available Use% Mounted on
/dev/mapper/vbirdvg-vbirdlv
                      29540436    176288  28163696   1% /mnt/lvm
</pre></td></tr></tbody></table>

		嘿嘿！真的放大了吧！！而且如果你已经有填数据在 LVM 扇区当中的话！
		这个数据是不会死掉的喔！还是继续存在原本的扇区当中啦！
		整个动作竟然这么简单就完成了！原本的数据还是一直存在而不会消失～
		您说， LVM 好不好用啊！ <br><br>

		事实上， resize2fs 也可以用来处理 ext2/ext3 原本 filesystem 的大小。
		可以先以 fdisk 处理分割区，再以这个 resize2fs 来放大或者缩小 partition 啊！
		要注意，待处理的 partition 不可挂载喔！<br><br>
	</div>

	<hr><a name="lvm_note"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">注意事项：</span><br>
	<div class="block2">
		先来说一说，你必须要知道的一些 LVM 的指令整理：

<table width="95%" bgcolor="lightyellow" border="1" cellpadding="3" cellspacing="0">
<tbody><tr align="center" bgcolor="#182448"><td width="120"><font color="#FFFFFF">任务</font></td><td><font color="#FFFFFF">PV</font></td><td><font color="#FFFFFF">VG</font></td><td><font color="#FFFFFF">LV</font></td></tr>
<tr><td bgcolor="#182448"><font color="#FFFFFF">搜寻(scan)</font></td><td>pvscan</td><td>vgscan</td><td>lvscan</td></tr>
<tr><td bgcolor="#182448"><font color="#FFFFFF">建立(create)</font></td><td>pvcreate</td><td>vgcreate</td><td>lvcreate</td></tr>
<tr><td bgcolor="#182448"><font color="#FFFFFF">列出(display)</font></td><td>pvdisplay</td><td>vgdisplay</td><td>lvdisplay</td></tr>
<tr><td bgcolor="#182448"><font color="#FFFFFF">增加(extend)</font></td><td>　</td><td>vgextend</td><td>lvextend</td></tr>
<tr><td bgcolor="#182448"><font color="#FFFFFF">减少(reduce)</font></td><td>　</td><td>vgreduce</td><td>lvreduce</td></tr>
<tr><td bgcolor="#182448"><font color="#FFFFFF">删除(remove)</font></td><td>pvremove</td><td>vgremove</td><td>lvremove</td></tr>
<tr><td bgcolor="#182448"><font color="#FFFFFF">改变容量(resize)</font></td><td>　</td><td>　</td><td>lvresize</td></tr>
</tbody></table><br>
		另外，还需要以 resize2fs 来修订文件系统实际的大小才行啊！ ^_^
		。至于虽然 LVM 可以弹性的管理你的磁盘容量，但是要注意，
		如果你想要使用 LVM 管理您的硬盘时，那么在安装的时候就得要做好 LVM 的规划了，
		否则未来还是需要先以传统的磁盘增加方式来增加后，移动数据后，才能够进行 LVM 的使用啊！<br><br>

		无论如何还是要跟大家报告的，鸟哥个人认为 LVM 比较适合用在制作一个具有弹性的磁盘容量的环境，
		并不是要制作一个高效能的储存设备的环境，所以鸟哥在 lvcreate 时，
		才没有讲到如何制作 triped 模式的参数啊！如果真的想要制作一个高可靠性、
		高性能的储存环境，那还是得重硬件来着手，譬如底下我们要谈一谈的 iSCSI 的 RAID 
		储存架构，应该就是个不错的选择喔！ ^_^<br><br>

		另外，如果你想要将 LVM 移除的话，那么就应该要：<ol><span class="text_import2">
		<li>先卸除系统上面的 LVM 扇区；
		</li><li>使用 lvremove 移除 LV ；
		</li><li>使用 vgchange -a n VGname 让 VGname 这个 VG 不具有 Active 的标志；
		</li><li>使用 vgremove 移除 VG：
		</li><li>使用 pvremove 移除 PV；
		</li><li>最后，使用 fdisk 修改 ID 回来啊！</li></span></ol>

		好吧！那就实际的将鸟哥刚刚建立的 LVM 给他拿掉吧！<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">umount /mnt/lvm</span>
[root@linux ~]# <span class="term_command">lvremove /dev/vbirdvg/vbirdlv</span>
Do you really want to remove active logical volume "vbirdlv"? [y/n]: <span class="term_command">y</span>
  Logical volume "vbirdlv" successfully removed
[root@linux ~]# <span class="term_command">vgchange -a n vbirdvg</span>
  0 logical volume(s) in volume group "vbirdvg" now active
[root@linux ~]# <span class="term_command">vgremove vbirdvg</span>
  Volume group "vbirdvg" successfully removed
[root@linux ~]# <span class="term_command">pvremove /dev/hdb1</span>
  Labels on physical volume "/dev/hdb1" successfully wiped
[root@linux ~]# <span class="term_command">pvremove /dev/hdb2</span>
  Labels on physical volume "/dev/hdb2" successfully wiped
[root@linux ~]# <span class="term_command">pvremove /dev/hdb3</span>
  Labels on physical volume "/dev/hdb3" successfully wiped
</pre></td></tr></tbody></table>

		最后在用 fdisk 将磁盘的 ID 给他改回来 82 就好啦！整个过程就这样的啦！ ^_^
	</div>
</div>


<hr><a name="raid"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">额外的储存设备 iSCSI 协议的磁盘阵列：</span><br>
<div class="block1">
	常常会听到所谓的 SAN ( Storage Area Networks ) 与 NAS ( Network Attached Storage ) 这两个字眼，
	NAS 主要是以一部专门给储存数据用的主机，以现有的 TCP/IP 协议来提供作为类似 file server 的用途，
	他可以直接放置在网络上面，提供用户存取数据之用。SAN 则类似一部储存设备，
	藉由光纤信道提供某几部主机进行数据的存取之用，价格昂贵，维护成本高，但是储存效能佳！
	但不论是哪一种架构，基本上，他们的储存硬盘通常是以磁盘阵列 (RAID) 作为基础的。
	底下我们会来谈一谈什么是磁盘阵列，并同时以目前较新的 iSCSI 架构的储存设备来进行一个简单的网络储存设备架设。<br><br>

	<hr><a name="raid_raid"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">什么是磁盘阵列</span><br>
	<div class="block2">
		磁盘阵列全名是『 Redundant Arrays of Inexpensive Disks 』，简写为 RAID，
		他是透过一个技术(软件或硬件)，将多个较小的磁盘整合成为一个较大的磁盘装置；
		而这个较大的磁盘功能可不止是储存而已，他还保有数据保护的功能呢。
		整个 RAID 由于选择的等级 (level) 不同，而使得整合后的磁盘具有不同的功能，
		基本常见的 level 有这几种：<br><br>

		<li><span class="text_import1">Linear mode (线性模式)：</span><br>
		<div class="block2">
			两个以上的磁盘整合成为一个实体的储存装置；这个模式的特色是，
			所有的数据是『一个一个填满后，才将数据继续写到下一个磁盘上』；
			由于数据是一个一个写入到不同的硬盘当中，因此，整个磁盘的读取效能并不会增加，
			此外，由于数据具有连续性，因此，若不小心有任何一个磁盘损毁时，嘿嘿！
			您的数据可能通通救不回来了～这种模式唯一的好处，
			就是磁盘的空间完整的被利用完毕！不会有任何保留空间 (redundant)。<br><br>
		</div>

		</li><li><span class="text_import1">RAID-0 (交错模式, stripe)：</span><br>
		<div class="block2">
			这种模式主要是利用容量相同的磁盘来达成，效能会比较好。
			所谓的交错 (stripe) 是因为档案数据是同步洒到不同的磁盘上头去的意思，
			也就是说，假设我有两颗磁盘设定成 RAID-0 ，那么当我有 100MB 数据要写入时，
			则 100MB 会被拆成两个 50MB 分别写入不同的磁盘上头去！<br><br>
			所以啰，因为每一个磁盘写入的数据量只有一半，因此，读写的效能都会大大的增加！
			而且越多颗磁盘所造成的 RAID-0 装置，理论上，效能增加的越明显。
			但是这种模式有个最大的问题，那就是，因为一笔数据被拆成几个部分分布在不同的磁盘上头，
			因此『<span class="text_import2">任何一颗磁盘的损毁，都会让你的数据救不回来！</span>』<br><br>
			另外，如果使用不同容量的磁盘来达成 RAID-0 时，则在储存数据长大到一定程度时，
			RAID-0 的效能会变差。假设我用了一颗 20GB 两颗 16GB 的硬盘好了，
			那么当总数据量少于 48GB (16x3) 时，效能是很不错的。
			但是当超过 48GB 时，则数据仅能储存在 20GB 那一颗了 (可用容量剩下 4GB 啊！)，
			所以啰，当然效能就变差了啊！<br><br>
		</div>

		</li><li><span class="text_import1">RAID-1 (映像模式, mirror)：</span>
		<div class="block2">
			这种模式也是需要相同的磁盘容量的，最好是一模一样的磁盘啦！
			如果是不同容量的磁盘组成 RAID-1 时，那么总容量将以最小的那一颗磁盘为主！
			这种模式主要是『让同一份数据，完整的保存在两颗磁盘上头』，
			也就是说，如果我有一个 100MB 的档案，且我仅有两颗磁盘组成 RAID-1 时，
			那么这两颗磁盘将会同步写入 100MB 到他们的储存空间去，
			因此，整体容量几乎少了 50%。由于两颗硬盘内容一模一样，好像镜子映照出来一样，
			所以我们也称他为 mirror 模式啰～<br><br>
			我们可以说，这种模式最大的优点大概就是在进行备份吧！
			因为所有的数据都被存放在两个磁盘上面，所以，任何一颗磁盘损毁时，嘿嘿！
			所有的数据可都还是保存的好好的呢～<br><br>
			至于效能上面，由于要写入的数据变多了，(同步写入两颗硬盘嘛！)，
			所以，效能会比单颗磁盘还要差一些，没办法，因为我们都是透过同一个总线在进行数据的通行啊～
			不过，读取的效能还不错，因为数据有两份，如果多个 processes 在读取同一笔数据时，
			RAID 会自行取得最佳的读取平衡。<br><br>
			事实上，为了保有 RAID-1 的储存优点，又想要具有类似 RAID-0 的效能增强，
			所以，后来也有所谓的 RAID 0+1 ，亦即同时具有 RAID-0 与 RAID-1 的功能；
			只是，这样的功能至少需要四颗以上的相同容量的磁盘才行～
			而且总可用容量会减少一半 (因为 RAID-1 啊！)。<br><br>
		</div>

		</li><li><span class="text_import1">RAID-5：</span>
		<div class="block2">
			这个类型最有趣～也是目前最常见的一种类型了。
			RAID-5 会整合多个磁盘 (通常需要三个以上)，然后每部磁盘驱动器上面都会记录少许的其他部磁盘驱动器的信息 (
			parity information )，由于这个动作，因此，实际上可以使用的容量其实是
			(N-1)*S ，那个 N 为全部的磁盘驱动器总数，S 则是最小的那个磁盘的容量。
			少掉的空间就是用来作为信息记录用的。<br><br>
			由于这个机制的存在，因此，当那 N 部磁盘驱动器有任何一部出问题时，
			他的数据都会被平均记录到其他 N-1 部磁盘驱动器内，所以，只要你将坏掉的那一颗拿掉，
			换一颗好的磁盘后，该磁盘原本的内容就会被重建 (rebuild) 起来，
			呵呵～很棒的备份效果吧！<br><br>
			除此之外，因应目前所谓的热拔插 RAID 架构，因此，很多的硬件 RAID 在制作这个 RAID-5
			的类型时，他会使用 N+1 颗磁盘，其中 N 颗用来作为 RAID-5 之用，
			另外那一颗则做为磁盘损坏时的实时处理之用 (spare disk)。
			所以，假设您有十颗磁盘在这样的架构下时，则事实上只有九颗在进行 RAID-5 的存取，
			一颗作为错误处理，所以总容量应该是 8xS 才对喔！而当有任何一颗磁盘出问题时，
			那一颗 spare disk 就派上用场了，他会立刻被重建，
			因此，您只要将有问题的磁盘拔掉，换上一颗新的，嘿嘿！搞定！<br><br>
			不过还是要注意啦，因为 RAID-5 仅能处理一颗硬盘坏掉时的处置，
			若同时有两颗以上的磁盘损毁，那....所有的数据还是会完蛋的！
			所以啦，特重要的信息还是得要复制出来才行～关于考虑，呵呵～请参考备份策略吧！<br><br>
			至于存取效能上面，读取的效能几乎可以媲美 RAID-0 ，但是写入的效能就无法像 RAID-0
			那样明显。因为还得要计算分别写入到所有磁盘当中的平衡信息 (parity information)，
			所以写入的效能虽然是会增加不少，不过，不容易计算出来实际的增加的效能啦～<br><br>
		</div>

		呵呵！经过上面的说明，您应该会晓得，为何企业会需要使用磁盘阵列了吧？
		没错，因为 RAID <span class="text_import2">不但可以增加数据存取的效能，
		而且对于备份与数据的可靠性而言，他具有相当程度的类似备份的功效，因此，
		很适合需要大量存取数据的主机系统</span>。所以啰，目前很多的在线储存设备，
		基本上，都是透过 RAID 装置来达成的～底下我们就大略的来介绍一下目前挺流行的 
		iSCSI 接口的储存设备吧！( 如果对于 Linux 上面的 RAID 有兴趣，
		可以参考这一篇：<a href="http://www.tldp.org/HOWTO/Software-RAID-HOWTO-1.html" target="_blank">http://www.tldp.org/HOWTO/ Software-RAID-HOWTO-1.html</a> )<br><br>
	</li></div>

	<hr><a name="raid_iscsi"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">iSCSI 磁盘阵列的架设与使用</span><br>
	<div class="block2">
		由于企业的数据量越来越大，而且重要性与保密性越来越高，尤其类似数据库的内容，
		哇！常常容量单位是以 TB (1TB = 1024GB) 在进行计算的；可怕吧！
		所以啰，上一个小节内提到的磁盘阵列 (RAID) 的应用就很重要了。
		不过， RAID 毕竟只是在一部主机上面的储存装置，如果想要提供给网络上面的其他 client 
		端来使用，可能还需要主机提供相关的服务才行啊！而且，透过网络主机来连接，
		效能上可能是卡在网络传输速度，而不是 RAID 的速度说。而且， RAID 装在一部主机上面时，
		能够提供给 client 端使用的情况有限啦～大多仅是数据而已。<br><br>

		<li><span class="text_import1">NAS</span></li>
		<div class="block2">
		为了解决网络应用上面的，很多厂商提供了一些不错的想法。首先，就是那个
		NAS (Network Attach Storage)，基本上， NAS 其实就是一部客制化好的主机了，
		只要将 NAS 连接上网络，那么在网络上面的其他主机就能够存取 NAS 上头的数据了。
		简单的说，NAS 就是一部 file server (文件服务器) 啰～
		不过， NAS 由于也是接在网络上面，所以，如果网络上有某个 client 大量存取 NAS 上头的资料时，
		是很容易造成网络停顿的问题的，这个比较麻烦点～<br>
		</div>

		<div style="padding: 10pt 0pt;" align="right"><table width="90%"><tbody><tr><td><b>Tips:</b><br><span style="color: rgb(0, 144, 0);"><font size="-1">			在鸟哥的理解当中， NAS 基本上就是一部完整的主机，
			他有独立的操作系统与运算、储存等处理单元，其他的 client 端只要能够与 NAS 
			的协议兼容，那么他就能够存取 NAS 上头的数据啊！
		</font></span></td><td><img src="0610hardware-fc4_files/vbird_face.gif" alt="鸟哥的图示" title="鸟哥的图示"></td></tr></tbody></table></div>
		<li><span class="text_import1">SAN</span></li>
		<div class="block2">
		我们需要大量的存取装置，目的就是为了要强化存取效能与总可用容量，现在知道总可用容量可以使用 RAID
		技术来加强，但是存取效能呢？透过网络来存取时，确实可能导致存取效能的低落啊。
		为了解决这个问题，因此后来很多厂商开发出所谓的光纤信道。光纤信道的速度要快上很多，
		目前标准的光纤信道是 2GB ，未来还可能到达 10GB 以上呢～
		不过，使用光纤等技术较高的设备，当然就比较贵一些。
		利用光纤，配合一些硬件的标准化，后来一些厂商提出了 SAN (Storage Area Network) 架构；
		SAN 利用较高阶的光纤信道来进行主机与储存设备的连接，
		让主机透过光纤来快速存取储存设备内的数据，而不是透过较慢的网络架构。
		但是 SAN 架构的初设成本太贵，而且维护费用颇高！<br><br>
		</div>

		拜以太网络盛行，加上技术成熟之赐，现今的以太网络媒体 (网络卡、交换器、路由器等等设备) 
		已经可以达到 GB 的速度了，离 SAN 的光纤信道速度其实差异已经缩小很多啦～
		那么是否我们可以透过这个 GB 的以太网络来达到类似 SAN 的功效呢？
		没错！这就是我们接下来要提到的 iSCSI 架构啦！ ^_^<br><br>

		<li><span class="text_import1">iSCSI</span></li>
		<div class="block2">
			其实，整个 iSCSI 的架构主要分为储存设备与提供 iSCSI 联机的主机端，
			而 iSCSI 则透过以太网络链接储存设备与主机就是了。
			两者的关系有点像底下这个图示：<br><br>

			<center><img src="0610hardware-fc4_files/0610_iscsi.jpg" title="iSCSI 架构图" alt="iSCSI 架构图"><br>图一、 iSCSI 的主机与储存设备的关系。</center><br>

			首先，您必须要拥有 iSCSI 接口的储存设备 (废话！不然怎么玩？) ，
			然后，您的 iSCSI 储存设备上面必须要具有 IP 地址，并且储存设备以网络线链接到拥有
			GB 速度的 Switch 上。再来，您的主机必须要启动 iSCSI 的驱动程序，
			驱动他之后，他会使用 TCP/IP 的网络协议链接到储存设备上头，
			并且『将整个储存设备视为主机上面的一个 SCSI 硬盘』的模样！
			也就是说，基本上，iSCSI 的储存设备就是您主机上面的一个实体硬盘，
			只是这个硬盘是以 iSCSI 协议及 TCP/IP 协议来达成的。而且，他在主机上面的使用，
			几乎就与实体 SCSI 硬盘没有两样！磁盘代号则为 /dev/sda... 。<br><br>
		</div>

		经过上面的说明，你可以了解到，其实整个 iSCSI 的储存设备并不是一个完整的主机喔，他仅是一个储存设备，
		跟上头提到的 NAS 并不相同，反而有点类似 SAN 啦～而且，这个储存设备可以让主机完整掌控，
		几乎就与主机上头的 SCSI 硬盘没有两样就是了。<br><br>

		底下鸟哥以 Promise 公司出品的 iSCSI 装置来进行说明，
		该 iSCSI 装置里面已经存在 10 颗 250GB 的 SATA 硬盘，其中有一颗做为备份 (spare disk) ，
		所以共有九颗硬盘作为 RAID-5 的架构。因此，整个 RAID 的容量则约略是：
		250*(9-1)=2TB，不过，这样只是约略估计啦，因为 250GB 硬盘的计算是以 10 进位计算的，
		跟我们常见的磁盘容量计算单位不相同。不过，很接近就是了！ ^_^<br><br>

		再来，由于 Promise 公司并没有提供 Linux 主机的 iSCSI 驱动程序，所以，
		鸟哥则以 Linux-iSCSI project 提供的相关信息，并以底下这一篇为基底：
		<a href="http://www.cuddletech.com/articles/iscsi/index.html" target="_blank">http://www.cuddletech.com/articles/iscsi/index.html</a>
		安装鸟哥的 Red Hat 9 Linux 的 iSCSI driver 。基本上，在该篇文章中，
		Linux 主机被称为是 initiator 的啦！<br>

		<div style="padding: 10pt 0pt;" align="right"><table width="90%"><tbody><tr><td><b>Tips:</b><br><span style="color: rgb(0, 144, 0);"><font size="-1">			事实上，由于 iSCSI 储存设备与 Linux 主机之间，是透过 TCP/IP 协议，
			亦即网络来进行数据的存放，因此，您至少必须要具备基础的网络基础知识才行～
			不过，这一篇实在挺有趣的，而单独写一篇服务器，似乎也没有那个必要，
			所以，就让鸟哥放到这个地方来了～所以啰，如果您目前看不懂也没关系啦；
			而且，鸟哥也是刚好有机会接触到 iSCSI 的设备才能够玩这一篇啊！呵呵～
			其实还挺高兴的！ ^_^
		</font></span></td><td><img src="0610hardware-fc4_files/vbird_face.gif" alt="鸟哥的图示" title="鸟哥的图示"></td></tr></tbody></table></div>
		基本上，鸟哥的环境架构是这样的：<ul>
		<li>Linux 主机：<ul>
			<li>系统： Red Hat 9
			</li><li>核心： Red Hat 9 的预设核心 ( 2.4.20-8mp )
			</li><li>软件： 已安装 kernel-source, make, gcc 等必要的套件；
			</li><li>iSCSI driver：<a href="http://sourceforge.net/project/showfiles.php?group_id=26396" target="_blank">http://sourceforge.net/project/showfiles.php?group_id=26396</a>
			</li><li>IP：我的 Red Hat 9 IP 为 192.168.10.30
			</li></ul></li><br>
		<li>iSCSI 储存设备架构：<ul>
			<li>型号为PROMISE M500i ，使用 iSCSI 机型；
			</li><li>使用 10 颗硬盘，1 颗为 spare disk，其余 9 颗做成 RAID-5；
			</li><li>IP：iSCSI 储存设备的 IP 为 192.168.10.200
			</li><li>连接到储存设备的账号与密码分别为： account/iscsipw
			</li></ul>
		</li></ul>

		相关的 iSCSI 装置、网络接线的链接，以及 GB switch 的选购与连结等等，
		请与相关的硬件厂商联系，他们会帮忙搞定的～我们要作的，仅是在 Linux 主机上面安装驱动程序，
		并且将他挂载起来就是了。其实，当 iSCSI RAID 到您府上时，安装好之后，
		我们就不需要动他的设定了～因为他仅提供储存空间嘛！只要控制 Linux 主机端即可啦！
		整个安装的步骤有点像这样：<ol>

		<hr><li><span class="text_import1">下载适当的驱动程序：</span><br><br>
			由于鸟哥的测试机使用的是 Red Hat 9 ，他的核心是 2.4.xx 版本，
			所以，我下载的是 3.6.3 的版本，当然，你也可以直接下载给 Red Hat 9 使用的
			RPM 档案啊！：<br><br>
			<ul><li>iSCSI driver：<a href="http://sourceforge.net/project/showfiles.php?group_id=26396" target="_blank">http://sourceforge.net/project/showfiles.php?group_id=26396</a></li></ul>
			<br><br>

		<hr></li><li><span class="text_import1">开始安装 iSCSI 驱动程序：</span><br><br>
			iSCSI 的驱动程序安装真的很简单啊！我们刚刚下载的档案放置到 /usr/local/src 后，
			然后直接解压缩，之后将他直接进行 make 与 make install 即可！
			鸟哥这里讲得很简单，若有需要更详细的 tarball 安装说明，请参考
			<a href="http://linux.vbird.org/linux_basic/0610hardware/0520source_code_and_tarball.php">原始码与 tarball</a> 那个章节啊！
			此外，由于 iSCSI 是一种驱动程序，因此，他会读取 Linux kernel 的相关原始码档案，
			所以，你也必须要确认你的系统上面确实含有 Linux kernel 在 /usr/src/linux 目录下才行！
			这也是很重要的一项准备工作喔！<br>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">1. 先进行解压缩的动作：</span>
[root@linux ~]# <span class="term_command">cd /usr/local/src</span>
[root@linux src]# <span class="term_command">tar -zxvf linux-iscsi-3.6.3.tgz</span>
[root@linux src]# <span class="term_command">cd linux-iscsi-3.6.3c</span>


<span class="term_hd">2. 开始进行编译与安装</span>
[root@linux linux-iscsi-3.6.3]# <span class="term_command">make clean &amp;&amp; make</span>
[root@linux linux-iscsi-3.6.3]# <span class="term_command">make install</span>
<span class="term_say"># 首先，会有一些关于核心方面的相关说明，这里看看即可！</span>
Note: using kernel source from /lib/modules/2.4.20-8smp/build containing
kernel version 2.4.20-8custom
Note: using kernel config from /boot/config-2.4.20-8smp
Installing iSCSI driver for Linux 2.4.20-8smp

<span class="term_say"># 再来，则会安装启动 iSCSI 的 script ，预设放置到 /etc/rc.d/init.d/iscsi 去！
# 同时注意一下，这个程序会自动的加入到 chkconfig 的管理项目当中，因此，
# 安装好的同时，这个 iscsi 就会在开机时主动的启动了。</span>
The initialization script has been installed as /etc/rc.d/init.d/iscsi.
iSCSI has been set up to run automatically when you reboot.

<span class="term_say"># 同时，会将我们的 Linux 主机仿真成为 CISCO 的 iSCSI
# 协议的接受器，相关的设定数据会被写入到 /etc/initiatorname.iscsi 当中。</span>
InitiatorName iqn.1987-05.com.cisco:01.d1dbb1112d38 has already been
generated and written to /etc/initiatorname.iscsi.

<span class="term_say"># 接下来这个档案才是我们所关心的！那就是链接到 iSCSI 储存装置的配置文件！
# 你必须要根据你的装置来给予相关的修改后，他才会顺利工作喔！</span>
Make sure you check and edit the /etc/iscsi.conf file!


<span class="term_hd">3. 开始进行修改的工作：</span>
[root@linux ~]# <span class="term_command">vi /etc/iscsi.conf</span>
<span class="term_say"># 在这个档案当中新增底下这几行，注意，账号、密码与 IP 均需确定正确喔！</span>
Username=account
Password=iscsipw
DiscoveryAddress=192.168.10.200
  Username=account
  Password=iscsipw


<span class="term_hd">4. 开始启动 iscsi 啰！</span>
[root@linux ~]# <span class="term_command">/etc/init.d/iscsi start</span>
Starting iSCSI: iscsi iscsid fsck/mount

[root@linux ~]# <span class="term_command">vi /var/log/messages</span>
iscsid[3208]: version 3.6.3.0 variant (27-Jun-2005)
iscsid[3208]: root development build created Mon Jun 27 14:34:43 CDT 2005
iscsid[3209]: INBP boot check returned this_is_inbp_boot = 0
iscsid[3212]: Connected to Discovery Address 192.168.10.200
kernel: iSCSI: bus 0 target 0 = iqn.1994-12.com.promise.target.3b.31.
	4.55.1.0.0.20
kernel: iSCSI: bus 0 target 0 portal 0 = address 192.168.10.200 port 
	3260 group 2
kernel: iSCSI: bus 0 target 0 trying to establish session f5ad6000 to
	 portal 0, address 192.168.10.200 port 3260 group 2
kernel: iSCSI: bus 0 target 0 established session f5ad6000 #1 to portal 
	0, address 192.168.10.200 port 3260 group 2, alias VTrak M500i
kernel: scsi singledevice 0 0 0 0
kernel:   Vendor: Promise   Model: VTrak M500i       Rev: 1122
kernel:   Type:   Direct-Access                      ANSI SCSI revision: 04
kernel: Attached scsi disk sda at scsi0, channel 0, id 0, lun 0
kernel: SCSI device sda: 3890624512 512-byte hdwr sectors (1992000 MB)
kernel:  sda:
<span class="term_say"># 看到了吗？没错！确实有连接到正确的储存位置了～
# 而且捉到的是 sda 这个装置代号喔！容量可有 1992000MB 这么大！
# 然后我们来看看系统是否能够捉到这个装置呢？</span>

[root@linux ~]# <span class="term_command">fdisk -l</span>
Disk /dev/sda: 1991.9 GB, 1991999750144 bytes
64 heads, 32 sectors/track, 1899719 cylinders
Units = cylinders of 2048 * 512 = 1048576 bytes

   Device Boot    Start       End    Blocks   Id  System

[root@linux ~]# <span class="term_command">iscsi-ls</span>
*******************************************************************************
        SFNet iSCSI Driver Version ... 3.6.3 (27-Jun-2005 )
*******************************************************************************
TARGET NAME             : iqn.1994-12.com.promise.target.3b.31.4.55.1.0.0.20
TARGET ALIAS            : VTrak M500i
HOST NO                 : 0
BUS NO                  : 0
TARGET ID               : 0
TARGET ADDRESS          : 192.168.10.200:3260
SESSION STATUS          : ESTABLISHED AT Thu Nov 10 20:13:43 2005
NO. OF PORTALS          : 1
PORTAL ADDRESS 1        : 192.168.10.200:3260,2
SESSION ID              : ISID 00023d000001 TSIH 04
*******************************************************************************
<span class="term_say"># 看到了吧？使用 fdisk -l 可以看到名称为 /dev/sda 的装置，使用 iSCSI
# 提供的 iscsi-ls 也可以查询的到相关的信息呢！真是很不错啊！</span>


<span class="term_hd">5. 分割 /dev/sda 与格式化！</span>
[root@linux ~]# <span class="term_command">fdisk /dev/sda</span>
Command (m for help): <span class="term_command">n</span>
Command action
   e   extended
   p   primary partition (1-4)
<span class="term_command">p</span>
Partition number (1-4): <span class="term_command">1</span>
First cylinder (1-1899719, default 1):
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-1899719, default 1899719):
Using default value 1899719
Command (m for help): <span class="term_command">w</span>

[root@linux ~]# <span class="term_command">mke2fs -j /dev/sda1</span>
</pre></td></tr></tbody></table>

			经过这个简单的动作，我的 Linux 主机已经捉到 iSCSI 储存装置，
			并且，他就好像是我自己 Linux 本机上面的一个 SCSI 硬盘一样！
			使用的方式几乎一模一样～没有差异呢！真是太方便了～接下来，当然就是要挂载啦！<br><br>

		<hr></li><li><span class="text_import1">设定挂载：</span><br><br>
			假设我的这部 iSCSI 主机要挂载到 /cluster/raid 这个目录下，那么我就这样做：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">mkdir /cluster/raid</span>
[root@linux ~]# <span class="term_command">mount -t ext3 /dev/sda1 /cluster/raid</span>
[root@linux ~]# <span class="term_command">df</span>
Filesystem           1K-blocks      Used Available  Use% Mounted on
/dev/hda1             10080488   2950408   6618012   31% /
/dev/hda2              5036316     81172   4699312    2% /var
/dev/hda3              3020172     33492   2833260    2% /tmp
none                    773736         0    773736    0% /dev/shm
<span class="term_write">/dev/sda1            1914788196  27040372 1790482212  2% /cluster/raid</span>
</pre></td></tr></tbody></table>

			很有趣吧！这样就能够将 iSCSI 挂载到我们的机器上啰～<br><br>

		<hr></li><li><span class="text_import1">设定自动挂载：</span><br><br>
			不过，如果你想要让系统自动挂载 iSCSI 装置的数据，该写入哪里？
			当然不可能是 /etc/fstab 啰～因为在加载 /etc/fstab 之前，根本就还没有驱动网络，
			所以，当然不可能写入 /etc/fstab 。好在，我们的 iSCSI 有提供不错的模块，
			你可以直接修改 /etc/fstab.iscsi 这个档案，将他设定成为：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">vi /etc/fstab.iscsi</span>
<span class="term_write">/dev/sda1   /cluster/raid   ext3    defaults     0   0</span>
</pre></td></tr></tbody></table>

			如此一来，开机就会自动的挂载该 iSCSI 的装置啦！就是这么简单啊！^_^
		</li></ol>

		鸟哥是由于研究室有一部 iSCSI 的 Raid 才有可能接触到这么高档的货色～
		真是觉得很开心！整个 iSCSI 的设定并不困难，当然，要达成更高效率的读写数据，
		可能还是需要进一步的研究啦！提供给您作为一个设定的参考啰！ ^_^
	</div>
</div>


<hr><a name="reference"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">参考文献</span><br>
<div class="block1">
<ul>
	<li>USB 的在线书籍：<a href="http://www.linux-usb.org/USB-guide/book1.html" target="_blank">http://www.linux-usb.org/USB-guide/book1.html</a>
	</li><li>Linux USB ：<a href="http://www.linux-usb.org/" target="_blank">http://www.linux-usb.org/</a>
	</li><li>LM_sensors 官方网站：<a href="http://www2.lm-sensors.nu/~lm78/" target="_blank">http://www2.lm-sensors.nu/~lm78/</a>
	</li><li>Linux 磁盘阵列：<a href="http://www.tldp.org/HOWTO/Software-RAID-HOWTO-1.html" target="_blank">http://www.tldp.org/HOWTO/Software-RAID-HOWTO-1.html</a>
	</li><li>Linux iSCSI project：<a href="http://linux-iscsi.sourceforge.net/" target="_blank">http://linux-iscsi.sourceforge.net/</a>
	</li><li>A Quick Guide to iSCSI on Linux：<a href="http://www.cuddletech.com/articles/iscsi/index.html" target="_blank">http://www.cuddletech.com/articles/iscsi/index.html</a>
	</li><li>工研院 iSCSI 简介：<a href="http://www.itri.org.tw/chi/southern_branch/ccl_01c.jsp" target="_blank">http://www.itri.org.tw/chi/southern_branch/ccl_01c.jsp</a>
	</li><li>季明, "SuSE Linux Enterprise Server 9 管理手册", 第六章, 碁峰出版社。
	</li><li>日京三子的 LVM 笔记：<a href="http://phorum.study-area.org/viewtopic.php?t=19073" target="_blank">http://phorum.study-area.org/viewtopic.php?t=19073</a>
</li></ul>
</div>


<hr><a name="FAQ"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">习题练习</span><br>
( 要看答案请将鼠标移动到『答：』底下的空白处，按下左键圈选空白处即可察看)
<div class="block1">
<ul>
	<li>如何建立 /dev/usb/lp8？</li>
	<div class="block2"><font color="white" size="-1">
		首先，必须要查阅得该装置的主要装置代号，亦即 180，至于次要代号则是 8 ，
		再使用 mknod 来建立，因此，需要这样做：<br><font face="细明体">
		mknod /dev/usb/lp8 c 180 8<br>
		chown root:lp /dev/usb/lp8<br>
		chmod 660 /dev/usb/lp8<br></font>
	</font></div>

	<li>如何使用 lm_sensors 侦测主机内的温度，详细说明整个步骤？</li>
	<div class="block2"><font color="white" size="-1">
		</font><ul><font color="white" size="-1"><li>先确定您的主板具有温度与电压等侦测芯片，可使用 lspci 检查芯片组；
		</li><li>开机进入 BIOS 后，查询一下是否具有硬件侦测温度、电压的项目，将输出的项目顺序记一下；
		</li><li>确定 Linux 已经安装了 lm_sensors，再使用 sensors-detect 检查所需要的设定项目；
		</li><li>依据上个步骤，设定 /etc/modprobe.conf 及 /etc/rc.d/rc.local 两个档案；
		</li><li>使用 chkconfig 让 lm_sensors 开机启动，并且重新启动 (reboot)；
		</li><li>开始使用 sensors 进行侦测，也可以尝试修改 /etc/sensors.conf 的内容，以符合实际状况。
		</li></font></ul>
<font color="white" size="-1">	</font></div>

	<li>我原本的 Linux 系统使用 80GB 的硬盘，分成 /dev/hda1(/), /dev/hda2(/home), /dev/hda3(swap)，
	现在我想要将所有的数据通通搬移到另一颗 250GB 的硬盘上面去，所有的数据都不要改变，
	我想要利用 dd, fdisk, mke2fs, resize2fs 等指令的辅助，可以如何工作？</li>
	<div class="block2"><font color="white" size="-1">
		这个问题很有趣喔！建议你可以先参考这一篇：
		http://www.l-penguin.idv.tw/article/dd-sys-backup.htm ，主要的工作可以这样做：
		</font><ul><font color="white" size="-1"><li>先以 fdisk 将 250GB 的硬盘分割成为 3 个 partitions ，
			个别对应到 /dev/hda1, /dev/hda2, /dev/hda3 ，必须要注意，
			后来的新硬盘的 partition 必须要大于原本的！
		</li><li>利用 mke2fs 将后来新硬盘的 1, 2 partitions 格式化！
		</li><li>利用『 dd if=/dev/hda1 of=/dev/hdb1 』将数据开始复制！
		</li><li>使用 fsck 检查 /dev/hdb1, /dev/hdb2 两个 partition；
		</li><li>利用本章学到的 resize2fs 去校正剩下的磁盘空间：『resize2fs /dev/hdb1』
		</li><li>用尽各种方法将 grub 植入 /dev/hdb 当中！成功！搞定！ ^_^</li></font></ul>
<font color="white" size="-1">	</font></div>

</ul>
</div>


<hr><span class="text_history">
2005/10/25：准备准备～写一些跟硬件比较有关系的数据！<br>
2005/11/08：准备完毕 <a href="#hw_pre_usb">USB</a> 与 <a href="#hw_pre_lm">lm_sensors</a> 
	的部分了～啊！拖了真久～还有 <a href="#raid_raid">RAID</a> 的说明也差不多哩！<br>
2005/11/09：加入了 FC4 的 <a href="#fc_setup">setup</a> 指令，尤其是打印机的部分，可以参考参考！<br>
2005/11/10：终于将 iSCSI 的装置写好了～这部份真的是很有趣！不过，一般使用者可能碰不到就是了。<br>
2005/11/13：终于将 CUPS 架构设定好自己的 Printer 部分了！<br>
2005/11/14：连同 LVM 也大致的给他写完了！那个 resize2fs 指令确实有趣！<br>
2005/11/25：加入一个简单的练习题～利用 dd 配合 resize2fs 来制作备份的资料！<hr>
</span>
    </td>
    <td style="width: 16px; font-size: 6px;">　</td></tr>
<tr><td style="width: 16px; height: 16px;">　</td>
    <td style="width: 866px; height: 16px;">　</td>
    <td style="width: 16px; height: 16px;">　</td></tr>
</tbody></table>

<div style="padding-top: 0px; text-align: center;">
<span style="font-size: 80%;">
	<a href="http://linux.vbird.org/" target="_top" title="前往鸟哥的首页">http://linux.vbird.org</a>
	is designed by <a href="mailto:vbird@mail.vbird.idv.tw" title="联络鸟哥(我不要广告信！)">VBird</a>
		during 2001-2011. <a href="http://www.ksu.edu.tw/" target="_blank">ksu.edu</a></span>
                        ﻿<div id="apDiv4">
      <p>本网页主要以Firefox配合解析度 1024x768 作为设计依据&nbsp;&nbsp;&nbsp;&nbsp; 鸟哥自由软件整合应用研究室</p></div></div></div>
</center>
</body></html>
