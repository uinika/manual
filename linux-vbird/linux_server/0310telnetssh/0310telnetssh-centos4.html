
<html><head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf8">
	<meta name="Author" content="VBird, 鸟哥">
	<meta name="Description" content="关于文字接口登入主机的 telnet/ssh/rsh 及图形接口登入主机的 VNC/XDMCP 等方法">
	<title>鸟哥的 Linux 私房菜 -- 远程联机服务器 Telnet/SSH/XDMCP/VNC/RSH</title>
    <script src="../../script/SpryMenuBar.js" type="text/javascript"></script>
	<script src="../../script/index.js" type="text/javascript"></script>
	<link href="../../css/SpryMenuBarHorizontal.css" rel="stylesheet" type="text/css" />
    <link href="../../css/main.css" rel="stylesheet" type="text/css" />
    </head><body style="margin: 0pt; padding: 0pt;" class="table"onload="MM_preloadImages('../../index-2.html','../../index-2.html','../../index-2.html','../../index-2.html','../../index-2.html','../../index-2.html','../../index-2.html','../../index-2.html')">

<center>
<div id="apDiv5">
<div> <LINK REL="SHORTCUT ICON" HREF="../../index-2.html">
<!-- ImageReady Slices (title3.ai) -->
<table id="___01" width="898" height="81" border="0" align="center" cellpadding="0" cellspacing="0";>
	<tr>
		<td colspan="15">
			<img src="image/title/title_01.png" width="900" height="1" alt=""></td>
	</tr>
	<tr>
		<td rowspan="4" bgcolor="#182448"><p><img src="http://linux.vbird.org/cgi-bin/Count.cgi?dd=C&amp;ft=5&amp;sh=T&amp;md=8&amp;pad=Y&amp;df=vbird.dic.ksu.edu.tw.dat" width="93" align="left" title="計數器" /></p>
	    <p><font color="#FFFFFF" size="-1">since2012/04/23</font></p></td>
		<td rowspan="4" align="left" valign="top"><a href="../../index.html"><img src="image/title/title_03.png" alt="" width="263" height="79" border="0"></a></td>
		<td colspan="13">
			<img src="image/title/title_04.png" alt="" width="535" height="9" border="0"></td>
	</tr>
	<tr>
		<td rowspan="3">
			<img src="image/title/title_05.png" alt="" width="53" height="70" border="0"></td>
		<td colspan="2" align="left" valign="top"><a href="../../linux_basic/0110whatislinux.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image51','','image/title/title_06.png',1)"><img src="image/title/title3_06.png" name="Image51" width="106" height="25" border="0" id="Image51" alt=""/></a></td>
		<td rowspan="2">
			<img src="image/title/title_07.png" alt="" width="27" height="37" border="0"></td>
		<td colspan="3" align="left" valign="top"><a href="../0110network_basic.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image52','','image/title/title_08.png',1)"><img src="image/title/title3_08.png" name="Image52" width="107" height="25" border="0" id="Image52" alt=""/></a></td>
		<td rowspan="2">
			<img src="image/title/title_09.png" alt="" width="37" height="37" border="0"></td>
		<td colspan="2" align="left" valign="top"><a href="../../about.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image53','','image/title/title_10.png',1)"><img src="image/title/title3_10.png" name="Image53" width="75" height="25" border="0" id="Image53" alt=""/></a></td>
		<td rowspan="3">
			<img src="image/title/title_11.png" alt="" width="35" height="70" border="0"></td>
		<td align="left" valign="top"><a href="mailto:vbird@mail.vbird.idv.tw" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image54','','image/title/title_12.png',1)"><img src="image/title/title3_12.png" name="Image54" width="74" height="25" border="0" id="Image54" alt=""/></a></td>
		<td rowspan="3">
			<img src="image/title/title_13.png" alt="" width="21" height="70" border="0"></td>
	</tr>
	<tr>
		<td colspan="2">
			<img src="image/title/title_14.png" alt="" width="106" height="12" border="0"></td>
		<td colspan="3">
			<img src="image/title/title_15.png" alt="" width="107" height="12" border="0"></td>
		<td colspan="2">
			<img src="image/title/title_16.png" width="75" height="12" alt=""></td>
		<td rowspan="2">
			<img src="image/title/title_17.png" alt="" width="74" height="45" border="0"></td>
	</tr>
	<tr>
		<td>
			<img src="image/title/title_18.png" alt="" width="15" height="33" border="0"></td>
		<td colspan="3" align="left" valign="top"><ul id="MenuBar1" class="MenuBarHorizontal">
	  <li><a href="../../linux_basic/linux_basic.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image44','','image/title/title_19.png',1)"><img src="image/title/title3_19.png" name="Image44" width="123" height="33" border="0" id="Image44" /></a>
			    <ul>
			      <li><a href="../../linux_basic/Mandrake9.0/mandrake9.0.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image46','','image/title/title_26.png',1)"><img src="image/title/title_23.png" name="Image46" width="120" height="26" border="0" id="Image46" alt="" /></a></li>
                  <li><a href="../../linux_basic/fedora_4/fc4.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image47','','image/title/title_27.png',1)"><img src="image/title/title_24.png" name="Image47" width="120" height="26" border="0" id="Image47" alt="" /></a></li>
                  <li><a href="../../linux_basic/linux_basic.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image48','','image/title/title_28.png',1)"><img src="image/title/title_25.png" name="Image48" width="120" height="26" border="0" id="Image48" alt="" /></a></li>
                </ul>
		      </li>
		</ul></td>
		<td>
			<img src="image/title/title_20.png" alt="" width="42" height="33" border="0"></td>
		<td colspan="3" align="left" valign="top"><ul id="MenuBar2" class="MenuBarHorizontal">
	  <li><a href="../index.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image45','','image/title/title_21.png',1)"><img src="image/title/title3_21.png" name="Image45" width="125" height="33" border="0" id="Image45" /></a>
			    <ul>
			      <li><a href="../linux_redhat9/redhat9.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image43','','image/title/title_26.png',1)"><img src="image/title/title_23.png" name="Image43" width="120" height="26" border="0" id="Image43" alt=""/></a></li>
			      <li><a href="../centos4.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image49','','image/title/title_27.png',1)"><img src="image/title/title_24.png" name="Image49" width="120" height="26" border="0" id="Image49" alt="" /></a></li>
			      <li><a href="../index.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image50','','image/title/title_28.png',1)"><img src="image/title/title_25.png" name="Image50" width="120" height="26" border="0" id="Image50" alt="" /></a></li>
		        </ul>
		      </li>
		</ul></td>
		<td>
			<img src="image/title/title_22.png" alt="" width="47" height="33" border="0"></td>
	</tr>
	<tr>
		<td>
			<img src="image/title/Spacer.gif" width="101" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="263" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="53" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="15" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="91" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="27" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="5" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="42" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="60" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="37" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="28" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="47" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="35" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="74" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="22" height="1" alt=""></td>
	</tr>
</table>
<!-- End ImageReady Slices -->
<script type="text/javascript">
<!--
var MenuBar1 = new Spry.Widget.MenuBar("MenuBar1", {imgDown:"SpryAssets/SpryMenuBarDownHover.gif", imgRight:"SpryAssets/SpryMenuBarRightHover.gif"});
var MenuBar2 = new Spry.Widget.MenuBar("MenuBar2", {imgDown:"SpryAssets/SpryMenuBarDownHover.gif", imgRight:"SpryAssets/SpryMenuBarRightHover.gif"});
//-->
</script>
</div>
<table summary="本文内容的排版" style="width: 898px;" border="0" cellpadding="0" cellspacing="0">
<tbody><tr><td style="width: 16px; height: 16px;">　</td>
    <td style="width: 866px; height: 16px;">　</td>
    <td style="width: 16px; height: 16px;">　</td></tr>
<tr><td style="width: 16px; font-size: 6px;">　</td>
    <td width="866">

<!-- 本文的档头部分 -->
<div style="text-align:center">
    <a href="http://vbird.dic.ksu.edu.tw/linux_server/0310telnetssh/0310telnetssh-centos4.php">
    <span class="text_head0">远程联机服务器<span class="text_head_en"> Telnet / SSH / VNC / XDMCP / RSH</span></span></a><br>
</div>
    <div style="text-align:right">
        <span class="text_history">最近更新日期：2006/09/19</span>
    </div>

<center>本文已不再维护，更新文章请参考<a href="http://linux.vbird.org/linux_server/0310telnetssh.php">这里</a><br><br></center>

<!-- 本文的档头部分 -->
<center><table class="head1" summary="排版：文章档头的说明"><tbody><tr><td class="head1">
	一部连上 Internet 上面的您的个人主机，最重要的是什么呢？
	大概就是如何让您自己可以联机进入自己的主机，并且进行所谓的『远程操控』了吧！
	也就是说，您可以在任何具有连上 Internet 的计算机中，以远程联机软件连上 Internet
	，并藉由您主机上面的远程联机服务器软件提供的功能，直接登入您的主机来进行操控的工作！此时，您将发现
	Linux 有趣又好玩的地方啰！在早期的 Unix Like 机器当中，几乎都提供 Telnet 这个远程联机服务器软件，不过，
	Telnet 本身是以『明码』来传送您操作的数据，安全上面是值得来思考要不要开放吶！
	这个时候就有需要了解一下传送过程中以加密动作来传送数据封包的
	SSH 这个远程联机服务器软件啦！
	另外，除了纯文本接口登入主机来进行操控之外，在现在的 Linux distributions 当中，
	还可以利用 X 相关的服务来帮助我们以图形接口登入喔！很棒吧！ ^_^
</td></tr></tbody></table></center><br>

<!-- 本文的连结区部分 -->
<div class="block1">
<span class="text_h1">
1. <a href="#before">本章的行前准备工作</a><br>
2. <a href="#remote_access">远程联机服务器</a><br>
	<span class="text_h2">
	　　2.1 <a href="#remote_access_what">什么是远程联机服务器</a><br>
	　　2.2 <a href="#remote_access_work">有哪些可供登入的类型？</a><br>
	</span>
3. <a href="#telnet">Telnet 服务器</a><br>
	<span class="text_h2">
	　　3.1 <a href="#telnet_start">安装、启动与关闭服务</a><br>
	　　3.2 <a href="#telnet_client">好用的联机软件</a><br>
	　　3.3 <a href="#telnet_safe">iptables, TCP_Wrappers, 纯建议</a><br>
	</span>
4. <a href="#ssh">SSH 服务器</a><br>
	<span class="text_h2">
	　　4.1 <a href="#ssh_connect">联机加密技术简介</a><br>
	　　4.2 <a href="#ssh_start">启动 ssh 服务</a><br>
	　　4.3 <a href="#ssh_client">ssh 客户端联机</a>：
		<a href="#ssh_client_ssh">ssh</a>, 
		<a href="#ssh_client_sftp">sftp</a>,
		<a href="#ssh_client_scp">scp</a>,
		<a href="#ssh_client_putty">putty 与 pietty</a>,
		<a href="#ssh_client_psftp">psftp</a>,
		<a href="#ssh_client_filezilla">filezilla</a><br>
	　　4.4 <a href="#ssh_sshdconfig">详细设定 sshd 服务器：</a><br>
	　　4.5 <a href="#ssh_nopasswd">制作不用密码可立即登入的 ssh 用户</a>： ssh-keygen<br>
	　　4.6 <a href="#ssh_secure">安全设定：</a><br>
	</span>
5. <a href="#xdmcp">Xdmcp 服务的启用</a><br>
	<span class="text_h2">
	　　5.1 <a href="#xdmcp_theory">X Window 的 Server/Client 架构</a><br>
	　　5.2 <a href="#xdmcp_setup">设定 XDMCP</a><br>
	　　5.3 <a href="#xdmcp_client">用户登入</a><br>
	　　5.4 <a href="#xdmcp_close">关闭 XDMCP</a><br>
	</span>
6. <a href="#vnc">VNC 服务器</a><br>
7. <a href="#rsh">RSH 服务器</a><br>
	<span class="text_h2">
	　　7.1 <a href="#rsh_server">RSH Server</a>：<a href="#hosts.equiv">/etc/hosts.equiv</a>, 
		<a href="#rhosts">~user/.rhosts</a><br>
	　　7.2 <a href="#rsh_client">RSH Client</a>：<a href="#rsh_cmd">rsh</a>,
		<a href="#rcp">rcp</a><br>
	</span>
8. <a href="#rsync">以 rsync 进行同步镜相备份</a><br>
9. <a href="#review">重点回顾</a><br>
10. <a href="#FAQ">课后练习</a><br>
11.<a href="#reference">参考资源</a><br>
<span class="text_h2">
12.<a href="http://phorum.vbird.org/viewtopic.php?p=114550" target="_blank">针对本文的建议：http://phorum.vbird.org/viewtopic.php?p=114550</a><br>
</span>
</span>

</div>


<!-- 本文的正式部分 -->
<hr><a name="before"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">本章的行前准备工作</span><br>
<div class="block1">
	在这个章节当中我们会使用客户端的联机软件联机到主机端来操作主机，所以你必须要了解到你的主机防火墙必须要开放，
	并且要取消 SELinux 才行！另外，登入时会分析到的 PAM 模块也需要进行了解吶！
	本章后半部会介绍 X Window 的远程登录，所以你也必须对于 X Server/client 的架构有点了解才行。<br>
	<ul>
	<li>了解<a href="http://vbird.dic.ksu.edu.tw/linux_server/0310telnetssh/0110network_basic-centos4.php">网络基础</a>，尤其网络是双向的；
	</li><li>认识<a href="http://vbird.dic.ksu.edu.tw/linux_server/0310telnetssh/0240network-secure-1-centos4.php">网络安全</a>当中的取消 SELinux ，以及<a href="http://vbird.dic.ksu.edu.tw/linux_server/0310telnetssh/0250simple_firewall-centos4.php">防火墙</a>的基本概念；
	</li><li>了解<a href="http://vbird.dic.ksu.edu.tw/linux_server/linux_basic/0410accountmanager.php">使用者与账号</a>的相关概念；
	</li><li>认识 <a href="http://vbird.dic.ksu.edu.tw/linux_server/linux_basic/0590xwindow.php">X Window System</a>；
	</li><li>由于很多远程联机服务器软件系统默认并不安装，因此你必须要了解 <a href="http://vbird.dic.ksu.edu.tw/linux_server/linux_basic/0520rpm_and_srpm.php">RPM</a> 
		及 <a href="http://vbird.dic.ksu.edu.tw/linux_server/0310telnetssh/0220upgrade.php">yum</a> 的使用。
	</li></ul>
</div>

<hr><a name="remote_access"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">远程联机服务器</span><br>
<div class="block1">
	远程联机服务器对我们来说，可是一项很有用的工具啊！他可以让我们更方便的管理主机。
	不过，方便是方便，安全性其实不很好的～所以，才要特别强调一下这个玩意儿啊！<br><br>

	<hr><a name="remote_access_what"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">什么是远程联机服务器
	</span><br>
	<div class="block2">
		首先，我们要先来了解一下，什么是『<span class="text_import2">远程联机服务器</span>』？
		这个东西的功能为何？我想，您应该已经听过，一个良好的网络环境当中，一部开放到
		Internet 上面的服务器，基本上，他可以不需要屏幕、键盘、鼠标等等的配备，
		只要有基本的主板、CPU、RAM、硬盘再加上一块好一点的网络卡，并且连上
		Internet ！哈哈！那么您要操控这部主机的时候，只要透过网络联机进来，然后进行任何修改即可！
		嘿！所以啰，这个时候主机自然不需要接口设备啦！<br><br>

		以鸟哥个人为例，目前鸟哥管理大约七、八部左右的 Unix-Like 主机，
		这些主机都不在同一个地方，分布在南台湾各处！那么当有新的套件的漏洞被发布，
		或者是需要进行一些额外的设定的时候，是否鸟哥本人一定要到现场吗？当然不需要，
		只要透过网络联机到该主机上面，就可以进行任何工作了！真的就好像在主机前面工作一般的轻松愉快！
		^_^！这就是远程联机服务器啦！<br><br>

		远程联机服务器的功能当然还不只如此！举个例子来说：当您的工作需要使用到
		Linux 的强大的编译功能时，那么您一定需要 Linux 对吧！而且最好是指令周期快一点的主机，
		这个时候您可以将您研究室最快的那一部主机开放出来，设定一下远程联机服务器，让您的学生啦，
		或者是研究室的同仁啦，可以透过这部机器帮他们进行研究的工作，这个时候，您的主机就可以让多人进行分享
		Linux 运算的功能啦！<br><br>

		在早期的网络世界里，由于只有 Unix 机器，而且个人计算机还不流行的时候，
		想要使用大型主机来进行数值程序的运算时(在我们工程界，比较常使用
		Fortran 这一类的程序语言，至于 C 语言则较少碰～)，就需要向学校单位申请 Unix 工作站的账号，
		并且以远程联机程序连进主机，以使用
		Unix 的资源来进行我们的数值模式运算！所以啦，那个远程联机服务器的设定，
		对于系统管理员是很重要的！尤其对于大型工作站类型的
		Unix-Like 主机，由于很多人都需要使用到他的运算功能，或者是他的编译程序(
		compiler )来进行运算，这时的远程联机就更形重要啦！<br><br>

		那么是否每一部连上 Internet 上面的主机都应该要开放远程联机的功能呢？其实并不尽然，
		还是需要针对您的主机来进行规划的，我们底下分服务器与工作站来说明：<br><br>

		<li><span class="text_import1">服务器类型( Server )的联机程序</span>：</li>
		<div class="block2">
			在一般开放因特网服务的服务器中，由于开放的服务可能会有较为重要的信息，
			而远程联机程序连进主机之后，可以进行的工作又太多了(几乎就像在主机前面工作一般！)，
			因此因特网的远程联机程序通常仅针对少部分系统维护者开放而已！
			<span class="text_import2">除非必要，否则
			Server 类型的主机还真的不建议开放联机的服务呢！</span>
			以鸟哥为例，我的主机提供了我们研究室使用
			Mail 与 Internet 上面的 WWW 服务，如果还主动提供远程联机的话，
			那么万一不小心被入侵，那可就伤脑筋了！因此，鸟哥仅开放『很小部分的网域』让系统管理员连进来，
			其他来源的 IP 一律抵挡！不许使用远程联机的功能呢！<br><br>
		</div>

		<li><span class="text_import1">工作站类型( Workstation )的联机程序</span>：</li>
		<div class="block2">
			至于工作站的情况就跟服务器不太一样了！工作站常常仅针对内部的几个使用者开放而已，
			通常是不希望连上 Internet 的啦！而且所谓的工作站自然就是用来做工的！
			例如鸟哥的其中一部 Linux 就是专门用来进行大型的数值模式计算仿真之用！
			这个时候的远程联机服务器可能就得要对多人启动了！
			因为工作站的强大运算功能可以让很多人一同使用他的计算能力！而且也可以免除每部计算机都得要安装
			compiler 的窘境！要知道，某些工程用的 compiler 是粉贵的～<br>
		</div>
	</div>

	<hr><a name="remote_access_work"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">有哪些可供登入的类型？
	</span><br>
	<div class="block2">
		那么目前远程联机服务器的主要类型有哪些？如果以显示的类型来分类，
		基本上有文字接口与图形接口两种。<br><br>

		在文字类型登入方面的服务器，主要有以『明码』传送数据的
		telnet 服务器，及以加密技术进行封包加密来传送的 SSH 服务器！虽然 telnet
		可以支持的 client 端软件比较多，不过由于他是使用明码来传送数据，
		您的资料很容易遭到有心人士的撷取！所以近来我们都呼吁大家多使用
		SSH 这一种联机方式，而舍弃掉 telnet 这个比较不安全的咚咚啰！<br><br>

		至于图形接口的服务器，比较简单的有 Xdmcp ，架设 Xdmcp 很简单，
		不过 client 端的软件比较少。另外一款目前很常见的服务器，就是 VNC (Virtual Network Computing)，
		透过 VNC server/client 软件来进行连接。图形接口最大的优点是『图形』啊！
		不过，因为是透过图形来传送，传输的数据量相当的大，所以速度与安全性都有待考虑。
		因此，我们仅建议您将图形接口的远程登录服务器开放在内部网域 (LAN) 就好了！<br><br>

		那么什么是『明码』与『加密』的数据封包传送模式呢？
		为什么 telnet 使用明码就比较不安全？所谓的明码就是：
		『<span class="text_import2">当我们的数据封包在网络上流窜时，该数据封包的内容为数据的原始格式</span>』，
		还记得我们在<a href="http://vbird.dic.ksu.edu.tw/linux_server/0310telnetssh/0140networkcommand-centos4.php#tcpdump">网络常用指令章节当中介绍的 tcpdump</a> 吧？
		我们在 telnet 下达的指令与密码等等，都会以类似 ASCII 的格式传送到主机端，
		而主机端就藉由这些数据来下达指令。如果这些数据封包在经过某些
		broadcast 或者是 Router 时，被有心人士捉去，那么他将会完整的取得您的数据喔！
		所以啦，万一您的数据封包里面含有信用卡数据、密码、身份确认等重要信息时，是否很危险吶？！
		因此，目前我们通常都希望使用可以将这些在网络上面跑的数据加密的技术，以增加数据在
		Internet 上面传送的安全性啊！<br>
	</div>
</div>

<hr><a name="telnet"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">Telnet 服务器</span><br>
<div class="block1">
	知道 telnet 是什么吗？咦！不就是连接 BBS 的工具吗？没错！他确实也是
	BBS 软件类的一个服务器啦！不过这里我们暂不玩弄 BBS ！ telnet 
	可以说是历史相当悠久的远程联机服务器哩！而且支持他的软件也相当的多！例如知名的
	netterm 就直接支持他啦！联机之后的界面也漂亮，在 client 端的中文传输与输入也没有问题！
	相当的不错用！不过，他最麻烦的地方就是.....比较不安全而已啦～<br><br>

	底下我们谈一谈怎么启动与使用 telnet 服务器吧！<br><br>

	<hr><a name="telnet_start"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">安装、启动与关闭服务
	</span><br>
	<div class="block2">
		<li><span class="text_import1">安装：</span></li>
		<div class="block2">
		近年来由于 telnet 是以明码在传输的问题，所以在新的 Linux 版本上面，<span class="text_import2">已经都将
		telnet 这个服务器排除在『先发名单』之外啦</span>，也就是说，很多 Linux
		distributions 预设是不安装 telnet 的，不过，在每个主要的 Linux distributions
		<span class="text_import2">还是有提供
		telnet 套件在光盘当中啦</span>！所以您要拿出原版光盘，并且安装好他就可以用啦！如何确认是否已经安装了
		telnet 呢？最简单的方法就是使用最广泛被使用的 RPM 啦！<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">rpm -qa | grep telnet</span>
telnet-0.17-31.EL4.3
telnet-server-0.17-31.EL4.3
<span class="term_say"># 上面是 CentOS 4.x 预设的套件版本。如果是其他的 distribution，
# 档名可能会不太一样～可利用 yum 或 apt 等方式来安装喔！</span>
</pre></td></tr></tbody></table>

		需要特别留意的是，如果要提供 telnet 联机服务，通常需要安装两个 RPM 喔：
		<ol><span class="text_import2">
		<li>一个是 telnet，这个套件提供的是 telnet 客户端的联机程序；</li>
		<li>另一个是 telnet-server 套件，这个才是真正的 Telnet server 软件喔！</li></span>
		</ol>
		如果找不到 telnet-server 的话，请拿出原版光盘来安装，或者直接使用 yum 吧！
		否则就无法进行下一步的设定啦！^_^<br><br>
		</div>

		<li><span class="text_import1">启动与关闭：</span></li>
		<div class="block2">
		还记得『<a href="http://vbird.dic.ksu.edu.tw/linux_server/linux_basic/linux_basic.php">鸟哥的 Linux 私房菜 -- 基础学习篇</a>』里面的
		『<a href="http://vbird.dic.ksu.edu.tw/linux_server/linux_basic/0560daemons.php">认识服务( daemon )</a>』那个章节吧？
		要记得 super daemon 呦！因为我们的
		telnet 就是挂在 super daemon 底下的一支服务而已！那个咚咚就是有名的 xinetd 啰！<br>

		<div style="padding: 10pt 0pt 10pt 0pt ;" align="right"><table width="90%"><tbody><tr><td><b>Tips:</b><br><span style="color : #009000"><font size="-1">			在某些旧版的套件上面也有使用 inetd 的，启动的方式有点不太一样，不过差异不大啦！
			只要懂得基本的常识，那么就不会有问题啰！所以鸟哥才会要大家先读完
			<a href="http://vbird.dic.ksu.edu.tw/linux_server/linux_basic/linux_basic.php">Linux 基础篇</a> 啦！
		</font></span></td><td><img src="0310telnetssh-centos4.php_files/vbird_face.gif" alt="鸟哥的图示" title="鸟哥的图示"></td></tr></tbody></table></div>
		启动的方式就是：

		<ol><span class="text_import2">
		<li>将 xinetd 里面关于 telnet 的项目开启，然后
		</li><li>重新启动一次 xinetd 就成功啦！</li></span></ol>

		那么如何开启 telnet 的项目呢？很简单，有两个方式：
		<ol>
		<li><span class="text_import2">使用 ntsysv 或
		<a href="http://vbird.dic.ksu.edu.tw/linux_server/linux_basic/0560daemons.php#chkconfig">chkconfig</a>：</span></li>
		还记得 Red Hat 系列(含 CentOS)的套件里面的 <a href="http://vbird.dic.ksu.edu.tw/linux_server/linux_basic/0560daemons.php#ntsysv">ntsysv</a>
		这个好用的东西吗？对了，在 CentOS 底下有这么一个好用的设定工具，您可以使用
		<a href="http://vbird.dic.ksu.edu.tw/linux_server/linux_basic/0560daemons.php#ntsysv">ntsysv</a>
		出现的窗口之中，将 telnet 勾选起来，然后按下 OK 离开即可啰！<br><br>
		<li><span class="text_import2">使用 <a href="http://vbird.dic.ksu.edu.tw/linux_server/linux_basic/0310vi.php">vi</a> 修改
		/etc/xinetd.d/telnet 这个档案：</span></li>
		那么如果不是 Red Hat 系列的 Linux 系统呢？基本上， ntsysv 也只是修改 /etc/xinetd.d
		这个目录下的数据而已，所以我们当然可以手动自己修改他啦！<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">vi /etc/xinetd.d/telnet</span>
service telnet
{
        flags           = REUSE
        socket_type     = stream
        wait            = no
        user            = root
        server          = /usr/sbin/in.telnetd
        log_on_failure  += USERID
<span class="term_write">#       disable         = yes
        disable         = no</span>
<span class="term_say"># 基本上，改上面这两行就够了！将 disable 设定成 no 表示要启动！</span>
}
</pre></td></tr></tbody></table>

		</ol>

		设定完开启之后，自然就是要启动啦，刚刚提到 <span class="text_import2">telnet
		是挂在 xinetd 底下的，所以自然只要重新启动 xinetd 就能够将 /etc/xinetd.d/ 里头的设定重新读进来</span>，
		所以刚刚设定启动的
		telnet 自然也就可以被启动啦！而启动的方式也有两种方式，其中 service 这个指令仅支持在
		CentOS 与 Mandriva 底下，所以通常鸟哥还是以 /etc/init.d 底下的 scripts
		为启动的主要方法啦！<br>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">仅适合 Red Hat 系列 / Mandriva 系列的主机启动方式</span>
[root@linux ~]# <span class="term_command">service xinetd restart</span>
Stopping xinetd:                       [  OK  ]
Starting xinetd:                       [  OK  ]

<span class="term_hd">适合各版本的主机启动方式</span>
[root@linux ~]# <span class="term_command">/etc/init.d/xinetd restart</span>
Stopping xinetd:                       [  OK  ]
Starting xinetd:                       [  OK  ]
<span class="term_say"># 某些版本并没有 restart 的选项，这个时候就需要：stop 再 start 啰！</span>
</pre></td></tr></tbody></table>

		那么要看有没有启动服务呢？怎么看？其实也很简单啦，还记得我们在前几章提到的『
		<a href="http://vbird.dic.ksu.edu.tw/linux_server/0310telnetssh/0210port_limit.php">限制 Linux port 的联机</a> 』那一章吗？使用
		<a href="http://vbird.dic.ksu.edu.tw/linux_server/0310telnetssh/0140networkcommand-centos4.php#netstat">netstat</a>
		就可以啦！<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">netstat -tlup</span>
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address  Foreign Address   State   PID/Program name
tcp        0      0 *:telnet       *:*               LISTEN  23817/xinetd
</pre></td></tr></tbody></table>

		看到了吗？没错，那个 telnet 就是启动的项目啦！那么要如何关闭呢？呵呵！
		那就真的是太简单啦！就将刚刚的步骤再做一次，而将设定值转变一下即可！步骤如下啦！<br>

		<div style="padding: 10pt 0pt 10pt 0pt ;" align="right"><table width="90%"><tbody><tr><td><b>Tips:</b><br><span style="color : #009000"><font size="-1">			这里考一个问题，那个 port 对应的服务名称在哪一个档案里面查询到的呢？
			在每一个 Linux 系统都有的档案呦！忘记了呀！？再回到前面看看
			<a href="http://vbird.dic.ksu.edu.tw/linux_server/0310telnetssh/0210port_limit.php">限制 Linux port 的联机</a> ，
			然后用 <a href="http://vbird.dic.ksu.edu.tw/linux_server/linux_basic/0310vi.php">vi</a> 去看看那一个档案的内容吧！ ^_^ 
		</font></span></td><td><img src="0310telnetssh-centos4.php_files/vbird_face.gif" alt="鸟哥的图示" title="鸟哥的图示"></td></tr></tbody></table></div>
<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">Step 1: 修改配置文件</span>
[root@linux ~]# <span class="term_command">vi /etc/xinetd.d/telnet</span>
service telnet
{
        flags           = REUSE
        socket_type     = stream
        wait            = no
        user            = root
        server          = /usr/sbin/in.telnetd
        log_on_failure  += USERID
        disable         = yes  <span class="term_say">&lt;== 就是这里啦！将他改成 yes 就是关闭！</span>
}

<span class="term_hd">Step 2: 重新启动 xinetd 这个 super daemon</span>
[root@linux ~]# <span class="term_command">/etc/init.d/xinetd restart</span>
</pre></td></tr></tbody></table>

		</div>
	</div>

	<hr><a name="telnet_client"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">好用的联机软件</span><br>
	<div class="block2">
		刚刚上面提到的都是在服务器端的设定而已！那么在客户端有什么好用的软件可以连上 
		Server 的呢？最常见到的应该就是 netterm 这个鼎鼎大名的联机软件了吧！
		我想，只要玩过 BBS 的大概都晓得这个软件才对！所以这里就不提了！
		另外，目前几乎所有的操作系统都提供了 telnet 这个程序，这个程序可以直接轻易的就连上 
		telnet server 呢！例如您要在 Linux 上面连上自己的 telnet 服务器，可以这样做：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">telnet localhost</span>
Trying 127.0.0.1...
Connected to localhost.localdomain (127.0.0.1).
Escape character is '^]'.
CentOS release 4.4 (Final)
Kernel 2.6.9-42.0.2.EL on an i686
login: <span class="term_command">dmtsai</span>    <span class="term_say">&lt;== 就是这里啦！请输入『一般』账号，不能用 root 喔！</span>
Password:         <span class="term_say">&lt;== 这里输入该账号的密码！请注意，输入时，屏幕不会有任何信息！</span>
Last login: Fri Jul  1 09:31:21 from 127.0.0.1  <span class="term_say">&lt;== 上次登入的信息为何?</span>
[dmtsai@linux ~]$ <span class="term_say">&lt;== 这里就是已经登入的地方！亦即远程主机了！</span>
[dmtsai@linux ~]$ <span class="term_command">exit</span>    <span class="term_say">&lt;== 这样就能够离开 telnet 与远程主机咯！</span>
</pre></td></tr></tbody></table>

		这样就联机进来啦！很简单吧！那么在 Windows 的环境底下呢？同样的，也是可以使用
		telnet 的程序联机到 Linux 的 telnet server 里面来！没有问题的啦！可以依序这样做：

		<ol><span class="text_import2">
		<li>按下 Windows 内的 『开始』
		</li><li>选择 『执行』
		</li><li>在出现的窗口中输入 『telnet your.IP.or.hostname』</li></span></ol>

		这样就可以进入 Linux 的环境中了！很方便吧！当然啦！您也可以使用类似
		netterm 这个很棒的联机软件来联机的，这里我们就不示范啦！<br>

		<div style="padding: 10pt 0pt 10pt 0pt ;" align="right"><table width="90%"><tbody><tr><td><b>Tips:</b><br><span style="color : #009000"><font size="-1">		在 Linux tty1 ~ tty6 的终端机默认模式下，我们是没有办法看到中文的！
		除非安装某些特殊的中文接口才行！比如 JMCCE 之类的咚咚！
		因为不是很重要，所以鸟哥这里就不加介绍了。 ^_^
		</font></span></td><td><img src="0310telnetssh-centos4.php_files/vbird_face.gif" alt="鸟哥的图示" title="鸟哥的图示"></td></tr></tbody></table></div>
		另外，需要先留意的是，为了系统安全的考虑，<span class="text_import2">预设的 telnet 
		是『不允许』使用 root 这个账号登入的～</span>
		这个很重要喔！您不要使用 root 尝试登入 telnet 啊！ ^_^
	</div>

	<hr><a name="telnet_safe"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">iptables, TCP_Wrappers, 纯建议</span><br>
	<div class="block2">
		telnet 这个服务器方便归方便，但<span class="text_import2">总是一个不太好的联机解决方案</span>，
		因为毕竟他是一个以『明码』传输的协议，所以很不适合在 Internet 上面使用啦！
		你总不希望你的账号密码在 Internet 上面被窃取吧？不过，如果 telnet 是启动在内部环境当中那就还好啦！
		尤其有些朋友因为旧软件的关系，还是需要使用到 telnet 来联机。那么我们就提一些基本的注意事项好了！<br><br>

		<li><span class="text_import1">以比较限制的配置文件来规范联机的 IP ：</span></li>
		<div class="block2">
			事实上， xinetd 就已经提供些许的保护措施了，
			您可以针对您主机的多重接口(有对内以及对外喔！)来提供不同保护等级的措施！
			底下列出一个范例，不过，更多的信息请再回到『<a href="http://vbird.dic.ksu.edu.tw/linux_server/linux_basic/linux_basic.php">鸟哥的
			Linux 私房菜 -- 基础学习篇</a>』当中去查阅一下
			『<a href="http://vbird.dic.ksu.edu.tw/linux_server/linux_basic/0560daemons.php">认识服务</a>
			』那一章里面的详细设定说明，或者直接 man xinetd.conf 吧！<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">vi /etc/xinetd.d/telnet</span>
<span class="term_say"># This file had been modified by VBird 2002/11/04
# 首先为内部网络的参数设定</span>
service telnet
{
        disable         = no
<span class="term_write">        bind            = 192.168.1.2
        only_from       = 192.168.1.0/24</span>
        <span class="term_say"># 上面这两行说明仅提供内部网域！</span>
        instance        = UNLIMITED
        nice            = 0
        flags           = REUSE
        socket_type     = stream
        wait            = no
        user            = root
        server          = /usr/sbin/telnetd
        server_args     = -a none
        log_on_failure  += USERID
}

<span class="term_say"># 再来则是针对外部网域的设定</span>
service telnet
{
        disable         = no
<span class="term_write">        bind            = 140.116.142.196
        only_from       = 140.116.0.0/16
        no_access       = 140.116.32.{10,26}</span>
        <span class="term_say"># 上面这三行设定外部较为严格的限制</span>
        instance        = 10   <span class="term_say">&lt;==最多允许同时 10 个联机</span>
        umask           = 022
        nice            = 10
        flags           = REUSE
        socket_type     = stream
        wait            = no
        user            = root
        server          = /usr/sbin/telnetd
        server_args     = -a none
        log_on_failure  += USERID
}
</pre></td></tr></tbody></table>
		</div>
		<li><span class="text_import1">root 不能直接以 telnet 连接上主机：</span></li>
		<div class="block2">
			<span class="text_import2">既然 telnet 不是很安全，自然预设的情况之下就是无法允许
			root 以 telnet 登入 Linux 主机的</span>！但事实上， telnet 
			只是利用一些较为安全的机制 (其实就是 PAM 模块啦) 来防止
			root 登入而已～所以啰，假如您确定您的环境够安全(例如您的主机并没有连上
			Internet )，并且想要开放 root 以 telnet 登入 Linux 主机的话，请直接将 /etc/securetty
			更改檔名即可！<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">mv /etc/securetty /etc/securetty.bak</span>
</pre></td></tr></tbody></table>

			这样一来，root 就可以登入啦！不过，相当的不建议这样做喔！毕竟不是很安全啦！此外，您也可以藉由修改
			pam 模块来达成同样的功能！修改 /etc/pam.d/login 这个档案的第二行设定即可：

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">vi /etc/pam.d/login</span>
#%PAM-1.0
<span class="term_write">#auth       required     pam_securetty.so</span>  <span class="term_say">&lt;== 就是这样一行，将他批注即可！</span>
auth       required     pam_stack.so service=system-auth
auth       required     pam_nologin.so
account    required     pam_stack.so service=system-auth
password   required     pam_stack.so service=system-auth
# pam_selinux.so close should be the first session rule
session    required     pam_selinux.so close
session    required     pam_stack.so service=system-auth
session    required     pam_loginuid.so
session    optional     pam_console.so
# pam_selinux.so open should be the last session rule
session    required     pam_selinux.so multiple open
</pre></td></tr></tbody></table>

		如此一来， root 将可以直接进入 Linux 主机了！不过，既然我们可以透过 su 或 sudo 来切换身份，
		那么干嘛还需要开放 root 用 telnet 登入主机呢？真是没必要～所以，
		<span class="text_import1">还是不建议如此做的</span>！<br><br>
		</div>

		<li><span class="text_import1">加上防火墙 iptables：</span></li>
		<div class="block2">
			针对 telnet 加设防火墙 iptables 是一个好主意！如果您已经参考了前面章节提到的『
			<a href="http://vbird.dic.ksu.edu.tw/linux_server/0310telnetssh/0250simple_firewall-centos4.php">简易防火墙架设</a> 』一文，并且使用里面的
			scripts 的话，那么不用担心 telnet 啦！基本上，他原本就仅对内部开放 telnet
			，外部是无法连上您的 telnet 的！但是，若是您自己设定了自己的防火墙机制之后，那么想要针对
			192.168.0.0/24 这个网域，及 61.xxx.xxx.xxx 这个 IP 进行 telnet 的开放呢？可以增加这几行在您的
			iptables 规则之内(请注意：防火墙的规则顺序是很重要的！所以再回头看看 
			<a href="http://vbird.dic.ksu.edu.tw/linux_server/0310telnetssh/0250simple_firewall-centos4.php">简易防火墙架设</a> 一文是有必要的！)<br>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_write">iptables -A INPUT -p tcp -i $INIF  -s 192.168.0.0/24 --dport 23 -j ACCEPT
iptables -A INPUT -p tcp -i $EXTIF -s 61.xxx.xxx.xxx --dport 23 -j ACCEPT
iptables -A INPUT -p tcp -i $EXTIF                   --dport 23 -j DROP</span>
</pre></td></tr></tbody></table>

			上面的规则中，$EXTIF 指的是对外的联机接口，$INIF 则是对内的接口。
			第一、二行是针对来源的 IP 来开放 port 23 亦即是 telnet 的协议啦！
			而最后一行则是将其他的所有来源的，想要连上
			telnet 的联机封包都丢掉的意思！怎么样！很简单吧！<br><br>
		</div>

		<li><span class="text_import1">加上防火墙 /etc/hosts.allow(deny) 机制：</span></li>
		<div class="block2">
			防火墙的机制是越多越好！永远也不嫌多的啦！这里也可以使用 TCP_Wrappers
			的机制呢！刚刚是开放了 192.168.0.0/24 这个网段，但是如果您只想要其中的
			192.168.0.1 ~ 192.168.0.5 进入呢？而其他的 IP 只要一经联机，就会被记录该
			IP ，以提供 root 查询呢？可以这样做：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">vi /etc/hosts.allow</span>
in.telnetd: 192.168.0.1, 192.168.0.2, 192.168.0.3, 192.168.0.4
in.telnetd: 192.168.0.5

[root@linux ~]# <span class="term_command">vi /etc/hosts.deny</span>
in.telnetd : ALL : spawn (/bin/echo Security notice from `/bin/hostname`; \
/bin/echo; /usr/sbin/safe_finger @%h ) | \
/bin/mail -s "%d -%h security" root@localhost &amp; \
: twist ( /bin/echo -e "\n\nWARNING connectin not allowed. \n\n\n" )
</pre></td></tr></tbody></table>

		</div>

		<li><span class="text_import1">建议事项：</span></li>
		<div class="block2">
			事实上， telnet 最大的不安全在于数据是以明码传输，所以在 Internet 
			这个大家都能够连上的地方来传输数据时，实在很不安全！所以：
			<ol><span class="text_import2">
			<li>非必要时，不要启动 telnet ，如果真的需要启动 telnet
			，那么也请在启动并且使用完毕之后，立即将他关掉！</li>
			<li>如果确定真的要启动 telnet 时，请确定好限制的联机范围，使用
			iptables 来设定联机的限制区域；</li>
			<li>加上 TCP_Wrappers 的辅助，加强防火墙的功能！</li>
			<li>随时注意登录档案里面关于 login 的事项！并且不要让
			root 能以 telnet 登入 Linux 主机！</li>
			</span></ol>
		</div>
	</div>
</div>

<hr><a name="ssh"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">SSH 服务器</span><br>
<div class="block1">
	既然 telnet 的数据在 Internet 上不是很安全，那么我又需要以远程联机服务来操控我的 Linux
	主机，那么应该怎么办呀？最好的方法当然就是以较为安全的联机机制来解决联机的问题啰！
	那么该如何解决这样的问题呢？这也不难啦，使用
	SSH 即可。那么 SSH 是什么呢？他有什么特异功能？<br><br>

	简单的来说，<span class="text_import2">SSH
	是 <b>S</b>ecure <b>SH</b>ell protocol 的简写</span>，他可以经由将联机的封包加密的技术，
	来进行数据的传递，因此，数据当然就比较安全啰！这个
	SSH 可以用来取代 Internet 上面较不安全的 finger, R Shell (rcp, rlogin,
	rsh 等指令), talk 及 telnet 等联机模式。底下我们将先简介一下 SSH 的联机模式，来说明为什么
	SSH 会比较安全呢！<br><br>

	特别注意：这个 SSH 协议，在预设的状态中，本身就提供两个服务器功能：
	<ol><span class="text_import2">
	<li>一个就是类似 telnet 的远程联机使用 shell 的服务器，亦即是俗称的 ssh ；</li>
	<li>另一个就是类似 FTP 服务的 sftp-server ！提供更安全的 FTP 服务。</li>
	</span></ol><br>

	<hr><a name="ssh_connect"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">联机加密技术简介：</span><br>
	<div class="block2">
		什么是『数据加密』呢？简单的说，就是将人们看的懂得电子数据，经过一些运算，
		让这些数据变成没有意义的(至少对人类来说)咚咚，然后这个咚咚可以在网络上面传输，
		而当用户想要查阅这个数据时，再透过反向运算，将这些咚咚反推出原始的电子数据。
		由于这些数据已经被重新处理过，所以，即使数据在 Internet 上被 cracker 
		监听而窃取，他们也不容易就推算得出来原始资料内容的。<br><br>

		网络封包的加密技术通常是藉由所谓的『<span class="text_import2">一对公钥与私钥</span>』
		亦即『<span class="text_import2">Public and Private 组合成的 key pair</span>』
		来进行加密与解密的动作！如下图所示。主机端所要传给 client 端的数据，会先经由公钥加密后才到网络上传输。
		而到达 client 端之后，再经由私钥将加密的数据解开来～由于在 Internet 上面跑的数据是加密过后的，
		所以你的数据内容当然就比较安全啦！<br><br>

		<center><img src="0310telnetssh-centos4.php_files/0310telnetssh-1.jpg" title="公钥与私钥在进行数据传输时的角色示意图" alt="公钥与私钥在进行数据传输时的角色示意图"><br>
			图一、公钥与私钥在进行数据传输时的角色示意图</center><br>

		<div style="padding: 10pt 0pt 10pt 0pt ;" align="right"><table width="90%"><tbody><tr><td><b>Tips:</b><br><span style="color : #009000"><font size="-1">			数据加密的技术真的相当的多，也各有其优缺点，有的指令周期快，
			但是不够安全；有的够安全，但是加密/解密的速度较慢～
			目前在 SSH 使用上，主要是利用 RSA/DSA/Diffie-Hellman 等机制喔！
		</font></span></td><td><img src="0310telnetssh-centos4.php_files/vbird_face.gif" alt="鸟哥的图示" title="鸟哥的图示"></td></tr></tbody></table></div>
		那么这些公钥与私钥是如何产生的呢？底下我们来谈一谈目前
		SSH 的两种版本的联机模式啰！<br><br>

		<li><span class="text_import1">SSH protocol version 1</span>：</li>
		<div class="block2">
			每一部 SSH 服务器主机都可以使用 RSA 加密方式来产生一个 1024-bit 的 RSA Key ，
			这个 RSA 的加密方式，主要就是用来产生公钥与私钥的演算方法！这个 
			version 1 的整个联机的加密步骤可以简单的这么看：

			<ol><span class="text_import2">
			<li>当每次 SSH daemon (sshd) 启动时，就会产生一支 768-bit 
			的公钥(或称为 server key)存放在 Server 中；</li>
			<li>若有 client 端的 ssh 联机需求传送来时，那么 Server 就会将这一支公钥传给 
			client ，此时 client 也会比对一下这支公钥的正确性。比对的方法为利用 
			/etc/ssh/ssh_known_hosts 或 ~/.ssh/known_hosts 档案内容。</li>
			<li>在 Client 接受这个 768-bit 的 server key 之后，Client 自己也会随机产生一支
			256-bit 的私钥(host key)，并且以加密的方式将 server key 与 host key 整合成一对完整的
			Key pair，并且将这对 Key pair 也传送给 server ；</li>
			<li>之后，Server 与 Client 在这次的联机当中，就以这一对 1024-bit 的 Key pair 来进行数据的传递！</li>
			</span></ol>

			也就是说，Public Key 是放在 Server 上的，而 Client 端的软件必须要能接受 Public Key 以及计算出
			Private Key 以组合成为一把独一无二的 key pair ，因为 Client 端每次的 256-bit 的 Key 
			是随机取的，所以您这次的联机与下次的联机的 Key 可能就会不一样啦！此外在 Client 端的用户家目录下的
			~/.ssh/known_hosts 会记录曾经联机过的主机的 public key ，用以确认每次来自该主机的联机是正确的。
			这个 ~/.ssh/known_hosts 档案的意义后续还会介绍的。<br>

		</div>
		<li><span class="text_import1">SSH protocol version 2</span>：</li>
		<div class="block2">
		在 SSH version1 的联机过程当中，当 server 端接受 client 端的 private key 后，就不再针对该次联机的
		key pair 进行检验。此时若有恶意的 cracker 针对该联机给予恶意的程序代码时，由于主机端不会检验联机的正确性，
		因此可能会接受该程序代码，进一步造成系统被黑掉的问题。<br><br>

		为了改正这个缺失，SSH version 2 多加了一个确认联机正确性的 Diffie-Hellman 机制，
		在每次数据的传输当中 server 端都会以该机制检查数据的来源是否正确，
		所以可以避免联机过程当中被插入恶意代码的问题！
		也就是说， ssh version 2 是比较安全的喔！<br><br>
		</div>

		由于 SSH version 1 本身存在着的一些问题，因此，近来我们都希望大家使用 ssh version 2 的联机模式，
		会比较安全一点。而联机版本的设定则需要在 ssh 主机端与客户端均设定好才行喔！<br><br>
	</div>

	<hr><a name="ssh_start"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">启动 SSH 服务：</span><br>
	<div class="block2">
		事实上，在我们使用的 Linux 系统当中，默认就已经含有 SSH 的所有需要的套件了！
		这包含了可以产生密码等协议的 <a href="http://www.openssl.org/" target="_blank">OpenSSL</a>
		套件与 <a href="http://www.openssh.com/" target="_blank">OpenSSH</a> 
		套件，所以呢，要启动 SSH 真的是太简单了！就直接给他启动就是了！此外，在目前的 
		Linux Distributions 当中，<span class="text_import2">都是预设启动 SSH 的</span>，
		所以一点都不麻烦，因为不用去设定，他就已经启动了！哇！真是爽快～无论如何，
		我们还是得说一说这个启动的方式吧！直接启动就是以
		SSH daemon ，简称为 sshd 来启动的，所以，手动可以这样启动：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">/etc/init.d/sshd restart</span>
[root@linux ~]# <span class="term_command">netstat -tlp</span>
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address  Foreign Address  State   PID/Program name
tcp        0      0 *:ssh          *:*              LISTEN  24266/sshd
</pre></td></tr></tbody></table>

		启动后，利用 <a href="http://vbird.dic.ksu.edu.tw/linux_server/0310telnetssh/0140networkcommand-centos4.php#netstat">netstat</a> 查阅一下
		sshd 这个程序是否正确的在 LISTEN 即可！当然，这个时候您的 SSH 服务器设定值均是使用系统默认值，
		能不能够仅用较安全的 version 2 ，则需要进一步的设定呢。
		接下来，如果您想要在开机就启动 SSH 的话(预设也是启动的！)，可以利用
		<a href="http://vbird.dic.ksu.edu.tw/linux_server/linux_basic/0560daemons.php#chkconfig">chkconfig</a>
		来设定开机启动即可。<br><br>

		虽然新的 Linux distributions 都预设会有 SSH 存在的，但是较旧的版本就仅有 telnet 而已。
		例如 Red Hat 6.x 之前的版本。那么如果您想要在旧的 distributions 当中安装 SSH 该如何是好？
		嘿嘿！可以参考一下鸟哥之前写过的一篇咚咚，有详细的说明 tarball 的安装流程哩！

		<ul><a href="http://linux.vbird.org/linux_server/0310telnetssh/0310telnetssh-2.php">使用 Tarbal 安装 SSH 以及升级 SSH 可能会遇到的问题说明<br>
		(http://linux.vbird.org/linux_server/0310telnetssh/0310telnetssh-2.php)</a></ul>

		需要注意的是， SSH 不但提供了 shell 给我们使用，亦即是 ssh protocol
		的主要目的，同时亦提供了一个较为安全的 FTP server ，亦即是 ssh-ftp server
		给我们当成是 FTP 来使用！所以，<span class="text_import2">这个 sshd 可以同时提供
		shell 与 ftp 喔！而且都是架构在 port 22 上面的呢</span>！所以，底下我们就来提一提，那么怎么样由
		Client 端连接上 Server 端呢？同时，如何以 FTP 的服务来连接上 Server 并且使用
		FTP 的功能呢？<br><br>
	</div>

	<hr><a name="ssh_client"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">ssh 客户端联机：</span><br>
	<div class="block2">
		由于 Linux 与 Windows 这两个客户端 Client 联机软件/指令并不一样，所以我们分别来介绍可以使用的指令：<br><br>

		<li><a name="ssh_client_ssh"></a><span class="text_import1">Linux Client: ssh</span></li>
		<div class="block2">
			SSH 在 client 端使用的是 ssh 这个指令，这个指令可以指定联机的版本 (version1, version2)，
			还可以指定非正规的 ssh port (正规 ssh port 为 22)。不过，一般的用法可以使用底下的方式：<br>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">1. 直接登入到对方主机的方法：</span>
[root@linux ~]# <span class="term_command">ssh account@hostname</span>
<span class="term_say"># 连接到我们自己本机上面的 ssh 服务！更多讯息，请 man ssh 喔！</span>
[root@linux ~]# <span class="term_command">ssh dmtsai@localhost</span>
The authenticity of host 'localhost (127.0.0.1)' can't be established.
RSA key fingerprint is f8:ae:67:0e:f0:e0:3e:bb:d9:88:1e:c9:2e:62:22:72.
Are you sure you want to continue connecting (yes/no)? <span class="term_command">yes</span>
<span class="term_say"># 上面很重要喔！务必填入完整的 "yes" 而不是 Y 或 y 而已。</span>
Warning: Permanently added 'localhost' (RSA) to the list of known hosts.
dmtsai@localhost's password: <span class="term_say">&lt;== 在这里填入密码，同样的，屏幕不会有讯息的！</span>
Last login: Fri Jul  1 14:23:27 2005 from localhost.localdomain
[dmtsai@linux ~]$      <span class="term_say">&lt;== 瞧！已经登入啰～</span>
[dmtsai@linux ~]$ <span class="term_command">exit</span> <span class="term_say">&lt;== 输入 exit 就能够离开对方主机啰！</span>

<span class="term_hd">2. 不登入对方主机，直接在对方主机执行指令的方法：</span>
[root@linux ~]# <span class="term_command">ssh dmtsai@localhost date</span>
dmtsai@localhost's password:
Tue Nov 22 11:57:27 CST 2005
[root@linux ~]# 
<span class="term_say"># 看！身份还是 root 喔！只是以 dmtsai 的身份在远程主机上执行了一个指令而已！</span>
</pre></td></tr></tbody></table>

			这里请特别留意的是，如果直接以『 <span class="text_import2">ssh hostname</span>
			 』这个指令来连接进入 hostname 这个主机时，则<span class="text_import2">进入 hostname 
			这个主机的『账号名称』将会是目前您所在的这个环境当中的使用者账号！</span>
			以上面为例，因为我是以 root 的身份在执行，所以如果我执行了『 ssh host.domain.name 』时，
			那么对方 host.domain.name 这部主机，就会以 root 的身份来让我进行密码确认的登入动作！<br><br>

			因此，为了避免这样的麻烦，通常鸟哥都是以简单的 e-mail 的写法来登入远方的主机，
			例如『<span class="text_import2">ssh user@hostname </span>』即表示，
			鸟哥是以 user 这个账号去登入 hostname 这部主机的意思。当然，也可以使用 
			-l username 这样的形式来书写！登入对方主机之后，其他的所有执行行为都跟在
			Linux 主机内没有两样～所以，真的是很简单吧！ ^_^ 这样就可以达到远程控管主机的目的了！<br><br>

			此外，<span class="text_import2">在预设的情况下， SSH 是『允许您以 root 的身份登入』喔</span>
			！呵呵！更是爽快啦！要特别留意的是，当您要连接到对方的主机时，如果是首次连接，那么
			Server 会问您，您的联机的 Key 尚未被建立，要不要接受 Server 传来的 Key
			，并建立起联机呢？呵呵！这个时候请『<span class="text_import2">务必要输入 yes
			而不是 y 或 Y</span>』，这样程序才会接受喔！<br><br>

			<li><span class="text_import1">关于 Server Keys 的纪录数据： ~/.ssh/known_hosts</span></li>
			<div class="block2">
			如果您刚刚有研究过 SSH 的联机流程的话，会发现到当 client 端接受来自 server 端的 
			public key 之后，会主动的比对这支 Key 的正确性。而比对的档案是 ~/.ssh/known_hosts 。
			若是接受到的这支 public key 并没有被纪录在这档案内，那么上面表格的讯息，
			就是要您回答 yes/no 的那个讯息才会出现～而您回答 yes 之后，该 public key 
			信息就会被记录起来，以留待下次登入同一部主机时的检查之用啊！
			<span class="text_import2">如果 Server Key 与 ~/.ssh/known_hosts 比对成功，
			那么您就会直接进入等待密码输入的画面，</span>
			那就不必每次都得要输入 (yes/no) 啰～<br><br>

			不过，您或许也会发现一件事情啊，我们知道 SSH server 虽然使用 version 2 已经不会重复制造 
			server key (public key) 了，但是如果该主机重新安装过新的 linux distributions 时，
			那把 server key 就会被改变啊！而 client 又会去比对这个 public key 与 ~/.ssh/known_hosts ，
			此时 Client 就会发现两者不同了，于是乎产生如下的错误讯息了：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">ssh dmtsai@localhost</span>
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!
Someone could be eavesdropping on you right now (man-in-the-middle attack)!
It is also possible that the RSA host key has just been changed.
The fingerprint for the RSA key sent by the remote host is
f8:ae:67:0e:f0:a0:3e:aa:d9:77:19:c9:2e:62:22:72.
Please contact your system administrator.
Add correct host key in /root/.ssh/known_hosts to get rid of this message.
Offending key in /root/.ssh/known_hosts:1
RSA host key for localhost has changed and you have requested strict checking.
Host key verification failed.
</pre></td></tr></tbody></table>

			这个错误讯息在告诉您，上次所登录的远程 SSH 主机的 Keys 
			已经被改过了(最可能的原因就是 Server 端重新启动/重新安装/更新套件等等啦！)，
			所以无法继续登入～呵呵！这个时候怎么办？很简单啊！<span class="text_import2">进入您的家目录的
			~/.ssh 里面，编辑一下 known_hosts ，将欲连接的主机名的 Key 给他消除</span>，就可以重新联机啦！<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">vi ~/.ssh/known_hosts</span>
localhost ssh-rsa AAAAB3NzaC1yc2Euowireffodjoiwjefmoeiwhoqhwupoi
t[egmlomowimvoiweo6VpTHTw2/tENp4U7Wn8J6nxYWP36YziFgxtWu4MPSKaRmr
E4eUpR1G/zV3TkChRZY5hGUybAreupTVdxCZvJlYvNiejfijoejwiojfijeoiwx5
eRkzvSj7a19vELZ5f8XhzH62E=
</pre></td></tr></tbody></table>

			上面表格的内容其实是同一行的～那一行代表『 localhost 这部主机，利用的是 ssh-rsa 联机机制，
			而后续的数据则是那把 Server Key 的内容。』如果您确定这次的比对无法成功是正常的，
			那么您可以将这一行给他删除，这样下次要再登入时，就又会再次的出现问 (yes/no) 的画面啊！<br><br>
			</div>
		</div>

		<li><a name="ssh_client_sftp"></a><span class="text_import1">Linux Client: sftp</span></li>
		<div class="block2">
			那么如何使用 SSH FTP 的功能呢？也是很容易啦！就是使用
			sftp 这支程序即可！而登入的方式与 ssh 相同，都是使用 sftp -l username hostname
			或者直接以 sftp user@hosname 来书写！执行之后会有底下的模样：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">sftp dmtsai@localhost</span>
Connecting to localhost...
dmtsai@localhost's password: <span class="term_say">&lt;== 这里请输入密码啊！</span>
sftp&gt; <span class="term_say">&lt;== 这里就是在等待您输入 ftp 相关指令的地方了！</span>
</pre></td></tr></tbody></table>

			进入到 sftp 之后，那就跟在一般 FTP 模式下的操作方法没有两样了！底下我们就来谈一谈，
			sftp 这个接口下的使用指令吧！<br><br>

			<table bgcolor="lightyellow" border="1" cellpadding="5" cellspacing="0" width="90%">
			<tbody><tr bgcolor="#182448"><td colspan="2"><font color="#FFFFFF">针对远方主机(Server)之行为</font></td></tr>
			<tr><td width="40%">变换目录到 /etc/test 或其他目录</td>
				<td><font face="细明体">cd /etc/test<br>cd PATH</font></td></tr>
			<tr><td>列出目前所在目录下的文件名</td>
				<td><font face="细明体">ls<br>dir</font></td></tr>
			<tr><td>建立目录</td>
				<td><font face="细明体">mkdir directory</font></td></tr>
			<tr><td>删除目录</td>
				<td><font face="细明体">rmdir directory</font></td></tr>
			<tr><td>显示目前所在的目录</td>
				<td><font face="细明体">pwd</font></td></tr>
			<tr><td>更改档案或目录群组</td>
				<td><font face="细明体">chgrp groupname PATH</font></td></tr>
			<tr><td>更改档案或目录拥有者</td>
				<td><font face="细明体">chown username PATH</font></td></tr>
			<tr><td>更改档案或目录的权限</td>
				<td><font face="细明体">chmod 644 PATH<br>其中，644 与权限有关！回去看基础篇！</font></td></tr>
			<tr><td>建立连结档</td>
				<td><font face="细明体">ln oldname newname</font></td></tr>
			<tr><td>删除档案或目录</td>
				<td><font face="细明体">rm PATH</font></td></tr>
			<tr><td>更改档案或目录名称</td>
				<td><font face="细明体">rename oldname newname</font></td></tr>
			<tr><td>离开远程主机</td>
				<td><font face="细明体">exit (or) bye (or) quit</font></td></tr>
			<tr bgcolor="#182448"><td colspan="2"><font color="#FFFFFF">针对本机(Client)之行为(都加上 l, L 的小写 )</font></td></tr>
			<tr><td>变换目录到本机的 PATH 当中</td>
				<td><font face="细明体">lcd PATH</font></td></tr>
			<tr><td>列出目前本机所在目录下的文件名</td>
				<td><font face="细明体">lls</font></td></tr>
			<tr><td>在本机建立目录</td>
				<td><font face="细明体">lmkdir</font></td></tr>
			<tr><td>显示目前所在的本机目录</td>
				<td><font face="细明体">lpwd</font></td></tr>
			<tr bgcolor="#182448"><td colspan="2"><font color="#FFFFFF">针对资料上传/下载的行为</font></td></tr>
			<tr><td>将档案由本机上传到远程主机</td>
				<td><font face="细明体">put [本机目录或档案] [远程]<br>
				put [本机目录或档案]<br>
				如果是这种格式，则档案会放置到目前远程主机的目录下！</font></td></tr>
			<tr><td>将档案由远程主机下载回来</td>
				<td><font face="细明体">get [远程主机目录或档案] [本机]<br>
				get [远程主机目录或档案]<br>
				若是这种格式，则档案会放置在目前本机所在的目录当中！可以使用通配符，例如：<br>
				get *<br>get *.rpm<br>亦是可以的格式！</font></td></tr>
			</tbody></table><br>

			就整体而言， sftp 在 Linux 底下，如果不考虑图形接口，那么他已经可以取代
			FTP 了呢！因为所有的功能都已经涵盖啦！因此，在不考虑到图形接口的 FTP 软件时，可以直接关掉
			FTP 的服务，而改以 sftp-server 来提供 FTP 的服务吧！ ^_^<br><br>
		</div>

		<li><a name="ssh_client_scp"></a><span class="text_import1">Linux Client: scp</span></li>
		<div class="block2">
			如果我要在两个主机之间复制档案的话，除了 sftp 之外，还有没有更简单的方式？
			有的，那就是利用 scp 这个指令啦！这个指令的用法与 cp 很相像，不过，
			在远程主机的目录写法，比较需要注意就是了。举例如下：<br>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">1. 将数据由本机上传到远程主机上去</span>
[root@linux ~]# <span class="term_command">scp /etc/crontab dmtsai@localhost:/home/dmtsai/</span>
dmtsai@localhost's password: <span class="term_note">&lt;== 这里请输入密码啊！</span>
crontab                  100%  620     0.6KB/s   00:00
<span class="term_say"># 这个例子在说明，我将本机目录的 /etc/crontab 这个档案传送给 dmtsai 
# 这个使用者，而这个使用者是在 "localhost" 那部主机上面喔！
# 仔细看一下，会有一个传输数据的讯息跑出来喔！</span>

<span class="term_hd">2. 将数据由远程主机下载到本机上！</span>
[root@linux ~]# <span class="term_command">scp dmtsai@localhost:~/.bashrc .</span>
<span class="term_say"># 这个例子则是在说明，我要将 localhost 那部机器上的 dmtsai 这个人，
# 他家目录下的 .bashrc 复制到我的机器上！</span>
</pre></td></tr></tbody></table>

			也就是说，远程主机上的档案或目录要复制时，是以『 <span class="text_import2">hostname:PATH</span> 』
			方式来书写的～不要写错了呦！而如果想要复制目录的话，那么可以加上 -r 的参数！<br><br>
		</div>

		<li><a name="ssh_client_putty"></a><span class="text_import1">Windows Client: putty</span></li>
		<div class="block2">
			在 Linux 底下想要连接 SSH 服务器，可以直接利用 <a href="#ssh_client_ssh">ssh</a> 这个指令
			，那么如果在 Windows 操作系统底下，又该如何连接到 SSH 服务器呢？可以直接使用
			putty 或 pietty 这种类型的联机软件呢，他也是免费的自由软件喔！取得的方式可以参考底下的网站：

			<ul><li>putty 官方网站：<a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/" target="_blank">http://www.chiark.greenend.org.uk/~sgtatham/putty/</a>
			</li><li>pietty 官方网站：<a href="http://www.csie.ntu.edu.tw/~piaip/pietty/" target="_blank">http://www.csie.ntu.edu.tw/~piaip/pietty/</a></li></ul>

			在 putty 的官方网站上有很多的 client 软件可以使用的，包括 putty/pscp/psftp 等等。
			他们分别对应了 ssh/scp/sftp 这三个指令就是了。而上述的三个 putty/pscp/psftp 主要是在 Windows
			上面连接到 Unix like 机器的 SSH 服务器的 Client 软件呢。请自行下载该软件喔。<br><br>

			事实上，鸟哥比较喜欢林弘德先生的 pietty，因为这个软件不但是完整支持 putty 
			，而且提供的文字编码较丰富， 实在很好用。在你下载了 pietty 后直接双击他，
			会有类似底下的图示出现。<br><br>

			<center><img src="0310telnetssh-centos4.php_files/pietty_01.png" title="pietty 的执行图示之一" alt="pietty 的执行图示之一"><br>
				图二、pietty 的执行图示之一</center><br>

			在上图 1 的地方请填写相关的主机名或者是 IP ，2 当然务必选择 SSH 那一项，
			至于 3 的地方，鸟哥比较喜欢选单出现的样式，所以我是选择选单啦！若没有问题，按下『联机』后，
			就会出现如下样式：<br><br>

			<center><img src="0310telnetssh-centos4.php_files/pietty_02.png" title="pietty 的执行图示之一" alt="pietty 的执行图示之一"><br>
				图三、pietty 的执行图示之一</center><br>

			很像在主机前面工作吧！而且上头还有选单可以随时调整类似字形、字体、字符编码等等。
			尤其是字符编码。有时候你会发现开启档案时，竟然画面当中会有乱码而不是正常的中文显示，
			那就是编码的问题。要解决这个问题时，你必须要牢记：<br>
			<ul><span class="text_import2">
			<li>文本文件本身在存档时所挑选的语系；
			</li><li>Linux 主机本身所使用的语系 (可用 LANG 变量调整)；
			</li><li>pietty 所使用的语系。
			</li></span></ul>
			这三个咚咚的语系要完全相同时才会正确的显示出中文！千要要牢记啊！
			那如何调整 pietty 的中文编码呢？<br><br>

			<center><img src="0310telnetssh-centos4.php_files/pietty_03.png" title="pietty 的执行图示之一" alt="pietty 的执行图示之一"><br>
				图四、pietty 的执行图示之一</center><br>

			在『选项』的『字符编码』里面可以挑选 big5 或者是 utf8 的中文编码，
			让他符合你的 Linux 与档案所储存的数据格式，那就 OK 的啦！ ^_^！
			如果想要作更细部的设定时，可以选择图四上头最底下的那个『详细设定』项目，
			就会出现如下图示。其中更为重要的是『键盘右侧的数字键想要生效』时，
			可以按照下图的指示来启动数字键的功能：<br><br>

			<center><img src="0310telnetssh-centos4.php_files/pietty_04.png" title="pietty 的执行图示之一" alt="pietty 的执行图示之一"><br>
				图五、pietty 的执行图示之一</center><br>

			如上图所示，在你输入『Apply』之后，就可以自动的生效了！现在你可以按键盘右边的按钮了，
			真方便。再来你可以调整 pietty 滚动条的记忆行数，这样当数据太多时，你依旧可以调整滚动条来查阅之前的数据。
			设定的方法如下：<br><br>

			<center><img src="0310telnetssh-centos4.php_files/pietty_05.png" title="pietty 的执行图示之一" alt="pietty 的执行图示之一"><br>
				图六、pietty 的执行图示之一</center><br>

			调整完了屏幕的大小之后，再来这是最重要的：『您要以哪一个版本的 SSH
			算法登入？！』前面说过，我们预设是以 version2 来登入的，所以这里我们可以调整为
			2 那个项目！这样每次登入都会以 version 2 的模式登入主机了！<br><br>

			<center><img src="0310telnetssh-centos4.php_files/pietty_06.png" title="pietty 的执行图示之一" alt="pietty 的执行图示之一"><br>
				图七、pietty 的执行图示之一</center><br>

			整个 pietty 大致上的流程就是这样！如此一来，您就可以在 Windows 上面以
			SSH 的协议，登入远程的 Linux 主机噜！粉方便吧！ ^_^ ！
			那么如果想要中文支持的话，目前
			pietty 已经支持中文啦！您可以输入中文喔！不过需要修改一下字符集，
			选择图四的『选项』内的『字型』，会出现如下图示：<br><br>

			<center><img src="0310telnetssh-centos4.php_files/pietty_07.png" title="pietty 的执行图示之一" alt="pietty 的执行图示之一"><br>
				图八、pietty 的执行图示之一</center><br>

			<span class="text_import2">将(1)字型设定为细明体
			(2)字集设定为『Big5』，如此一来，您的 pietty 就支持中文的输入啰！</span> ^_^<br>

			那么上面我们作的这些设定值都记录在哪里啊？呵呵！都记录在 Windows 的登录文件当中啊！
			您可以在 Windows 的系统当中，在『开始』--&gt;『执行』后，出现的框框内输入『regedit』，
			之后会出现一个大窗口。请在左边的画面当中选择『<span class="text_import1">
			HKEY_CURRENT_USER --&gt; Software --&gt; SimonTatham --&gt; PuTTY --&gt; Sessions</span>』，
			就可以看到您的设定值啰！ ^_^！ 这样，也就可以储存您的设定值啰～<br><br>
		</div>

		<li><a name="ssh_client_psftp"></a><span class="text_import1">Windows Client: psftp</span></li>
		<div class="block2">
			在 putty 的官方网站上也提供 psftp 这支程序。这一支程序的重点则是在于以 sftp 
			联机上 Server 。联机的方式可以直接点选
			psftp 这个档案，让他直接启动，则会出现下面的图样：<br>

<table class="term"><tbody><tr><td class="term"><pre>psftp: no hostname specified; use "open host.name" to connect
psftp&gt;
</pre></td></tr></tbody></table>

			这个时候可以填入您要连接上去的主机名，例如我的区域内网络 linux.dmtsai.tw 这个主机<br>

<table class="term"><tbody><tr><td class="term"><pre>psftp: no hostname specified; use "open host.name" to connect
psftp&gt; <span class="term_command">open test.linux.org</span>
login as: <span class="term_command">dmtsai</span>
Using username "dmtsai".
dmtsai@linux.dmtsai.tw's password:
Remote working directory is /home/dmtsai
psftp&gt; <span class="term_say">&lt;== 这里就在等待您输入 FTP 的指令了！</span>
</pre></td></tr></tbody></table>

			呵呵！这样就登入主机啦！很简单吧！然后其他的使用方式跟前面提到的 sftp 一样哩！加油的使用吧！<br><br>
		</div>

		<li><a name="ssh_client_filezilla"></a><span class="text_import1">Windows Client: Fliezilla</span></li>
		<div class="block2">
		那么 SSH 所提供的 sftp 功能只能利用纯文本接口的 psftp 来联机吗？有没有图形接口的软件呢？呵呵！当然有！
		那就是非常有用的 Filezilla 啰！Filezilla 是图形接口的一个 FTP 客户端软件，使用上非常的方便，
		至于详细的安装与使用流程请参考 <a href="http://vbird.dic.ksu.edu.tw/linux_server/0310telnetssh/0410vsftpd-centos4.php#client">vsftpd</a> 章节的说明喔！<br>
		</div>
	</div>

	<hr><a name="ssh_sshdconfig"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">详细设定 sshd 服务器</span><br>
	<div class="block2">
		基本上，所有的 ssh 相关设定都放在 <span class="text_import2">/etc/ssh/sshd_config</span> 
		里面！不过，每个 Linux distribution 的预设设定都不太相同，
		所以我们有必要来了解一下整个设定值的意义为何才好！<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">vi /etc/ssh/sshd_config</span>
<span class="term_hd"># 1. 关于 SSH Server 的整体设定，包含使用的 port 啦，以及使用的密码演算方式</span>
<span class="term_say"># 先留意一下，在预设的档案内，只要是被批注的设定值(#)，即为『默认值！』</span>
<span class="term_write">Port 22</span>
<span class="term_say"># SSH 预设使用 22 这个port，也可以使用多个port，即重复使用 port 这个设定项目！
# 例如想要开放 sshd 在 22 与 443 ，则多加一行内容为：
# Port 443 
# 这样就好了！不过，不建议修改 port number 啦！</span>

<span class="term_write">Protocol 1,2</span>
<span class="term_say"># 选择的 SSH 协议版本，可以是 1 也可以是 2 ，
# 如果要同时支持两者，就必须要使用 2,1 这个分隔了(Protocol 1,2)！
# 目前我们会建议您，直接使用 Protocol 2 即可！</span>

<span class="term_write">#ListenAddress 0.0.0.0</span>
<span class="term_say"># 监听的主机适配器！举个例子来说，如果您有两个 IP，
# 分别是 192.168.0.100 及 192.168.2.20 ，那么只想要
# 开放 192.168.0.100 时，就可以写如同下面的样式：</span>
<span class="term_write">ListenAddress 192.168.0.100</span>
<span class="term_say"># 只监听来自 192.168.0.100 这个 IP 的SSH联机。
# 如果不使用设定的话，则默认所有接口均接受 SSH</span>

<span class="term_write">#PidFile /var/run/sshd.pid</span>
<span class="term_say"># 可以放置 SSHD 这个 PID 的档案！左列为默认值</span>

<span class="term_write">#LoginGraceTime 2m</span>
<span class="term_say"># 当使用者连上 SSH server 之后，会出现输入密码的画面，在该画面中，
# 在多久时间内没有成功连上 SSH server ，就断线！若无单位则默认时间为秒！</span>

<span class="term_write">#Compression yes</span>
<span class="term_say"># 是否可以使用压缩指令？当然可以啰</span>

<span class="term_hd"># 2. 说明主机的 Private Key 放置的档案，预设使用下面的档案即可！</span>
<span class="term_write">#HostKey /etc/ssh/ssh_host_key</span>        <span class="term_say"># SSH version 1 使用的私钥</span>
<span class="term_write">#HostKey /etc/ssh/ssh_host_rsa_key</span>    <span class="term_say"># SSH version 2 使用的 RSA 私钥</span>
<span class="term_write">#HostKey /etc/ssh/ssh_host_dsa_key</span>    <span class="term_say"># SSH version 2 使用的 DSA 私钥
# 还记得我们在主机的 SSH 联机流程里面谈到的，这里就是 Host Key ～</span>

<span class="term_hd"># 2.1 关于 version 1 的一些设定！</span>
<span class="term_write">#KeyRegenerationInterval 1h</span>
<span class="term_say"># 由前面联机的说明可以知道， version 1 会使用 server 的 Public Key ，
# 那么如果这个 Public Key 被偷的话，岂不完蛋？所以需要每隔一段时间
# 来重新建立一次！这里的时间为秒！不过我们通常都仅使用 version 2 ，
# 所以这个设定可以被忽略喔！</span>

<span class="term_write">#ServerKeyBits 768</span>
<span class="term_say"># 没错！这个就是 Server key 的长度！用默认值即可。</span>

<span class="term_hd"># 3. 关于登录文件的讯息数据放置与 daemon 的名称！</span>
<span class="term_write">SyslogFacility AUTHPRIV</span>
<span class="term_say"># 当有人使用 SSH 登入系统的时候，SSH会记录信息，这个信息要记录在什么 daemon name
# 底下？预设是以 AUTH 来设定的，即是 /var/log/secure 里面！什么？忘记了！
# 回到 <a href="http://vbird.dic.ksu.edu.tw/linux_server/linux_basic/linux_basic.php">Linux 基础</a> 去翻一下。其他可用的 daemon name 为：DAEMON,USER,AUTH,
# LOCAL0,LOCAL1,LOCAL2,LOCAL3,LOCAL4,LOCAL5,</span>

<span class="term_write">#LogLevel INFO</span>
<span class="term_say"># 登录记录的等级！嘿嘿！任何讯息！同样的，忘记了就回去参考！</span>

<span class="term_hd"># 4. 安全设定项目！极重要！
# 4.1 登入设定部分</span>
<span class="term_write">PermitRootLogin no</span>
<span class="term_say"># 是否允许 root 登入！预设是允许的，但是<span class="term_note_b">建议设定成 no！</span></span>

<span class="term_write">#UserLogin no</span>
<span class="term_say"># 在 SSH 底下本来就不接受 login 这个程序的登入！</span>

<span class="term_write">#StrictModes yes</span>
<span class="term_say"># 当使用者的 host key 改变之后，Server 就不接受联机，可以抵挡部分的木马程序！</span>

<span class="term_write">#RSAAuthentication yes</span>    <span class="term_say"># 是否使用纯的 RSA 认证！？仅针对 version 1 ！</span>
<span class="term_write">#PubkeyAuthentication yes</span> <span class="term_say"># 是否允许 Public Key ？当然允许啦！仅针对 version 2</span>
<a name="sshd_config_auth"></a>
<span class="term_write">#AuthorizedKeysFile      .ssh/authorized_keys</span>
<span class="term_say"># 上面这个在设定若要使用不需要密码登入的账号时，那么那个账号的存放档案所在档名！
# 这个设定值很重要喔！档名给他记一下！</span>

<span class="term_hd"># 4.2 认证部分</span>
<span class="term_write">#RhostsAuthentication no</span>
<span class="term_say"># 本机系统不使用 .rhosts，因为仅使用 .rhosts太不安全了，所以这里一定要设定为 no</span>

<span class="term_write">#IgnoreRhosts yes</span>
<span class="term_say"># 是否取消使用 ~/.ssh/.rhosts 来做为认证！当然是！</span>

<span class="term_write">#RhostsRSAAuthentication no #</span>
<span class="term_say"># 这个选项是专门给 version 1 用的，使用 rhosts 档案在 /etc/hosts.equiv
# 配合 RSA 演算方式来进行认证！不要使用啊！</span>

<span class="term_write">#HostbasedAuthentication no</span>
<span class="term_say"># 这个项目与上面的项目类似，不过是给 version 2 使用的！</span>

<span class="term_write">#IgnoreUserKnownHosts no</span>
<span class="term_say"># 是否忽略家目录内的 ~/.ssh/known_hosts 这个档案所记录的主机内容？
# 当然不要忽略，所以这里就是 no 啦！</span>

<span class="term_write">PasswordAuthentication yes</span>
<span class="term_say"># 密码验证当然是需要的！所以这里写 yes 啰！</span>

<span class="term_write">#PermitEmptyPasswords no</span>
<span class="term_say"># 若上面那一项如果设定为 yes 的话，这一项就最好设定为 no ，
# 这个项目在是否允许以空的密码登入！当然不许！</span>

<span class="term_write">ChallengeResponseAuthentication no</span>
<span class="term_say"># 允许任何的密码认证！所以，任何 login.conf 规定的认证方式，均可适用！
# 但目前我们比较喜欢使用 PAM 模块帮忙管理认证，因此这个选项可以设定为 no 喔！</span>
<span class="term_write">UsePAM yes</span>
<span class="term_say"># 利用 PAM 管理使用者认证有很多好处，可以记录与管理。
# 所以这里我们建议您使用 UsePAM 且 ChallengeResponseAuthentication 设定为 no </span>
　
<span class="term_hd"># 4.3 与 Kerberos 有关的参数设定！因为我们没有 Kerberos 主机，所以底下不用设定！</span>
<span class="term_write">#KerberosAuthentication no
#KerberosOrLocalPasswd yes
#KerberosTicketCleanup yes
#KerberosTgtPassing no</span>
　
<span class="term_hd"># 4.4 底下是有关在 X-Window 底下使用的相关设定！</span>
<span class="term_write">X11Forwarding yes
#X11DisplayOffset 10
#X11UseLocalhost yes</span>

<span class="term_hd"># 4.5 登入后的项目：</span>
<span class="term_write">PrintMotd no</span>
<span class="term_say"># 登入后是否显示出一些信息呢？例如上次登入的时间、地点等等，预设是 yes
# 亦即是打印出 /etc/motd 这个档案的内容。但是，如果为了安全，可以考虑改为 no ！</span>

<span class="term_write">PrintLastLog yes</span>
<span class="term_say"># 显示上次登入的信息！可以啊！预设也是 yes ！</span>

<span class="term_write">KeepAlive yes</span>
<span class="term_say"># 一般而言，如果设定这项目的话，那么 SSH Server 会传送KeepAlive 的讯息给 
# Client端，以确保两者的联机正常！在这个情况下，任何一端死掉后，SSH可以立刻知道！
# 而不会有僵尸程序的发生！</span>

<span class="term_write">UsePrivilegeSeparation yes</span>
<span class="term_say"># 用户的权限设定项目！就设定为 yes 吧！</span>

<span class="term_write">MaxStartups 10</span>
<span class="term_say"># 同时允许几个尚未登入的联机画面？当我们连上 SSH ，但是尚未输入密码时，
# 这个时候就是我们所谓的联机画面啦！在这个联机画面中，为了保护主机，
# 所以需要设定最大值，预设最多十个联机画面，而已经建立联机的不计算在这十个当中</span>

<span class="term_hd"># 4.6 关于用户抵挡的设定项目：</span>
<span class="term_write">DenyUsers *</span>
<span class="term_say"># 设定受抵挡的使用者名称，如果是全部的使用者，那就是全部挡吧！
# 若是部分使用者，可以将该账号填入！例如下列！</span>
<span class="term_write">DenyUsers test

DenyGroups test</span>
<span class="term_say"># 与 DenyUsers 相同！仅抵挡几个群组而已！</span>

<span class="term_hd"># 5. 关于 SFTP 服务的设定项目！</span>
<span class="term_write">Subsystem       sftp    /usr/lib/ssh/sftp-server</span>
</pre></td></tr></tbody></table>

		基本上，CentOS 预设的 sshd 服务已经算是挺安全的了，不过还不够！
		<span class="text_import2">建议你 (1)将 root 的登入权限取消； (2)将 ssh 版本设定为 2 </span>。
		其他的设定值就请您依照自己的喜好来设定了。通常不建议进行随便修改啦！
		另外，如果您修改过上面这个档案(/etc/ssh/sshd_config)，那么就必需要重新启动一次
		sshd 这个 daemon 才行！亦即是：
		<ul><li><span class="text_import2"><font face="细明体">/etc/init.d/sshd restart</font></span></li></ul>
	</div>

	<hr><a name="ssh_nopasswd"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">制作不用密码可立即登入的 ssh 用户：</span><br>
	<div class="block2">
		咦！既然 SSH 可以使用 Key 来比对数据，并且提供用户数据的加密功能，
		那么可不可能利用这个 Key 就提供用户自己进入主机，而不需要输入密码呢？
		呵呵！好主意！我们可以将 Client 产生的 Key 给他拷贝到 Server 当中，所以，
		以后 Client 登入 Server 时，由于两者在 SSH 要联机的讯号传递中，就已经比对过 Key 了，
		因此，可以立即进入数据传输接口中，而不需要再输入密码呢！在实作上的步骤可以是：

		<ol><span class="text_import2">
		<li>首先，先在 Client 上面建立 Public Key 跟 Private Key 这两把钥匙，利用的指令为 
			ssh-keygen 这个命令；
		</li><li>再来，将 Private Key 放在 Client 上面的家目录，亦即 $HOME/.ssh/ ，
			并且修改权限为仅有该 User 可读的状态；
		</li><li>最后，将那把 Public Key 放在任何一个您想要用来登入的主机的 Server 端的某 
			User 的家目录内之 .ssh/ 里面的认证档案即可完成整个程序。</li></span></ol>

		说是好像很困难的样子，其实步骤真的很简单，我们依序来进行作业好了！假设前提：

		<ul>
		<li>Server 部分为 linux.dmtsai.tw 这部 192.168.0.2 的主机，欲使用的 User 为 test 这个账号；
		</li><li>Client 部分为 test2.dmtsai.tw 这部 192.168.0.100  PC 的 test2 这个账号，
			他要用来登入 192.168.0.2 这部主机的 test 这个账号。
		</li></ul>

		<ol>
		<li><span class="text_import1">在 Client 端建立 Public 与 Private Key ：</span></li><br>
			建立的方法真的是简单到不行！直接在 192.168.0.100 这个 Client 上面，以
			test2 这个账号，使用 ssh-keygen 这个指令来进行 Key 的产生即可！不过，需要注意的是，
			version 1 与 version 2 使用的密码演算方式不同，此外， version 2 
			提供两个密码演算的方法，我们这里仅针对 version 2 的 RSA 这个演算方法进行说明！<br>

<table class="term"><tbody><tr><td class="term"><pre>[test2@test2 ~]$ <span class="term_command">ssh-keygen -t rsa</span>  <span class="term_say">&lt;==这个步骤在产生 Key pair</span>
Generating public/private rsa key pair.
Enter file in which to save the key (/home/test2/.ssh/id_rsa): <span class="term_say">&lt;==这里按下Enter</span>
Enter passphrase (empty for no passphrase): <span class="term_say">&lt;==这里按 Enter</span>
Enter same passphrase again:  <span class="term_say">&lt;==再按一次 Enter</span>
<span class="term_write">Your identification has been saved in /home/test2/.ssh/id_rsa. <span class="term_say">&lt;==这是私钥</span>
Your public key has been saved in /home/test2/.ssh/id_rsa.pub. <span class="term_say">&lt;==这是公钥</span></span>
The key fingerprint is:
c4:ae:d9:02:d1:ba:06:5d:07:e6:92:e6:6a:c8:14:ba test2@test2.linux.org
<span class="term_say"># 注意： -t 指的是『使用何种密码演算方式？』由于我们使用 RSA ，
# 所以直接输入 -t rsa 即可建立两支 Keys ！
# 此外，建立的两把 Keys 都放置在家目录下的 .ssh 这个目录中！
# 察看一下这两把 Keys 吧！</span>

[test2@test2 ~]$ <span class="term_command">ll ~/.ssh</span>
total 12
-rw-------    1 test2    test2         887 Nov 12 22:36 id_rsa
-rw-r--r--    1 test2    test2         233 Nov 12 22:36 id_rsa.pub
-rw-r--r--    1 test2    test2         222 Oct 31 11:20 known_hosts
</pre></td></tr></tbody></table>

			请注意上面喔，我的身份是 test2 ，所以当我执行 ssh-keygen 时，
			才会在我的家目录底下的 .ssh/ 这个目录里面产生所需要的两把 Keys 
			，分别是<span class="text_import2">私钥(id_rsa)与公钥(id_rsa.pub)</span>。另外一个要特别注意的就是那个 
			id_rsa 的档案权限啦！他必须要是 <span class="text_import2">-rw-------</span> 
			才好！否则内容被人家知道了，那么您的 Keys 不就有可能外泄了？所以请特别留意他的权限喔！
			<span class="text_import2">那么那个 id_rsa.pub 则是『公钥！』这个档案必须要被放置到 Server 端才行！</span>
			<br><br>

		<li><span class="text_import1">在 Client 端放置私钥：</span></li><br>
			在预设的条件中，我们的私钥必需要放置在家目录底下的 .ssh 里面，那么如果是
			version 2 的 RSA 算法，就需要放置在 $HOME/.ssh/id_rsa 当中！咦！刚好使用
			ssh-keygen 就是已经产生在这个目录下了，所以自然就不需要去调整他了！以我的
			test2.dmtsai.tw 来看，那么我的档案就会放置在 /home/test2/.ssh/id_rsa 这个档案就是私钥啦！<br><br>

		<li><span class="text_import1">在 Server 端放置可以登入的公钥：</span></li><br>
			既然我们要让 test2 可以用 test 这个账号登入 linux.dmtsai.tw 这部主机，那么这部主机自然需要保有
			test2 的 public key 啰！对的！所以我们必需要将 Client 端建立的 id_rsa.pub
			档案给他拷贝到 linux.dmtsai.tw 里头的 test 这个用户的家目录之下！那么如果您还记得上面的
			<a href="#sshd_config_auth">sshd_config</a> 这个档案的设定的话，那么应该就记得『
			<span class="text_import1">AuthorizedKeysFile</span> 』这个设定吧！是的！
			在被登入的主机的某个账号，他的公钥放置的文件名默认就是这个项目所记载的！而他预设的档名就是
			<span class="text_import1">authorized_keys</span>
			这个文件名啦！那么应该怎么做呢？<br>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">1. 先在 Client 端以 sftp 将公钥丢到 test 上面去！</span>
[test2@test2 ~]$ <span class="term_command">cd ~/.ssh</span>
[test2@test2 .ssh]$ <span class="term_command">scp id_rsa.pub test@192.168.0.2:~/</span>
test@192.168.0.2's password:
id_rsa.pub          100%  233     0.2KB/s   00:00

<span class="term_hd">2. 到 Server 上面，将公钥转存到 authorized_keys 档案中！</span>
[test@linux ~]$ <span class="term_command">cd ~/.ssh</span>
[test@linux .ssh]$ <span class="term_command">cat ../id_rsa.pub &gt;&gt; authorized_keys</span>
</pre></td></tr></tbody></table>

			请注意上面的机器！由于 authorized_keys 可以保存相当多的公钥内容，因此，
			可以使用 &gt;&gt; 的方式来将 Client 端的公钥新增到该档案内！呵呵！做完这一步一后，未来 
			test2 就可以直接在 test2.dmtsai.tw 以<br>

<table class="term"><tbody><tr><td class="term"><pre>[test2@test2 ~]$ <span class="term_command">ssh test@linux.dmtsai.tw</span>
</pre></td></tr></tbody></table>

			这样就可以不需要输入密码啰！但是请注意， test 不能以 test2 登入 test2.linux.org 喔！
		</ol>

		很简单的步骤吧！这样一来，就可以不需密码的手续了！无论如何，您要记得的是：<br>
		<ul><span class="text_import2">
		<li>Client 必须制作出 Public &amp; Private 这两把 keys，且 Private 需放到 ~/.ssh/ 内；
		</li><li>Server 必须要有 Public Key ，且放置到用户家目录下的 ~/.ssh/authorized_keys；
		</li></span></ul>

		未来，当您还想要登入其他的主机时，只要将您的 public key (就是 id_rsa.pub 这个档案) 给他 
		copy 到其他主机上面去，并且新增到某账号的 ~/.ssh/authorized_keys 这个档案中！哈哈！成功！<br><br>
	</div>

	<hr><a name="ssh_secure"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">安全设定：</span><br>
	<div class="block2">
		老实说，大家都被『<span class="text_import2">SSH 是个安全的服务』所欺骗了</span>！其实
		sshd 并不怎么安全的！翻开 openssh 的过去历史来看，确实有很多人是利用 ssh 的程序漏洞来取得远程主机 root 
		的权限，进一步黑掉对方的主机！<br><br>

		sshd 之所谓的『安全』其实指的是『
		<span class="text_import2">sshd 的数据是加密过的，所以他的数据在 Internet 上面传递时是比较安全的。</span>
		至于 sshd 这个服务本身就不是那样安全了！所以说：『<span class="text_import2">非必要，不要将 sshd 对
		Internet 开放可登入的权限，尽量局限在几个小范围内的 IP 或主机名即可！</span>
		这很重要的喔！<br><br>



		好了，那么关于安全的设定方面，有没有什么值得注意的呢？当然是有啦！
		我们可以先建议几个项目吧！分别可以由：

		<ul><span class="text_import2">
		<li>/etc/ssh/sshd_config
		</li><li>/etc/hosts.allow, /etc/hosts.deny
		</li><li>iptables</li></span></ul>

		这三方面来着手进行！底下我们就说一说吧！<br><br>

		<li><span class="text_import1">/etc/ssh/sshd_config</span></li>
		<div class="block2">
			一般而言，这个档案的默认项目就已经很完备了！所以，事实上是不太需要更动他的！
			但是，如果您有些使用者方面的顾虑，那么可以这样修正一些问题呢！

			<ul>
			<li><span class="text_import2">禁止 root 的登入</span>：<br>
			任何时候，不许 root 以远程联机的方式登入，都会是一个好主意！所以这里蛮建议大家直接将
			root 的登入权限拿掉吧！所以，可以修改 /etc/ssh/sshd_config 这个档案的内容为：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">vi /etc/ssh/sshd_config</span>
<span class="term_write">PermitRootLogin no</span>     <span class="term_say">&lt;== 将他改成 no 吧！</span>
[root@linux ~]# <span class="term_command">/etc/init.d/sshd restart</span>
</pre></td></tr></tbody></table>

			如此一来，以后 root 就不能以 ssh 登入啰！这样还是比较好的啦！ ^_^<br><br>

			</li><li><span class="text_import2">不许某个群组登入</span>：<br>
			有些特殊情况中，我们想要让使用者只能使用
			sendmail, pop3, ftp 等，但是不希望他可以远程联机进来，那么您可以这样做：<br><br>

			1. 将这些使用者都归纳在某一个特殊群组之下，例如 nossh 这个群组好了；<br>
			2. 在 /etc/ssh/sshd_config 当中加入这一行：『
				<span class="text_import2">DenyGroups&nbsp;&nbsp;nossh</span> 』<br>
			3. 重新启动 sshd ： <font face="细明体">/etc/init.d/sshd restart</font><br><br>

			这样就OK啦！<br><br>

			</li><li><span class="text_import2">不许某个使用者登入</span>：<br>
			跟 DenyGroups 类似，使用 DenyUsers 即可！参考 <a href="#ssh_sshdconfig">sshd_config</a> 的设定喔！
			</li></ul>
		</div>

		<li><span class="text_import1">/etc/hosts.allow 及 /etc/hosts.deny</span></li>
		<div class="block2">
			简单的方法就是：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">vi /etc/hosts.allow</span>
sshd: 192.168.0.1, 192.168.0.2, 192.168.0.3, 192.168.0.4, 192.168.0.5: allow

[root@linux ~]# <span class="term_command">vi /etc/hosts.deny</span>
sshd : ALL : spawn (/bin/echo Security notice from host `/bin/hostname`; \ 
/bin/echo; /usr/sbin/safe_finger @%h ) | \ 
/bin/mail -s "%d -%h security" root@localhost &amp; \ 
: twist ( /bin/echo -e "\n\nWARNING connectin not allowed.". ) 
</pre></td></tr></tbody></table>
		</div>

		<li><span class="text_import1">iptables</span></li>
		<div class="block2">
			多几层保护也很好的！所以也可以使用 iptables 喔！参考：
			<a href="http://vbird.dic.ksu.edu.tw/linux_server/0310telnetssh/0250simple_firewall-centos4.php">简易防火墙架设</a> 一文啰！
		</div>

		最后，『<span class="text_import1">鸟哥呼吁大家，不要开放 SSH 的登入权限给所有 Internet 上面的主机～</span>』
		这很重要喔～因为如果对方可以 ssh 进入您的主机，那么......太危险了～
	</div>
</div>

<hr><a name="xdmcp"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">XDMCP 服务器</span><br>
<div class="block1">
	考虑一个情况，如果您的 Linux 主机上面主要是用来作为图形处理时，而且同时有多人需要用到那个功能，
	那么一部 Linux 是否一次仅能提供一个人处理那个软件呢？嘿嘿！那可不一定喔！因为 Linux 
	有相当优秀的 X Window System 啊！<br><br>

	<hr><a name="xdmcp_theory"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">X Window 的 Server/Client 架构</span><br>
	<div class="block2">
		X Window System 的架构对于常常玩网络的朋友来说(这也包括鸟哥啦！ @_@)实在不太好理解～
		因为 X Window System 在运作的过程中，同样包含了 X Server 与 X Client 这两个东西，
		但是他的作用却与网络主机的 Server/Client 架构大异其趣喔～先来说说 X Server/Client 所负责的东西：

		<ul>
		<li><span class="text_import2">X Server： 他主要负责的是屏幕画面的绘制与显示</span>。
			X Server 可以接收来自 X client 的数据，
			将这些数据绘制呈现为图面在屏幕上。此外，我们移动鼠标、点击数据、由键盘输入数据等等，
			也会透过 X Server 来传达到 X Client 端，而由 X Client 来加以运算；</li><br>
		<li><span class="text_import2">X Client： 他主要负责的是数据的运算。</span>
			X Client 在接受到 X Server 传来的数据后，会经由本身的运算，而得到鼠标应该要如何移动、
			点击的结果应该要出现什么样的数据、键盘输入的结果应该要如何呈现等等，
			然后将这些结果告知 X Server ，让他自行去绘制到屏幕上。</li></ul>

		这样说可以理解吗？也就是说，我们移动鼠标或敲打键盘时， X server 可以接受到这些硬件所输入的数据，
		但他不知道应该要怎么作才好，就把这些数据告诉 X Client ，此时， X Client 就会将这些数据计算，
		最后得到鼠标应该要如何移动与键盘的数据应该要如何呈现，并将这些结果告知 X Server ，
		而 X Server 就会经由 X Client 的告知，而将那些数据数据在屏幕上面呈现出来。<br><br>

		事实上， X Server 与 X Client 通常是在同一部机器上面的，
		例如我们在 Linux 上面执行有名的 KDE 这个桌面一样。
		但是 X Server/Client 却不必然一定要在同一部机器上的，
		也就是说，我们可以透过网络连接两部主机的 X 系统呢！
		这也是最早 X 系统开发时的概念。不过，这个时候的 X server 指的是哪一部呢？<br><br>

		举个例子来说，我们可以在 Windows 系统上面执行一套 X Win32 的软件，
		他可以连接到 Linux 的 X 上头而让用户以图形接口登入 Linux 。
		此时，因为『X Win 32』主要是在屏幕上面显示，他的做用就是屏幕绘制，因此他是 X Server 。
		不信的话，等一下我们测试底下的资料时，您会发现，启动 X win32 这套软件后，
		在 Windows 系统上就会出现 port 6000 这个 X server 的 port 呢～而这个时候 X Win 32 
		软件其实就是连接到 Linux 的某个程序，我们等一下要介绍的 XDMCP 就是其中一种。
		这个 XDMCP 可以将 X Win32 传送过来的数据运算成可以绘制的数据而回传给 X win 32 那套软件，
		此时的 XDMCP 程序就是一个 X Client 啰～<br><br>

		所以啦！如果您的 Windows 想要连接到 Linux 主机的话，那么 Windows 就得要有可以执行的 X Server 软件啦～
		而 Linux 主机则必须要启动一个可以接受 X Server 资料运算的 X Client 啦～
		就是这样说～<br><br>

		但是，这样做有什么好处呢？呵呵～最大的好处就是，<span class="text_import2">在服务器上的 X Client 不需要知道 
		X Server 的硬件是什么～</span>因为负责显示的是 X server 的事情，管理硬件的动作也是 X server 在做，
		在主机上的 X Client 只是将这些鼠标移动与点击还有键盘的输入等的数据在主机端运算后，
		最后将结果传送给 X Server 显示而已。(当然啦， 
		X Client 的运算内容还是会用到主机端的配置文件与函式库就是了。)<br><br>

		<center>
		<img src="0310telnetssh-centos4.php_files/Xserver_client.png" title="X server/client 的架构" alt="X server/client 的架构" border="1"><br>
		图九、X server/client 的架构</center><br>

		那么什么时候会出现多用户连入 X 主机的情况呢？以鸟哥的例子来说，我们实验室有一部 Linux 在进行数值模拟，
		他输出的结果是 NetCDF 档案，我们必须使用 PAVE 这一套软件去处理这些数据，
		以绘制等浓度图等等的。但是我们有两三个人同时都会使用到那个功能，
		偏偏 Linux 主机是放在机架柜里面的，要我们挤在那个小小的空间前面『站着』操作计算机，
		可真是讨人厌啊～这个时候，我们就会架设图形接口的远程登录服务器，
		让我们可以『<span class="text_import2">多人同时以图形接口登入 Linux 主机</span>』来操作我们自己的程序！
		很棒，不是吗？！<br><br>
	</div>

	<hr><a name="xdmcp_setup"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">设定 XDMCP</span><br>
	<div class="block2">
		XDM 是 X Display Manager 的简称，他的功能是什么呢？
		简单的说，就是管理操控 X Server 的显示啦～他主要有两种管理方式，
		如果 X Server/Client 在同一部机器上，那么启动 xdm 之后，就会产生一个 X server 了；
		而如果 X server/client 不在同一部主机上面，那么启动 xdm 后，他就会透过网络去管理远程那部主机的 
		X server 了。而 XDMCP (X Display Manager Control Protocol) 就是负责监听来自网络上面对于 
		xdm 的要求的啦～<br><br>

		由 X11 (CentOS 使用的是 Xorg 这个计划的 X11)提供的 display manager 为 xdm ，配置文件在 
		<span class="text_import2">/etc/X11/xdm/xdm-config</span> ，
		而著名的 KDE 与 GNOME 也都有自己的 display manager 管理程序，分别是 kdm 与 gdm ，
		配置文件则是 <span class="text_import2">/etc/X11/xdm/kdmrc 与 /etc/X11/gdm/gdm.conf</span>
		(不同的 distribution 这个档案放置的目录不太一样)。我们可以透过三者中任何一者的 display manager 
		的配置文件来启动 xdmcp 这个协定呢～<br><br>

		要启用 xdmcp 的功能真的很简单，如果您要启用 xdm 的话，修改 /etc/X11/xdm/xdm-config 这个档案，
		找到底下这一行(一般在最后一行)：<br>

<table class="term"><tbody><tr><td class="term"><pre>DisplayManager.requestPort:    0
</pre></td></tr></tbody></table>

		将他修改成为：<br>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_write">!</span>DisplayManager.requestPort:    0
</pre></td></tr></tbody></table>

		亦即是批注掉，然后再重新启动 xdm 就好了。而 kdm 与 gdm 的设定也类似，底下鸟哥主要以 kdm 
		来进行 xdmcp 的架设。不过要注意的是，即使在 Linux 主机端不启用 X Server (port 6000) 
		也是可以正确无误的提供 X 接口的登入的～就如同上面提到的概念一般～
		但是，如果要获得比较正确的讯息，那么还是建议您，<span class="text_import2">启用 kdm 时一并正确的启动 X </span>，
		只是安全性上面就要注意一些了！好了，多说无益，来实作吧！<br>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">1. 先让 kdm 支持 xdmcp 模式</span>
[root@linux ~]# <span class="term_command">cd /etc/X11/xdm</span>
[root@linux xdm]# <span class="term_command">vi kdmrc</span>
<span class="term_write">[Xdmcp]
Enable=1</span>
<span class="term_say"># 大约是在 70 行左右。不要怀疑！真的只要这样就好了！</span>

<span class="term_hd">2. 让 client 可以透过 X 来登入系统！与权限有关的设定</span>
[root@linux xdm]# <span class="term_command">vi Xaccess</span>
<span class="term_write">*</span>
<span class="term_say"># 为了安全性上面的需要，想要登入 X 的话，得要通过这个档案的验证才行。
# 找到上面这一行，如果没有这一行的话(整行只有一个 * )，
# 就自行加入。这表示『不论来自哪里，我都接受 X 登入』的意思！</span>

<span class="term_hd">3. 启动 kdm 喔！</span>
[root@linux xdm]# <span class="term_command">/etc/init.d/xfs start</span>
<span class="term_say"># 就如同我们上面提到的， kdm 执行后，可能的话，会在本机端启动一个 X server 的，
# 而我们这一版的 Xorg 要顺利的启动，得要先启用 X font Server 才行，
# 否则的话，您就得要到 /etc/X11/Xorg.conf 里面去设定好每个字型的路径才行。</span>
[root@linux xdm]# <span class="term_command">kdm</span>
[root@linux xdm]# <span class="term_command">netstat -tlunp</span>
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address  Foreign Address  State  PID/Program name
tcp        0      0 0.0.0.0:<span class="term_write">6000</span>   0.0.0.0:*        LISTEN 5920/X
tcp        0      0 :::6000        :::*             LISTEN 5920/X
udp        0      0 :::<span class="term_write">177</span>         :::*                    5918/kdm
<span class="term_say"># 要看到有 177 的 udp port 出现才行～ 因为那是 xdmcp 协议的监听埠口。
# 不过，如果要看看是否有成功启动 X 的话，就得要查阅 6000 这个 port 啰～
# 如果没有看到 port 6000 的话，请查阅 /var/log/Xorg.0.log 喔！
# 如果想要设定开机就自动执行的话，可以利用 chkconfig 加入 xfs ，
# 也可以将 kdm 这个指令写到 /etc/rc.d/rc.local 这个档案中～</span>
</pre></td></tr></tbody></table>

	虽然是非必备的，不过为了避免困扰，这里还是得要提醒大家。(因为 CentOS 不需要启动 X 就能够提供 xdmcp 登入)
	鸟哥上面的测试是在 run level 为 3 的环境下，且整体在执行的时候，
	/var/log/messages 与 /var/log/Xorg.0.log 这两个档案内容中并没有 kdm 的相关错误讯息～
	很重要啊！因为某些套件如果没有成功的启动 X 时，他就无法提供登入呢～<br><br>
	</div>

	<hr><a name="xdmcp_client"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">客户端登入</span><br>
	<div class="block2">
	<li><span class="text_import1">客户端是 Linux 主机：</span></li>
	<div class="block2">
		如果想要进行 XDMCP 提供的 X 接口的登入 Linux 主机时，在 Linux 底下可是容易的很～
		底下的流程是在『客户端』执行的喔～不是刚刚那部 XDMCP 所在的 Linux 主机啦！<br>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">0. 请务必要在 X Window 当中，进入 X Window 的方式有：</span>
[root@client ~]# <span class="term_command">startx</span>
<span class="term_say"># 或</span>
[root@client ~]# <span class="term_command">init 5</span>
　
<span class="term_hd">1. 在 X Window 的画面当中，启用一个 shell ，然后输入：</span>
[root@client ~]# <span class="term_command">xhost + 192.168.1.100</span>
192.168.1.100 being added to access control list
<span class="term_say"># 假设我刚刚那部 Linux 主机的 IP 为 192.168.1.100</span>
[root@client ~]# <span class="term_command">init 3</span>   <span class="term_say">&lt;== 关闭 X Server</span>

<span class="term_hd">2. 在文字接口下输入：</span>
[root@client ~]# <span class="term_command">X -query 192.168.1.100</span>
<span class="term_say"># 进入 X Window 啰！</span>
</pre></td></tr></tbody></table>

		如果一切顺利的话，您应该就能够到 X Window 的画面底下去登入远程主机啰～<br><br>
	</div>

	<li><span class="text_import1">客户端是 Windows 主机：</span></li>
	<div class="block2">
		如果想要进行 XDMCP 提供的 X 接口的登入 Linux 主机时，在 Windows 
		底下就得要使用其他软件来支持了。例如：

	<ul><li><a href="http://www.starnet.com/evalkey/" target="_blank">X-Win32 (http://www.starnet.com/evalkey/)</a>
	</li><li><a href="http://www.hummingbird.com/products/nc/exceed/index.html?cks=y" target="_blank">Exceed (http://www.hummingbird.com/products/nc/exceed/index.html?cks=y)</a></li></ul>

	这里鸟哥用 X-Win32 来进行测试。正个运作流程是这样的：

	<ol>

	<li>安装 X-Win32 ，很简单～就是直接执行下一步即可。比较可惜的是，这个软件目前没有中文支持喔！</li><br>

	<li>直接在『开始』--&gt;『程序集』--&gt;『X Win 32』执行『X-Win32』这支程序～会出现如下图：<br><br>
		<center><img src="0310telnetssh-centos4.php_files/x-win32-01.jpg" title="X Win 32 执行范例" alt="X Win 32 执行范例"><br>
			图十、X Win 32 执行范例</center><br>

		上面只是在告诉我们，这个软件需要注册。但是我们只是试用而已，所以可以直接按下 Evaluation 即可。
		不过，试用版有联机三十分钟的限制就是了～@_@ <br><br>

	</li><li>在出现的窗口当中，当然要选择 XDMCP 这个模式啰～<br><br>
		<center><img src="0310telnetssh-centos4.php_files/x-win32-02.jpg" title="X Win 32 执行范例" alt="X Win 32 执行范例"><br>
			图 11 、X Win 32 执行范例</center><br>

	</li><li>因为我们可以直接给予一个 X server 的 IP，所以这里我们可以选择『Query』这个项目。
		如果您是在 LAN 环境当中，而且 Client/Server 是在同一个网段时，其实可以选择 Broadcast 
		比较好用！无论如何，这里鸟哥先以 Query 来介绍。<br><br>
		<center><img src="0310telnetssh-centos4.php_files/x-win32-03.jpg" title="X Win 32 执行范例" alt="X Win 32 执行范例"><br>
			图 12 、X Win 32 执行范例</center><br>

	</li><li>接下来的画面可以填入 IP 或主机名啊！建议直接输入 IP 啦！<br><br>
		<center><img src="0310telnetssh-centos4.php_files/x-win32-04.jpg" title="X Win 32 执行范例" alt="X Win 32 执行范例"><br>
			图 13 、X Win 32 执行范例</center><br>

	</li><li>接下来的画面只要填入一个简单的好记得名称即可！如果想要立即执行的话，那个『Launch this session now』
		可以直接打勾喔！<br><br>
		<center><img src="0310telnetssh-centos4.php_files/x-win32-05.jpg" title="X Win 32 执行范例" alt="X Win 32 执行范例"><br>
			图 14 、X Win 32 执行范例</center><br>

	</li><li>理论上，这样应该就可以立即的进行联机到 X Window Server 才对。不过，如果没有成功呢？
		没关系！我们可以重新来修改一下设定啊～如果执行了 X-Win32 之后，在任务栏的右下角会出现 X 图示，
		如下所示：<br><br>
		<center><img src="0310telnetssh-centos4.php_files/x-win32-06.jpg" title="X Win 32 执行范例" alt="X Win 32 执行范例"><br>
			图 15 、X Win 32 执行范例</center><br>
		将鼠标指针移动到 X 上头，按下右键，可以得到如下的选单出现：<br><br>
		<center><img src="0310telnetssh-centos4.php_files/x-win32-07.jpg" title="X Win 32 执行范例" alt="X Win 32 执行范例"><br>
			图 16 、X Win 32 执行范例</center><br>
		在上图上面按下『XConfig』就可以出现底下的图示：<br><br>
		<center><img src="0310telnetssh-centos4.php_files/x-win32-08.jpg" title="X Win 32 执行范例" alt="X Win 32 执行范例"><br>
			图 17 、X Win 32 执行范例</center><br>
		然后选择我们刚刚设定好的那个 session ，按下『Edit』，就可以开始修改刚刚的设定值啰～
		更多的选项请自行参考 X Win32 当中的说明。此时，我们可以在任务栏的 X 上面，按下左键，
		应该会出现所有可以用的 session ，请选择 linux.dmtsai.tw 那个 session ，如果一切顺利，
		就会出现如下的画面：<br><br>
		<center><img src="0310telnetssh-centos4.php_files/x-win32-09.jpg" title="X Win 32 执行范例" alt="X Win 32 执行范例"><br>
			图 18 、X Win 32 执行范例</center><br>
		输入账号密码之后，嘿嘿！立刻就可以在 Windows 上面看到您 Linux 主机的 X Window 画面了～
		感动吧～ ^_^
	</li></ol>

	<div style="padding: 10pt 0pt 10pt 0pt ;" align="right"><table width="90%"><tbody><tr><td><b>Tips:</b><br><span style="color : #009000"><font size="-1">		事实上，xdmcp 真的很容易设定的～鸟哥曾经以 gdm (配置文件为 gdm.conf) 及 kdm 分别设定过，
		执行上都没有问题。不过，需要特别留意的是，因为 X Window 执行的数据量实在是太大了，
		所以，如果您在 Internet 上面使用 ADSL 传输的话，想要玩这个玩意儿～
		奉劝您：『别想了～』这东西主要还是应用在内部网域当中的啦！
	</font></span></td><td><img src="0310telnetssh-centos4.php_files/vbird_face.gif" alt="鸟哥的图示" title="鸟哥的图示"></td></tr></tbody></table></div>
	</div>
	</div>

	<hr><a name="xdmcp_close"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">关闭 XDMCP</span><br>
	<div class="block2">
		如果想要关掉的话，就这样做：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux xdm]# <span class="term_command">killall -9 kdm</span>
[root@linux xdm]# <span class="term_command">/etc/init.d/xfs stop</span>
</pre></td></tr></tbody></table>

		这样就可以将 xdmcp 给他关掉啰～ ^_^
	</div>
</div>


<hr><a name="vnc"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">VNC 服务器</span><br>
<div class="block1">
	虽然 xdmcp 就已经很好用了，不过，就以传输速度上来讲，他真的是慢啊～～
	这个时候，我们可以利用 VNC (Virtual Network Computing) 这个好用的咚咚来进一步设定我们的 
	X Window 登入系统喔。<br><br>

	VNC 必须要透过 VNC Server 与 VNC client 软件的呼相搭配，就可以进行比较快速一点的数据传输。
	而 VNC 如果想要漂亮的一点的话，也是需要搭配 xdmcp 的啦～因为如果是纯粹使用 VNC 连接到 Xorg 
	(或 XFree86) 那个简单的画面，真的是....有点不好用～<br><br>

	其实 VNC Server 会在主机多开一个程序在等待 Client 的登入要求，
	等到 Client 登入之后，才去执行 Window manager 的启动。而这个 Window manager 的启动方式有很多种，
	最阳春的就是利用 Xorg 默认的 twm 这个窗口管理程序，他真的是不好看～
	画面有点像这样：<br><br>

		<center><img src="0310telnetssh-centos4.php_files/vnc-01.jpg" title="使用 twm 联机为 VNC Server 的执行范例" alt="使用 twm 联机为 VNC Server 的执行范例"><br>
			图 19 、使用 twm 联机为 VNC Server 的执行范例</center><br>

	真的不很好看喔～那怎么办？其实我们可以透过更改 VNC 的启动配置文件： xstartup 来设定不同的 Window manager ，
	另外，我们也可以透过启用 kdm 或 gdm 这两个好用的 display manager 来代为管理 Window manager 呢～
	鸟哥比较喜欢使用查询 (Query) XDMCP 的方式来启动 VNC ，而不是直接启动 startkde 这个程序的说～
	所以，底下我们就直接来设定可以连接到 xdmcp 上的 VNC Server 吧！<br>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">1. 先让 kdm 支持 xdmcp 模式</span>
[root@linux ~]# <span class="term_command">cd /etc/X11/xdm</span>
[root@linux xdm]# <span class="term_command">vi kdmrc</span>
<span class="term_write">[Xdmcp]
Enable=1</span>

<span class="term_hd">2. 让 client 可以透过 X 来登入系统！与权限有关的设定</span>
[root@linux xdm]# <span class="term_command">vi Xaccess</span>
<span class="term_write">*</span>

<span class="term_hd">3. 启动 kdm 喔！</span>
[root@linux xdm]# <span class="term_command">/etc/init.d/xfs start</span>
[root@linux xdm]# <span class="term_command">kdm</span>
[root@linux xdm]# <span class="term_command">netstat -tlunp</span>
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address  Foreign Address  State  PID/Program name
tcp        0      0 0.0.0.0:6000   0.0.0.0:*        LISTEN 5920/X
tcp        0      0 :::6000        :::*             LISTEN 5920/X
udp        0      0 :::177         :::*                    5918/kdm
<span class="term_say"># 要看到有 177 的 udp port 与 port 6000 才行；
# 如果没有看到的话，就得要查询底下几个档案的内容，看看错误讯息了！
# a. 必须查阅 netstat -tlunp
# b. 必须查阅 /var/log/Xorg.log.0
# c. 必须查阅 /var/log/messages
# d. 必须查阅 /var/log/kdm.log</span>

<span class="term_hd">4. 用某身份建立 passfile 给 VNC 联机时使用</span>
<span class="term_say"># 因为 VNC 开的每个 port 都是给某特定使用者登入的，因此，
# 每个 VNC server 都会启用自己的 port 呢～据说最大可开放到 10 个～
# 鸟哥这里假设利用 dmtsai 这个使用者来执行 VNC ，那么他就必须要有底下几个动作：</span>
<span class="term_hd">4.1 建立联机用密码</span>
[root@linux xdm]# <span class="term_command">su dmtsai</span>
[dmtsai@linux xdm]$ <span class="term_command">vncpasswd</span>
Password: <span class="term_note">&lt;== 这里请输入密码</span>  
Verify: <span class="term_note">&lt;== 再输入一次～</span>
<span class="term_say"># 特别注意，为了安全起见，密码的长度是有限制的！
# 至少要大于六个字符，且不能与账号相同～
# 密码建立后，会在 /home/dmtsai/.vnc/passwd 这个档案中记录了你的密码～
# 同时，在这个目录下，还有配置文件 xstartup 可以利用喔！ ^_^</span>
<span class="term_hd">4.2 修改配置文件 xstartup</span>
[dmtsai@linux xdm]$ <span class="term_command">vi /home/dmtsai/.vnc/xstartup</span>
<span class="term_say"># 将这个档案内的所有数据通通给他批注掉～不需要保留～</span>
<span class="term_hd">4.3 离开此一身份使用者的画面</span>
[dmtsai@linux xdm]$ <span class="term_command">exit</span>

<span class="term_hd">5. 修改 /etc/sysconfig/vncserver 档案内容</span>
<span class="term_say"># 这个档案是 FC4 预设的启动 VNC 的读取档，所以我们可以修改他～</span>
[root@linux xdm]# <span class="term_command">vi /etc/sysconfig/vncservers</span>
<span class="term_say"># 将原本的数据改成这样：</span>
<span class="term_write">VNCSERVERS="2:dmtsai"
VNCSERVERARGS[2]="-geometry 800x600 -query localhost"</span>
<span class="term_say"># 意思是说，我们要启动一个 VNC 在 port 5900+2 即 5902 的意思，</span>

<span class="term_hd">6. 启动 VNC server </span>
[root@linux xdm]# <span class="term_command">/etc/init.d/vncserver start</span>
<span class="term_say"># 此时在 /home/dmtsai/.vnc/ 里面应该会有几个档案您应该要注意的，
# 最重要的就是 dmtasi.linux.dmtsai.tw:2.log 这个档案，档名的由来是：
# username.hostname.domainname:[port number].log ，因为我们是启用 5902 ，
# 所以就有 :2.log 的附档名啦～务必看到里面没有错误才行喔～
# 如果发现找不到/usr/X11R6/lib/X11/xserver/SecurityPolicy 的错误，先略过不要紧～</span>

<span class="term_hd">7. 查阅设定结果</span>
[root@linux xdm]# <span class="term_command">netstat -tulnp</span>
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address Foreign Address State    PID/Program name
tcp        0      0 0.0.0.0:5802  0.0.0.0:*       LISTEN   15287/Xvnc
tcp        0      0 0.0.0.0:5902  0.0.0.0:*       LISTEN   15287/Xvnc
tcp        0      0 0.0.0.0:6000  0.0.0.0:*       LISTEN   15019/X
tcp        0      0 0.0.0.0:6002  0.0.0.0:*       LISTEN   15287/Xvnc
tcp        0      0 :::6000       :::*            LISTEN   15019/X
tcp        0      0 :::6002       :::*            LISTEN   15287/Xvnc
udp        0      0 0.0.0.0:32924 0.0.0.0:*                15287/Xvnc
udp        0      0 :::177        :::*                     15017/kdm
</pre></td></tr></tbody></table>

	设定好像也很简单喔～那么鸟哥干嘛讲这么多原理？
	原因无他，因为希望大家可以在不同的 Linux distributions 也能够顺利的架设好
	XDMCP 与 VNC ，如果您能够善用登录文件的内容信息，
	那么应该会比较容易 debug 的啦～ ^_^<br><br>

	另外，事实上启动 VNC 的 script 是由 vncserver 这个指令所启用的，
	您也可以直接利用某个身份直接下达：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">vncserver :3</span>

You will require a password to access your desktops.

Password: <span class="term_note">&lt;== 就输入密码吧！</span>
Verify: <span class="term_note">&lt;== 再输入密码吧！</span>

New 'dmtsai.linux.dmtsai.tw:3 (dmtsai)' desktop is dmtsai.linux.dmtsai.tw:3

Starting applications specified in /root/.vnc/xstartup
Log file is /root/.vnc/dmtsai.linux.dmtsai.tw:3.log
</pre></td></tr></tbody></table>

	如此一来，就可以启用一个 port 为 5903 的 VNC 服务啰～
	您可以再度的去到 logfile 查一查啊～至于关闭的话，可以用：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">vncserver -kill :3</span>
</pre></td></tr></tbody></table>

	这样就能够关闭啰～呵呵！那么如果想要连接到 VNC Server 的话，
	在 Linux 底下可以利用 KDE 的 krdc 这支远程联机程序，如果是 Windows 的话，
	就得需要 VNC Client 啰～您可以前往底下的网站：

	<ul><li><a href="http://www.realvnc.com/download.html" target="_blnak">http://www.realvnc.com/download.html</a></li></ul>

	直接下载 Free Edition 来测试看看就好了。安装过程我们就不提了～
	安装完毕之后，直接执行『开始』--&gt;『程序集』--&gt;『RealVNC』--&gt;『Run VNC viewer』后，
	出现如下的窗口：<br><br>

	<center><img src="0310telnetssh-centos4.php_files/realvnc-01.jpg" title="VNC viewer 执行范例" alt="VNC viewer 执行范例"><br>
		图 20 、VNC viewer 执行范例</center><br>

	输入了您的主机 IP 与该 VNC 对应的 port 之后，会出现一个密码窗口：<br><br>

	<center><img src="0310telnetssh-centos4.php_files/realvnc-02.jpg" title="VNC viewer 执行范例" alt="VNC viewer 执行范例"><br>
		图 21 、VNC viewer 执行范例</center><br>

	记得啊～这里的密码指的是『您利用 vncpasswd 所建立的密码』，而不是登入者的密码啊～
	按下 Enter 之后，如果顺利的话，就会出现如下的图示啰～<br><br>

	<center><img src="0310telnetssh-centos4.php_files/realvnc-03.jpg" title="VNC viewer 执行范例" alt="VNC viewer 执行范例"><br>
		图 22 、VNC viewer 执行范例</center><br>

	<center><img src="0310telnetssh-centos4.php_files/realvnc-04.jpg" title="VNC viewer 执行范例" alt="VNC viewer 执行范例"><br>
		图 23 、VNC viewer 执行范例</center><br>

	很不错吧！ ^_^ 这样就能够在 Client 端登入 Linux 主机啰～
	而且还可以多人共享呢～真是棒～ ^_^。但是，如果您设定完毕之后，
	在登录档老是出现这个咚咚：
	『XDMCP fatal error: Manager unwilling Host unwilling』，
	就是 /etc/X11/xdm/Xaccess 这个档案的设定需要变更了！<br><br>

	另外，有些朋友一定会觉得奇怪，那就是，为甚么我的 VNC 服务器的 server / client 端画面并不是同步的呢?
	这是因为 Linux 本身提供多个 VNC server ，她们是各自独立的，所以当然就不会与 tty7 的画面同步了。
	但是如果您想要与 Linux 的 tty7 同步的话，可以利用 VNC 释出的给 X Server 使用的模块来加以设定即可。
	如果您是 CentOS 4.x 这个 distribution 的话，恭喜您，系统默认已经将 vnc.so 这个模块释出了，您可以查阅
	/usr/X11R6/lib/modules/extensions/ 这个档案，即可知道有没有 vnc.so 这个模块。如果您没有这个模块的话，
	请参考 <a href="http://phorum.study-area.org/viewtopic.php?t=25713" target="_blank">http://phorum.study-area.org/viewtopic.php?t=25713</a> 这一篇文章的说明，
	依序来设定吧!<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">vi /etc/X11/xorg.conf (或 XF86Config)</span>
Section "Module"
	....
        <span class="term_write">Load  "vnc"</span>
EndSection
<span class="term_say"># 在 Module 这个 section 当中加入 vnc 这个模块即可</span>
Section "Screen"
        Identifier "Screen0"
        Device     "Videocard0"
        Monitor    "Monitor0"
        <span class="term_write">Option     "passwordFile"  "/etc/vnc/passwd"</span>
        DefaultDepth     16
	......
EndSection
<span class="term_say"># 假设您的 vnc 密码档案放置在 /etc/vnc/passwd 里头，
# 这个时候就得要将密码文件内容写到 Screen 这个 section 当中了</span>
</pre></td></tr></tbody></table>

	此时给他重新启动一下 kdm 或者是重新进入 run level 5 的时候，您就会发现多了一个 port 5900 呢，
	嘿嘿，准备同步登入吧 ^_^<br><br>
</div>


<hr><a name="rsh"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">RSH 服务器</span><br>
<div class="block1">
	什么是 RSH 服务器呢？其实，这是早期的不同主机之间互相『直接操作』对方资源的一个方法。
	其实就好像使用『 ssh dmtsai@localhost date 』之类的执行方法啦！
	我们可以透过 rsh 来操作对方主机啊。这个 RSH 就是被称为 R Shell 的咚咚啰～<br><br>

	目前 RSH 很少被使用到一般的服务器上面，尤其是对 Internet 开放的主机，
	这是因为 RSH 的危险性很高！他不但是明码传输，而且一个设定不良，可能会让所有人都能使用 RSH 来登入主机！
	不过，RSH 却是操作丛集计算机 (cluster) 里面最常见的服务之一！<br><br>

	所谓的丛集计算机，简单的说就是『<span class="text_import2">将很多部主机透过网络链接在一起，
	以其中一部主机作为主要操控计算机 (或者称为 master) ，其他主机仅负责来自 master 的要求 
	(所以被称为 slave)；所有的计算机工作都是由 master 所掌控， slave 仅负责运算的部分。</span>』
	这也就是说， slave 大概就仅提供 CPU 的运算单元，其他的事都是 master 负责来运作。
	当然，我们也是只要操控 master 那部主要计算机而已。在这样的情况下， slave 接受 master 的指令，
	最主要就是透过 RSH 啊！ (当然，也可以透过 SSH 配合密钥来达成这样的工作！)。
	关于更多的 cluster  的介绍，可以参考一下鸟哥之前写的一篇小文章：
	<ul><a href="http://linux.vbird.org/linux_server/0600cluster.php" target="_blank">http://linux.vbird.org/linux_server/0600cluster.php</a></ul>

	至于 RSH server 与 Client 的互动可以使用下面的图示来查阅：<br><br>

	<a name="fig_24"></a><center><img src="0310telnetssh-centos4.php_files/rsh.png" title="RHS Server/Client 互动示意图" alt="RHS Server/Client 互动示意图" border="1"><br>
		图 24 、RHS Server/Client 互动示意图</center><br>

	上图中在 RSH server 当中的几个配置文件是这样的：<br>
	<ul>
	<li><span class="text_import1">/etc/hosts</span>：主要规范 RSH server/client 的主机名与 IP 对应！
	</li><li><span class="text_import1">/etc/hosts.equiv</span>：规范出哪一部 client 可以连上这部 RSH server；
	</li><li><span class="text_import1">~user/.rhosts</span>：规范出那个用户可以不需要输入密码即可执行 RSH；
	</li><li><span class="text_import1">/etc/pam.d/rsh</span>：规范 root 能否使用 RSH 的配置文件。
	</li></ul>


	虽然 RSH 目前已经很少被使用，但是在内部主机的联机上面还是有他的存在的价值啦！
	因此，底下我们就来谈一谈如何玩弄这个 RSH 吧！<br><br>

	<hr><a name="rsh_server"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">RSH Server</span><br>
	<div class="block2">
		其实 R Shell 有很多的工具与启动的 port ，常见的 R Shell 工具有 rexec, rlogin, rsh 等，
		而这些工具都对应到不同的 port 上面，你可以到 /etc/services 上查阅一下 512, 513, 514 这三个 port 吧！<br><br>

		<hr><li><span class="text_import1">RSH Server 的启动：</span></li>
		<div class="block2">
		如<a href="#fig_24">图 24</a> 所示，我们在 RSH Client 计算机上面想要使用 RSH Server 上头的数据时，
		那么 RSH server 自然就得要启动 RSH 这项服务啰！那么如何启动呢？简单的很～
		就利用 super deamon 来启动，
		<span class="text_import2">我们需要有 rsh 及 rsh-server 两个套件才行</span>！请自行安装吧！
		另外， rsh-server 共提供三个服务，分别是『 rexec, rlogin, rsh 』，我们先单纯讨论 rsh 吧！
		安装完毕之后，直接启动即可：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">vi /etc/xinetd.d/rsh</span>
service shell
{
        <span class="term_write">disable                 = no</span>
        socket_type             = stream
        wait                    = no
        user                    = root
        log_on_success          += USERID
        log_on_failure          += USERID
        server                  = /usr/sbin/in.rshd
}
<span class="term_say"># 没错！只要将 disable 改成 no  即可！</span>

[root@linux ~]# <span class="term_command">/etc/init.d/xinetd restart</span>

[root@linux ~]# <span class="term_command">netstat -tlnp | grep 514</span>
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address Foreign Address State  PID/Program name
tcp        0      0 0.0.0.0:514   0.0.0.0:*       LISTEN 23369/xinetd
<span class="term_say"># 有看到 514 的 port 出现就对了！</span>
</pre></td></tr></tbody></table>
		</div>

		<hr><li><span class="text_import1">设定可以使用 RSH 的来源主机与账号： /etc/hosts, 
		/etc/hosts.equiv, ~user/.rhosts</span></li>
		<div class="block2">
		假设我已经在 /etc/hosts 里面做好了我内部主机的 IP 与主机名的对应了，
		例如，我 192.168.1.2 机器的 /etc/hosts 里面是这样的：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">vi /etc/hosts</span>
127.0.0.1       localhost       localhost.localdomain
192.168.1.2     rsh.server      rshserver
192.168.1.100   rsh.client      rshclient
<span class="term_say"># 上面仅有两部主机，假设 RSH server 的 IP 是 192.168.1.2 啦！</span>
</pre></td></tr></tbody></table>

		这个档案很重要，因为我们的 RSH 通常是利用主机名来作为指令的下达的，
		所以啰，您局域网络内的主机名与 IP 必须要设定的能够对应的起来，否则问题就大了。
		在上表当中，你会发现到，其实鸟哥的重点是那部 rsh.server 的机器，
		当我想要让 192.168.1.100 亦即是 rsh.client 那部机器连进来 rsh.server 执行一些指令的话，
		那我就得要启动权限才行！此时就得要 /etc/hosts.equiv 来处理了。这个档案的格式是这样的：<br>

<a name="hosts.equiv"></a>
<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">vi /etc/hosts.equiv</span>
<span class="term_write">rsh.client dmtsai</span>
<span class="term_say"># 这个档案的格式是 [hostname] [username]
# 将你要开放的用户与某主机给他对应好写上去即可！</span>
</pre></td></tr></tbody></table>

		这样就做好了设定了！未来任何想要登入这部 rsh.server 机器的主机，只要将他的主机名与 IP 对应写入
		/etc/hosts ，然后再将该主机名写入 /etc/hosts.equiv ，就成功了！
		这个档案的设计只要是在规范『可以不用输入密码就能够进入本机执行指令』的设定啦！
		但是请注意，『<span class="text_import2">在预设的情况下， root 是不允许使用 rsh 
		登入 rsh.server 机器的。</span>』这个很重要！不要使用 root 一直测试啊！没有用的。
		更多的 hosts.equiv 设定值，请参考 man hosts.equiv 啰！<br><br>

		<a name="rhosts"></a>
		但你可能会发现一件事，那就是每部主机与用户都需要配合的话，但 /etc/hosts.equiv 预设仅有 root 可修改，
		如此一来实在不好管理！此时我们可以使用用户家目录的档案来处理喔！那就是 ~/.rhosts 啰！
		这个档案的设定就更简单了！只要将使用者预计要登入的那部主机名写入即可！<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">vi ~dmtsai/.rhosts</span>
<span class="term_write">rsh.client</span>
</pre></td></tr></tbody></table>

		这样就 OK 啦！意思是说，我这部 rsh.server 上有个 dmtsai 的使用者，他可以让 rsh.client
		这个主机登入并且不需要密码即可进行 R Shell 的相关指令下达工作！
		同样的，如果我还想让其他使用者可以由不同的主机登入这部 rsh.server 进行 RSH 的话，
		同样在他的家目录新增 .rhosts 这个档案即可！如果想要让未来新增的用户都具有这个功能，
		那就这样做：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">vi /etc/skel/.rhosts</span>
<span class="term_write">rsh.client</span>
</pre></td></tr></tbody></table>

		未来新增用户时，他们的家目录底下就会自动产生 .rhosts 的档案啰！ ^_^<br>
		</div>

		<hr><li><span class="text_import1">让 root 也可以使用 RSH ：</span></li>
		<div class="block2">
		先通知一声，鸟哥不建议您这样做！但是，如果万一您需要某些服务是 root 也需要的，
		那或许就得要开放 root 使用 RSH 登入主机了。其实 root 不能使用 rsh 
		是因为 PAM 的问题而已，所以，你只要将 /etc/pam.d/rsh 这个档案批注掉一行即可：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">vi /etc/pam.d/rsh</span>
#%PAM-1.0
# For root login to succeed here with pam_securetty, "rsh" must be
# listed in /etc/securetty.
auth       required     pam_nologin.so
<span class="term_write">#auth       required    pam_securetty.so</span>
auth       required     pam_env.so
auth       required     pam_rhosts_auth.so
account    required     pam_stack.so service=system-auth
session    required     pam_stack.so service=system-auth
</pre></td></tr></tbody></table>

		将上面这一行批注掉，立刻就能让 root 登入 rsh 主机啦！当然啦，如果您担心有问题，
		那么修改另一个档案也可以：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">vi /etc/securetty</span>
<span class="term_say">.....(省略).....</span>
<span class="term_write">rsh</span>
</pre></td></tr></tbody></table>

		加入这一行也行！注意，上面这两个档案是具有相关性的，所以，您只要修改任何一个即可，
		不必两个同时进行！然后将主机名与 root 的对应写入 <a href="#hosts.equiv">/etc/hosts.equiv</a>
		档案中即可！你的 root 就能够使用 rsh 啰！但是，鸟哥还是不很建议开放 root 使用 RSH 喔！注意注意！<br>
		</div>
	</div>

	<hr><a name="rsh_client"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">RSH Client</span><br>
	<div class="block2">
		这个 RSH client 的指令 rsh 默认是不给 root 执行的！所以不要使用 root 来测试！
		另外， RSH Client 最好与 RSH server 具有相同的账号来执行 rsh 比较不会有问题喔！<br><br>

		<a name="rsh_cmd"></a><hr><li><span class="text_import1">测试 RSH ：</span></li>
		<div class="block2">
		接下来，当然要进行测试啰～请到 rsh.client 那部机器上面，使用 rsh 这个指令来下达指令吧！<br>

<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@rshclient ~]$ <span class="term_command">rsh [-l 远程账号] [远程主机名] [远程主机指令]</span>
<span class="term_say">参数：
-l   ：一般来说， server 与 client 『要有相同的使用者账号名称』比较好的！
       如果没有的话，那么您必须要指定 server 的使用者账号名才行！
远程主机名  ：您要登入的那部 rsh.server 主机名，记得与 /etc/hosts 相应！
远程主机指令：您要在远程机器上面下达什么指令？</span>

<span class="term_hd">范例一：在 rsh.server 上面下达 ls -l / 这个指令：</span>
[dmtsai@rshclient ~]$ <span class="term_command">rsh rsh.server 'ls -l /'</span>
<span class="term_say">.....输出省略.....</span>
<span class="term_say"># 注意喔，我是使用 dmtsai 这个一般身份使用者，而且 rshserver rshclient
# 两部主机上面都有一个名为 dmtsai 的使用者账号才行喔！至于那个 ls -l /
# 则是在 rsh.server 主机上面的指令！留意留意！</span>
</pre></td></tr></tbody></table>

		一般来说，由于 RSH server/client 最好是要有相同的账号，如此一来才能够避免很多不必要的权限问题(
		permission denied. )。所以说，通常 RSH 可能会搭配后续会继续谈到的 NIS/NFS 等服务器才是！
		这样瞭呼？<br><br>

		另外， rsh 后续的指令通常仅适合单一指令而已，所以如果你的指令串很长 (接了很多参数)，
		那最好将那一整串指令用单引号括起来，可以避免指令下达错误的问题喔！ ^_^<br><br>
		</div>

		<a name="rcp"></a><hr><li><span class="text_import1">利用 rcp 复制：</span></li>
		<div class="block2">
		除了 rsh 可以在远程直接操控系统外，我们可以透过 rcp 来进行复制喔！其实这个 rcp 与 scp 几乎一模一样啦！
		而且 rcp 的参数几乎与 cp 一模一样哩！另外， rcp 也是透过 RSH 这个 514 的 port 来进行数据的传输的。
		简单的说明如下：<br>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例：先查阅远程主机有什么数据，然后将他复制过来：</span>
[dmtsai@rshclient ~]# <span class="term_command">rsh rsh.server 'ls -l ~'</span>
drwx------  3 dmtsai dmtsai     4096 Dec 27  2005 Desktop
-rw-r--r--  1 dmtsai dmtsai     3385 May 29 17:52 bashrc
drwx------  3 dmtsai dmtsai     4096 Mar  6  2006 mail
-rw-r--r--  1 dmtsai dmtsai   883888 May 29 17:51 netcdf.tar.gz
drwxr-xr-x  2 dmtsai dmtsai     4096 Jul 26 16:05 test
-rw-rw-r--  1 dmtsai dmtsai    34816 Mar 19  2006 testing.ppt

[dmtsai@rshclient ~]# <span class="term_command">rcp -r dmtsai@rsh.server:~/mail .</span>
<span class="term_say"># 加上 -r 是为了要复制目录喔！否则的话，可以直接复制即可！</span>
</pre></td></tr></tbody></table>

		再说一次，其实这个 RSH 目前仅有在某些特殊的场合才会用到了！
		例如未来流行的新信息『 Cluster 』！不过如果要玩 Cluster 的话，
		得要加入 NIS/NFS 等服务器哩！那就等您好好发展啦！ ^_^
		</div>
	</div>
</div>


<hr><a name="rsync"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">以 rsync 进行同步镜相备份</span><br>
<div class="block1">
	我们曾在基础篇里面谈过 <a href="http://vbird.dic.ksu.edu.tw/linux_server/linux_basic/0580backup.php">Linux 的备份策略</a>，
	该篇曾介绍常用的备份指令，包括 tar, dd, cp 等等，不过当时并未介绍网络，所以有个很棒的网络工具没有介绍，
	那就是这个地方要谈到的 rsync 啦！这个 rsync 可以作为一个相当棒的异地备援系统的备份指令喔！
	因为 rsync 可以达到类似『镜相 (mirror) 』的功能呢！<br><br>

	rsync 最早是想要取代 rcp 这个指令的，因为 rsync 不但传输的速度快，而且他在传输时，
	可以比对本地端与远程主机欲复制的档案内容，而仅复制两端有差异的档案而已，所以传输的时间就相对的降低很多！
	此外， rsync 的传输方式至少可以透过三种方式来运作：<br>

	<ul><span class="text_import2">
	<li>在本机上直接运作，用法就与 cp 几乎一模一样，例如：<br>
		rsync -av /etc /tmp (将 /etc/ 的数据备份到 /tmp/etc 内)<br><br>
	</li><li>透过 rsh 或 ssh 的信道在 server / client 之间进行数据传输，例如：<br>
		rsync -av -e ssh user@rsh.server:/etc /tmp (将 rsh.server 的 /etc 备份到本地主机的 /tmp 内)<br><br>
	</li><li>直接透过 rsync 提供的服务 (daemon) 来传输，此时 rsync 主机需要启动 873 port：<br>
		1. 你必须要在 server 端启动 rsync ， 看 /etc/xinetd.d/rsync 即可；<br>
		2. 你必须编辑 /etc/rsyncd.conf 配置文件；<br>
		3. 你必须设定好 client 端联机的密码数据；<br>
		4. 在 client 端可以利用：rsync -av user@hostname::/dir/path /local/path<br>
	</li></span></ul>

	其实三种传输模式差异在于有没有冒号 (:) 而已，本地端传输不需要冒号，透过 ssh 或 rsh 时，就得要利用一个冒号 (:)，
	如果是透过 rsync daemon 的话，就得要两个冒号 (::) ，应该不难理解啦！因为本地端处理很简单，
	而我们的系统本来就有提供 ssh 的服务，所以，底下鸟哥将直接介绍利用 rsync 透过 ssh 来备份的动作喔。
	不过，在此之前咱们先来看看 rsync 的语法吧！<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">rsync [-avrlptgoD] [-e ssh] [user@host:/dir] [/local/path]</span>
<span class="term_say">参数：
-v ：观察模式，可以列出更多的信息；
-q ：与 -v  相反，安静模式，输出的信息比较少；
-r ：递归复制！可以针对『目录』来处理！很重要！
-u ：仅更新 (update)，不会覆盖目标的新档案；
-l ：复制链接文件的属性，而非链接的目标源文件内容；
-p ：复制时，连同属性 (permission) 也保存不变！
-g ：保存源文件的拥有群组；
-o ：保存源文件的拥有人；
-D ：保存源文件的装置属性 (device)
-t ：保存源文件的时间参数；
-I ：忽略更新时间 (mtime) 的属性，档案比对上会比较快速；
-z ：加上压缩的参数！
-e ：使用的信道协议，例如使用 ssh 通道，则 -e ssh
-a ：相当于 -rlptgoD ，所以这个 -a 是最常用的参数了！
更多说明请参考 man rsync 的解说！</span>

<span class="term_hd">范例一：将 /etc 的数据备份到 /tmp 底下：</span>
[root@linux ~]# <span class="term_command">rsync -av /etc /tmp</span>
<span class="term_say">....前面输出省略....</span>
sent 23007335 bytes  received 32280 bytes  5119914.44 bytes/sec
total size is 22870014  speedup is 0.99
<span class="term_say"># 第一次运作时会花比较久的时间，因为首次建立嘛！如果再次备份呢？</span>

[root@linux ~]# <span class="term_command">rsync -av /etc /tmp</span>
building file list ... done
sent 77105 bytes  received 20 bytes  154250.00 bytes/sec
total size is 22870014  speedup is 296.53
<span class="term_say"># 瞧！立刻就跑完了！传输的数据也很少！因为再次比对，仅有差异的档案会被复制。</span>

<span class="term_hd">范例二：利用 dmtsai 的身份，将 rsh.server 用户家目录复制到 /tmp </span>
[root@linux ~]# <span class="term_command">rsync -av -e ssh dmtsai@rsh.server:~ /tmp </span>
The authenticity of host 'rsh.server (192.168.1.2)' can't be established.
RSA key fingerprint is 29:b8:a9:32:ea:d8:ff:97:6c:42:3b:aa:11:ab:55:dd.
Are you sure you want to continue connecting (yes/no)? <span class="term_command">yes</span>
Warning: Permanently added 'rsh.server' (RSA) to the list of known hosts.
dmtsai@rsh.server's password:
receiving file list ... done
<span class="term_say">....档案输出省略....</span>
sent 8436 bytes  received 43224862 bytes  2789245.03 bytes/sec
total size is 43189031  speedup is 1.00

[root@linux ~]# <span class="term_command">ll -d /tmp/dmtsai</span>
drwxr-xr-x  22 dmtsai dmtsai  4096 Sep 18 23:25 /tmp/dmtsai
<span class="term_say"># 瞧！这样就做好备份啦！很简单吧！</span>
</pre></td></tr></tbody></table>

	你可以利用上面的范例二来做为备份 script 的参考！不过要注意的是，
	因为 rsync 是透过 ssh 来传输资料的，所以你可以针对 dmtsai 这个家伙制作出免用密码登入的 ssh 密钥！
	如此一来往后异地备援系统就能够自动的以 crontab 来进行备份了！简单到爆！<br><br>

	免密码的 ssh 账号我们在上头已经讲过了，撰写 shell script 的能力也是必须要有的！
	利用 rsync 来进行你的备份工作吧！ ^_^！
	至于更多的 rsync 用法可以参考本章后面所列出的<a href="#reference">参考数据</a>网站喔！<br><br>
</div>


<hr><a name="review"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">重点回顾：</span><br>
<div class="block1">
<ul><span class="text_import2">
	<li>远程联机服务器可以让使用者在任何一部计算机登入主机，以使用主机的资源或管理与维护主机；
	</li><li>常见的远程登录服务有 rsh, telnet, ssh, vnc, 及 xdmcp 等；
	</li><li>telnet 与 rsh 都是以明码传输数据，当数据在 Internet 上面传输时较不安全；
	</li><li>telnet 与 rsh  预设无法让 root 的身份登入，不过可以藉由 pam 模块的修改而启用 root 登入功能；
	</li><li>ssh 由于使用密钥系统，因此数据在 Internet 上面传输时是加密过的，所以较为安全；
	</li><li>但 ssh 还是属于比较危险的服务，请不要对整个 Internet 开放 ssh 的可登入权限，可利用 iptables 规范可登入范围；
	</li><li>ssh 的 public Key 是放在主机端，而 private key 是放在 client 端；
	</li><li>ssh 的联机机制有两种版本，建议使用可确认联机正确性的 version 2 ；
	</li><li>使用 ssh 时，尽量使用类似 email 的方式来登入，亦即： ssh username@hostname
	</li><li>client 端可以比对 server  传来的 public key 的一致性，利用的档案为 ~user/.ssh/known_hosts；
	</li><li>ssh 的 client 端软件提供 ssh, scp, sftp 等程序；
	</li><li>在 /etc/ssh/sshd_config 当中可以取消 root 的登入权限与修改支持的 ssh 密钥版本；
	</li><li>制作不需要密码的 ssh 账号可利用 ssh-keygen -t rsa 来制作 public, private Key pair；
	</li><li>上述指令所制作出的 public key 必须要上传到 server 的 ~user/.ssh/authorized_keys 档案中；
	</li><li>如果想以 X 图形系统登入 Linux 主机，则你必须要在 Client 主机启动 X server ，
		需要在 Linux 主机启动 X client ；
	</li><li>Xdmcp 是透过 X display manager (xdm, gdm, kdm 等) 所提供的功能协议；
	</li><li>若 client 端为 Linux 时，需要在 X 环境下以 xhost 增加可连接到本机 X Server 的 IP 才行；
	</li><li>除了 Xdmcp 之外，我们可以利用 VNC 来进行 X 的远程登录架构；
	</li><li>VNC 预设开的 port number 为 5900  开始，每个 port 仅允许一个联机；
	</li><li>控制 rsh client 是否可以联机进入的配置文件在 /etc/hosts.equiv 或 ~username/.rhosts ；
	</li><li>rsh 支持的 client 端软件有 rsh, rlogin, rcp  等；
	</li><li>rsync 可透过 ssh 的服务通道或 rsync --daemon 的方式来联机传输，其主要功能可以透过类似镜像备份，
		仅备份新的数据，因此传输备份速度相当快速！
</li></span></ul>
</div>


<hr><a name="FAQ"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">课后练习</span><br>
<div class="block1">
<ul>
	<li>Telnet 与 SSH 都是远程联机服务器，为何我们都会推荐使用 SSH 而避免使用 Telnet 呢？原因何在？</li>
	<div class="block2"><font color="white" size="-1">
	因为 Telnet 除了使用『明码』传送数据外，本身 telnet 就是很容易被入侵的一个服务器，所以当然也就比较危险了。
	至于 ssh 其实也不是很安全的！由台湾计算机危机处理小组的文件可以明显的发现 openssl + openssh 
	也是常常有漏洞在发布！不过，比起 telnet 来说，确实是稍微安全一些！ 
	</font></div>

	<li>请尝试说明 SSH 在 Server 与 Client 端联机时的封包加密机制；</li>
	<div class="block2"><font color="white" size="-1">
	利用 key pair 来达到加密的机制：Server 提供 Public Key 给 Client 端演算 Private key ，以提供封包传送时的加密、解密！
	</font></div>

	<li>请问 SSH 的配置文件是哪一个？如果我要修改让 root 无法使用 SSH 联机进入我的
	SSH 主机，应该如何设定？又，如果要让 badbird 这个用户无法登入 SSH 主机，该如何设定？</li>
	<div class="block2"><font color="white" size="-1">
	SSH 配置文件档名为 sshd_config ，通常放置在 /etc/ssh/sshd_config 内；如果不想让 root 登入，可以修改 
	sshd_config 内的参数成为：『PermitRootLogin no 』，并重新启动 ssh 来设定！如果要让 badbird 
	使用者无法登入，同样在 sshd_config 里面设定为：『DenyUsers badbird』即可！
	</font></div>

	<li>在 Linux 上，预设的 Telnet 与 SSH 服务器使用的埠口(port number)各为多少？</li>
	<div class="block2"><font color="white" size="-1">
	telnet 与 ssh 的埠口分别是：23 与 22！请参考 /etc/services 喔！ 
	</font></div>

	<li>如果发现我无法在 Client 端使用 ssh 程序登入我的 Linux 主机，但是 Linux
	主机却一切正常，可能的原因为何？(防火墙、known_hosts...)</li>
	<div class="block2"><font color="white" size="-1">
	无法登入的原因可能有很多，最好先查询一下 /var/log/messages 里面的错误讯息来判断，当然，还有其他可能的原因为：
	<ol>
	<li>被防火墙挡住了，请以 iptables -L -n 来察看，当然也要察看 /etc/hosts.deny；
	</li><li>可能由于主机重新启动过， public key 改变了，请修改您的 ~/ssh/known_hosts 里面的主机 IP ；
	</li><li>可能由于 /etc/ssh/sshd_config 里面的设定问题，导致您这个使用者无法使用；
	</li><li>在 /etc/passwd 里面，您的 user 不具有可以登入的 shell ；
	</li><li>其他因素(如账号密码过期等等)</li></ol>
	</font></div>

	<li>既然 ssh 是比较安全的资料封包传送方式，那么我就可以在 Internet 上面开放我的
	Linux 主机的 SSH 服务了吗？！请说明您选择的答案的原因！</li>
	<div class="block2"><font color="white" size="-1">
	最好不要对 Internet 开放您的 SSH 服务，因为 SSH 的加密函式库使用的是 openssl ，一般 Linux distribution 使用的 
	SSH 则是 openssh ，这两个套件事实上仍有不少的漏洞被发布过，因此，最好不要对 Internet 开放，毕竟 
	SSH 对于主机的权限是很高的！ 
	</font></div>

	<li>如果我想要将 server 的重要数据备份到 backserver，如果可以使用 rsync 透过 ssh 的通道，
	你可以请尝试这样做：<ol><li>先在 server 上面以 root 建置 ssh 的 public 与 private key pair ；
	</li><li>将 public key 传送与设定到 backserver 上的某个使用者环境下；
	</li><li>在 backserver 上面制作好预计要存放备份数据的目录！重点在于『权限』的设定上！
	</li><li>在 server 上面设定好 rsync 的备份 script ～
	</li><li>利用 crontab 每隔一段时间自动异地备份。</li></ol>
	请依照上述的作法在您的两部主机上面进行测试与实作。(未提供解答)</li>
</ul>
</div>


<hr><a name="reference"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">参考资源</span><br>
<div class="block1">
<ul>
	<li>OpenSSH 官方网站：<a href="http://www.openssh.com/" target="_blank">http://www.openssh.com/</a></li>
	<li>OpenSSL 官方网站：<a href="http://www.openssl.org/" target="_blank">http://www.openssl.org/</a></li>
	<li>putty 官方网站：<a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/" target="_blank">http://www.chiark.greenend.org.uk/~sgtatham/putty/</a></li>
	<li>pputty 中文网站：<a href="http://www.csie.ntu.edu.tw/~piaip/prjs/pputty/" target="_blank">http://www.csie.ntu.edu.tw/~piaip/prjs/pputty/</a></li>
	<li>man vncserver</li>
	<li>man Xvnc</li>
	<li>使用 X 的 VNC Module：<a href="http://phorum.study-area.org/viewtopic.php?t=25713" target="_blank">http://phorum.study-area.org/viewtopic.php?t=25713</a></li>
	<li><a href="http://fedoranews.org/tchung/vnc/03.shtml" target="_blank">http://fedoranews.org/tchung/vnc/03.shtml</a></li>
	<li><a href="http://www.faqs.org/docs/Linux-HOWTO/XDMCP-HOWTO.html" target="_blank">http://www.faqs.org/docs/Linux-HOWTO/XDMCP-HOWTO.html</a></li>
	<li>man rsh</li>
	<li>man rlogin</li>
	<li>酷学园：用 rsync 做备份：<a href="http://phorum.study-area.org/viewtopic.php?t=15553" target="_blank">http://phorum.study-area.org/viewtopic.php?t=15553</a></li>
	<li>卧龙小三的 rsync 介绍：<a href="http://linux.tnc.edu.tw/techdoc/rsync.htm" target="_blank">http://linux.tnc.edu.tw/techdoc/rsync.htm</a></li>
	<li>ADJ 实验室的 rsync + SSH：<a href="http://www.adj.idv.tw/server/linux_rsync.php" target="_blank">http://www.adj.idv.tw/server/linux_rsync.php</a></li>
</ul>
</div>


<hr><span class="text_history">
2002/11/14：第一次完成<br>
2003/03/08：加入标头说明，与修改部分内容，例如 Telnet 服务器软件的安装等等，以及 SSH 的 putty 使用中文状态！<br>
2003/09/09：将本文进行一些修订，此外，加入了课后练习！<br>
2005/07/02：将旧的文章移动到 <a href="http://linux.vbird.org/linux_server/0310telnetssh/0310telnetssh.php">这里</a> 。<br>
2005/07/07：好不容易将 VNC 还有 XDMCP 给他写了写～大家帮鸟哥参考看看啊～<br>
2005/07/09：加入了让 VNC 与 tty7 同步的 vnc.so 模块的说明<br>
2005/11/22：加入了 <a href="#rsh">RSH 服务器</a> 的相关数据！<br>
2006/09/18：将 putty 的介绍转成 pietty 的介绍！因为 pietty 更好用！另外也将 rsh 重新改写一下，校稿过！<br>
2006/09/19：加入 rsync 的简易说明与操作！最文末的习题可以瞧一瞧！<hr>
</span>
    </td>
    <td style="width: 16px; font-size: 6px;">　</td></tr>
<tr><td style="width: 16px; height: 16px;">　</td>
    <td style="width: 866px; height: 16px;">　</td>
    <td style="width: 16px; height: 16px;">　</td></tr>
</tbody></table>

<div style="padding-top: 0px; text-align: center;">
<span style="font-size: 80%;">
	<a href="http://vbird.dic.ksu.edu.tw/" target="_top" title="前往鸟哥的首页">http://linux.vbird.org</a>
	is designed by <a href="mailto:vbird@mail.vbird.idv.tw" title="联络鸟哥(我不要广告信！)">VBird</a>
		during 2001-2011. <a href="http://www.ksu.edu.tw/" target="_blank">ksu.edu</a></span>
         ﻿<div id="apDiv4">
      <p>本网页主要以Firefox配合解析度 1024x768 作为设计依据&nbsp;&nbsp;&nbsp;&nbsp; 鸟哥自由软件整合应用研究室</p></div></div>
</div>
</center>
</body></html>
