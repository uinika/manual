<html><head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf8">
	<meta name="Author" content="VBird, 鸟哥 2011-05-20-lee">
	<meta name="Description" content="说明一下简单的网络基础概念！">
	<title>鸟哥的 Linux 私房菜 -- 简易网络基础概念</title>
    <script src="../../script/SpryMenuBar.js" type="text/javascript"></script>
	<script src="../../script/index.js" type="text/javascript"></script>
	<link href="../../css/SpryMenuBarHorizontal.css" rel="stylesheet" type="text/css" />
    <link href="../../css/main.css" rel="stylesheet" type="text/css" />
    </head><body style="margin: 0pt; padding: 0pt;" class="table"onload="MM_preloadImages('../../index-2.html','../../index-2.html','../../index-2.html','../../index-2.html','../../index-2.html','../../index-2.html','../../index-2.html','../../index-2.html')">

<center>
<div id="apDiv5">
<div> <LINK REL="SHORTCUT ICON" HREF="../../index-2.html">
<!-- ImageReady Slices (title3.ai) -->
<table id="___01" width="898" height="81" border="0" align="center" cellpadding="0" cellspacing="0";>
	<tr>
		<td colspan="15">
			<img src="image/title/title_01.png" width="900" height="1" alt=""></td>
	</tr>
	<tr>
		<td rowspan="4" bgcolor="#182448"><p><img src="http://linux.vbird.org/cgi-bin/Count.cgi?dd=C&amp;ft=5&amp;sh=T&amp;md=8&amp;pad=Y&amp;df=vbird.dic.ksu.edu.tw.dat" width="93" align="left" title="計數器" /></p>
	    <p><font color="#FFFFFF" size="-1">since2012/04/23</font></p></td>
		<td rowspan="4" align="left" valign="top"><a href="../../index.html"><img src="image/title/title_03.png" alt="" width="263" height="79" border="0"></a></td>
		<td colspan="13">
			<img src="image/title/title_04.png" alt="" width="535" height="9" border="0"></td>
	</tr>
	<tr>
		<td rowspan="3">
			<img src="image/title/title_05.png" alt="" width="53" height="70" border="0"></td>
		<td colspan="2" align="left" valign="top"><a href="../../linux_basic/0110whatislinux.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image51','','image/title/title_06.png',1)"><img src="image/title/title3_06.png" name="Image51" width="106" height="25" border="0" id="Image51" alt=""/></a></td>
		<td rowspan="2">
			<img src="image/title/title_07.png" alt="" width="27" height="37" border="0"></td>
		<td colspan="3" align="left" valign="top"><a href="../0110network_basic.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image52','','image/title/title_08.png',1)"><img src="image/title/title3_08.png" name="Image52" width="107" height="25" border="0" id="Image52" alt=""/></a></td>
		<td rowspan="2">
			<img src="image/title/title_09.png" alt="" width="37" height="37" border="0"></td>
		<td colspan="2" align="left" valign="top"><a href="../../about.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image53','','image/title/title_10.png',1)"><img src="image/title/title3_10.png" name="Image53" width="75" height="25" border="0" id="Image53" alt=""/></a></td>
		<td rowspan="3">
			<img src="image/title/title_11.png" alt="" width="35" height="70" border="0"></td>
		<td align="left" valign="top"><a href="mailto:vbird@mail.vbird.idv.tw" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image54','','image/title/title_12.png',1)"><img src="image/title/title3_12.png" name="Image54" width="74" height="25" border="0" id="Image54" alt=""/></a></td>
		<td rowspan="3">
			<img src="image/title/title_13.png" alt="" width="21" height="70" border="0"></td>
	</tr>
	<tr>
		<td colspan="2">
			<img src="image/title/title_14.png" alt="" width="106" height="12" border="0"></td>
		<td colspan="3">
			<img src="image/title/title_15.png" alt="" width="107" height="12" border="0"></td>
		<td colspan="2">
			<img src="image/title/title_16.png" width="75" height="12" alt=""></td>
		<td rowspan="2">
			<img src="image/title/title_17.png" alt="" width="74" height="45" border="0"></td>
	</tr>
	<tr>
		<td>
			<img src="image/title/title_18.png" alt="" width="15" height="33" border="0"></td>
		<td colspan="3" align="left" valign="top"><ul id="MenuBar1" class="MenuBarHorizontal">
	  <li><a href="../../linux_basic/linux_basic.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image44','','image/title/title_19.png',1)"><img src="image/title/title3_19.png" name="Image44" width="123" height="33" border="0" id="Image44" /></a>
			    <ul>
			      <li><a href="../../linux_basic/Mandrake9.0/mandrake9.0.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image46','','image/title/title_26.png',1)"><img src="image/title/title_23.png" name="Image46" width="120" height="26" border="0" id="Image46" alt="" /></a></li>
                  <li><a href="../../linux_basic/fedora_4/fc4.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image47','','image/title/title_27.png',1)"><img src="image/title/title_24.png" name="Image47" width="120" height="26" border="0" id="Image47" alt="" /></a></li>
                  <li><a href="../../linux_basic/linux_basic.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image48','','image/title/title_28.png',1)"><img src="image/title/title_25.png" name="Image48" width="120" height="26" border="0" id="Image48" alt="" /></a></li>
                </ul>
		      </li>
		</ul></td>
		<td>
			<img src="image/title/title_20.png" alt="" width="42" height="33" border="0"></td>
		<td colspan="3" align="left" valign="top"><ul id="MenuBar2" class="MenuBarHorizontal">
	  <li><a href="../index.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image45','','image/title/title_21.png',1)"><img src="image/title/title3_21.png" name="Image45" width="125" height="33" border="0" id="Image45" /></a>
			    <ul>
			      <li><a href="../linux_redhat9/redhat9.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image43','','image/title/title_26.png',1)"><img src="image/title/title_23.png" name="Image43" width="120" height="26" border="0" id="Image43" alt=""/></a></li>
			      <li><a href="../centos4.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image49','','image/title/title_27.png',1)"><img src="image/title/title_24.png" name="Image49" width="120" height="26" border="0" id="Image49" alt="" /></a></li>
			      <li><a href="../index.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image50','','image/title/title_28.png',1)"><img src="image/title/title_25.png" name="Image50" width="120" height="26" border="0" id="Image50" alt="" /></a></li>
		        </ul>
		      </li>
		</ul></td>
		<td>
			<img src="image/title/title_22.png" alt="" width="47" height="33" border="0"></td>
	</tr>
	<tr>
		<td>
			<img src="image/title/Spacer.gif" width="101" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="263" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="53" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="15" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="91" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="27" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="5" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="42" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="60" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="37" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="28" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="47" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="35" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="74" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="22" height="1" alt=""></td>
	</tr>
</table>
<!-- End ImageReady Slices -->
<script type="text/javascript">
<!--
var MenuBar1 = new Spry.Widget.MenuBar("MenuBar1", {imgDown:"SpryAssets/SpryMenuBarDownHover.gif", imgRight:"SpryAssets/SpryMenuBarRightHover.gif"});
var MenuBar2 = new Spry.Widget.MenuBar("MenuBar2", {imgDown:"SpryAssets/SpryMenuBarDownHover.gif", imgRight:"SpryAssets/SpryMenuBarRightHover.gif"});
//-->
</script>
</div>
<table summary="本文内容的排版" style="width: 898px;" border="0" cellpadding="0" cellspacing="0">
<tbody><tr><td style="width: 16px; height: 16px;">　</td>
    <td style="width: 866px; height: 16px;">　</td>
    <td style="width: 16px; height: 16px;">　</td></tr>
<tr><td style="width: 16px; font-size: 6px;">　</td>
    <td width="866">

<!-- 本文的档头部分 -->
<div style="text-align:center">
    <a href="http://linux.vbird.org/linux_server/0110network_basic/0110network_basic-centos4.php">
    <span class="text_head0">网络基础概念</span></a><br>
</div>
    <div style="text-align:right">
        <span class="text_history">最近升级日期：2007/10/21</span>
    </div>

<center>本文已不再维护，升级文章请参考<a href="http://linux.vbird.org/linux_server/0110network_basic.php">这里</a><br><br></center>

<!-- 本文的档头部分 -->
<center><table class="head1" summary="排版：文章档头的说明"><tbody><tr><td class="head1">
	在金庸的小说里面提到了『欲练神功，挥刀自宫』才能练成无敌的葵花宝典，
	另外，金大侠也提到太极拳的学习到最后需要将所学的忘光光，此时才能『无招胜有招』。
	呵呵～这跟 Linux 有啥关系呐？在前一章我们不是提到关於『<a href="http://linux.vbird.org/linux_server/0110network_basic/0105beforeserver.php">架站前的技巧分析</a>』吗？里面提到在 Linux 里面想要玩架站，
	最重要的是得要搞熟 Linux 相关的操作技巧，这些技巧在一开始时真的得要花很多时间去熟悉，
	真的会让人觉得好像已经『自宫』的样子！不过，别担心，
	等您花时间学习过后，肯定让您忘不了了！因为那时您已经『无招胜有招』啦！
	发生问题时，肯定会依循之前学习到的一贯解决方法去搜寻、解答！很重要的！<br><br>

	在这一章里面，我们得要来谈的就是另一个『神功』啦！那就是网络基础。
	网络基础真的很重要的，包括以太网络硬件的了解可以让您知道如何查出有问题的地方，进一步解决他；
	了解网络协议(IP)与路由(route)让您可以完整的配置好您的网络架构，更可进一步进行子网络的划分，
	以创建更小而美的网络环境！当然还有不可不提的 OSI 网络七层协议，真是重要啊！
	不过，在这一章鸟哥以较为口语的方式来介绍这些基础网络架构，希望能带给朋友们快速了解网络是啥。
	当然，想要更了解网络相关功能的话，文末的参考数据可以参考看看喔！ ^_^
</td></tr></tbody></table></center><br>


<!-- 本文的连结区部分 -->
<div class="block1">
<span class="text_h1">
1. <a href="#whatisnetwork">网络 (Network)</a><br>
	<span class="text_h2">
	　　1.1 <a href="#whatisnetwork_what">什么是网络</a><br>
	　　1.2 <a href="#whatisnetwork_ethernet">以太网络</a><br>
	　　1.3 <a href="#whatisnetwork_osi">OSI 七层协议</a><br>
	</span>
2. <a href="#ipandmac">IP 与 MAC</a><br>
	<span class="text_h2">
	　　2.1 <a href="#ipandmac_mac">传输单位与 MAC</a><br>
	　　2.2 <a href="#ipandmac_ip">IP 的组成</a><br>
	　　2.3 <a href="#ipandmac_network">网域的概念与 IP 的分级</a><br>
	　　2.4 <a href="#ipandmac_netmask">Netmask 的用途与子网络的切分</a><br>
	　　2.5 <a href="#ipandmac_type">IP 的种类与取得方式</a><br>
	　　2.6 <a href="#ipandmac_head">IP 封包的表头</a><br>
	</span>
3. <a href="#route">网络层之路由概念</a><br>
	<span class="text_h2">
	　　3.1 <a href="#route_route">什么是路由</a><br>
	　　3.2 <a href="#route_host">观察主机的路由</a><br>
	</span>
4. <a href="#protocol">常见的通讯协议</a><br>
	<span class="text_h2">
	　　4.1 <a href="#protocol_tcp">TCP 协议</a>： 
		<a href="#protocol_tcp_socket">通讯端口与 Socket</a>, 
		<a href="#protocol_tcp_connect">封包的传送</a>, 
		<a href="#protocol_tcp_3_handshake">三向交握</a><br>
	　　4.2 <a href="#protocol_udp">UDP 协议</a><br>
	　　4.3 <a href="#protocol_icmp">ICMP 协议</a><br>
	　　4.4 <a href="#protocol_mtu">MTU 的限制</a><br>
	　　4.5 <a href="#protocol_firewall">封包过滤的防火墙概念</a><br>
	</span>
5. <a href="#prepare">连上 Internet 前的准备事项</a><br>
	<span class="text_h2">
	　　5.1 <a href="#prepare_dns">什么是主机名称与 DNS</a><br>
	　　5.2 <a href="#prepare_con">一组可以连上 Internet 的必要网络参数</a><br>
	</span>
6. <a href="#review">重点回顾</a><br>
7. <a href="#ex">课后练习</a><br>
8. <a href="#reference">参考数据</a><br>
	<span class="text_h2">
9. <a href="http://phorum.vbird.org/viewtopic.php?t=25884" target="_blank">针对本文的建议：http://phorum.vbird.org/viewtopic.php?t=25884</a><br>
	</span>
</span>
</div>


<!-- 本文的正式部分 -->
<hr><a name="whatisnetwork"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">网络(Network)</span><br>
<div class="block1">
	Linux 这个操作系统的优势之一就是在 (Network) 功能啦！这包含他的高稳定度系统资源分配，
	以及较为安全的网络防备能力！所以很多人都喜欢拿他来进行网络服务器的架设。
	然而，这些网络功能的优点却同时也是缺点，怎么说呢？因为 Linux 网络功能太强了，
	所以一旦被 Cracker (网络怪客) 入侵的话，嘿嘿嘿嘿！会遇上什么灾难你可能也想像不到！
	所以罗，上网之前，请先注意：『我的网络做好安全防护了吗？』<br><br>

	再者，相对於窗口操作系统来说， Linux 的配置确实会让使用者花费比较多的心力，
	毕竟当初它是一群工程师由於本身兴趣而设计出来的，所以依旧具有相当麻烦的配置工作需要作！
	这个时候，如果没有一些网络基础方面的认知的话，那么在 Linux 
	上面配置网络或者是进行网络除错将是您一生当中最大的梦魇......。
	所以，这里有几件事情要请您好好的来参考一下：

	<ul>
	<li><span class="text_import1">熟悉 Linux 操作与 Linux 基础</span>：<br>
		还是要一再地不断强调，如果您确定您只是想要『<span class="text_import2">Linux
		能正常运行就好</span>』那一类型的使用者，那么真的不要再往下看了，因为主机后续的维护问题会很大，
		倒不如花个小钱，请个专家来帮您搞定即可！而如果您确定您是『<span class="text_import2">想要更了解 
		Linux 的使用者，并且想要熟悉架设网站</span>』，
		那么请不要再在网络上询问：『为何我不能使用 FTP 传送数据到主机上？』
		或者是『为何我不能创建个人网页』之类的傻问题，因为这仅仅牵涉到『
		<a href="http://linux.vbird.org/linux_server/linux_basic/0210filepermission.php">文件权限与属性</a>
		』的概念而已，而这些概念都是 Linux 基础里头相当重要的功课！此外，由於远程操控 
		Linux 主机时，几乎都是使用文字界面来工作，所以不懂 
		<a href="http://linux.vbird.org/linux_server/linux_basic/0320bash.php">bash shell</a> ？
		哈哈！那么想要干嘛都码不可能！</li><br>

	<li><span class="text_import1">花几晚的时间将网络基础看一看</span>：<br>
		这一个章节旨在引导网络新鲜人快速进入网络的世界，所以鸟哥写的比较浅显一些些，
		基本上，还有一堆网络硬件与通讯协议并没有被包含在这篇短文里头。
		如果您的求知欲已经高过本章节，那么请自行到书局寻找适合您自己的书籍来阅读！
		当然，您也可以在网际网络上面找到您所需要的数据。
		在本章最后的<a href="#reference">参考数据</a>可以瞧一瞧呐！</li><br>

	<li><span class="text_import1">随时掌握主机信息</span>：<br>
		 这是最麻烦的一点了！因为大家还是常常认为『<span class="text_import2">我的网站这么小，没有人会注意的啦！</span>』唉！
		说过若干次了，就是因为有这种心理存在，我们才会常常听到
		『奇怪！我在早上刚安装完毕，怎么下午就无法以 root 的身份登陆了！』
		请随时注意您主机的信息，好好的爱护他吧！</li>
	</ul>

	好了，底下我们就得要来谈一谈一些重要的网络基础概念了，清醒了没？
	赶紧清醒清醒，准备要好好用功啦！ ^_^<br><br>

	<hr><a name="whatisnetwork_what"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">什么是网络</span><br>
	<div class="block2">
		我们都知道，<span class="text_import2">网络就是几部计算机主机或者是网络打印机之类的周边设备，
		透过网络线或者是无线网络的技术，将这些主机与设备连接起来，
		使得数据可以透过网络媒体(网络线以及其他网络卡等硬件)来传输的一种方式</span>。
		请您想像一下，如果您家里面只有计算机、打印机、传真机等机器，却没有网络连接这些硬件，
		那么使用上会不会很麻烦？如果将这个场景移到需要工作的办公室时，
		计算机的数据无法使用网络连接到打印机来列印，那是否很伤脑筋呢？
		对吧！光用想的就觉得很麻烦吧！不幸的是，这些麻烦事在 1970 年代以前，确实是存在的啊！<br><br>

		<span class="text_import1">各自为政的『硬件与软件』技术发展</span><br>
		<div class="block2">
		在 1970 年代前后，为了解决这个烦人的数据传输问题，各主要信息相关的公司都在研究独自的网络连接技术，
		以使自家的产品可以在办公室的环境底下组织起来。其中比较有名的就是全录公司的 Ethernet 技术，
		以及 IBM 研发的 Token-Ring 技术了。但是这些技术有个很大的问题，那就是这些技术彼此不认识对方的网络技术，
		也就是说，万一你的办公室购买了整合 Ethernet 技术的计算机主机，但是其他的计算机却是使用 IBM 的机器时，
		想要在这两者之间进行数据的沟通，在早期来说那是不可能的。<br><br>
		</div>

		<span class="text_import1">以『软件』技术将硬件整合</span><br>
		<div class="block2">
		但是，这些硬件的技术出现之后，还是对企业造成一定程度的困扰，怎么说呢？
		因为一个公司不太可能仅会使用一家厂商所推出的信息产品吧！所以罗，这么多的硬件技术又该如何整合呐？
		举例来说， IBM 不可能不用自己的 Token-Ring 技术，当然也不会将该技术用在其他公司的硬件上面，
		所以，这些厂商当然只会针对自家的硬件来进行网络传输软件的撰写罗。那么当许多不同公司的产品在自己企业内时，
		您该如何将这些咚咚整合在一起呢？伤脑筋是吧！<br><br>

		所以在 1960 年代末期美国国防部就开始研究一个
		<span class="text_import2">可以在这些不同的网络硬件上面运行的软件技术，
		使得不同公司的计算机或数据可以透过这个软件来达成数据沟通</span>。这个研究由美国国防部尖端研究企画署
		( Defense Advanced Research Project Agency, DARPA )负责，他们将该网络系统称为 ARPANET，
		这个咚咚就是目前熟知的 TCP/IP 技术的雏形了！在 1975 年左右， ARPANET 已可以在常见的
		Ethernet 与 Token-Ring 等硬件平台底下互通数据了。DARPA 在 1980 年正式推出 TCP/IP 技术后，
		由於想要推展此项技术，因此与柏克莱 (Berkeley) 大学合作，将 TCP/IP 植入著名的 BSD Unix 系统内，
		由於大学乃是未来人才数据库的培养处，所以， TCP/IP 这个技术便吸引越来越多使用者的投入，
		而这种连接网络的技术也被称之为 Internet 。<br><br>
		</div>

		<span class="text_import1">没有任何王法的 Internet </span><br>
		<div class="block2">
		现在我们知道 Internet 就是使用 TCP/IP 的网络连接技术所串联起来的一个网络世界，
		而这个 Internet 在 1980 年代之后由於浏览器图形介面的兴起，因此快速的蔓延在计算机世界中。
		但是， Internet 有没有人在管理啊？呵呵！很不巧的是， Internet 是一个管理相当松散的所在。
		只要你能够使用任何支持 TCP/IP 技术的硬件与操作系统，并且实际连接上网络后，
		你就进入 Internet 的世界了。在该世界当中，没有任何王法的保护，您的实际数据如果接上 Internet ，
		在任何时刻都需要自己保护自己，免得中了『流弹』而受伤啊！<br><br>

		为甚么说 Internet 没有王法呢？这是因为 Internet 仅是提供一个网络的连接介面，
		所以您只要连接上 Internet 后，全世界都可以任你遨游，不过也因为如此，『跨海』而来的攻击就成了简单的事件，
		简单说，台湾的法律仅适用台湾地区对吧？但是计算机怪客可以在国外透过 Internet 对你的主机进行攻击，
		我们的法律可管不到国外地区啊！虽然可以透过很多国际管道来寻求协助，不过，还是很难协助你缉拿凶手的啊。
		因此罗，在你的主机要连上 Internet 之前，请先询问自己，真的有需要连上 Internet 吗？^_^<br><br>
		</div>

		<span class="text_import1">软硬件标准制定的成功带来的影响</span><br>
		<div class="block2">
		现在我们常常听到『你要上网啊！？那你要去买网络卡喔！还得要连接到 Internet 才行啊！』
		这个网络卡就是市面上随处可见的一个介面卡而已，至於 Internet 则是去向 Hinet/Seed net 或
		其他网络服务提供公司 (Internet Service Provider, ISP) 申请的帐号口令。
		问题是，是否就仅有网络卡与 Internet 才能上网啊？呵呵！当然不是！网络的硬件与软件可多著那！
		不过，最成功的却是以太网络 (Ethernet) 与 Internet ，这是为甚么呢？这两者的技术比较好吗？
		当然不是！这是因为这两者都被『标准』所支持的缘故。<br><br>

		以太网络最初是由全录 (Xerox PARC) 所建构出来的，而后透过 DEC, Intel 与 Xerox 合作将以太网络标准化。
		再经由 IEEE (Institute of Electrical and Electronic Engineers) 这个国际著名的专业组织利用一个 802 
		的专案制定出标准，之后有 19 家公司宣布支持 IEEE 所发布的 802.3 标准，
		并且到了 1989 年国际标准组织 ISO (International Organization for Standard) 将以太网络编入 IS88023 标准，
		呵呵！这表示以太网络已经是一项公认的标准介面了，如此一来，大家都可以依据这个标准来配置与开发自己的硬件，
		只要硬件符合这个标准，理论上，他就能够加入以太网络的世界，所以，购买以太网络时，
		仅需要查看这个以太网络卡支持哪些标准就能够知道这个硬件的功能有哪些，
		而不必知道这个以太网络卡是由哪家公司所制造的呐。<br><br>

		<div style="padding: 10pt 0pt 10pt 0pt ;" align="right"><table width="90%"><tbody><tr><td><b>Tips:</b><br><span style="color : #009000"><font size="-1">			标准真的是个很重要的东西，真要感谢这些维护标准的专业组织。当有公司想要开发新的硬件时，
			它可以参考标准组织所发布与维护的文件数据，透过这些文件数据后，该公司就知道要制作的硬件需要符合哪些标准，
			同时也知道如何设计这些硬件，让它可以『兼容』於目前的机器，让使用者不会无所适从啊。
			包括软件也有标准，早期 Linux 在开发时就是透过了解 POSIX 这个标准来设计核心的，
			也使得 Linux 上面可以运行大多数的标准介面软件呢！您说，标准是否真的很重要啊！
		</font></span></td><td><img src="0110network_basic-centos4.php_files/vbird_face.gif" alt="鸟哥的图示" title="鸟哥的图示"></td></tr></tbody></table></div>
		当然啦，以太网络的成功除了加入成为国际标准之外，他持续发展成为星型连线也是一个相当重要的影响。
		之后 Novell 的 NetWare 这个网络操作系统支持以太网络，加上 NetWare 的强大功能与支持 IBM 的个人计算机，
		都导致以太网络的流行！直到现在，以太网络是整个办公室与家庭内部的相当重要的一项硬件配备呢！
		他也是等同於基本网络设备的同义字了呐！ ^_^<br><br>

		除了硬件之外，TCP/IP 这个 Internet 的通讯协议也是有标准的，那就是底下的网站所提供的基本文件∶
		<ul><li><a href="http://www.rfc-editor.org/" target="_blank">http://www.rfc-editor.org/</a></li></ul>

		透过这些文件的辅助，任何人只要会写程序语言的话，就有可能发展出自己的 TCP/IP 软件，
		并且连接上 Internet 。早期的 Linux 为了要连接上 Internet ，Linux 团队就自己撰写出 TCP/IP 的程序码，
		透过的就是这些基础文件的标准依据啊！举例来说∶ <a href="ftp://ftp.rfc-editor.org/in-notes/rfc1122.txt" target="_blank">RFC1122</a> 这个建议文件就指出一些基本需求，
		让人们可以了解啊！<br><br>
		</div>

		透过这些软硬件的标准以及实际上很多公司的支持，让现今的网络世界很容易就串接在一起。
		而目前我们最常谈到的就是上面提到的咚咚，硬件就属『以太网络』最为常见，
		软件当然就是 TCP/IP 这个 Internet 最通用的通讯协议罗。那么以太网络是啥？
		为甚么有高速以太网络、超高速以太网络？ TCP/IP 是啥？
		通讯协议是啥？浏览器又是啥？他们之间的关系是怎样？这些东西我们就慢慢来了解一下罗。<br><br>
	</div>

	<hr><a name="whatisnetwork_ethernet"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">以太网络</span><br>
	<div class="block2">
		在目前的网络社会当中，常见的网络硬件包括有最常见的以太网络，当然还有速度算是最快的光纤网络，
		别忘了还有蓝芽无线技术以及 ATM (Asynchronous Transfer Mode, 可不是自动提款机啊！！)
		等硬件。会有这么多网络硬件的原因有很多，
		只要是将各个网络硬件的使用场合分类吧！举例来说，一般家庭使用的网络速度并不需要太高，
		若使用光纤网络，贵的哩！用不起～而企业场合如果仅使用以太网络作为整合介面，
		又可能造成频宽的不足！所以罗，这些硬件各有其优缺点啦！<br><br>
		因此，在谈以太网络之前您必须要了解的是，<span class="text_import2">整个网络世界并非仅有以太网络这个硬件介面</span>，
		只是由於个人计算机的成功以及相关操作系统的支持度，加上以太网络加入成为标准，
		使得以太网络成为目前最为热门的网络硬件技术。
		因此，我们当然得就以太网络来聊一聊啦！事实上，整个以太网络的发展建议您可以直接参考风信子与张民人先生翻译的
		『Switched &amp; Fast 以太网络』一书，该书内容相当的有趣，挺适合阅读的呐。
		底下我们仅做个简单的介绍而已说。<br><br>

		就像前一小节提到的，以太网络最早是由全录这家公司为了自家的硬件设备而发展起来的，
		经由发明者 Metcalfe 大力推动以太网络成为业界的标准后，
		再经由 3Com 发展大量的以太网络硬件，配合越来越流行的兼容於 IBM 的个人计算机，
		以及支持网络的操作系统的流行，最后使得大家都参与以太网络这个介面的发展呐，
		也由於多数公司的量产，使得以太网络设备越来越便宜。早期的一张 10/100 Mbps 的网络卡要价上千元，
		目前最便宜的只要 150 台币就能购买到了！<br><br>

		<span class="text_import1">以太网络的速度</span><br>
		<div class="block2">
			前面说到，以太网络的流行除了相关的硬件以及操作系统的流行之外，『标准』也是一个很重要的因素。
			早先 IEEE 所制订的以太网络标准为 802.3 的 <span class="text_import2">IEEE 10BASE5</span> ，
			这个标准主要的定义是：『<span class="text_import2">10 代表传输速度为 10Mbps，
			BASE 表至采用基频信号来进行传输，至於 5 则是指每个网络节点之间最长可达 500 公尺。</span>』
			网络的传输信息就是 0 与 1 啊，因此，<span class="text_import2">数据传输的单位为每秒多少 bit ，
			亦即是 M bits/second, Mbps 的意思。</span>那么为何制订成为 10Mbps 呢？
			这是因为早期的网络线压制的方法以及相关的制作方法，还有以太网络卡制作的技术并不是很好，
			加上当时的数据传输需求并没有像现在这么高，所以 10Mbps 已经可以符合大多数人的需求了。<br><br>

			当时的网络线使用的是旧式的同轴电缆线，这种线路在现在几乎已经看不到了。
			取而代之的是类似传统电话线的双绞线 (Twisted Pair Ethernet) ，
			IEEE 并将这种线路的以太网络传输方法制订成为 <span class="text_import2">10BASE-T</span>
			的标准。 10BASE-T 使用的是 10 Mbps 全速运行且采用无遮蔽式双绞线 (UTP) 的网络线。此外， 
			10BASE-T 的 UTP	网络线可以使用<span class="text_import2">星形连线(star)，
			也就是以一个集线器为中心来串连各网络设备的一个方法</span>，
			有点类似底下的图示：<br><br>

			<center>
			<img src="0110network_basic-centos4.php_files/0110network_basic_what_01.html" title="星形连线图示" alt="星形连线图示"><br>
			图一、星形连线 (star) 简易图示
			</center><br>

			不同於早期以一条同轴电缆线连结所有的计算机的 bus 连线，
			透过星形连线的帮助，我们可以很简单的加装其他的设备或者是移除其他设备，
			而不会受到其他装置的影响，这对网络设备的扩充性与除错来说，都是一项相当棒的设计！
			也因此 10BASE-T 让以太网络设备的销售额大幅提升啊！<br><br>

			后来 IEEE 更制订了 <span class="text_import2">802.3u 这个支持到 100Mbps 传输速度的 
			100BASE-T 标准，</span>这个标准与 10BASE-T 差异不大，
			只是双绞线线材制作需要更精良，同时也已经支持使用了四对绞线的网络线了，
			也就是目前很常见的八蕊网络线呐！这种网络线我们常称为等级五 (Category 5, CAT5) 的网络线。
			这种传输速度的以太网络就被称为 Fast ethernet 。至於目前我们常常听到的 Gigabit 网络速度
			1000 Mbps 又是什么呐？那就是 Gigabit ethernet 哩！只是 Gigabit ethernet 
			的网络线就需要更加的精良。<br><br>

			为什么每当传输速度添加时，网络线的要求就更严格呢？
			这是因为当传输速度添加时，线材的电磁效应相互干扰会增强，
			因此在网络线的制作时就得需要特别注意线材的质料以及内部线蕊心之间的缠绕情况配置等，
			以使电子流之间的电磁干扰降到最小，才能使传输速度提升到应有的 Gigabit 。
			所以说，在以太网络世界当中，如果您想要提升原有的 fast ethernet 到 gigabit ethernet 的话，
			除了网络卡 (Network Internet Card, NIC) 需要升级之外，主机与主机之间的网络线，
			以及连接主机线路的集线器/交换器等，都必须要提升到可以支持 gigabit 速度等级的设备才行喔！<br><br>
		</div>

		<span class="text_import1">以太网络的网络线接头</span><br>
		<div class="block2">
			前面提到，网络的速度与线材是有一定程度的相关性的，那么线材的接头又是怎样呢？
			目前在以太网络上最常见到的接头就是 RJ-45 的网络接头，共有八蕊的接头，有点像是胖了的电话线接头，
			如下所示：<br>

			<center>
			<img src="0110network_basic-centos4.php_files/rj45.html" title="RJ-45 接头示意图" alt="RJ-45 接头示意图"><br>
			图二、RJ-45 接头示意图
			</center><br>

			而 RJ-45 接头又因为每条蕊线的对应不同而分为 568A 与 568B 接头，
			这两款接头内的蕊线对应如下表：<br><br>

			<table border="1" cellpadding="3" cellspacing="0" cols="2" width="500">
			<tbody><tr><td align="center" width="100">
				<font face="细明体">接头名称</font></td>
				<td><font face="细明体">　1　　2　　3　　4　　5　　6　　7　　8</font></td></tr>
			<tr><td align="center" bgcolor="#CCFFFF">
				<font face="细明体">568A</font></td>
				<td bgcolor="#CCFFFF"><font face="细明体">白绿　绿　白橙　蓝　白蓝　橙　白棕　棕</font></td>
			</tr>
			<tr><td align="center" bgcolor="#66FFFF">
				<font face="细明体">568B</font></td>
				<td bgcolor="#66FFFF"><font face="细明体">白橙　橙　白绿　蓝　白蓝　绿　白棕　棕</font></td>
			</tr>
			</tbody></table><br>

			事实上，虽然目前的以太网络线有八蕊且两两成对，但实际使用的只有 1,2,3,6 蕊而已，
			其他的则是某些特殊用途的场合才会使用到。但由於主机与主机的连线以及主机与集线器的连线时，
			所使用的网络线脚位定义并不相同，因此由於接头的不同网络线又可分为两种：<br>
			<ul><span class="text_import2">
			<li>平行线：两边接头同为 568A 或同为 568B 时称为平行线，用在连结主机网络卡与集线器之间的线材；</li>
			<li>跳线：一边为 568A 一边为 568B 的接头时称为跳线，用在直接连结两部主机的网络卡。</li>
			</span></ul>
			而不同等级的线材除了针对线材材质的电阻等规格加以规范之外，有时为了更好的电磁效应屏蔽功能，
			会将四对蕊线以金属薄膜包覆，以提供更佳的抗干扰能力。
			<span class="text_import2">没有屏蔽的我们就称为无遮蔽双绞线(UTP)，
			有屏蔽的就被称为有遮蔽双绞线(sheild Twisted Pair, STP)。</span>
			STP 的网络线由於加上屏蔽物质，所以较硬、较贵也较不易布线，不过优点则是对於电磁效应屏蔽较佳。
			那么网络线如何选择？以目前来说，由於我们想到达到 Gigabit Ethernet 的网络速度，
			所以必须使用 CAT 5e 以上等级包含 CAT 6 的网络线材才行！那么如何区分？
			其实在网络线上面的缆线表面都会写上这条网络线的相关规范，看一看就知道啦！
			而且还得要看看该条线段是『跳线』还是『平行线』喔！<br><br>
		</div>

		<a name="csmacd"></a>
		<span class="text_import1">数据在以太网络间的传送 (MAC)</span><br>
		<div class="block2">
			接下来要谈的是那么以太网络到底是如何传输数据的呢？
			由於目前办公室内部的以太网络多是利用集线器以及交换器(Hub/Switch)做为中心，
			利用星形连线达成网络环境的一种方式，因此网络线是一个很重要的媒体喔！
			那么网络线里头最多就是电子讯号在跑嘛(就是 0 与 1 啊)！而如果同时有两部计算机要使用这个网络线时，
			怎么可能同时发出两个电子讯号出来呢？这个时候是会发生讯号碰撞的问题的，
			因此，<span class="text_import2">网络共享媒体(包括网络线、集线器等)在单一时间点内，
			仅能被一部主机所使用</span>这个概念必须要先了解才行。<br><br>

			为了杜绝这种讯号碰撞产生的问题，所以以太网络在发展时就使用一种名为<span class="text_import2">
			CSMA/CD (Carrier-Sense Multiple Access with Collision Detection)</span> 的技术。
			这种技术的特点就是当节点想要在网络媒体上面传输数据时，
			会先侦测该媒体上面是否有其他的节点正在使用，确定没有其他节点在使用该媒体时，该节点才会开始传送数据。
			并且，当节点开始传送数据时，节点也能够同时侦测是否有发生碰撞的现象。
			<span class="text_vbird">(注：任何一个具有 MAC 的网络媒体接在该网络上面，就称为一个节点"node"，
			所以，一部主机就是一个 node ！)</span>
			不过，事实上在这样的共享媒体环境下，当网络相当忙碌时，
			数据的碰撞 (collision) 还是会发生的啦！<br><br>

			再来，我们还是得要知道一下『那电子讯号由一部主机发出后，这个讯号怎么知道要传到哪里去？』
			既然有来源也有目标，那当然就得需要一个可以判别讯号来源与等待接受的主机的相关信息罗？
			没错！在以太网络内，我们就是以 <span class="text_import2">MAC 
			(Media Access Control, 媒体存取控制)</span>来管理数据传送的。
			而 <a name="frame"></a><span class="text_import2">MAC 其实就是一个讯框( frame )</span>，
			你可以把他想成是一个在网络线上面传递的包裹，
			而这个包裹是<span class="text_import2">整个网络硬件上面传送数据的最小单位了</span>。
			也就是说，网络线可想成是一条『一次仅可通过一个人』的独木桥，
			而 MAC 就是在这个独木桥上面动的人啦！那 MAC 又该如何判断这独木桥的两端分别是何处呢？
			这就得要看一看 MAC 这个讯框的内容了：<br><br>

			<center><a name="fig_mac"></a>
			<img src="0110network_basic-centos4.php_files/mac.html" title="以太网络的 MAC 讯框" alt="以太网络的 MAC 讯框"><br>
			图三、以太网络的 MAC 讯框
			</center><br>

			在这个 MAC 当中，最重要的就是那个 6 Bytes 的目的与来源位址了！
			事实上，在所有的以太网络卡当中都有一个独一无二的网络卡卡号，
			那就是上头的『目的与来源位址』，这个位址是硬件位址( hardware address )，
			共有 6 bytes ，分别由 00:00:00:00:00:00 到 FF:FF:FF:FF:FF:FF，
			这 6 bytes 当中，前 3bytes 为厂商的代码，后 3bytes 则是该厂商自行配置的装置码了。
			在 Linux 当中，你可以使用 ifconfig 这个命令来查阅你的网络卡卡号喔！
			不过，由於 MAC 主要是与网络卡卡号有关，所以我们也常常将 MAC 作为网络卡卡号的代称。
			<span class="text_import2">特别注意，在这个 MAC 的传送中，他仅在区域网络内生效，
			如果跨过不同的网域 (这个后面 IP 的部分时会介绍)，那么来源与目的的位址就会跟著改变了。
			这是因为变成不同网络卡之间的交流了嘛！所以卡号当然不同了！</span>如下所示：<br><br>

			<center>
			<img src="0110network_basic-centos4.php_files/mac-2.html" title="在不同主机间持续传送相同数据" alt="在不同主机间持续传送相同数据"><br>
			图四、在不同主机间持续传送相同数据的 MAC 讯框变化
			</center><br>

			例如上面的图示，我的数据要由计算机 A 通过 B 后才送达 C ，而 B 计算机有两块网络卡，
			其中 MAC-2 与 A 计算机的 MAC-1 互通，至於 MAC-3 则与 C 计算机的 MAC-4 互通。
			但是 MAC-1 不能与 MAC-3 与 MAC-4 互通，为啥？因为 MAC-1 这块网络卡并没有与 
			MAC-3 及 MAC-4 使用同样的 switch/hub 相接嘛！所以，数据的流通会变成：<br>

			<ol><li>先由 MAC-1 传送到 MAC-2 ，此时来源是 MAC-1 而目的地是 MAC-2；
			</li><li>B 计算机接收后，察看该讯框，发现目标其实是 C 计算机，而为了与 C 计算机沟通，
			所以他会将讯框内的来源 MAC 改为 MAC-3 ，而目的改为 MAC-4 ，如此就可以直接传送到 C 计算机了。</li></ol>

			也就是说，只要透过 B (就是路由器) 才将封包送到另一个网域 (IP 部分会讲) 去的时候，
			那么讯框内的硬件位址就会被改变，然后才能够在同一个网域里面直接进行 frame 的流通啊！<br><br>

			另外，这个 MAC 讯框可以容纳多大的数据啊？？在正规的以太网络当中，
			就如同上<a href="#fig_mac">图三</a>所标示的，一个讯框标准容量最大可达 1500Bytes，
			也就是说，在整条网络上面，一个讯框最大就仅能达到 1500bytes。
			那如果我有 100M Bytes 的数据要传送怎办呢？那您的操作系统会主动的将该 100M bytes 
			的数据拆解成为多个 1500bytes 的讯框后，传送到目的地，再重新组合成为原本 100Mbytes 的文件！
			这里也就可以解释，为什么网络共享媒体一次只能有一部主机使用，
			但是区域网络内的两部计算机却可以同时下载文件？这是因为『每次要发出一个讯框时，
			都需要进行 <a href="#csmacd">CSMA/CD</a> 的监听，而刚刚成功发出讯框的那部主机，
			也需要再使用 <a href="#csmacd">CSMA/CD</a> 来跟大家抢。』
			所以罗，谁能抢到呢？有时后因为网络太忙碌，那么 frame 与 frame 就可能会碰撞啦。<br><br>

			在早期 10/100 Mbps 的年代，这个 1500 bytes 的网络媒体传输数值还没有多大的影响，
			但到了 gigabit 的年代，如果使用的还是 1500 bytes 时，大型的文件将会被拆解成多个 frame ，
			而多个 frame 就意味著主机需要进行多次数据的拆解，网络也需要进行多次的传输。
			如果可以将这个 MAC 的数据存放处加大的话，那么不就可以节省系统资源，
			并且网络传递的次数也会降低，呵呵！没错～在这样的思考逻辑下，於是目前的 Gigabit Ethernet 
			通常都已经支持大的讯框架构，那就是 Jumbo Frame 罗～
			一般来说，只要是 Gigabit 以太网络卡都会支持 Jumbo frame 的 (请参考文末的参考文献连结)，
			他的大小通常是定义在 9000 bytes 的，
			不过其他的以太网络媒体可就不一定了。由於网络媒体支持 Jumbo frame 后，
			他的效能是会有所改善的，所以挑选以太网络媒体时，记得查阅一下该媒体的说明喔！<br>
			<div style="padding: 10pt 0pt 10pt 0pt ;" align="right"><table width="90%"><tbody><tr><td><b>Tips:</b><br><span style="color : #009000"><font size="-1">			由於网络卡卡号是跟著网络卡走的，并不会因为重灌操作系统而改变，
			所以防火墙软件大多也能够针对网络卡来进行抵挡的工作喔！
			不过抵挡网卡仅能在区域网络内进行而已，因为 MAC 不能跨 router 嘛！！
			</font></span></td><td><img src="0110network_basic-centos4.php_files/vbird_face.gif" alt="鸟哥的图示" title="鸟哥的图示"></td></tr></tbody></table></div>		</div>

		<a name="switch_hub"></a>
		<span class="text_import1">共不共享很重要，集线器还是交换器？</span><br>
		<div class="block2">
		刚刚我们上面提到了，当一个很忙碌的网络在运行时，网络共享媒体就可能会发生碰撞的情况，
		这是因为 <a href="#csmacd">CSMA/CD</a> 的缘故。那我们也知道在一个星形连线当中，
		正中央的那个设备是集线器或交换器来连接各 PC 的。
		那么 Hub 与 Switch 有啥不同啊？其实，<span class="text_import2">那个 Hub 就是网络共享媒体，
		Hub 仅是将所有来自 PC 的 frame 再次送出去给所有的 PC 而已，所以他是个共享媒体。</span><br><br>

		Switch 则不然喔！Switch 内部具有微处理器以及内存，这个<span class="text_import2">内存可以记录每个
		switch port 与其连接的 PC 的 MAC 位址</span>，所以，当来自 switch 两端的 PC 要互传数据时，
		每个 frame 将不会透过 <a href="#csmacd">CSMA/CD</a> 的监听，而是透过 switch 
		直接将该 frame 送到目标主机上头去呐！
		也就是说， switch 不是个共享媒体，且 switch 的每个端口 (port) 都具有独立的频宽喔！
		举例来说，10/100 的 Hub 上连结 5 部主机，那么整个 10/100Mbps 是分给这五部主机的，
		所以这五部主机总共只能使用 10/100Mbps 而已。那如果是 switch 呢？由於『每个 port 都具有 10/100Mbps 的频宽』，
		所以就看您当时的传输行为是如何罗！举例来说，如果是底下的状况时，每个连线都是 10/100 Mbps 的。<br><br>

			<center>
			<img src="0110network_basic-centos4.php_files/switch.html" title="Switch 的频宽简介" alt="Switch 的频宽简介"><br>
			图五、Switch 的频宽简介
			</center><br>
		A 传送到 D 与 B 传送到 C 都独自拥有 10/100Mbps 的频宽，两边并不会互相影响！
		不过，如果是 A 与 D 都传给 C 时，由於 C port 就仅有 10/100Mbps ，等於 A 与 D 都需要抢 C 节点的 10/100Mbps 来用的意思。
		总之，你就是得要记得的是，switch 已经克服了封包碰撞的问题，因为他有个 switch port 对应 MAC 的相关功能，
		所以 switch 并非共享媒体喔！同时需要记得的是，现在的 switch 规格很多，
		在选购的时候，千万记得选购可以支持全双工/半双工，以及支持 Jumbo frame 的为佳！<br><br>

		<a name="duplex"></a>
		那什么是<span class="text_import2">全双工/半双工(full-duplex, half-duplex)</span>？
		前面谈到网络线时，我们知道八蕊的网络线实际上仅有两对被使用，一对是用在传送，另一对则是在接收。
		如果两端的 PC 同时支持全双工时，那表示 Input/Output 均可达到 10/100Mbps，
		亦即数据的传送与接收同时均可达到 10/100bps 的意思，总频宽则可达到 20/200Mbps 罗
		(其实是有点语病的，因为 Input 可达 10/100Mbps， output 可达 10/100Mbps ，
		而不是 Input 可直接达到 20/200Mbps 喔！)如果您的网络环境想要达到全双工时，
		使用共享媒体的 Hub 是不可能的，因为网络线脚位的关系，无法使用共享媒体来达到全双工的！
		如果你的 switch 也支持全双工模式，那么在 switch 两端的 PC 才能达到全双工喔！<br><br>

		</div>

		<span class="text_import1">一些常见的以太网络技术</span><br>
		<div class="block2">
		如果您常常在网络上搜寻一些硬件信息时，或者是常常跑到信息卖场去看看新鲜货时，
		应该会注意到一些网络硬件，尤其是越来越普及的 switch 这玩意儿的相关硬件信息吧！
		而且，我们知道网络线因为接头的关系而有平行线与跳线，这两种网络线使用的时机并不相同，
		那么你是否一定需要购买特殊的线段才能够连结 PC 与 switch 呢？呵呵！不需要～
		因为现在的硬件实在太聪明了！底下的功能您应该都可以在新的硬件上面发现的！<br><br>

		<a name="n-way"></a>
		<span class="text_import1">自动协调速度机制</span>：<br>
		我们都知道现在的以太网络卡是可以向下支持的，亦即是 Gigabit 网络卡可以与早期的 10/100Mbps 
		网络卡连结而不会发生问题。但是，此时的网络速度是怎样判定呢？
		早期的 switch/hub 必须要手动切换速度才行，新的 hub/switch 因为有支持 auto-negotiation 又称为 N-Way
		的功能，他可自动的协调出最高的传输速度来沟通喔！如果有 Gigabit 与 10/100Mbps 在 switch 上面，
		则 N-Way 会先使用最高的速度 (gigabit) 测试是否能够全部支持，如果不行的话，就降速到下一个等级亦即
		100 Mbps 的速度来运行的！<br><br>

		<a name="auto_mdi"></a>
		<span class="text_import1">Auto MDI/MDIX</span>：<br>
		那么我们是否需要自行分辨平行线与跳线呢？不需要啦！因为 switch 若含有auto MDI/MDIX 的功能时，
		会自动分辨网络线的脚位来调整连线的，所以您就不需要管你的网络线是跳线还是平行线罗！方便吧！ ^_^<br><br>
		</div>

		<span class="text_import1">讯号衰减造成的问题</span><br>
		<div class="block2">
		由於电子讯号是会衰减的，所以当网络线过长导致电子讯号衰减的情况严重时，
		就会导致连线品质的不良了。因此，连结各个节点的网络线长度是有限制的喔！
		不过，一般来说，现今的以太网络 CAT5 等级的网络线大概都可以支持到 100 公尺的长度，
		所以应该无庸担心才是呐！<br><br>

		但是，造成讯号衰减的情况并非仅有网络线长度而已！如果您的网络线折得太严重(例如在门边常常被门板压，导致变形)
		，或者是自行压制网络线接头，但是接头部分的八蕊蕊线缠绕度不足导致电磁干扰严重，
		或者是网络线放在户外风吹日晒导致脆化的情况等等，都会导致电子讯号传递的不良而造成连线品质恶劣，
		此时常常就会发现偶而可以连线、有时却又无法连线的问题了！因此，当您需要针对企业内部来架设整体的网络时，
		注意结构化布线可是很重要的喔！<br><br>
		</div>

		<span class="text_import1">结构化布线</span><br>
		<div class="block2">
		所谓的结构化布线指的是将各个网络的组件分别拆开，分别安装与布置到企业内部，
		则未来想要提升网络硬件等级或者是移动某些网络设备时，只需要更动类似配线盘的机柜处，
		以及末端的墙上预留孔与主机设备的连线就能够达到目的了。例如底下的图示：<br><br>

			<center>
			<img src="0110network_basic-centos4.php_files/structure.html" title="结构化布线简易图示" alt="结构化布线简易图示"><br>
			图六、结构化布线简易图示
			</center><br>

		在墙内的布线需要很注意，因为可能一布线完成后就使用 5-10 年以上喔！
		那您需要注意的仅有末端墙上的预留孔以及配线端部分。
		事实上，光是结构化布线所需要选择的网络媒体与网络线的等级，
		还有机柜、机架，以及美化与隐藏网络线的材料等等的挑选，以及实际施工所需要注意的事项，
		还有所有硬件、施工所需要注意的标准规范等等，
		已经可以写满厚厚一本书，而鸟哥这里的文章旨在介绍一个中小企业内部主机数量较少的环境，
		所以仅提到最简单的以一个或两个交换器 (swtich) 串接所有网络设备的小型星形连线状态而已，
		如果您有需要相关硬件结构化布线的信息，可以参考风信子兄翻译的『Swtich and Fast 
		以太网络』一书的后半段！至於网络上的高手吗？您可以前往酷学园请教 
		<a href="http://phorum.study-area.org/profile.php?mode=viewprofile&amp;u=801" target="_blank">ZMAN</a> 大哥喔！<br>
		</div>
	</div>

	<hr><a name="whatisnetwork_osi"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">OSI 七层协议</span><br>
	<div class="block2">
		目前我们的主机只要能够取得正确的 IP 与相关参数配置时，你就可以连上 Internet 了，
		根本不管你的网络硬件是以太网络还是光纤网络。而且，你主机的操作系统是啥， Internet 也是不管的！
		这是为什么呢？因为网络的传输是有分层架构的，每个分层 (layer) 是可以独立的。
		同时每个分层都有独自的标准可供依循，例如在网络媒体的硬件部分就可以参考 IEEE 的 802.3 的标准！
		如此一来，大家都可以在自己的分层当中找到相关的标准来配置自己的数据，如此网络连结就变的更容易了。
		关於网络的分层我们最喜欢拿 <span class="text_import2">OSI (Open system Interconnection)</span>
		七层协议来说明喔！
		事实上， OSI 七层协议只是一个参考的模型 (model)，不过，由於 OSI 所定义出来的七层协议相当良好，
		所以拿来当作网络连线解释真是太棒了！底下就来说说吧！<br><br>


<table bgcolor="lightyellow" border="1" cellpadding="3" cellspacing="0" width="95%">
<tbody><tr align="center" bgcolor="#182448"><td width="150"><font color="#FFFFFF">分层</font></td><td><font color="#FFFFFF">负责内容</font></td></tr>
<tr><td align="center">Layer 1<br>实体层<br>Physical Layer, PHY</td>
	<td>在这个层级当中主要定义了最基础的网络硬件标准，包括各种网络线、各种无线连线方式，各种设备规范、
	以及各种接头的守则，还有传输讯号的电压等等，反正与硬件有关的标准大多都在这个层级当中定义的！</td></tr>
<tr bgcolor="lightgreen"><td align="center">Layer 2<br>数据连接层<br>Data-Link Layer</td>
	<td><a name="arp"></a>由於传送数据的网络媒体是以电子讯号进行传送，所以我们的数据要使用这样的讯号传送时，
	就需要制订各种网络型态的讯框 (frame) 了，才能确保数据可以在不同的网络媒体进行传送的动作。
	所以，在这一层当中就制订了 frame 的格式以及通过网络的方式。
	包括讯框的数据格式、错误控制、流量控制、检查数据传输错误的方法等等，都在这里控制。
	既然与讯框有关，当然这个层级就与前面提到的 MAC 有很强烈的相关性罗！<br><br>
	但我们知道事实上目前的 Internet 使用的其实是 IP 来进行连线的啊！但硬件数据却是由讯框所传送的。
	为了要将两者对应 (MAC 与 IP 的对应)，就必须要经由 <span class="text_import2">Address Resolution Protocol (ARP)</span>
	这个协议来帮忙解析出对应才行！</td></tr>
<tr><td align="center">Layer 3<br>网络层<br>Network Layer</td>
	<td>这一层是我们最感兴趣的罗～因为我们提及的 IP (Internet Protocol) 就是在这一层定义的，
	同时也定义出计算机之间的连线创建、终止与维持等，数据封包 (packet) 的传输路径选择等等，
	因此这个层级当中最重要的除了 IP 之外，就是封包能否到达目的地的路由 (route) 概念了！
	此外，这一个网络层可以涵盖实体层与数据连结层，通常我们不需要配置硬件与相关 MAC 的数据，
	就是因为网络层已经 (有点类似) 隐藏了底下两层，让我们只要配置好 IP 就能够上网呐！
	IP 与 route 的部分我们会在下一小节加以介绍的。</td></tr>
<tr bgcolor="lightgreen"><td align="center">Layer 4<br>传送层<br>Transport Layer</td>
	<td>这一个分层定义了发送端与接收端的连线技术(如 TCP 技术)，
	同时包括该技术的封包格式，数据封包的传送、流程的控制、传输过程的侦测检查与复原重新传送等等，
	以确保各个数据封包可以正确无误的到达目的端。</td></tr>
<tr><td align="center">Layer 5<br>会谈层<br>Session Layer</td>
	<td>在这个层级当中主要定义了两个位址之间的连线通道之连接与挂断，此外，亦可创建应用程序之对谈、
	提供其他加强型服务如网络管理、签到签退、对谈之控制等等。如果说传送层是在判断数据封包是否可以正确的到达目标，
	那么会谈层则是在确定网络服务创建连线的确认，例如三向交握。这部分我们会在底下的 TCP 技术当中做个说明。</td></tr>
<tr bgcolor="lightgreen"><td align="center">Layer 6<br>表现层<br>Presentation Layer</td>
	<td>我们在应用程序上面所制作出来的数据格式不一定符合网络传输的标准编码格式的！
	所以，在这个层级当中，主要的动作就是：将来自本地端应用程序的数据格式转换(或者是重新编码)成为网络的标准格式，
	然后再交给底下传送层等的协议来进行处理。所以，在这个层级上面主要定义的是网络服务(或程序)之间的数据格式的转换，
	包括数据的加解密也是在这个分层上面处理。</td></tr>
<tr><td align="center">Layer 7<br>应用层<br>Application Layer</td>
	<td>完全与程序有关的罗，包括定义出文件的读取、复制、开启、关闭等等，
	常见的程序包括有浏览器、数据库处理系统与电子邮件系统等等。</td></tr>
</tbody></table><br>

		事实上，在上述的七层协议当中，前两层(实体与数据连接层)主要就是由一些硬件标准所规范出来的，
		像我们前一小节提到的以太网络之 MAC 讯框相关的格式，以及一些类似以太网络线接头规范、
		<a href="#csmacd">CSMA/CD</a> 的技术等等，都是在前两层进行规范的。<br><br>

		至於网络层与传送层则与 TCP/IP 有关。我们知道目前的 Internet 相关的 IP 与 TCP 封包格式是由
		Internet Network Information Center (INTERNIC) 所统一整理与维护的，至於 
		TCP/IP 的标准则主要以 Request For Comment (RFC) 技术报告的形式公开。
		而会谈、表现与应用层则主要与操作系统及应用程序有关了。<br><br>

		那么这七层到底是如何运行的呢？我们以常见的 WWW 浏览器来进行说明好了。
		假设你想要由奇摩雅虎(tw.yahoo.com)下载一个大於 10Mbytes 的文件，
		那么你必须要由你的主机打开浏览器，并且输入相关的网址列后才能开始下载，对吧！
		不过，我们知道由於网络媒体的关系，标准以太网络的硬件最大仅能支持 1500 bytes 的讯框大小，
		而我要去奇摩雅虎时，必须要知道奇摩雅虎那部主机的 IP 才行，而我们的浏览器使用的是 TCP
		的封包格式。这样一层一层下来，你可以将各个分层想成是一个一个的大袋子，
		而且每个袋子都必须要包含在下一个袋子内，例如 IP 的袋子必须要装在 MAC 讯框的袋子内。<br>

		<ul>
		<li>所以，由於最后被传送的袋子(实体层)的限制，我必须要将 10Mbytes 的文件先切成数个小包，
		然后将这些小包给他包到 TCP 的袋子内，这个袋子记载了我的数据内容。</li>
		<li>然后这个袋子还要装到 IP 这个袋子内，IP 这个袋子会记录我的住址以及要传送到的目的地的住址，</li>
		<li>最后再将这个 IP 的袋子装到 MAC 的讯框袋子内，
		这个袋子就记录了可以在同一区域内传递袋子的网卡卡号了。</li>
		</ul>
		之后这个 MAC 的大袋子就会被带到下个传递点去，
		当然啦， MAC 这个袋子的传递是需要符合 <a href="#csmacd">CSMA/CD</a> 以及以太网络的相关定义的喔！
		当传到目的地后，对方会一个袋子一个袋子的解开，最后拿到他们的数据。不过，由於我的 10Mbytes 
		已经被分成多个小袋子了，所以每个小袋子内需要有序号，这样当所有的小袋子都到达目的地后，
		对方才可以依照这些序号将所有小袋子内的数据给他整合成为原来的数据啊！<br><br>

		所以啊，这些分层可以使用底下的图示来看：<br><br>

			<center>
			<img src="0110network_basic-centos4.php_files/osi_7layer.html" title="OSI 七层协议的相关性" alt="OSI 七层协议的相关性"><br>
			图七、OSI 七层协议的相关性
			</center><br>

<table border="1" cellpadding="5" cellspacing="0" width="90%"><tbody><tr><td>
例题一：请找出您 Linux 主机上面的网络卡硬件位址(Hardware Address, 或 MAC)，
如果已经连上网络的话，请找出您区域网络内其他计算机的网络卡卡号。<br><br>
答：<ul>
在 Linux 底下网络卡的装置代号一般是 eth0 ，所以想要了解您的网络卡卡号时，可以使用：
『 ifconfig eth0 』这个命令来查阅，在出现的数据中第一行最右边搜寻 HWaddr 的后面接的那串咚咚，就是你的卡号。
至於其他的卡号与 IP 的对应方面，直接输入『 arp -n 』应该就可以查阅的到相关的对应表罗！
更多说明请先使用 man 来查询，后续章节我们也会继续加以介绍的。
</ul>
</td></tr></tbody></table>

	</div>
</div>


<hr><a name="ipandmac"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">IP 与 MAC</span><br>
<div class="block1">
	我们现在知道要有网络的话，必须要有网络相关的硬件，而目前最常见的网络硬件介面为以太网络，
	包括网络线、网络卡、Hub/Switch 等等。而以太网络上面的传输使用网络卡卡号为基准的 MAC 讯框，
	配合 <a href="#csmacd">CSMA/CD</a> 的监听技术来传送讯框，这是硬件部分。那么在软件部分，我们知道 Internet
	其实就是 TCP/IP 这个通讯协议的通称，Internet 是由 INTERNIC 所统一管理的，
	但其实他仅是负责分配 Internet 上面的 IP 以及提供相关的 TCP/IP 技术文件而已，
	另外，在 TCP/IP 上面还有很多的应用程序，包括 FTP, HTTP, EMAIL 等等的技术！
	底下我们就先来谈一谈最底层的 MAC 与 IP 吧！<br><br>

	<hr><a name="ipandmac_mac"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">传输单位与 MAC</span><br>
	<div class="block2">
		想一想，如果没有电的话，我们的网络是否能够通行无阻？当然不行！
		因为网络其实就是电子讯号的传送啊！如果没有电，当然就没有办法传送信息了。而电子讯号只有
		0 跟 1 啊，所以在网络单位的计算上，一般通常是以二进位的 bit 为单位的。那么这个
		bit 与我们通常用来计算文件大小的单位 bytes 有什么关连性？其实：<br>
		<ul><span class="text_import2"><b><font face="细明体">1byte = 8bits</font></b></span></ul>
		所以啦，一般来说，我们看到的网络提供者<span class="text_import2"> (Internet
		Services Provider, ISP)</span> 所宣称他们的 ADSL 传输速度可以达到 下行/上行
		2Mbps/128Kbps ( Kbits per second) 时，那个 Kb 指的可不是 bytes 而是 bits
		喔！所以 2M/128K 在实际的文件大小传输速度上面，最大理论的传输为 256KBps/16
		KBps(KBytes per second)，所以正常下载的速度约在每秒 100~200 KBytes 之间呐！
		同样的道理，在网络卡或者是一些网络媒体的广告上面，他们都会宣称自己的产品可以自动辨识传输速度为
		10/100 Mbps ( Mega-bits per second)，呵呵！该数值还是得再除以 8 才是我们一般常用的文件容量计算的单位
		bytes 喔！这样可以了解传输单位的意义了吗？！<br><br>

		那么 MAC 呢？MAC 是 Media Access Control (媒体存取控制)，我们在前小节的
		<a href="#fig_mac">图三</a>已经介绍过该讯框的数据格式，
		且 MAC 常用来做为硬件位址 (Hardware address) 的代称。我们自己主机上面的 MAC 很好解决，
		假设您的网络卡仅有一张，则 Linux 系统内网卡的代号默认由 eth0 开始编号，
		因此当你输入 ifconfig eth0 这个命令时，就会出现如下的信息了：<br>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">在 Linux 环境下</span>
[root@linux ~]# <span class="term_command">ifconfig eth0</span>
eth0      Link encap:Ethernet  <span class="term_write">HWaddr 00:01:03:43:E5:34</span>
          inet addr:192.168.1.100   Bcast:192.168.1.255   Mask:255.255.255.0
          inet6 addr: fe80::201:3ff:fe43:e534/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  <span class="term_write">MTU:1500</span>  Metric:1
.....

<span class="term_hd">在 Windows 环境下</span>
C:\Documents and Settings\admin..&gt; <span class="term_command">ipconfig /all</span>
....
        Physical Address. . . . . . . . . : <span class="term_write">00-01-03-43-E5-34</span>
....
</pre></td></tr></tbody></table>

		<a name="arp2"></a>
		事实上，这个 MAC 几乎都是焊死在网络卡上面的，所以不能够被修改。
		不过，近来有些笔记本计算机上面的网络卡可以透过软件来进行 MAC 的修改罗～
		好，在我们的主机上网络卡可以透过 ifconfig 来查询到 MAC ，但我们知道讯框是在两张网络卡之间传讯的，
		那我如何知道其他主机的网络卡卡号呢？此时就得要透过
		<a href="#arp">ARP (Address Resolution Protocol)</a> 的帮忙了。
		由於 TCP/IP 的通讯协议内大多仅需要了解 IP 即可，但讯框却是透过 MAC 来传递，
		因此 IP 与 MAC 就得要透过一个解析的功能罗！那就是 ARP 啦！<br><br>

		当我们的主机想要找出目标 IP 时，就会对整个区域网络进行广播封包(broadcast)的传送，
		这个广播封包可以对所有区域网络内的计算机要求回报他的 IP 与 MAC ，
		当目标 IP 看到这个广播封包时，就会回应您主机相关的 MAC 信息，如果非目标主机接到这个封包，
		就会主动的忽略！如此一来，你就可以取得目标主机的 MAC 罗！
		而这个目标主机的 MAC 就会被记录到你的主机内的 ARP table (ARP table 在内存中)，
		不过还是要再次的提醒， MAC 是不能跨路由的，请参考图四的相关说明喔！
		如果想要查阅你的 ARP 记录，可以使用 arp 这个命令即可。<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">arp -[nd] hostname</span>
[root@linux ~]# <span class="term_command">arp -s hostname(IP) Hardware_address</span>
<span class="term_say">参数：
-n ：将主机名称以 IP 的型态显示
-d ：将 hostname 的 hardware_address 由 ARP table 当中删除掉
-s ：配置某个 IP 或 hostname 的 MAC 到 ARP table 当中 </span>
<span class="term_hd">范例一：</span>
[root@linux ~]# <span class="term_command">arp -n</span>
Address            HWtype  HWaddress           Flags Mask    Iface
192.168.1.100      ether   00:01:03:01:02:03      C          eth0
192.168.1.240      ether   00:01:03:01:DE:0A      C          eth0
192.168.1.254      ether   00:01:03:55:74:AB      C          eth0
<span class="term_hd">范例二：</span>
[root@linux ~]# <span class="term_command">arp -s 192.168.1.100  01:00:2D:23:A1:0E</span>
<span class="term_say"># 这个命令的目的在创建静态 ARP </span>
</pre></td></tr></tbody></table>

		如同上面的表格，我主机上面的 ARP 记录著这么多的 IP 与 MAC 的对应，
		这个 ARP 的好处可多了！由於有记录 MAC 与 IP 的对应，因此当下回我的数据又传送到同一部主机时，
		我的主机会主动的传送到同一个 MAC 去，而不需要再次透过 broadcast 来查询 MAC，
		所以省去了很多网络延迟的时间喔！此外，特别注意的是，
		<span class="text_import2">ARP table 是动态的信息</span>，他会随时随著您的网域里面计算机的
		IP 更动而变化，所以，即使您常常更动您的计算机 IP，不要担心，因为 ARP table
		会自动的重新对应 IP 与 MAC 的表格内容！但如果你有特殊需求的话，
		也可以利用『 arp -s 』这个参数来定义静态的 ARP 对应喔！<br><br>
	</div>

	<hr><a name="ipandmac_ip"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">IP 的组成</span><br>
	<div class="block2">
		好了，接下来可以开始介绍那个可爱的 TCP/IP 里头的 IP 啦！这个 IP 是
		Internet Protocol 的缩写，他的功能有点像是『门牌号码』，主要是在网络层( Layer 3 )的功能，
		那么这个 IP 有哪些重要的地方需要了解的呢？底下我们就来谈一谈吧！<br><br>

		IP 是一种数据封包的格式，这个 IP 数据封包最大可以到达 65535 bytes ，
		然而就如同<a href="#fig_mac">图三</a>以太网络讯框的数据所示，
		由於标准以太网络讯框可包含的数据最大仅达 1500 bytes ，
		并且依照不同的网络媒体而有不同的 MAC 讯框大小，我们前面也谈到的 OSI 七层协议当中，
		由於 IP 封包必须要放到 MAC 讯框当中，因此 IP 封包在 Internet 上面应该是不可能达到 65535 bytes
		这个值的(因为必须小於 MAC 讯框所能容许的最大值)。另外，
		由於网络连线过程当中封包所经过的网络媒体各不相同，因此 MAC 讯框大小当然也不同，
		而为了让 IP 封包可以适用在所有的网络媒体讯框当中，因此， 
		<span class="text_import2">IP 封包是可以被『重组的』</span>！<br><br>

		我们知道 MAC 讯框表头 (将他想成是一个信封袋外面的记录数据) 当中最重要的就是网络卡卡号 
		(hardware address) 这个咚咚！(参考<a href="#fig_mac">图三</a> )，那么 IP 
		表头最重要的是什么呢？呵呵！那就是 IP 位址 (address) 了！目前我们在 Internet 上面使用的 IP
		协议是第四版，通称为 <span class="text_import2">IPv4</span> ，这个版本的 <span class="text_import2">IP 
		位址主要是由 32 bits 的数据所组成的一组数据</span>，也就是 32 个 0 跟 1 
		所组成的数据数据，因为只有零跟一，所以
		IP 的组成当然就是计算机认识的二进位的表示方式了。<br><br>

		不过，因为人类对於二进位实在是不怎么熟悉，所以为了顺应人们对於十进位的依赖性，因此，就将
		32 bits 的 IP 分成四小段，每段含有 8 个 bits ，将 8 个 bits 
		计算成为十进位，并且每一段中间以小数点隔开，那就成了目前大家所熟悉的
		IP 的书写模样了。如下所示：<br>

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">IP 的表示式：</span>
00000000.00000000.00000000.00000000   ==&gt; <span class="term_write">0.0.0.0</span>
11111111.11111111.11111111.11111111   ==&gt; <span class="term_write">255.255.255.255</span>
</pre></td></tr></tbody></table>

		所以 IP 最小可以由 0.0.0.0 一直到 255.255.255.255 哩！事实上， IP 的组成当中，除了以
		32 bits 的组成方式来说明外，还具有所谓的『网域』的概念存在。底下就来谈一谈什么是网域吧！<br><br>
	</div>

	<hr><a name="ipandmac_network"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">网域的概念与 IP 的分级</span><br>
	<div class="block2">
		事实上在 IP 的 32 bits 数据中，主要分为 HOST_ID 与 Net_ID 两部份，我们先以
		192.168.0.0 ~ 192.168.0.255 这个 C Class 的网域当作例子来说明好了：

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">192.168.0.0~192.168.0.255 这个 C Class 的说明：</span>
11000000.10101000.00000000.00000000
11000000.10101000.00000000.11111111
<span class="term_write">|----------Net_ID---------|-host--|</span>
</pre></td></tr></tbody></table>

		在 C Class 的范例当中，前面三组数字 (192.168.0) 称为网域号码 (Net_ID) ，最后面一组数字则称为
		主机号码 (Host_ID)。同一个网域当中的定义是『<span class="text_import2">在同一个物理网段内，主机的
		IP 具有相同的 Net_ID ，并且具有独特的 Host_ID</span>』，那么这些 IP 群就是同一个网域内的
		IP 网段啦！ <br>

		<div style="padding: 10pt 0pt 10pt 0pt ;" align="right"><table width="90%"><tbody><tr><td><b>Tips:</b><br><span style="color : #009000"><font size="-1">		什么是物理网段呢？当所有的主机都是使用同一个网络媒体串在一起，
		这个时候这些主机在实体装置上面其实是连线在一起的，那么就可以称为这些主机在同一个物理网段内了！
		同时并请注意，同一个物理网段之内，可以依据不同的
		IP 的配置，而配置成多个『IP 网段』喔！
		</font></span></td><td><img src="0110network_basic-centos4.php_files/vbird_face.gif" alt="鸟哥的图示" title="鸟哥的图示"></td></tr></tbody></table></div>
		上面例子当中的 192.168.0.1, 192.168.0.2, ...., 192.168.0.255 这些 IP 就是同一个网域内的
		IP 群(同一个网域也称为同一个网段！)，请注意，同一个 Net_ID 内，不能具有相同的
		Host_ID ，否则就会发生 IP 冲突，可能会造成两部主机都没有办法使用网络的问题！
		那么同一个网域该怎么配置，与将 IP 配置在同一个网域之内有什么好处呢？<br>

		<ul><span class="text_import2">
		<li>在同一个网段内，Net_ID 是不变的，而 Host_ID 则是不可重复，此外，
		Host_ID 在二进位的表示法当中，不可同时为 0 也不可同时为 1 ，例如上面的例子当中，
		192.168.0.0 ( Host_ID 全部为 0 )以及 192.168.0.255 ( Host_ID 全部为 1 )
		不可用来作为网段内主机的 IP 配置，也就是说，这个网段内可用来配置主机的
		IP 是由 192.168.0.1 到 192.168.0.254；<br><br></li>

		<li>在同一个网域之内，每一部主机都可以透过 MAC 讯框的格式传递数据，
		并透过 ARP 协议与广播封包 (broadcast) 取得 MAC 与 IP 的对应后，直接利用 MAC 讯框传递数据。
		<br><br></li>

		<li>在同一个物理网段之内，如果两部主机配置成不同的 IP
		网段，则两部主机无法直接以 MAC 讯框格式进行数据的传递，因为广播封包无法查询到 MAC 与 IP 的对应。
		<br><br></li>

		<li>当 Host_ID 所占用的位越大，亦即 Host_ID 数量越多时，表示同一个网域内可用以配置主机的 IP 
		数量越多。<br></li></span></ul>

		所以说，贵单位公司内的计算机群，或者是您宿舍或家里面的所有计算机，当然都配置在同一个网域内是最方便的，
		因为如此一来每一部计算机都可以直接透过 MAC 来进行数据的交流，而不必经由
		Router ( 路由器 ) 来进行封包的转递呢！( Router 这部份在后续才会提及！ )。<br><br>

		<span class="text_import1">IP 的分级</span><br>
		<div class="block2">
		好了，现在我们知道 Net_ID 越大时，表示 Host_ID 越少，亦即网域内可以分配的 IP 数量就越少了！
		咦！这表示 Net_ID 是有分级的喔！是啊！没错～刚刚上面那个 192.168.0.0~192.168.0.255 称为 Class C，
		那还有哪些等级啊？目前 Internet 将 IP 简单的分类成为三种常见的等级，亦即所谓的 A, B, C class，
		他们代表的意义如下：

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">以二进位说明 Network 第一个数字的定义：</span>
A Class : <span class="term_write">0</span>xxxxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx  <span class="term_say">==&gt; NetI_D 的开头是 0
          |--net--|---------host------------|</span>
B Class : <span class="term_write">10</span>xxxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx  <span class="term_say">==&gt; NetI_D 的开头是 10
          |------net-------|------host------|</span>
C Class : <span class="term_write">110</span>xxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx  <span class="term_say">==&gt; NetI_D 的开头是 110
          |-----------net-----------|-host--|</span>

<span class="term_hd">三种分级在十进位的表示：</span>
A Class : <span class="term_write">  0.xx.xx.xx ~ 126.xx.xx.xx</span>
B Class : <span class="term_write">128.xx.xx.xx ~ 191.xx.xx.xx</span>
C Class : <span class="term_write">192.xx.xx.xx ~ 223.xx.xx.xx</span>
</pre></td></tr></tbody></table>

		在上表中，可能您会觉得很奇怪，咦！那个
		127.xx.xx.xx 怎么不见了？！他应该也是 A Class 的一段吧？！没错，是不见了，
		因为这个网段被拿去给操作系统做为<span class="text_import2">内部回圈网络
		( <a href="#loopback">loopback</a> )</span> 之用了！在各个操作系统当中，不管该主机的硬件有没有网络卡，
		为了让作业确认自己的网络没有问题，所以将
		127.xx.xx.xx 这个 A Class 的网段拿到操作系统当中，来做为内部的回路测试！所以啦，这个
		127.0.0.1 就不可以用来做为其他网络卡的网络网域之配置喔。<br><br>
	</div>
	</div>

	<hr><a name="ipandmac_netmask"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">Netmask 的用途与子网络的切分</span><br>
	<div class="block2">
		在上一小节当中提到的 A, B, C 三个层级的网域是由 IP 协议默认分配的，在这样的层级当中，我们可以发现
		A Class 可以用於配置计算机主机的 IP 数量 ( Host ) 真的是很多，在同一个 A
		Class 的网域内，主机的数量可以达到『 <span class="text_import2">256 X 256 X
		256 - 2(Host_ID 全为 0 或 1 ) = 16777214</span>』，不过，
		这样的配置情况对於一般网络的效能却是不太好的！为什么呢？<br><br>

		让我们回到前面<a href="#csmacd">以太网络的 MAC 运行模式</a>那个小节，我们知道在共享媒体上面，
		每当任何一部主机想要使用该网络媒体时，就得要利用 <a href="#csmacd">CSMA/CD</a> 
		的方式去进行网络监听的工作，此时对於这么大的一个网络架构来说，每部主机要发出 MAC 讯框前要进行的这个
		<a href="#csmacd">CSMA/CD</a> 实在会造成系统上面很严重的停顿问题啊！
		因为封包碰撞 (collision) 以及在进行 MAC 与 IP 对应的广播 (broadcast) 时，
		要回应的主机数量也真是太多了点吧！
		如此一来，整个网络的效能将会变的很糟糕！所以，一般来说，我们最多都仅配置
		C Class 做为整个区域网络的架构，其实就连 C Class 也都太大了！不过不打紧，只要记得一个网域内不要超过
		30 部以上的主机数量，那样网络的效能就会比较好一点～<br><br>

		其实，除了 C Class 之外，我们还是可以继续将网络切的更细的！上个小节我们提到
		IP 这个 32 bits 的数值中分为 Net_ID 与 Host_ID，其中 C Class 的 Net_ID 占了 
		24 bits ，而其实我们还可以将这样的网域切的更细，<span class="text_import1">就是让第一个
		Host_ID 被拿来作为 Net_ID</span> ，所以，整个 Net_ID 就有 25 bits ，至於 Host_ID
		则减少为 7 bits 。在这样的情况下，<span class="text_import2">原来的一个 C Class 
		的网域就可以被切分为两个子网域</span>，而每个子网域就有『
		<span class="text_import2">256/2 - 2 = 126</span> 』个可用的 IP 
		了！这样一来，在这个网域当中的主机在进行逻辑广播时，回应的主机数量就少了一半，
		当然对於网络的效能多多少少有点好处的啦！<br><br>

		<a name="netmask"></a>
		好了，知道了子网络切分的大致情况后，现在要谈的是，那么到底是什么参数来达成子网络的切分呢？呵呵！那就是
		Netmask ( 子网络遮罩 ) 的用途啦！这个 Netmask 是用来定义出网域的最重要的一个参数了！不过他也最难理解了～
		@_@。为了帮助大家比较容易记忆住 Netmask 的配置依据，底下我们介绍一个比较容易记忆的方法。同样以
		192.168.0.0~192.168.0.255 这个网域为范例好了，如下所示，这个 IP 网段可以分为
		Net_ID 与 Host_ID，既然 Net_ID 是不可变的，那就假设他所占据的 bits 已经被用光了
		( 全部为 1 )，而 Host_ID 是可变的，就将他想成是保留著 ( 全部为 0 )，所以，
		Netmask 的表示就成为：

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">192.168.0.0~192.168.0.255 这个 C Class 的 Netmask 说明</span>
11000000.10101000.00000000.00000000
11000000.10101000.00000000.11111111<span class="term_write">
|----------Net_ID---------|-host--|
11111111.11111111.11111111.00000000  &lt;== Netmask 二进位
  255   .  255   .  255   .   0      &lt;== Netmask 十进位</span>
</pre></td></tr></tbody></table>

		将他转成十进位的话，就成为『<span class="text_import2">255.255.255.0</span>』啦！
		这样记忆简单多了吧！照这样的记忆方法，那么 A, B, C Class 的 Netmask 表示就成为这样：

<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">Class A, B, C 三个等级的 Netmask 表示方式：</span>
A Class : <span class="term_write">11111111.</span>00000000.00000000.00000000 ==&gt; 255.  0.  0.  0
B Class : <span class="term_write">11111111.11111111.</span>00000000.00000000 ==&gt; 255.255.  0.  0
C Class : <span class="term_write">11111111.11111111.11111111.</span>00000000 ==&gt; 255.255.255.  0
</pre></td></tr></tbody></table>

		所以说， 192.168.0.0~192.168.0.255 这个 C Class 的网域中，他的 Netmask
		就是 255.255.255.0 了！再来，我们刚刚提到了<span class="text_import2">当 Host_ID 全部为 0 以及全部为
		1 的时后该 IP 是不可以使用的，因为 Host_ID 全部为 0 的时后，表示 IP 是该网段的
		Network ，至於全部为 1 的时后就表示该网段最后一个 IP ，也称为 Broadcast</span>
		，所以说，在 192.168.0.0 ~ 192.168.0.255 这个 IP 网段里面的相关网络参数就有：

<table class="term"><tbody><tr><td class="term"><pre>Netmask:   255.255.255.0   <span class="term_say">&lt;==网域定义中，最重要的参数</span>
Network:   192.168.0.0     <span class="term_say">&lt;==第一个 IP</span>
Broadcast: 192.168.0.255   <span class="term_say">&lt;==最后一个 IP</span>
可用以配置成为主机的 IP 数：
<span class="term_write">192.168.0.1 ~ 192.168.0.254</span>
</pre></td></tr></tbody></table>

		一般来说，如果我们知道了 Network 以及 Netmask 之后，就可以定义出该网域的所有
		IP 了！因为由 Netmask 就可以推算出来 Broadcast 的 IP 啊！因此，我们常常会以
		Network 以及 Netmask 来表示一个网域，例如这样的写法：

<table class="term"><tbody><tr><td class="term"><pre><span class="term_write">Network/Netmask
192.168.0.0/255.255.255.0
192.168.0.0/24</span>    <span class="term_say">&lt;==因为 Net_ID 共有 24 个 bits</span>
</pre></td></tr></tbody></table>

		另外，既然 Netmask 里面的 Net_ID 都是 1 ，那么 C Class 共有 24 bits
		的 Net_ID ，所以啦，就有类似上面 192.168.0.0/24 这样的写法罗！这就是一般网域的表示方法。好了，刚刚提到
		C Class 还可以继续进行子网域 ( Subnet ) 的切分啊，以 192.168.0.0/24 
		这个情况为例，他要如何再细分为两个子网域呢？我们已经知道
		Host_ID 可以拿来当作 Net_ID，那么 Net_ID 使用了 25 bits 时，就会如下所示：


<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">原本的 C Class 的 Net_ID 与 Host_ID 的分别</span>
11000000.10101000.00000000.00000000     <span class="term_say"> Network:   192.168.0.0</span>
11000000.10101000.00000000.11111111     <span class="term_say"> Broadcast: 192.168.0.255</span>
<span class="term_write">|----------Net_ID---------|-host--|</span>

<span class="term_hd">切成两个子网络之后的 Net_ID 与 Host_ID 为何？</span>
<span class="term_write">11000000.10101000.00000000.0</span> 0000000  <span class="term_say">多了一个 Net_ID 了, 为0</span>
<span class="term_write">11000000.10101000.00000000.1</span> 0000000  <span class="term_say">多了一个 Net_ID 了, 为1
|----------Net_ID-----------|-host--|</span>

<span class="term_hd">第一个子网络</span>
Network:   <span class="term_write">11000000.10101000.00000000.0 0000000</span>   192.168.0.0
Broadcast: <span class="term_write">11000000.10101000.00000000.0 1111111</span>   192.168.0.127
           |----------Net_ID-----------|-host-|
Netmask:   <span class="term_write">11111111.11111111.11111111.1 0000000</span>   255.255.255.128
所有 IP 与网域表示式：
<span class="term_write">192.168.0.0/25 或 192.168.0.0/255.255.255.128</span>

<span class="term_hd">第二个子网络</span>
Network:   <span class="term_write">11000000.10101000.00000000.1 0000000</span>   192.168.0.128
Broadcast: <span class="term_write">11000000.10101000.00000000.1 1111111</span>   192.168.0.255
           |----------Net_ID-----------|-host-|
Netmask:   <span class="term_write">11111111.11111111.11111111.1 0000000</span>   255.255.255.128
所有 IP 与网域表示式：
<span class="term_write">192.168.0.128/25 或 192.168.0.128/255.255.255.128</span>
</pre></td></tr></tbody></table>

		所以说，当再细分下去时，就会得到两个子网域，而两个子网域还可以再细分下去喔
		(Net_ID 用掉 26 bits ....)。呵呵！如果您真的能够理解 IP, Network, Broadcast,
		Netmask 的话，恭喜您，未来的服务器学习之路已经顺畅了一半啦！ ^_^<br><br>

<table border="1" cellpadding="5" cellspacing="0" width="90%"><tbody><tr><td>
例题二：请试著计算出 172.16.0.0/23 这个网域的 Netmask, Network, Broadcast 等参数<br><br>
答：<ul>
由於 172.16.xxx.xxx 是在 Class B 的等级当中，亦即 172.16.0.0/16 才对。不过题目中询问的是 172.16.0.0/23，
等於是向 Host_ID 借了 7 个 bits 用在 Net_ID 当中。所以整个 IP 
的位址会变成这样：<span class="text_import2"><pre>默认：       172  .  16    .0000000 <b>0.00000000</b>
          |----Net_ID--------------|<b>--Host---|</b>
Network:     172  .  16    .0000000 <b>0.00000000</b>   172.16.0.0
Broadcast:   172  .  16    .0000000 <b>1.11111111</b>   172.16.1.255
Netmask:  11111111.11111111.1111111 <b>0.00000000</b>   255.255.254.0</pre></span>
鸟哥在这里有偷懒，因为这个 IP 段的前 16 个 bits 不会被改变，所以并没有计算成二进位( 172.16 )，
真是不好意思啊～至於粗体部分则是代表 host_ID 啊！
</ul>
</td></tr></tbody></table><br>

	</div>

	<hr><a name="ipandmac_type"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">IP 的种类与取得方式</span><br>
	<div class="block2">
		接下来要跟大家谈一谈也是很容易造成大家困扰的一个部分，那就是 IP 的种类！很多朋友常常听到什么『真实IP,
		实体 IP, 虚拟 IP, 假的 IP....』烦都烦死了～其实不要太紧张啦！实际上，在
		IPv4 里面就只有两种 IP 的类别，分别是：
		<ul><li><span class="text_import1">Public IP</span> : 公共 IP ，经由 INTERNIC 所统一规划的 IP，
			有这种 IP 才可以连上 Internet ；<br><br></li>
		<li><span class="text_import1">Private IP</span> : 私有 IP 或保留 IP，不能直接连上 Internet 的 IP ，
			主要用於区域网络内的主机连线规划。</li></ul>

		早在 IPv4 规划的时候就担心 IP 会有不足的情况，而且为了应付某些私有网络的网络配置，於是就有了私有
		IP ( Private IP ) 的产生了。私有 IP 也分别在 A, B, C 三个 Class 当中各保留一段作为私有
		IP 网段，那就是：

		<ul><span class="text_import2"><font face="细明体">
		<li>A Class：10.0.0.0&nbsp;&nbsp;&nbsp; - 10.255.255.255</li>
		<li>B Class：172.16.0.0&nbsp; - 172.31.255.255</li>
		<li>C Class：192.168.0.0 - 192.168.255.255</li>
		</font></span></ul>

		由於这三个 Class 的 IP 是预留使用的，所以<span class="text_import2">并不能直接作为
		Internet 上面的连接之用</span>，不然的话，到处都有相同的
		IP 罗！那怎么行！网络岂不混乱？所以罗，这三个 IP 网段就只做为内部私有网域的
		IP 沟通之用，也就是说，他有底下的几个限制：
		<ul><span class="text_import2">
		<li>私有位址的路由信息不能对外散播 （就是内部网络咯）；</li>
		<li>使用私有位址作为来源或目的地址的封包，不能透过 Internet 来转送 （呵呵！当然罗！不然网络会混乱）；</li>
		<li>关於私有位址的参考纪录(如DNS)，只能限于内部网络使用（一样的原理啦！）</li>
		</span></ul>

		这个私有 IP 有什么好处呢？呵呵！由於他的私有路由不能对外直接提供信息，所以呢，
		你的内部网络将不会直接被 Internet 上面的 Cracker 所攻击！但是，你也就无法以私有
		IP 来『直接上网』罗！所以相当适合一些尚未具有
		Public IP 的企业内部用来规划其网络之配置之用！否则当你随便指定一些可能是
		Public IP 的网段来规划你企业内部的网络配置时，万一哪一天真的连上
		Internet 了，那么启不是可能会造成跟 Internet 上面的 Public IP 相同了吗？
		这可不是闹著玩的，要将你原先规划的
		IP 网段整个重新调整过呢！哈哈！累死了！<br><br>

		那么万一你又要将这些私有 IP 送上 Internet 呢？呵呵！这个简单，配置一个简单的防火墙加上 NAT ( Network
		Address Transfer ) 主机配置，你就可以透过
		IP 伪装(不要急，这个在后面也会提到！)来使你的私有
		IP 的计算机也可以连上 Internet 罗(虽然不是真的直接，但是很像『直接上网』呢！)<br><br>

		<a name="loopback"></a><span class="text_import1">特殊的 loopback IP 网段</span><br>
		<div class="block2">
		好了，那么除了这个预留的 IP 网段的问题之外，还有没有什么其他的怪东西呢？呵呵！
		当然是有啦！不然鸟哥干嘛花时间来唬 XX 呢！？没错，还有一个奇怪的 A Class 的网域，那就是 lo 
		这个奇怪的网域啦( 注意：是小写的 o 而不是零喔！ )这个 lo 
		的网络是当初被用来作为测试操作系统内部回圈所用的一个网域，
		同时也能够提供给系统内部原本就需要使用网络介面的服务(daemon)所使用。<br><br>

		简单的说，如果你没有安装网络卡在的机器上面，
		但是你又希望可以测试一下在你的机器上面配置的服务器环境到底可不可以顺利运行，这个时候怎么办，
		嘿嘿！就是利用这个所谓的内部回圈网络啦！这个网段在
		127.0.0.0/8 这个 A Class ，而且默认的主机 ( localhost ) 的 IP 是 127.0.0.1
		呦！所以罗，当你启动了你的 WWW 服务器，然后在你的主机的 X-Window 上面运行
		http://localhost 就可以直接看到你的主页罗！而且不需要安装网络卡呢！测试很方便吧！<br><br>

		此外，你的内部使用的 mail 怎么运送邮件呢？例如你的主机系统如何
		mail 给 root 这个人呢？嘿嘿！也就是使用这一个内部回圈啦！当要测试你的
		TCP/IP 封包与状态是否正常时，可以使用这个呦！( 所以哪一天有人问你嘿！你的主机上面没有网络卡，
		那么你可以测试你的 WWW 服务器配置是否正确吗？这个时候可得回答：当然可以罗！使用 127.0.0.1
		这个 Address 呀！ ^_^... )<br><br>
		</div>

		<span class="text_import1">IP 的取得方式</span><br>
		<div class="block2">

		谈完了 IP 的种类与等级还有相关的子网域概念后，接下来我们得来了解一下，那么主机的 IP 是如何配置的呢？
		基本上，主机的 IP 与相关网域的配置方式主要有：<ul>
		<li><span class="text_import2">固定制手动配置(static)</span>：
			我们可以取得固定的 Public IP ，取得的管道可以是学术网络、或者是向 ISP 注册固定的 
			Public IP。不过，在使用固定的 Public IP 时，你必须要手动的在你的操作系统配置好网络参数；
			<br><br></li>
		<li><span class="text_import2">宽带拨接制(ADSL)</span>：
			除了上述的方法之外，传统的以调制解调器拨接，以及目前很流行的
			ADSL 拨接，都是另一个取得 Public IP 的方法。
			早期的拨接制 ADSL 所取得的 IP 通常是由 ISP 随机提供，因此每次拨接所取得的 IP 可能都不固定，
			所以也有人称这种取得 IP 的方式为浮动式 IP 取得方式。不过近来由於个人用户架站风行，
			为因应用户的需求，某些 ISP 也提供很多不同的 IP 分配机制。
			包括 hinet, seednet 等等都有提供 ADSL 拨接后取得固定 IP 的方式喔！
			详情请向您的 ISP 洽询。<br><br></li>
		<li><span class="text_import2">缆线(Cable modem)</span>：
			利用单向或者是双向 Cable 也可以向 ISP 注册取得 Public IP；</li>
		</ul>

		请记得，IP 就只有 Public 与 Private IP 这两种，而由於取得
		IP 的方法不同，可能又有人喜欢宣称浮动式、固定制、动态等等的 IP ，
		这很容易造成刚刚接触网络的朋友们的困扰！所以这里仅告诉大家记得『<span class="text_import2">Public
		与 Private IP</span>』而已！你只要记得他就对了！其他的，以后自然就会理解的啦！^_^<br>
		</div>
	</div>

	<hr><a name="ipandmac_head"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">IP 封包的表头</span><br>
	<div class="block2">
		现在我们知道 IP 这个数据封包 (packet) 是需要放置在 MAC 讯框里面的，所以当然不能比 MAC 
		所能容许的最大数据量还大！但是 IP 封包其实可以到 65535 bytes 那么大的呐！
		那么 IP 封包除了数据之外，他的表头数据 (head) 是长怎样呢？
		在<a href="#fig_mac">图三的 MAC 讯框表头</a>里面最重要的莫过於那个网络卡硬件位址，
		那么在 IP 表头里面当然就以来源与目标的 IP 位址为最重要罗！
		除此之外， IP 表头里面还含有哪些重要数据呢？如底下所示：(下图第一行为每个栏位的 
		<span class="text_import1">bit</span> 数)<br><br>

<center><a name="fig_ip"></a>
<table style="border-width: 1px; border-color: black; border-style: none;">
<tbody><tr align="center">
	<td style="width: 60px; border-width: 1px; border-style: none solid;">4 bits</td>
	<td style="width: 60px; border-width: 1px; border-style: none solid none none;">4 bits</td>
	<td style="width: 110px; border-width: 1px; border-style: none solid none none;">8 bits</td>
	<td style="width: 45px; border-width: 1px; border-style: none solid none none;">3 bits</td>
	<td style="width: 180px; border-width: 1px; border-style: none solid none none;">13 bits</td>
</tr>
</tbody></table>

<table class="text_import2" bgcolor="lightyellow" border="1" cellpadding="3" cellspacing="0" width="480">
<tbody><tr align="center">
	<td width="60">Version</td>
	<td width="60">IHL</td>
	<td width="120">Type of Service</td>
	<td colspan="2" width="240">Total Length</td>
</tr>
<tr align="center">
	<td colspan="3">Identification</td>
	<td width="45">Flags</td>
	<td width="195">Fragmentation Offset</td>
</tr>
<tr align="center">
	<td colspan="2" bgcolor="#182448"><font color="#FFFFFF">Time To Live</font></td>
	<td bgcolor="#182448"><font color="#FFFFFF">Protocol</font></td>
	<td colspan="2">Header Checksum</td>
</tr>
<tr align="center">
	<td colspan="5" bgcolor="#182448"><font color="#FFFFFF">Source Address</font></td></tr>
<tr align="center">
	<td colspan="5" bgcolor="#182448"><font color="#FFFFFF">Destination Address</font></td></tr>
<tr align="center">
	<td colspan="4">Options</td>
	<td>Padding</td>
</tr>
<tr align="center">
	<td colspan="5" bgcolor="lightgreen" height="50">Data</td></tr>
</tbody></table>
		图八、IP 封包的表头数据</center><br>

		在上面的图示中有个地方要注意，那就是『<span class="text_import2">每一行所占用的位数为 32 bits</span>』，
		也就是说， IP 封包的表头数据是 32 bits 的倍数喔！那各个表头的内容分别介绍如下：
		<ul>
		<li><span class="text_import1">Version(版本)</span><br>
			宣告这个 IP 封包的版本，例如目前惯用的还是 IPv4 这个版本，在这里宣告的。<br><br></li>
		<li><span class="text_import1">IHL(Internet Header Length, IP表头的长度)</span><br>
			<a name="20080421"></a>
			告知这个 IP 封包的表头长度，使用的单位应该是字长 (word) ，一个字长为 4bytes 大小喔。<br><br></li>
		<li><span class="text_import1">Type of Service(服务类型)</span><br>
			这个项目的内容为『PPPDTRUU』，表示这个 IP 封包的服务类型，主要分为：<br>
			PPP：表示此 IP 封包的优先度；
			D：若为 0 表示一般延迟(delay)，若为 1 表示为低延迟；<br>
			T：若为 0 表示为一般传输量 (throughput)，若为 1 表示为高传输量；<br>
			R：若为 0 表示为一般可靠度(reliability)，若为 1 表示高可靠度。<br>
			UU：保留尚未被使用。<br>
			我们前面谈到 gigabit 以太网络时曾提到 Jumbo frame 对吧！可以提高 MTU，
			由於 gigabit 以太网络的种种相关规格可以让这个 IP 封包加速且降低延迟，
			某些特殊的标志就是在这里说明的。<br><br></li>
		<li><span class="text_import1">Total Length(总长度)</span><br>
			指这个 IP 封包的总容量，包括表头与内容 (Data) 部分。最大可达 65535 bytes。<br><br></li>
		<li><span class="text_import1">Identification(辨别码)</span><br>
			我们前面提到 IP 袋子必须要放在 MAC 袋子当中。不过，如果 IP 袋子太大的话，
			就得先要将 IP 再重组成较小的袋子然后再放到 MAC 当中。而当 IP 被重组时，
			每个来自同一笔数据的小 IP 就得要有个识别码以告知接收端这些小 IP 其实是来自同一个封包才行。
			也就是说，假如 IP 封包其实是 65536 那么大 (前一个 Total Length 有规定)，
			那么这个 IP 就得要再被分成更小的 IP 分段后才能塞进 MAC 讯框中。那么每个小 IP 
			分段是否来自同一个 IP 数据，呵呵！这里就是那个识别码啦！<br><br></li>
		<li><span class="text_import1">Flags(特殊旗标)</span><br>
			这个地方的内容为『0DM』，其意义为：<br>
			D：若为 0 表示可以分段，若为 1 表示不可分段<br>
			M：若为 0 表示此 IP 为最后分段，若为 1 表示非最后分段。<br><br></li>
		<li><span class="text_import1">Fragment Offset(分段偏移)</span><br>
			表示目前这个 IP 分段在原始的 IP 封包中所占的位置。
			就有点像是序号啦，有这个序号才能将所有的小 IP 分段组合成为原本的 IP 封包大小嘛！
			透过 Total Length, Identification, Flags 以及这个 Fragment Offset
			就能够将小 IP 分段在收受端组合起来罗！<br><br></li>
		<li><span class="text_import1">Time To Live(TTL, 存活时间)</span><br>
			表示这个 IP 封包的存活时间，范围为 0-255。当这个 IP 封包通过一个路由器时，
			TTL 就会减一，当 TTL 为 0 时，这个封包将会被直接丢弃。说实在的，要让 IP 封包通过
			255 个路由器，还挺难的～ ^_^<br><br></li>
		<li><span class="text_import1">Protocol Number(协议代码)</span><br>
			由於网络上面的封包协议太多了，每个协议都是装在 IP 当中的，
			所以 IP 当然就得在表头上面告知收受端，这个 IP 内含有的数据是什么协议才行。
			一般常见的网络协议如下所示：<br>
<a name="internet_protocol"></a>
<table border="1" cellpadding="3" cellspacing="0" width="80%">
<tbody><tr align="center" bgcolor="#182448"><td width="100"><font color="#FFFFFF">IP 内的号码</font></td><td><font color="#FFFFFF">协议名称(全名)</font></td></tr>
<tr bgcolor="lightyellow"><td align="center">1</td><td>ICMP (Internet Control Message Protocol)</td></tr>
<tr><td align="center">2</td><td>IGMP (Internet Group Management Protocol)</td></tr>
<tr><td align="center">3</td><td>GGP (Gateway-to-Gateway Protocol)</td></tr>
<tr><td align="center">4</td><td>IP (IP in IP encapsulation)</td></tr>
<tr bgcolor="lightyellow"><td align="center">6</td><td>TCP (Transmission Control Protocol)</td></tr>
<tr><td align="center">8</td><td>EGP (Exterior Gateway Protocol)</td></tr>
<tr bgcolor="lightyellow"><td align="center">17</td><td>UDP (User Datagram Protocol)</td></tr>
</tbody></table>
			当然啦，我们比较常见到的还是那个 TCP, UDP, ICMP 说！<br><br></li>
		<li><span class="text_import1">Header Checksum(表头检查码)</span><br>
			用来检查这个 IP 表头的错误检验之用。<br><br></li>
		<li><span class="text_import1">Source Address</span><br>
			还用讲吗？当然是来源的 IP 位址，相关的 IP 我们之前提过罗！<br><br></li>
		<li><span class="text_import1">Destination Address</span><br>
			有来源还需要有目标才能传送，这里就是目标的 IP 位址。<br><br></li>
		<li><span class="text_import1">Options (其他参数)</span><br>
			这个是额外的功能，提供包括安全处理机制、路由纪录、时间戳记、
			严格与宽松之来源路由等。<br><br></li>
		<li><span class="text_import1">Padding(补齐项目)</span><br>
			由於 Options 的内容不一定有多大，但是我们知道 IP 每个数据都必须要是 32 bits，
			所以，若 Options 的数据不足 32 bits 时，则由 padding 主动补齐。<br><br></li>
		</ul>

		你只要知道 IP 表头里面还含有： TTL, Protocol, 来源 IP 与目标 IP 也就够了！
		而这个 IP 表头的来源与目标 IP ，以及那个判断通过多少路由器的 TTL ，就能了解到这个 IP 
		将被如何传送到目的端呐。下一节我们将介绍一下那么 IP 封包是如何被传送到目的地？
	</div>
</div>


<hr><a name="route"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">网络层之路由概念</span><br>
<div class="block1">
	我们在前面两个小节提到了以太网络在物理网段内可以使用 MAC 的讯框数据直接在两张网络卡之间传递数据，
	那在前一节提到的 IP 相关概念里面，也知道在 Internet 的环境中，同一个网域 (Net_ID 相同的网段)
	内可以直接使用广播的方式以 ARP 协议来取得 IP 与 MAC 的对应，好让我们的数据可以在同一个网域内进行传输。
	好了，那问题来了，如果我想要向非同一个网域的主机要求数据呢？这个时候封包要如何传递？
	呵呵～这可就需要路由(route)的帮忙啦！这个也是在网络层 (Layer 3) 里面的重要概念喔！<br><br>

	<hr><a name="route_route"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">什么是路由</span><br>
	<div class="block2">
		什么是『非同一个网域』呢？刚刚上一小节提到的 IP 应该还没有忘记吧？
		所谓的非同一个网域就是 Network/Netmask 不在同一个位址，
		也就是两部主机间的 Net_ID 不相同的意思。例如参考底下的练习：<br><br>

<table border="1" cellpadding="5" cellspacing="0" width="90%"><tbody><tr><td>
例题三：请问 192.168.10.100/25 与 192.168.10.200/25 是否在同一个网域内？<br><br>
答：<ul>
	如果经过计算，会发现 192.168.10.100 的 Network 为 192.168.10.0 ，但是 192.168.10.200 的
	Network 却是 192.168.10.128，由於 Net_ID 不相同，所以当然不在同一个网段内！
	关於 Network 与 Netmask  的算法则请参考上一小节。
</ul>
</td></tr></tbody></table><br>

		那么万一两部不在同一个网段内的主机想要互通信息时，该如何做？
		此时就得要经过 IP 的路径选择 (routing) 功能啦！我们以下面图示的例子来做说明。
		下列图示当中共有两个不同的网段，分别是 Network A 与 Network B，这两个网段是经由一部路由器
		(Server A) 来进行数据转递的，好了，那么当 PC01 这部主机想要传送数据到 PC11 时，
		他的 IP 封包该如何传输呢？<br>

			<center>
			<img src="0110network_basic-centos4.php_files/route_1.html" title="简易的路由示意图" alt="简易的路由示意图"><br>
			图九、简易的路由示意图
			</center><br>

		我们知道 Network A(192.168.0.0/24) 与 Network B(192.168.1.0/24) 是不同网段，
		所以 PC01 与 PC11 是不能互通数据的。不过， PC01 与 PC11 是如何知道他们两个不在同一个网段内？
		呵呵！这当然是透过 Net_ID 来发现的！那么当主机想要传送数据时，他主要的参考是啥？
		很简单！是『路由表 (route table)』，<span class="text_import1">每部主机都有自己的路由表</span>』，
		让我们来看一看默认的情况下， PC01 要如何将数据传送到 PC02 呢？<br>

		<ol><span class="text_import2">
		<li>当 PC01 有 IP 封包需要传送时，主机会查阅 IP 封包表头的目标 IP 位址；<br><br></li>
		<li>PC01 主机会分析自己的路由表，当发现目标 IP 与本机 IP 的 Net_ID 相同时(同一网域)，
			则 PC01 会参考本身的 ARP 记录，而直接利用 MAC 来互相传递信息。<br><br></li>
		<li>但在本案例中， PC01 与 PC11 并非同一网域，因此 PC01 会分析路由表当中是否有相符合的路由配置，
			如果没有的话，就直接将该 IP 封包送到默认路由器 (default gateway) 上头去，
			在本案例当中 default gateway 则是 Server A 这一部。<br><br></li>
		<li>当 IP 封包被送至 Server A 之后，Server A 同样分析该 IP 封包的目标位址，
			然后检查 Server A 自己的路由配置，注意，通常 Server A 这个作为路由器的主机，
			都会拥有两个以上的介面来沟通不同的网域的。在这个案例当中，
			Server A 会发现这个 IP 目标是 192.168.1.11 ，刚好是 Network B 这个相同网段的区域，
			因此 Server A 会直接以 MAC 讯框将数据送给 PC11 去。</li>
		</span></ol>

		<div style="padding: 10pt 0pt 10pt 0pt ;" align="right"><table width="90%"><tbody><tr><td><b>Tips:</b><br><span style="color : #009000"><font size="-1">		Gateway / Router ：网关/路由器的功能就是在负责不同网域之间的封包转递
		( IP Forwarder )，由於路由器具有 IP Forwarder 的功能，并且具有管理路由的能力，
		所以可以将来自不同网域之间的封包进行转递的功能。此外，您的主机与您主机配置的 
		Gateway 必定是在同一个网段内喔！
		</font></span></td><td><img src="0110network_basic-centos4.php_files/vbird_face.gif" alt="鸟哥的图示" title="鸟哥的图示"></td></tr></tbody></table></div>
		<br>大致的情况就是这样，所以啦，每一部主机里面都会存在著一个路由表 ( Route
		table )，数据的传递将依据这个路由表进行传送！而一旦封包已经经由路由表的守则传送出去后，
		那么主机本身就已经不再管封包的流向了，因为该封包的流向将是下一个主机
		(也就是那部 Router )来进行传送，而 Router 在传送时，也是依据 Router 
		自己的路由表来判断该封包应该经由哪里传送出去的！例如底下的图例：<br>

			<center>
			<img src="0110network_basic-centos4.php_files/route_2.html" title="路由的概念" alt="路由的概念"><br>
			图十、路由的概念
			</center><br>

		PC 01 要将数据送到 Server Bingo 去，则依据自己的路由表，将该封包送到
		Server A 去，Server A 再继续送到 Server B ，然后在一个一个的接力给他送下去，最后总是可以到达
		Server Bingo 的。<br><br>

		当然，上面的案例是一个很简单的路由概念，事实上， Internet 上面的路由协议与变化是相当复杂的，因为
		Internet 上面的路由并不是静态的，他可以随时因为环境的变化而修订每个封包的传送方向。
		举例来说，数年前在新竹因为土木施工导致台湾西部整个网络缆线的中断。
		不过南北的网络竟然还是能通，为什么呢？因为路由已经判断出西部缆线的终止，
		因此他自动的导向台湾东部的花莲路线，虽然如此一来绕了一大圈，而且造成网络的大塞车，
		不过封包还是能通就是了！这个例子仅是想告诉大家，我们上面提的路由仅是一个很简单的静态路由情况，
		如果想要更深入的了解 route ，请自行参考相关书籍喔！ ^_^ 。<br><br>

		此外，在属於 Public 的 Internet 环境中，由於最早时的 IP 分配都已经配置妥当，
		所以各单位的路由一经配置妥当后，上一级的路由则无须担心啊！
		IP 的分配可以参考底下的网页：
		<ul>
		<li>台湾地区 IP 核发情况：<a href="http://rms.twnic.net.tw/twnic/User/Member/Search/main7.jsp?Order=inet_aton%28Startip%29" target="_blank">http://rms.twnic.net.tw/twnic/User/Member/Search/main7.jsp?Order=inet_aton(Startip)</a>
		</li><li>全球 IPv4 的统计：<a href="http://www.twnic.net.tw/ipstats/ipv4stats.php" target="_blank">http://www.twnic.net.tw/ipstats/ipv4stats.php</a>
		</li></ul>
	</div>

	<hr><a name="route_host"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">观察主机的路由</span><br>
	<div class="block2">
		既然路由是这么的重要，而且『<span class="text_import2">路由一旦配置错误，
		将会造成某些封包完全无法正确的送出去</span>！』
		所以我们当然需要好好的来观察一下我们主机的路由表啦！还是请再注意一下，
		<span class="text_import2">每一部主机都有自己的路由表喔</span>！观察路由表的命令很简单，就是
		route ，这个命令挺难的，我们在后面章节再继续的介绍，这里仅说明一些比较简单的用法：<br>

<table class="term"><tbody><tr><td class="term"><pre>[root@linux ~]# <span class="term_command">route [-n]</span>
<span class="term_say">参数：
-n ： 将主机名称以 IP 的方式显示
范例：</span>

[root@linux ~]# <span class="term_command">route</span>
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref  Use Iface
192.168.0.0     *               255.255.255.0   U     0      0      0 eth0
127.0.0.0       *               255.0.0.0       U     0      0      0 lo
default         192.168.0.254   0.0.0.0         UG    0      0      0 eth0

[root@linux ~]# <span class="term_command">route -n</span>
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref  Use Iface
192.168.0.0     0.0.0.0         255.255.255.0   U     0      0      0 eth0
127.0.0.0       0.0.0.0         255.0.0.0       U     0      0      0 lo
0.0.0.0         192.168.0.254   0.0.0.0         UG    0      0      0 eth0

<span class="term_say"># 上面输出的数据共有八个栏位，您需要注意的有几个地方：
# Destination ：其实就是 Network 的意思；
# Gateway     ：就是该介面的 Gateway 那个 IP 啦！若为 0.0.0.0 表示不需要额外的 IP；
# Genmask     ：就是 Netmask 啦！与 Destination 组合成为一部主机或网域；
# Flags       ：共有多个旗标可以来表示该网域或主机代表的意义：
#               U：代表该路由可用；
#               G：代表该网域需要经由 Gateway 来帮忙转递；
#               H：代表该行路由为一部主机，而非一整个网域；
# Iface       ：就是 Interface (介面) 的意思。</span>
</pre></td></tr></tbody></table>

		在上面的例子当中，鸟哥是以 PC 01 这部主机的路由状态来进行说明。由於 PC 01 为 192.168.0.0/24
		这个网域，所以主机已经创建了这个网域的路由了，那就是『 <span class="text_import2">192.168.0.0
		* 255.255.255.0 ... </span>』那一行所显示的信息！当您下达 route 时，
		萤幕上说明了这部机器上面共有三个路由守则，第一栏为『<span class="text_import2">目的地的网域</span>』，例如
		192.168.0.0 就是一个网域咯，最后一栏显示的是
		『<span class="text_import2">要去到这个目的地要使用哪一个网络介面</span>！』例如
		eth0 就是网络卡的装置代号啦。如果我们要传送的封包在路由守则里面的 192.168.0.0/255.255.255.0
		或者 127.0.0.0/255.0.0.0 里面时，因为第二栏 Gateway 为 * ，所以就会直接以后面的网络介面来传送出去，而不透过
		Gateway 咯！<br><br>

		万一我们要传送的封包目的地 IP 不在路由守则里面，那么就会将封包传送到『default』所在的那个路由守则去，也就是
		192.168.0.254 那个 Gateway 喔！所以，几乎每一部主机都会有一个
		default gateway 来帮他们负责所有非网域内的封包转递！这是很重要的概念喔！^_^！
		关於更多的路由功能与配置方法，我们在后面的『<a href="http://linux.vbird.org/linux_server/0110network_basic/0230router.php">简易 Router 架设</a>』
		当中会再次的提及呢！<br><br>
	</div>
</div>


<hr><a name="protocol"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">常见的通讯协议</span><br>
<div class="block1">
	终於给他来到了封包格式的地方了！上面的咚咚大多是在网络最底层的基础知识，
	得自行好好的理解理解！第一次看不懂没关系，多看几次，或者是未来有些网络经验后再回来这个章节好好看一看！
	假设您已经知道了网络最底层的 IP 以及相关的参数的意义，那么应该知道的是，
	网络层的协议只是提供路由的判断以确定封包的传送路径，
	但是这些协议并没有管理可能由於网络媒体的损坏问题，或者是网络的负荷过重以及其他不可预期的情况，
	而造成封包损毁或者被丢弃的状态。为了使封包的传送过程中更具有稳定性与可靠性，
	我们就得提供一套机制来让数据可以没有错误的到达到目的地。<br><br>

	在 TCP/IP 这个协议组合当中，<span class="text_import2">TCP ( Transmission Control Protocol )</span>
	就是用来做为传送的一个协议，当然啦，还有一个 UDP 的协议呢！在 TCP 这个协议当中，
	他提供了较为稳定而且可靠的连线状态，至於 UDP 则是一个比较没有这么可靠的连线型态了。
	除了这个 TCP 与 UDP 之外，其他相关的网络协议请参考前一小节
	<a href="#internet_protocol">IP 封包内的 Protocol 说明</a>。
	底下我们就来分别谈一谈重要的 TCP/UDP/ICMP 吧！<br><br>

	<hr><a name="protocol_tcp"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">TCP 协议</span><br>
	<div class="block2">
		在前几个小节内谈到的 IP 与路由的相关说明中，我们知道 IP 与路由仅能将数据封包传送到正确的目标而已，
		但是这个目的地是否真的能够收下来这个封包？那可就不一定了。要确认该数据能否正确的被目的端所接收，
		就必须要在数据封包上面多加一些参数来判断才行。<br><br>

		在前面的 OSI 七层协议当中，在网络层的 IP 之上则是传送层，而传送层的数据打包成什么？
		最常见的就是 TCP 封包了。这个 TCP 封包数据必须要能够放到 IP 的数据袋当中才行喔！
		所以，我们可以将 MAC, IP 与 TCP 的封包数据这样看：<br>

			<center>
			<img src="0110network_basic-centos4.php_files/packet_total.html" title="各封包之间的相关性" alt="各封包之间的相关性"><br>
			图十一、各封包之间的相关性
			</center><br>

		所以说，IP 除了表头之外的 Data 内容其实就是 TCP 封包的表头与内容；而 MAC 的 Data 内容，
		就是一个完整的 IP 封包数据！这也是我们上头提到的，最终还是得以 MAC 能够支持的最大容许容量，
		才能够决定 IP 与 TCP 封包是否需要再进行分段的工作。那么既然 MAC 与 IP 都有表头数据，
		想当然尔，TCP 也有表头数据来记录该封包的相关信息罗？？没错啦～ TCP 封包的表头是长这个样子的：<br><br>

<center><a name="fig_tcp"></a>
<table style="border-width: 1px; border-color: black; border-style: none;">
<tbody><tr align="center">
	<td style="width: 64px; border-width: 1px; border-style: none solid;">4 bits</td>
	<td style="width: 92px; border-width: 1px; border-style: none solid none none;">6 bits</td>
	<td style="width: 92px; border-width: 1px; border-style: none solid none none;">6 bits</td>
	<td style="width: 123px; border-width: 1px; border-style: none solid none none;">8 bits</td>
	<td style="width: 125px; border-width: 1px; border-style: none solid none none;">8 bits</td>
</tr>
</tbody></table>

<table class="text_import2" bgcolor="lightyellow" border="1" cellpadding="3" cellspacing="0">
<tbody><tr align="center" bgcolor="#182448">
	<td colspan="3"><font color="#FFFFFF">Source Port</font></td>
	<td><font color="#FFFFFF">Destination Port</font></td>
</tr>
<tr align="center">
	<td colspan="4">Sequence Number</td>
</tr>
<tr align="center">
	<td colspan="4">Acknowledge Number</td>
</tr>
<tr align="center">
	<td width="60">Data<br> Offset</td>
	<td width="90">Reserved</td>
	<td bgcolor="#182448" width="90"><font color="#FFFFFF">Code</font></td>
	<td width="252">Window</td>
</tr>
<tr align="center">
	<td colspan="3">Checksum</td>
	<td>Urgent Pointer</td>
</tr>
<tr align="center">
	<td colspan="3">Options</td>
	<td>Padding</td>
</tr>
<tr align="center">
	<td colspan="4" bgcolor="lightgreen" height="40">Data</td>
</tr>
</tbody></table>
		图十二、TCP 封包的表头数据</center><br>

		上图就是一个 TCP 封包的表头数据，各个项目以 Source Port, Destination Port 及 Code 
		算是比较重要的项目，底下我们就分别来谈一谈各个表头数据的内容吧！<br>

		<ul>
		<li><span class="text_import1">Source Port &amp; Destination Port ( 来源端口 &amp; 目标端口 )</span><br>
			什么是端口(port)？我们知道 IP 封包的传送主要是藉由 IP 位址连接两端，
			但是到底这个连线的通道是连接到哪里去呢？没错！就是连接到 port 上头啦！
			举例来说，鸟站 (http://linux.vbird.org) 有开放 WWW 服务器，
			这表示鸟站的主机必须要启动一个可以让 client 端连接的端口，这个端口就是 port ，
			中文翻译成为端口。同样的，用户端想要连接到鸟哥的鸟站时，就必须要在 client 
			主机上面启动一个 port ，这样这两个主机才能够利用这条『通道』来传递封包数据喔！
			这个目标与来源 port 的纪录，可以说是 TCP 封包上最重要的参数了！
			下个小单元我们还会继续介绍。<br><br></li>
		<li><span class="text_import1">Sequence Number ( 封包序号 )</span><br>
			由於 TCP 封包必须要带入 IP 封包当中，所以如果 TCP 数据太大时(大於 IP 封包的容许程度)，
			就得要进行分段。这个 Sequence Number 就是记录每个封包的序号，
			可以让收受端重新将 TCP 的数据组合起来。<br><br></li>
		<li><span class="text_import1">Acknowledge Number ( 回应序号 ) </span><br>
			为了确认主机端确实有收到我们 client 端所送出的封包数据，我们 client
			端当然希望能够收到主机方面的回应，那就是这个 Acknowledge Number 的用途了。
			当 client 端收到这个确认码时，就能够确定之前传递的封包已经被正确的收下了。
			<br><br></li>
		<li><span class="text_import1">Data Offset (数据补偿)</span><br>
			在图十二倒数第二行有个 Options 栏位对吧！那个 Options 的栏位长度是非固定的，
			而为了要确认整个 TCP 封包的大小，就需要这个标志来说明整个封包区段的起始位置。
			<br><br></li>
		<li><span class="text_import1">Reserved (保留)</span><br>
			未使用的保留栏位。<br><br></li>
		<li><span class="text_import1">Code (Control Flag, 控制标志码)</span><br>
			当我们在进行网络连线的时候，必须要说明这个连线的状态，好让接收端了解这个封包的主要动作。
			这可是一个非常重要的控制码喔！这个栏位共有 6 个 bits ，分别代表
			6 个控制码，若为 1 则为启动。分别说明如下：<br><br>
			<ul><li><span class="text_import2">URG(Urgent)</span>：若为 1 则代表该封包为紧急封包，
			接收端应该要紧急处理，且图十二当中的 Urgent Pointer 栏位也会被激活。<br><br></li>
			<li><span class="text_import2">ACK(Acknowledge)</span>：若为 1 代表这个封包为回应封包，
			则与上面提到的 Acknowledge Number 有关。<br><br></li>
			<li><span class="text_import2">PSH(Push function)</span>：若为 1 时，
			代表要求对方立即传送缓冲区内的其他对应封包，而无须等待缓冲区满了才送。<br><br></li>
			<li><span class="text_import2">RST(Reset)</span>：如果 RST 为 1 的时候，
			表示连线会被马上结束，而无需等待终止确认手续。这也就是说，这是个强制结束的连线，
			且发送端已断线。<br><br></li>
			<li><span class="text_import2">SYN(Synchronous)</span>：若为 1 ，
			表示发送端希望双方创建同步处理，也就是要求创建连线。通常带有 SYN 
			标志的封包表示『主动』要连接到对方的意思。<br><br></li>
			<li><span class="text_import2">FIN(Finish)</span>：若为 1 ，表示传送结束，
			所以通知对方数据传毕，是否同意断线，只是发送者还在等待对方的回应而已。<br><br></li>
			</ul>
			其中比较常见到的应该是 ACK/SYN/FIN 等，这三个控制码是务必要记下来的，
			这样未来在谈到防火墙的时候，您才会比较清楚为啥每个 TCP 封包都有所谓的『状态』条件！
			那就是因为连线方向的不同所致啊！底下我们会进一步讨论喔！
			<br><br></li>
		<li><span class="text_import1">Window (滑动窗口)</span><br>
			主要是用来控制封包的流量的，可以告知对方目前本身有的缓冲器容量(Receive Buffer)
			还可以接收封包。当 Window=0 时，代表缓冲器已经额满，所以应该要暂停传输数据。
			Window 的单位是 byte。<br><br></li>
		<li><span class="text_import1">Checksum(确认检查码)</span><br>
			当数据要由发送端送出前，会进行一个检验的动作，并将该动作的检验值标注在这个栏位上；
			而接收者收到这个封包之后，会再次的对封包进行验证，并且比对原发送的 Checksum 
			值是否相符，如果相符就接受，若不符就会假设该封包已经损毁，进而要求对方重新发送此封包！
			<br><br></li>
		<li><span class="text_import1">Urgent Pointer(紧急数据)</span><br>
			这个栏位是在 Code 栏位内的 URG = 1 时才会产生作用。可以告知紧急数据所在的位置。
			<br><br></li>
		<li><span class="text_import1">Options(任意数据)</span><br>
			目前此栏位仅应用於表示接收端可以接收的最大数据区段容量，若此栏位不使用，
			表示可以使用任意数据区段的大小。这个栏位较少使用。
			<br><br></li>
		<li><span class="text_import1">Padding(补足栏位)</span><br>
			如同 IP 封包需要有固定的 32bits 表头一样， Options 由於栏位为非固定，
			所以也需要 Padding 栏位来加以补齐才行。同样也是 32 bits 的整数。<br></li>
		</ul>

		<br><hr><a name="protocol_tcp_socket"></a><span class="text_import1">通讯端口与 Socket</span>
		<div class="block2">
			在刚刚上头提到的 TCP 表头数据后，您大概也清楚了要创建一个 TCP 
			封包时所需要检验的相关参数可不少啊！其中最重要的就属通讯端口 (port) 了。
			这个 port 主要是由主机的程序所触发的，网络上面的其他 client 端，
			可以通过这个端口直接与启动该 port 的程序相互沟通，
			而达到数据传输的目的。我们都知道二进位程序 (binary program) 才是真的主机认识的程序命令，
			那么<span class="text_import2">我们要启动网络服务时，其实也就是启动一个 program</span>
			就是了。但是网络上面如何与您的
			program 互通数据呢？就是透过在网络介面上面的 port 来达成的啦。<br><br>

			不过，必须要注意的是 <span class="text_import2">port 的沟通是双向的</span>，
			举例来说，当我们要使用浏览器连接到奇摩雅虎查阅数据时，
			我们必须要使用 client 端主机的浏览器连接到 Yahoo 主机的 WWW 服务器软件上面。
			由於是透过网络介面，所以我们的浏览器也必须要启动一个 port 并且透过这个 port
			连接到 Yahoo 主机的 WWW port 上头去，然后透过 TCP 封包上头各项参数的确认后，
			才能够创建连线，并进一步开始传输数据啊！<br><br>

			现在来想一想，我们的主机上面有多少网络介面的 port 可用呢？
			基本上就有 <span class="text_import2">65536 (2<sup>16</sup>)</span>。那我们连线到 Yahoo 时，
			是连线到 Yahoo 主机的那个 port 啊？如果不知道几号 port ，那又该如何创建起这个连线呢？
			所以罗，Internet 上面已经有很多规范好的固定 port (well-known port)
			在提供使用者创建服务器时激活的 port number 啦。这些 port number 通常小於 1024 ，
			且是提供给许多知名的网络服务软件用的。在我们的 Linux 环境下，
			各网络服务与 port number 的对应默认给他写在 
			<span class="text_import1">/etc/services</span> 文件内喔！
			不过如果是 client 端的话，由於 client 端都是主动向 server 端要数据，
			所以 client 端的 port number 就使用随机取一个大於 1024 以上且没有在用的 port number
			来进行连线了。底下鸟哥列出几个常见的 port number 与网络服务的对应：<br><br>

<table bgcolor="lightyellow" border="1" cellpadding="3" cellspacing="0" width="95%">
<tbody><tr align="center" bgcolor="#182448"><td width="100"><font color="#FFFFFF">连接端口</font></td><td><font color="#FFFFFF">服务名称与内容</font></td></tr>
<tr><td align="center">20</td><td>FTP-data，文件传输协议所使用的主动数据传输端口</td></tr>
<tr><td align="center">21</td><td>FTP，文件传输协议的命令通道</td></tr>
<tr><td align="center">22</td><td>SSH，较为安全的远程连线服务器</td></tr>
<tr><td align="center">23</td><td>Telnet，早期的远程连线服务器软件</td></tr>
<tr><td align="center">25</td><td>SMTP，简单邮件传递协议，用在作为 mail server 的端口</td></tr>
<tr><td align="center">53</td><td>DNS，用在作为名称解析的领域名称服务器</td></tr>
<tr><td align="center">80</td><td>WWW，这个重要吧！就是全球信息网服务器</td></tr>
<tr><td align="center">110</td><td>POP3，邮件收信协议，办公室用的收信软件都是透过他</td></tr>
<tr><td align="center">443</td><td>https，有安全加密机制的WWW服务器</td></tr>
</tbody></table><br>

			另外一点比较值得注意的是，<span class="text_import2">小於 1023 以下的端口要启动时，
			启动者的身份必须要是 root 才行</span>！这个限制挺重要的，大家不要忘记了喔！<br><br>

<table bgcolor="#ffcccc" border="1" cellpadding="5" cellspacing="0" width="90%"><tbody><tr><td>
曾经有一个朋友问过我说：『一部主机上面这么多服务，那我们跟这部主机进行连线时，
该主机怎么知道我们要的数据是 WWW 还是 FTP 啊？！』呵呵！这就是 port
的不同的结果啦！因为每种 Client 软件他们所需要的数据都不相同，例如上面提到的浏览器( Netscape 
以及 IE ) 他们所需要的数据是 WWW ，所以该软件默认就会向主机的 80 port 
索求数据；而如果您是使用 cuteftp 来进行与主机的 FTP 数据索求时， cuteftp 这个 Client 
软件当然默认就是向主机的 FTP 相关端口 ( 默认就是 port 21 ) 
进行连接的动作啦！所以当然就可以正确无误的取得 Client 端所需要的数据了<br><br>
举个例子来说，一部主机就好像是一间多功能银行，该银行内的每个负责不同业务的窗口就好像是通讯端口，
而我们民众就好像是 Client 端来的封包。当您进入银行想要缴纳信用卡帐单时，
一到门口服务人员就会指示您直接到该窗口去缴纳，当然，如果您是要领钱，服务人员就会请您到领钱的窗口去填写数据，
您是不会跑错的对吧！ ^_^。万一跑错了怎么办？呵呵！当然该窗口就会告诉您『我不负责这个业务，您请回去！』，
呵呵！所以该次的连线就会『无法成功』咯！
</td></tr></tbody></table><br>

			谈过了通讯端口后，再来聊一聊每个封包的基本内容有哪些数据呢？这就得要谈论到
			<span class="text_import2">Socket Pair ( 成对的端口 )</span>了！
			当本机发送出封包时，主机是根据 IP 封包内的 IP 位址来判别来源与目的地的行进路线，
			并且，也需要 TCP 封包内的 port number 来告知 Client 与 Server 是以哪一个端口来进行连线的对吧！
			所以呢，一个连线过程所包含的底下这些咚咚就称为成对插槽 (socket pair) 了：
			<ul><span class="text_import2">
			<li>来源 IP ( Source Address )
			</li><li>目的 IP ( Destination Address )
			</li><li>来源端口 ( Source Port )
			</li><li>目的端口 ( Destination Port )
			</li></span></ul>

			这四个封包的基本信息是相当重要的！您得必须要了解喔！
		</div>

		<br><hr><a name="protocol_tcp_connect"></a><span class="text_import1">封包的传送</span>
		<div class="block2">
			OK，从前面这样一路看下来，相信您对於 OSI 七层协议当中的 MAC 讯框与 IP 封包有一定程度的了解了，
			也知道七层协议必须要在不同的主机之间一再地拿出来察看，因为 Internet 是用 IP 来传递封包数据，
			而实体线路则是使用 MAC 讯框。那我们也了解 TCP 封包的表头数据后，再来就是要了解一下，
			那我如何利用 TCP 这个传送层的协议来进行实际的封包接收呢？
			当然是得要透过 TCP 表头的 Sequence Number 来组合收集大的 TCP 封包，
			也必须要透过 Code (Control Flags) 来了解到这个封包的特性才行。
			说穿了，我们可以使用信封袋来说明，实际的内容 (data) 是在信封袋当中的，
			而信封的外面的信息就是各个封包的表头数据啦！<br><br>

			那么如何藉由 TCP 的表头来确认这个封包有实际被对方接收，并进一部与对方主机达成连线？
			我们以底下的图示来作为说明。<br><br>

			<a name="protocol_tcp_3_handshake"></a>
			<center>
			<img src="0110network_basic-centos4.php_files/3_hand_shak.html" title="三向交握之封包连接模式" alt="三向交握之封包连接模式"><br>
			图十三、封包连接模式之三向交握
			</center><br>

			在上面的封包连接模式当中，在创建连线之前都必须要通过三个确认的动作，
			所以<span class="text_import2">这种连线方式也就被称为三向交握(Three-way handshake)</span>。
			那么我们将整个流程依据上面的 A, B, C, D 四个阶段来说明一下：

			<ul>
			<li><span class="text_import2">A:封包发起</span><br>
			当用户端想要对服务器端连线时，就必须要送出一个要求连线的封包，
			此时用户端必须随机取用一个大於 1024 以上的端口来做为程序沟通的介面。
			然后在 TCP 的表头当中，必须要带有 SYN 的主动连线(SYN=1)，并且记下发送出连线封包给服务器端的序号
			(Sequence number = 10001 ) 。<br><br></li>
			<li><span class="text_import2">B:封包接收与确认封包传送</span><br>
			当服务器接到这个封包，并且确定要接收这个封包后，就会开始制作一个同时带有 SYN=1, ACK=1 的封包，
			其中那个 acknowledge 的号码是要给 client 端确认用的，所以该数字会比(A 步骤)里面的 
			Sequence 号码多一号 (ack = 10001+1 = 10002)，
			那我们服务器也必须要确认用户端确实可以接收我们的封包才行，所以也会发送出一个 Sequence (seq=20001)
			给用户端，并且开始等待用户端给我们服务器端的回应喔！<br><br></li>
			<li><span class="text_import2">C:回送确认封包</span><br>
			当用户端收到来自服务器端的 ACK 数字后 (10002) 就能够确认之前那个要求封包被正确的收受了，
			接下来如果用户端也同意与服务器端创建连线时，就会再次的发送一个确认封包 (ACK=1) 
			给服务器，亦即是 acknowledge = 20001+1 = 20002 罗。
			<br><br></li>
			<li><span class="text_import2">D:取得最后确认</span><br>
			若一切都顺利，在服务器端收到带有 ACK=1 且 ack=20002 序号的封包后，就能够创建起这次的连线了。
			<br></li>
			</ul>

			也就是说，你必须要了解『<span class="text_import2">网络是双向的</span>』这个事实！
			所以不论是服务器端还是用户端，都必须要透过一次 SYN 与 ACK 来创建连线，
			所以总共会进行三次的交谈！
			在配置防火墙或者是追踪网络连线的问题时，这个『双向』的概念最容易被忽略，
			而常常导致无法连线成功的问题啊！切记切记！<br><br>

			在创建了连线之后，该次连线通道就可以在用户端与服务器端创建起一对 socket pair ，
			然后通过该 socket pair 进行 TCP 封包的 PSH、FIN 等数据传输与连线中断等动作罗！
		</div>
	</div>

	<hr><a name="protocol_udp"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">UDP 协议</span><br>
	<div class="block2">
		UDP 的全名是：『<span class="text_import2">User Datagram Protocol, 用户数据流协议</span>』，UDP 
		与 TCP 不一样， UDP 不提供可靠的传输模式，因为他不是连线导向的一个机制，这是因为在 UDP 
		的传送过程中，接受端在接受到封包之后，不会回覆回应封包 ( ACK ) 给发送端，所以封包并没有像 
		TCP 封包有较为严密的验证机制。至於 UDP 的表头数据如下表所示：<br><br>

<center><a name="fig_udp"></a>
<table style="border-width: 1px; border-color: black; border-style: none;">
<tbody><tr align="center">
	<td style="width: 243px; border-width: 1px; border-style: none solid;">16 bits</td>
	<td style="width: 243px; border-width: 1px; border-style: none solid none none;">16 bits</td>
</tr>
</tbody></table>

<table class="text_import2" bgcolor="lightyellow" border="1" cellpadding="3" cellspacing="0">
<tbody><tr align="center" bgcolor="#182448">
	<td width="240"><font color="#FFFFFF">Source Port</font></td>
	<td width="240"><font color="#FFFFFF">Destination Port</font></td>
</tr>
<tr align="center">
	<td width="240">Message Length</td>
	<td width="240">Checksum</td>
</tr>
<tr align="center" bgcolor="lightgreen">
	<td colspan="2" height="40">Data</td>
</tr>
</tbody></table>
	图十四、UDP 封包的表头数据</center><br>

		TCP 封包确实是比较可靠的，因为通过三向交握嘛！不过，也由於三向交握的缘故， TCP 封包的传输速度会较慢。
		至於 UDP 封包由於不需要确认对方是否有正确的收到数据，故表头数据较少，也因为如此所以 UDP 就可以在 Data 
		处填入更多的数据了。同时 UDP 比较适合需要即时反应的一些数据流，例如即时通讯软件或者是影像即时传送软件等，
		就可以使用这类的封包传送说。也就是说， UDP 传输协议并不考虑连线要求、连线终止与流量控制等特性，
		所以使用的时机是当数据的正确性不很重要时，例如上面提到的即时通讯软件啊！<br><br>

		另外，很多的软件其实是同时提供 TCP 与 UDP 的传输协议的，举例来说，查询主机名称的 DNS 
		服务就同时提供了 UDP/TCP 协议。由於 UDP 较为快速，所以我们 client 端可以先使用 UDP 来与服务器连线。
		但是当使用 UDP 连线却还是无法取得正确的数据时，便转换为较为可靠的 TCP 传输协议来进行数据的传输罗。
		这样可以同时兼顾快速与可靠的传输说！<br><br>
	</div>

	<hr><a name="protocol_icmp"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">ICMP 协议</span><br>
	<div class="block2">
		ICMP 的全称是『 <span class="text_import2">Internet Control Message Protocol, 网际网络信息控制协议</span> 』。
		基本上，ICMP 是一个错误侦测与回报的机制，最大的功能就是可以确保我们网络的连线状态与连线的正确性！
		同样的，ICMP 封包也是必须要装在 IP 封包的 Data 内才行喔！
		因为在 Internet 上面有传输能力的就是 IP 封包啦！
		ICMP 有相当多的类别可以侦测与回报，底下是比较常见的几个 ICMP 的类别 (Type)：<br><br>

<table bgcolor="lightyellow" border="1" cellpadding="3" cellspacing="0" width="95%">
<tbody><tr align="center" bgcolor="#182448"><td width="80"><font color="#FFFFFF">类别代号</font></td><td><font color="#FFFFFF">类别名称与意义</font></td></tr>
<tr class="text_import1"><td align="center">0</td><td>Echo Reply (代表一个回应信息)</td></tr>
<tr><td align="center">3</td><td>Destination Unreachable (表示目的地不可到达)</td></tr>
<tr><td align="center">4</td><td>Source Quench (当 router 的负载过高时，此类别码可用来让发送端停止发送信息)</td></tr>
<tr><td align="center">5</td><td>Redirect (用来重新导向路由路径的信息)</td></tr>
<tr class="text_import1"><td align="center">8</td><td>Echo Request (请求回应信息)</td></tr>
<tr><td align="center">11</td><td>Time Exceeded for a Datagram (当数据封包在某些路由传送的现象中造成逾时状态，此类别码可告知来源该封包已被忽略的信息)</td></tr>
<tr><td align="center">12</td><td>Parameter Problem on a Datagram (当一个 ICMP 封包重复之前的错误时，会回覆来源主机关於参数错误的信息)</td></tr>
<tr><td align="center">13</td><td>Timestamp Request (要求对方送出时间信息，用以计算路由时间的差异，以满足同步性协议的要求)</td></tr>
<tr><td align="center">14</td><td>Timestamp Reply (此信息纯粹是回应 Timestamp Request 用的)</td></tr>
<tr><td align="center">15</td><td>Information Request (在 RARP 协议应用之前，此信息是用来在启动时取得网络信息)</td></tr>
<tr><td align="center">16</td><td>Information Reply (用以回应 Infromation Request 信息)</td></tr>
<tr><td align="center">17</td><td>Address Mask Request (这信息是用来查询子网络 mask 配置信息)</td></tr>
<tr><td align="center">18</td><td>Address Mask Reply (回应子网络 mask 查询信息的)</td></tr>
</tbody></table><br>

		那么我们是如何利用 ICMP 来检验网络的状态呢？最简单的命令就是 ping 与 traceroute  了，
		这两个命令可以透过 ICMP 封包的辅助来确认与回报网络主机的状态。在配置防火墙的时候，
		我们最容易忽略的就是这个 ICMP 的封包了，因为只会记住 TCP/UDP 而已～事实上，
		ICMP 封包可以帮助连线的状态回报，除了上述的 8 可以考虑关闭之外，基本上，
		ICMP 封包也不应该全部都挡掉喔！<br><br>
	</div>

	<hr><a name="protocol_mtu"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">MTU 的限制</span><br>
	<div class="block2">
		我们在本章的第一部份谈到 MAC 时，不是有提到标准以太网络封包的信息容量大约在 1500bytes 吗？
		所以 IP 封包、TCP 封包以及其他相关的封包，如果能够控制在 1500 bytes 内的话，
		那么 IP 封包将不需要重组成可以放进 MAC 讯框的分段了！<br><br>

		让我们来想一个小案例，假设你的数据量大到 60000 bytes 好了，如果你使用的传输协议为 TCP 封包，
		万一你没有考虑到 MAC 讯框的大小，而让整笔数据放到可以容纳最大 65535 bytes 的 IP 封包内，
		此时 IP 封包已经创建好成为内含 60000 bytes 的数据包了，但是再往下到达数据连接层时，唉～
		这个 IP 封包就得要进行重组，好让 IP 封包可以放到 MAC 讯框当中！您说，这个时候不是又得让系统多进行一段手续，
		而导致网络效能的低落吗？<br><br>

		此时，如果能够规范 TCP 以及 IP 在包起来时就考虑讯框的最大容量时，
		不就可以减少很多数据重组的问题罗？呵呵呵呵！没错啊！
		<span class="text_import2">那就是最大传输单元 (Maximum Transmission Unit, MTU)</span>
		这个配置值的重要性啊！<br><br>

		一般来说，我们的 Gigabit 网络卡已经可以支持 Jumbo frame ，所以 MTU 值都可以到达 9000 bytes 左右，
		不过，不建议您配置 MTU 成为 9000 喔！为什么呢？因为我们的封包总是需要在 Internet 上面跑吧？
		您无法确认所有的网络媒体都是支持那么大的 MTU 对吧！
		如果您的 9000 bytes 封包通过一个不支持 Jumbo frame 的网络媒体时，
		好一点的是该网络媒体 (例如 router ) 会主动的帮您重组封包而进行传送，
		差一点的可能就直接回报这个封包无效而丢弃了～那个时候可就糗大罗～
		所以， MTU 配置为 9000 这种事情，大概仅能在内部网络的环境作作～
		举例来说，很多的内部丛集系统 (cluster) 就将他们的内部网络环境 MTU 配置为 9000，
		但是对外的介面卡可还是原本的标准 1500 喔！ ^_^<br><br>

		也就是说，不论您的网络媒体支持 MTU 到多大，您必须要考量到您的封包需要传到目的地时，
		所需要经过的所有网络媒体，然后再来决定您的 MTU 配置才行。<br>

		<div style="padding: 10pt 0pt 10pt 0pt ;" align="right"><table width="90%"><tbody><tr><td><b>Tips:</b><br><span style="color : #009000"><font size="-1">			事实上，MTU 不会刚好等於 1500 呐！这是因为不论是 IP 封包或者是 TCP 封包都会有表头数据，
			这些表头数据都会占用去一些位容量，所以 MTU 就会比标准以太网络容量的 1500 小一些。
		</font></span></td><td><img src="0110network_basic-centos4.php_files/vbird_face.gif" alt="鸟哥的图示" title="鸟哥的图示"></td></tr></tbody></table></div>	</div>

	<hr><a name="protocol_firewall"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">封包过滤的防火墙概念</span><br>
	<div class="block2">
		由上面的说明当中，我们知道数据的传送其实就是封包的发出与接受的动作啦！并且不同的封包上面都有不一样的表头
		( header )，此外，封包上面通常都会具有四个基本的信息，那就是
		<a href="#protocol_tcp_socket">socket pair</a> 里面提到的『来源与目的 IP 以及来源与目的端的 
		port number』 。当然啦，如果是可靠性连线的
		TCP 封包，还包含 Control Flag 里面的 SYN/ACK 等等重要的信息呢！好了，开始动一动脑筋，
		有没有想到『<span class="text_import2">网络防火墙</span>』的字眼啊？
		网络防火墙可以抵挡掉一些可能有问题的封包，那么在
		Linux 系统上面是怎么挡掉封包的呢？其实说来也是很简单，既然封包的表头上面已经有这么多的重要信息，
		那么我就利用一些防火墙机制与软件来进行封包表头的分析，并且配置分析的守则，当发现某些特定的
		IP 、特定的端口或者是特定的封包信息(SYN/ACK等等)，那么就将该封包给他丢弃，
		那就是最基本的防火墙原理了！<br><br>

		举例来说，大家都知道 Telnet 这个服务器是挺危险的，而 Telnet 使用的
		port number 为 23 ，所以，当我们使用软件去分析要送进我们主机的封包时，
		只要发现该封包的目的地是我们主机的
		port 23 ，就将该封包丢掉去！那就是最基本的防火墙案例啦！
		更多的防火墙信息我们会在后头的『<a href="http://linux.vbird.org/linux_server/0110network_basic/0250simple_firewall.php">简易防火墙</a>』与
		『<a href="http://linux.vbird.org/linux_server/0110network_basic/0240network-secure-1.php">认识网络安全</a>』当中进行更多的说明喔！<br><br>
	</div>
</div>


<hr><a name="prepare"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">连上 Internet 前的准备事项</span><br>
<div class="block1">
	讲了这么多，其实我们最需要的仅是『连接上 Internet 』啦！那么在 Internet 上面其实使用的是 TCP/IP 
	这个通讯协议，所以我们就需要 Public IP 来连接上 Internet 啊！您说对吧～
	不过，您有没有发现一件事，那就是『为啥我不知道 Yahoo 的主机 IP ，但是俺的主机却可以连到 Yahoo 主机上？』
	如果您有发现这个问题的话，哈哈！您可以准备开始配置网络罗～ ^_^<br><br>

	<hr><a name="prepare_dns"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">什么是主机名称与 DNS</span><br>
	<div class="block2">
		除了上面提到的最基本的网络基础概念之外，这里还必须要先谈一个基本的观念，
		否则后续的主机名称查询配置挺难说明白的！好了，我们知道计算机在网络上面要找寻主机的时后，是利用 
		IP 来定址，而以 TCP/UDP/ICMP 等数据来进行传送的，并且传送的过程中还会去检验封包的信息。
		总归一句话，网络是靠 TCP/IP 家族来达成的，所以必须要知道 IP 之后，计算机才能够连上网络以及传送数据。<br><br>

		问题是，计算机网络是依据人类的需要来创建的，不过人类对於 IP 这一类的数字并不具有敏感性，即使 
		IP 已经被简化为十进位了，但是人类就是对数字没有办法啊！怎么办？没关系，反正计算机都有主机名称嘛！
		那么我就将主机名称与他的 IP 对应起来，未来要连接上该计算机时，只要知道该计算机的主机名称就好了，因为 
		IP 已经对应到主机名称了嘛！所以人类也容易记忆文字类的主机名称，计算机也可以藉由对应来找到他必须要知道的 
		IP ，啊！真是皆大欢喜啊！<br><br>

		这个主机名称 (Hostname) 对应 IP 的系统，就是鼎鼎有名的 <span class="text_import1">Domain Name System 
		(DNS)</span> 咯！也就是说， DNS 这个服务的最大功能就是在进行『主机名称与该主机的 IP 的对应』的一项协议。
		DNS 在网络环境当中是相当常被使用到的一项协议喔！举个例子来说，像鸟哥我常常会连到奇摩雅虎的 
		WWW 网站去看最新的新闻，那么我一定需要将奇摩雅虎的 WWW 网站的 IP 背下来吗？！天呐，
		鸟哥的忘性这么好，怎么可能将 IP 背下来？！不过，如果是要将奇摩站的主机名称背下来的话，
		那就容易的多了！不就是 http://tw.yahoo.com 吗？！而既然计算机主机只认识 IP 而已，
		因此当我在浏览器上面输入了『http://tw.yahoo.com』的时后，我的计算机首先就会藉由向 
		DNS 主机查询 tw.yahoo.com 的 IP 后，再将查询到的 IP 结果回应给我的浏览器，
		那么我的浏览器就可以藉由该 IP 来连接上主机啦！<br><br>

		发现了吗？<span class="text_import2">我的计算机必须要向 DNS 主机查询 Hostname 对应 IP 的信息</span>
		喔！那么那部 DNS 主机的 IP 就必须要在我的计算机里面配置好才行，并且必须要是输入 IP 喔，不然我的计算机怎么连到 DNS 
		主机去要求数据呢？呵呵！在 Linux 里面，DNS 主机 IP 的配置就是在 
		<span class="text_import1">/etc/resolv.conf</span> 这个文件里面啦！<br><br>

		目前各大 ISP 都有提供他们的 DNS 主机 IP 给他们的用户，好配置客户自己计算机的 DNS 查询主机，
		不过，如果您忘记了或者是您使用的环境中并没有提供 DNS 主机呢？呵呵！没有关系，
		那就配置 Hinet 那个最大的 DNS 主机吧！ <span class="text_import1">IP 是 168.95.1.1</span> 
		咯！要配置好 DNS 之后，未来上网浏览时，才能使用主机名称喔！不然就得一定需要使用 IP 
		才能上网呢！DNS 是很重要的，他的原理也顶复杂的，更详细的原理我们在后面的
		『<a href="http://linux.vbird.org/linux_server/0110network_basic/0350dns.php">DNS 服务器架设</a>』里面进行更多更详细的说明喔！这里仅提个大纲！<br><br>
	</div>

	<hr><a name="prepare_con"></a><img src="../image/logo.png" alt="小标题的图示" width="24" align="middle" height="23"><span class="text_h2">一组可以连上 Internet 的必要网络参数</span><br>
	<div class="block2">
		从上面的所有说明当中，我们知道一部主机要能够使用网络，必须要有 IP ，而 IP
		的配置当中，就必须要有 IP, Network, Broadcast, Netmask 等参数，此外，还需要考虑到路由里面的
		Default Gateway 才能够正确的将非同网域的封包给他传送出去。
		此外，考虑到主机名称与 IP 的对应，所以您还必须要给予系统一个 DNS 主机的 IP 才行～
		所以说，一组合理的网络配置需要哪些数据呢？呵呵！就是：<br>
		<ul><span class="text_import2">
		<li>IP
		</li><li>Netmask
		</li><li>Network
		</li><li>Broadcast
		</li><li>Gateway
		</li><li>DNS
		</li></span></ul>

		没错！就是这些数据！如果您是使用 ADSL 拨接来上网的话，上面这些数据都是由
		ISP 直接给您的，那您只要使用拨接程序进行拨接到 ISP 的工作之后，
		这些数据就自动的在您的主机上面配置完成了！但是如果是固定制
		( 如学术网络 ) 的话，那么就得自行使用上面的参数来配置您的主机罗！缺一不可呢！以
		192.168.0.0/24 这个 C Class 为例的话，那么您就必须要在您的主机上面配置好底下的参数：<br>

		<ul><span class="text_import2">
		<li>IP: 由 192.168.0~192.168.0.254
		</li><li>Netmask: 255.255.255.0
		</li><li>Network: 192.168.0.0
		</li><li>Broadcast: 192.168.0.255
		</li><li>Gateway: 每个环境都不同，请自行询问网络管理员
		</li><li>DNS: 也可以直接配置成 168.95.1.1
		</li></span></ul>
	</div>
</div>


<hr><a name="review"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">重点回顾：</span><br>
<div class="block1">
<ul><span class="text_import2">
	<li>只要是能够连接上 Internet 的主机，都有危险，不要以为小网站就不会被 cracker  所破解；</li>
	<li>虽然目前的网络媒体多以以太网络为标准，但网络媒体不只有以太网络而已；</li>
	<li>Internet 主要是由 Internet Network Information Center (INTERNIC) 所维护，但其仅维护一些技术文件的推展；</li>
	<li>以太网络的标准相当多，速度的定义亦不相同，购买时需要特别留意其速度标准。</li>
	<li>以太网络的 RJ-45 网络线，由於 568A/568B  接头的不同而又分为平行线与跳线；</li>
	<li>网络媒体都有其最大可接受的封包量，在以太网络上可接收的封包为 MAC (Media Access Control) 讯框</li>
	<li>以太网络上最重要的传输数据为 Carrier Sense Multiple Access with Collision Detect (CSMA/CD) 技术，
		至於传输过程当中，最重要的 MAC 讯框内以硬件位址 (hardware address) 数据最为重要；</li>
	<li>以太网络的交换技术 (switch) 已经可以克服 CSMA/CD 所发生的封包碰撞情况，因为 switch 为非共享媒体</li>
	<li>透过八蕊的网络线 (Cat 5 以上等级)，现在的以太网络可以支持全双工模式；</li>
	<li>OSI 七层协议为一个网络模型 ( model ) ，并非硬性规定。这七层协议可以协助软硬件开发有一个基本的准则，
		且每一分层各自独立，方便使用者开发；</li>
	<li>现今的网络基础是架构在 TCP/IP 这个通讯协议上面；</li>
	<li>数据连接层里重要的信息为 MAC (Media Access Control)，亦可称为硬件位址，而
		ARP Table 可以用来对应 MAC 与软件位址 ( IP ) ；</li>
	<li>网络的传输单位使用 bit 而不是 byte ；</li>
	<li>在网络媒体方面， Hub 为共享媒体，因此可能会有封包碰撞的问题，至於
		Switch 由於加入了 switch port 与 MAC 的对应，因此已经克服了封包碰撞的问题，也就是说，Switch
		并不是共享媒体；</li>
	<li>IP 为 32 bits 所组成的，为了适应人类的记忆，因此转成四组十进位的数据；</li>
	<li>IP 主要分为 Net ID 与 Host ID 两部份，加上 Netmask
		这个参数后，可以配置『网域』的概念；</li>
	<li>所谓的同一网域指的是 Net_ID 相同，但 Host_ID 不同的环境下；</li>
	<li>根据 IP 网域的大小，可将 IP 的等级分为 A, B, C 三种常见的等级；</li>
	<li>Loopback 这个网段在 127.0.0.0/8 ，用在每个操作系统内部的回圈测试中。</li>
	<li>网域可继续分成更小的网域 (subnetwork)，主要是透过将 Host_ID 借位成为 Net_ID 的技术；</li>
	<li>若 IP 封包大於 MAC 可接受的最大值时，就得将该 IP 封包重组分段；</li>
	<li>IP 只有两种，就是 Public IP 与 Private IP ，中文应该翻译为
		公共 IP 与 私有(或保留) IP，私有 IP 与私有路由不可以直接连接到 Internet 上；</li>
	<li>每一部主机都有自己的路由表，这个路由表规定了封包的传送途径，在路由表当中，最重要者为默认的通讯闸
		( Gateway/Router )；</li>
	<li>TCP 协议的表头数据当中，那个 Code (control flags) 所带有的 ACK, SYN, FIN 等为常见的旗标，
		可以控制封包的连线成功与否；</li>
	<li>TCP 与 IP 的 IP address/Port 可以组成一对 socket pair </li>
	<li>网络连线都是双向的，在 TCP 的连线当中，需要进行用户端与服务器端两次的 SYN/ACK 封包发送与确认，
		所以一次 TCP 连线确认时，需要进行三向交握的流程；</li>
	<li>UDP 通讯协议由於不需要连线确认，因此适用於快速即时传输且不需要数据可靠的软件中，例如即时通讯；</li>
	<li>ICMP 封包最主要的功能在回报网络的侦测状况，故不要使用防火墙将他完全挡掉；</li>
	<li>MTU 可以用来规范各种封包打包时的最大单位，单位为 byte。</li>
	<li>一般来说，一部主机里面的网络参数应该具备有：IP, Netmask,
		Network, Broadcast, Gateway 等；</li>
	<li>目前常见的数据封包格式有 TCP/UDP/ICMP 等，TCP 为较可靠的封包格式，
		透过多种确认手段来使封包可以准确的到达目的地，至於
		UDP 则略过这些确认手续，因此传送速度较快。</li>
	<li>在主机的 port 当中，只有 root 可以激活小於 1023 以下的 port ；</li>
	<li>DNS 主要的目的在於进行 Hostname 对应 IP 的功能；</li>
</span></ul>
</div>


<hr><a name="ex"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">课后练习：</span><br>
<div class="block1">
<ul>
	<li>请简述 OSI 网络七层协议每一层的功能；</li>
	<div class="block2"><font color="white" size="-1">
	请参考本章<a href="#whatisnetwork_osi"><font color="white" size="-1">第一节</font></a>的相关内容。
	</font></div>

	<li>在 ISP 提供的网络服务中，他们提到传输速度为 1.5M/382K ，请问这个数据的单位为何？
	<div class="block2"><font color="white" size="-1">
	数据单位为 bits/second, 与惯用的 bytes 差 8 倍。
	</font></div>

	</li><li>什么是 MAC ( Media Access Control ) ，MAC 主要的功能是什么？</li>
	<div class="block2"><font color="white" size="-1">
	Media Access Control 的缩写，为以太网络硬件讯框的规格，以太网络就是以 MAC 讯框进行数据的传送。
	目前 MAC 也常被用为以太网络卡卡号的代称。
	</font></div>

	<li>什么是封包碰撞？为什么会发生封包碰撞？</li>
	<div class="block2"><font color="white" size="-1">
	当主机要使用网络时，必须要先进行 CSMA/CD 监听网络，如果(1)网络使用频繁 (2)网络间隔太大，
	则可能会发生监听时均显示无主机使用，但发出封包后却发生同步发送封包的情况，此时两个封包就会产生碰撞，
	造成数据损毁。
	</font></div>

	<li>ARP Table 的作用为何？如何在我的 Linux 察看我的 ARP 表格？</li>
	<div class="block2"><font color="white" size="-1">
	ARP 协议主要在分析 MAC 与 IP 的对应，而解析完毕后的数据会存在系统的内存中，
	下次要传送到相同的 IP 时，就会主动的直接以该 MAC 传送，而不发送广播封包询问整个网域了。<br>
	利用 arp -n 即可
	</font></div>

	<li>简略说明 Netmask 的作用与优点；</li>
	<div class="block2"><font color="white" size="-1">
	Netmask 可以用来区分网域，且 Netmask 可以有效的添加网络的效率，这是因为 Netmask 
	可以定义出一个网域的大小，那么 broadcast 的时间就可以降低很多！一般来说，
	我们如果要将一个大网域再细分为小网域，也需要藉由 Netmask 来进行 subnet 的切割。 
	</font></div>

	<li>我有一组网域为： 192.168.0.0/28 ，请问这个网域的 Network, Netmask, Broadcast
		各为多少？而可以使用的 IP 数量与范围各是多少？</li>
	<div class="block2"><font color="white" size="-1">
	因为共有 28 个 bits 是不可动的，所以 Netmask 位址的最后一个数字为 11110000，也就是 (128+64+32+16=240) ，所以：<br>
Network：192.168.0.0<br>
Netmask：255.255.255.240<br>
Broadcast：192.168.0.15<br>
IP：由 192.168.0.1 ~ 192.168.0.14 共 14 个可用 IP 喔！ 
	</font></div>

	<li>承上题，如果网域是 192.168.0.128/29 呢？</li>
	<div class="block2"><font color="white" size="-1">
	因为是 29 个 bits 不可动，所以最后一个 Netmask 的位址为： 11111000 也就是 (128+64+32+16+8=248)，所以：<br>
Network：192.168.0.128<br>
Netmask：255.255.255.248<br>
Broadcast：192.168.0.135<br>
IP：由 192.168.0.129 ~ 192.168.0.134 共 6 个可用的 IP 喔！ <br>
	</font></div>

	<li>我要将 192.168.100.0/24 这个 C Class 的网域分为 4 个子网域，请问这四个子网域要如何表示？</li>
	<div class="block2"><font color="white" size="-1">
	既然要分为四个网域，也就是还需要藉助 Netmask 的两个 bits (2的2次方为4啊！)，所以 
	Netmask 会变成 255.255.255.192 ，每个子网域会有 256/4=64 个 IP ，而必须要扣除 
	Network 与 Broadcast ，所以每个子网域会有 62 个可用 IP 喔！因此，四个子网域的表示方法为：<br>
	192.168.100.0/26, 192.168.100.64/26, 192.168.100.128/26, 192.168.100.192/26。
	</font></div>

	<li>如何观察 Linux 主机上面的路由信息 ( route table )？</li>
	<div class="block2"><font color="white" size="-1">
	路由信息的观察可以下达 route 来直接察看！或者是下达 route -n 亦可
	</font></div>

	<li>TCP 封包上面的 SYN 与 ACK 标志代表的意义为何？</li>
	<div class="block2"><font color="white" size="-1">
	SYN 代表该封包为该系列连线的第一个封包，亦即是主动连线的意思；<br>
	ACK 则代表该封包为确认封包，亦即是回应封包！ <br>
	</font></div>

	<li>什么是三向交握？在哪一种封包格式上面才会有三向交握？</li>
	<div class="block2"><font color="white" size="-1">
	使用 TCP 封包才会有三向交握。TCP 封包的三向交握是一个确认封包正确性的重要步骤，通过 SYN, SYN/ACK, 
	ACK 三个封包的确认无误后，才能够创建连线。至於 UDP 封包则没有三向交握喔！ 
	</font></div>

	<li>参考合勤科技网页上的说明 (<a href="http://www.zyxel.com.tw/product/category.php?indexFlagvalue=1028014886" target="_blank">http://www.zyxel.com.tw/product/category.php?indexFlagvalue=1028014886</a> )
		试说明何谓有网管？无网管的 switch ？此外，这些 switch 的硬件应算在 OSI 七层协议的第几层？</li>
	<div class="block2"><font color="white" size="-1">
	有网管者，会在 switch 内部加入其他的小型 OS，藉以控管 IP 或 MAC 的流通；
	通常基础的 switch 仅达控管 MAC ，故为 OSI 第二层(数据连接层)
	</font></div>

	<li>为何 ISP 有时后会谈到『申请固定 8 个 IP ，其中只有 5 个可以用』，你觉得问题出在哪里？
		如果以网域的观念来看，他的 netmask 会是多少？</li>
	<div class="block2"><font color="white" size="-1">
	因为如果是一个网域的话，那么八个 IP 前后(Host_ID 全为 0 与 1 的条件)为 Network 及 Broadcast ，
	加上一个在 ISP 处的 Gateway ，所以仅有 5 个可以用。因为有 8 个 IP ，所以其 netmask 后八 bits 为 11111000
	，故为 255.255.255.248。
	</font></div>

	<li>Internet 协议中共包含 "Network Access Layer", "Internet Layer", "Transport Layer", "Application Layer"，
		请将这四层与 OSI 七层协议的内容进行连结 (自行上网查询相关文章说明)；</li>
	<div class="block2"><font color="white" size="-1">
	Network Access Layer: 涵盖 Data-Link 及 Physical Layer<br>
	Internet Layer: 也是 Network Layer<br>
	Transport Layer: 也是 Transport Layer<br>
	Application Layer: 涵盖 Application Layer, Persentatin Layer, Session Layer.
	</font></div>

	<li>请自行上网查询关於 NetBIOS 这个通讯协议的相关理论基础，并请说明 NetBIOS 是否可以跨路由？</li>
	<div class="block2"><font color="white" size="-1">
	请自行参考<a href="http://www.study-area.org/network/network_protocol.htm" target="_blank"><font color="white" size="-1">网中人的网络基础</font></a>文章
	</font></div>

	<li>什么是 Socket pair ？包含哪些基本数据？</li>
	<div class="block2"><font color="white" size="-1">
	由 IP 封包的 IP address 与 TCP 封包的 port number 达成，分别为目的端的 IP/port 与本地端的 IP/port。
	</font></div>

	<li>分别说明 568A 及 568B 这两种 RJ-45 接头的蕊线颜色排列顺序；</li>
	<div class="block2"><font color="white" size="-1">
	568A: 白绿　绿　白橙　蓝　白蓝　橙　白棕　棕<br>
	568B:白橙　橙　白绿　蓝　白蓝　绿　白棕　棕
	</font></div>

	<li>IP 有一段 A Class 的网段分给系统做为测试用，请问该网段为？配置的名称为？</li>
	<div class="block2"><font color="white" size="-1">
	127.0.0.0/8, loopback
	</font></div>

	<li>ICMP 这个协议最主要的目的为？同时做为『回应』的类别为第几类？</li>
	<div class="block2"><font color="white" size="-1">
	做为网络检测之用，为第 8 类 (echo request)
	</font></div>

	<li>IP 封包表头有个 TTL 的标志，请问该标志的基本说明为何？其数据有何特性？</li>
	<div class="block2"><font color="white" size="-1">
	为该封包的存活时间，该时间每经过一个 node 都会减少一，当 TTL 为 0 时，该封包会被路由器所丢弃。
	该数据最大为 255。
	</font></div>

	<li>在 Linux 当中，如何查询每个 port number 对於服务的对应 (filename)</li>
	<div class="block2"><font color="white" size="-1">
	/etc/services 文件中有纪录
	</font></div>

	<li>什么是星形连线？优点为何？</li>
	<div class="block2"><font color="white" size="-1">
	利用一 hub/switch 连结所有的网络设备的一种连线方式，最大的好处是，每个『网络设备与 switch 之间』都是独立的，
	所以所以每个主机故障时均不会影响其他主机的连线。
	</font></div>

	<li>请说明 CSMA/CD 的运行原理？
	<div class="block2"><font color="white" size="-1">
	发送流程
	<ol><li>主机欲使用网络时，会先监听网络，若网络没有被使用时，才会准备传送，否则继续监听；
	</li><li>当数据传送钟，发现有碰撞情况时，则会重新监听网络，并且重新发送一次该封包；
	</li><li>若重复发生碰撞 16 次，则网络会瘫痪；</li></ol>
	接收流程
	</font><ol><font color="white" size="-1"><li>主机如果没有在传送数据，则会监听网络，并且主动在接收的状态下；
	</li><li>若接收到一个封包，并且该表头所载 MAC 为本身的网卡卡号，则开始接收该封包，否则将该封包丢弃；
	</li><li>接收过程当中如果发生封包碰撞，则会通知原发送主机碰撞的数据；
	</li></font><li><font color="white" size="-1">封包接收完毕后，会以 MAC 表头所载长度同时分析本封包长度，若发生问题，则会通知对方重新传送。
	</font></li></ol></div>

	</li><li>TCP/IP 这两个通讯协议必须要在一起才能生效，为什么？</li>
	<div class="block2"><font color="white" size="-1">
	因为 IP 协议仅定位出 IP 的所在处与路由，并没有沟通协调的能力，
	至於 TCP 封包则具有目的端、本地端程序之间沟通的能力，但无法直接传送封包。
	故 TCP/IP 常会放在一起讲。
	</font></div>
</ul>
</div>


<hr><a name="reference"></a><img src="../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">参考数据</span><br>
<div class="block1">
	<span class="text_import1">特别感谢：</span><br>
	本文在 2002/07 发出之后，收到相当多朋友的关心，也从而发现了自己误会的一些基础的网络理论，真的是感谢好朋友
	Netman 兄与 ZMAN 兄的指导！这篇短文在 2003/08/03 做了相当大幅度的修订，与原来的文章
	( 上次升级日期 2002/09 ) 已经有一定程度的差异了，希望网友们如果有时间的话，能够再次的阅读，
	以厘清一些基本概念喔！<br>
<ul>
	<li>Study Area 之网络基础：<a href="http://www.study-area.org/network/network.htm" target="_blank">http://www.study-area.org/network/network.htm</a></li>
	<li>Request For Comment (RFC) 技术文件：<a href="ftp://nic.merit.edu/internet/documents/rfc" target="_blank">ftp://nic.merit.edu/internet/documents/rfc</a></li>
	<li>Request For Comment (RFC) 技术文件：<a href="http://www.rfc-editor.org/" target="_blank">http://www.rfc-editor.org/</a></li>
	<li>Hub 与 Switch 的迷思：<a href="http://www.study-area.org/tips/hub_switch.htm" target="_blank">http://www.study-area.org/tips/hub_switch.htm</a></li>
	<li>BBS 上的问答收集</li>
	<li>Robert Breyer &amp; Sean Riley 著、风信子、张民人译，『Switched &amp; Fast 以太网络』，
		旗标出版社</li>
	<li>粘添寿著，『Internet 网络原理与实务』，旗标出版社。</li>
	<li>Phil Dykstra, Gigabit Ethernet Jumbo Frames：
		<a href="http://sd.wareonearth.com/~phil/jumbo.html" target="_blank">http://sd.wareonearth.com/~phil/jumbo.html</a></li>
	<li>台湾地区 IP 核发情况：<a href="http://rms.twnic.net.tw/twnic/User/Member/Search/main7.jsp?Order=inet_aton%28Startip%29" target="_blank">http://rms.twnic.net.tw/twnic/User/Member/Search/main7.jsp?Order=inet_aton(Startip)</a>
	</li><li>全球 IPv4 的统计：<a href="http://www.twnic.net.tw/ipstats/ipv4stats.php" target="_blank">http://www.twnic.net.tw/ipstats/ipv4stats.php</a>
	</li><li>维基百科：<a href="http://en.wikipedia.org/wiki/IPv4" target="_blank">http://en.wikipedia.org/wiki/IPv4</a>
</li></ul>
</div>


<hr><span class="text_history">
2002/07/18：第一次完成日期！<br>
2002/09/26：修改了部分可能引起误解的文章部分！<br>
2003/08/03：重新编排版面，并且重新检视文章内容，修订文章！<br>
2003/08/20：添加重点回顾与课后练习<br>
2003/09/06：加入<a href="http://linux.vbird.org/linux_server/0110network_basic/1000results.php#0110network_basic">参考用解答</a><br>
2004/03/16：修订 <a href="#n-way">N-Way</a> 的错误，订正为 <a href="#auto_mdi">Auto MDI/MDIX</a> 的功能！<br>
2006/02/09：将旧的文章移动到 <a href="http://linux.vbird.org/linux_server/0110network_basic/0110network_basic/0110network_basic.php">此处</a><br>
2006/07/12：参考了粘教授与风信子兄的书籍，修改了很多基础数据喔！还有重点整理，不过，练习尚未升级<br>
2006/07/16：加入习题练习罗！<br>
2007/10/21：图14那个 UDP 的表头数据中，16 bits 误植为 16 bytes，感谢讨论区 ricky.liu 的告知！<br>
2008/04/21：经由网友 chyanlong 兄的指点，<a href="http://linux.vbird.org/linux_server/0110network_basic/20080421">IHL</a> 的大小单位误植为 byte，应该是字长 (word) 才对。<hr>
</span>
    </td>
    <td style="width: 16px; font-size: 6px;">　</td></tr>
<tr><td style="width: 16px; height: 16px;">　</td>
    <td style="width: 866px; height: 16px;">　</td>
    <td style="width: 16px; height: 16px;">　</td></tr>
</tbody></table>

<div style="padding-top: 0px; text-align: center;">
<span style="font-size: 80%;">
	<a href="http://vbird.dic.ksu.edu.tw/" target="_top" title="前往鸟哥的首页">http://linux.vbird.org</a>
	is designed by <a href="mailto:vbird@mail.vbird.idv.tw" title="联络鸟哥(我不要广告信！)">VBird</a>
		during 2001-2011. <a href="http://www.ksu.edu.tw/" target="_blank">ksu.edu</a></span>
         ﻿<div id="apDiv4">
      <p>本网页主要以Firefox配合解析度 1024x768 作为设计依据&nbsp;&nbsp;&nbsp;&nbsp; 鸟哥自由软件整合应用研究室</p></div></div>
</div>
</center>
</body></html>
