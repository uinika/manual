
<html><head>
   <meta http-equiv="Content-Type" content="text/html; charset=utf8">
   <meta name="Author" content="VBird">
   <meta name="Description" content="说明一下简单的网络基础概念！">
   <title>鸟哥的 Linux 私房菜 -- 简易网络基础</title>
    <script src="../../script/SpryMenuBar.js" type="text/javascript"></script>
	<script src="../../script/index.js" type="text/javascript"></script>
	<link href="../../css/SpryMenuBarHorizontal.css" rel="stylesheet" type="text/css" />
    <link href="../../css/main.css" rel="stylesheet" type="text/css" />
    </head><body style="margin: 0pt; padding: 0pt;" class="table"onload="MM_preloadImages('../../index-2.html','../../index-2.html','../../index-2.html','../../index-2.html','../../index-2.html','../../index-2.html','../../index-2.html','../../index-2.html')">

<center>
<div id="apDiv5">
<div> <LINK REL="SHORTCUT ICON" HREF="../../index-2.html">
<!-- ImageReady Slices (title3.ai) -->
<table id="___01" width="898" height="81" border="0" align="center" cellpadding="0" cellspacing="0";>
	<tr>
		<td colspan="15">
			<img src="image/title/title_01.png" width="900" height="1" alt=""></td>
	</tr>
	<tr>
		<td rowspan="4" bgcolor="#182448"><p><img src="http://linux.vbird.org/cgi-bin/Count.cgi?dd=C&amp;ft=5&amp;sh=T&amp;md=8&amp;pad=Y&amp;df=vbird.dic.ksu.edu.tw.dat" width="93" align="left" title="計數器" /></p>
	    <p><font color="#FFFFFF" size="-1">since2012/04/23</font></p></td>
		<td rowspan="4" align="left" valign="top"><a href="../../index.html"><img src="image/title/title_03.png" alt="" width="263" height="79" border="0"></a></td>
		<td colspan="13">
			<img src="image/title/title_04.png" alt="" width="535" height="9" border="0"></td>
	</tr>
	<tr>
		<td rowspan="3">
			<img src="image/title/title_05.png" alt="" width="53" height="70" border="0"></td>
		<td colspan="2" align="left" valign="top"><a href="../../linux_basic/0110whatislinux.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image51','','image/title/title_06.png',1)"><img src="image/title/title3_06.png" name="Image51" width="106" height="25" border="0" id="Image51" alt=""/></a></td>
		<td rowspan="2">
			<img src="image/title/title_07.png" alt="" width="27" height="37" border="0"></td>
		<td colspan="3" align="left" valign="top"><a href="../0110network_basic.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image52','','image/title/title_08.png',1)"><img src="image/title/title3_08.png" name="Image52" width="107" height="25" border="0" id="Image52" alt=""/></a></td>
		<td rowspan="2">
			<img src="image/title/title_09.png" alt="" width="37" height="37" border="0"></td>
		<td colspan="2" align="left" valign="top"><a href="../../about.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image53','','image/title/title_10.png',1)"><img src="image/title/title3_10.png" name="Image53" width="75" height="25" border="0" id="Image53" alt=""/></a></td>
		<td rowspan="3">
			<img src="image/title/title_11.png" alt="" width="35" height="70" border="0"></td>
		<td align="left" valign="top"><a href="mailto:vbird@mail.vbird.idv.tw" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image54','','image/title/title_12.png',1)"><img src="image/title/title3_12.png" name="Image54" width="74" height="25" border="0" id="Image54" alt=""/></a></td>
		<td rowspan="3">
			<img src="image/title/title_13.png" alt="" width="21" height="70" border="0"></td>
	</tr>
	<tr>
		<td colspan="2">
			<img src="image/title/title_14.png" alt="" width="106" height="12" border="0"></td>
		<td colspan="3">
			<img src="image/title/title_15.png" alt="" width="107" height="12" border="0"></td>
		<td colspan="2">
			<img src="image/title/title_16.png" width="75" height="12" alt=""></td>
		<td rowspan="2">
			<img src="image/title/title_17.png" alt="" width="74" height="45" border="0"></td>
	</tr>
	<tr>
		<td>
			<img src="image/title/title_18.png" alt="" width="15" height="33" border="0"></td>
		<td colspan="3" align="left" valign="top"><ul id="MenuBar1" class="MenuBarHorizontal">
	  <li><a href="../../linux_basic/linux_basic.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image44','','image/title/title_19.png',1)"><img src="image/title/title3_19.png" name="Image44" width="123" height="33" border="0" id="Image44" /></a>
			    <ul>
			      <li><a href="../../linux_basic/Mandrake9.0/mandrake9.0.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image46','','image/title/title_26.png',1)"><img src="image/title/title_23.png" name="Image46" width="120" height="26" border="0" id="Image46" alt="" /></a></li>
                  <li><a href="../../linux_basic/fedora_4/fc4.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image47','','image/title/title_27.png',1)"><img src="image/title/title_24.png" name="Image47" width="120" height="26" border="0" id="Image47" alt="" /></a></li>
                  <li><a href="../../linux_basic/linux_basic.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image48','','image/title/title_28.png',1)"><img src="image/title/title_25.png" name="Image48" width="120" height="26" border="0" id="Image48" alt="" /></a></li>
                </ul>
		      </li>
		</ul></td>
		<td>
			<img src="image/title/title_20.png" alt="" width="42" height="33" border="0"></td>
		<td colspan="3" align="left" valign="top"><ul id="MenuBar2" class="MenuBarHorizontal">
	  <li><a href="../index.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image45','','image/title/title_21.png',1)"><img src="image/title/title3_21.png" name="Image45" width="125" height="33" border="0" id="Image45" /></a>
			    <ul>
			      <li><a href="redhat9.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image43','','image/title/title_26.png',1)"><img src="image/title/title_23.png" name="Image43" width="120" height="26" border="0" id="Image43" alt=""/></a></li>
			      <li><a href="../centos4.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image49','','image/title/title_27.png',1)"><img src="image/title/title_24.png" name="Image49" width="120" height="26" border="0" id="Image49" alt="" /></a></li>
			      <li><a href="../index.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage('Image50','','image/title/title_28.png',1)"><img src="image/title/title_25.png" name="Image50" width="120" height="26" border="0" id="Image50" alt="" /></a></li>
		        </ul>
		      </li>
		</ul></td>
		<td>
			<img src="image/title/title_22.png" alt="" width="47" height="33" border="0"></td>
	</tr>
	<tr>
		<td>
			<img src="image/title/Spacer.gif" width="101" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="263" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="53" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="15" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="91" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="27" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="5" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="42" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="60" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="37" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="28" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="47" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="35" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="74" height="1" alt=""></td>
		<td>
			<img src="image/title/Spacer.gif" width="22" height="1" alt=""></td>
	</tr>
</table>
<!-- End ImageReady Slices -->
<script type="text/javascript">
<!--
var MenuBar1 = new Spry.Widget.MenuBar("MenuBar1", {imgDown:"SpryAssets/SpryMenuBarDownHover.gif", imgRight:"SpryAssets/SpryMenuBarRightHover.gif"});
var MenuBar2 = new Spry.Widget.MenuBar("MenuBar2", {imgDown:"SpryAssets/SpryMenuBarDownHover.gif", imgRight:"SpryAssets/SpryMenuBarRightHover.gif"});
//-->
</script>
</div>
<table summary="本文内容的排版" style="width: 898px;" border="0" cellpadding="0" cellspacing="0">
<tbody><tr><td style="width: 16px; height: 16px;">　</td>
    <td style="width: 866px; height: 16px;">　</td>
    <td style="width: 16px; height: 16px;">　</td></tr>
<tr><td style="width: 16px; font-size: 6px;">　</td>
    <td width="866">
<!-- 本文的档头部分 -->
<div style="text-align:center">
    <a href="0110network_basic.html">
    <span class="text_head0">简易网络基础架构</span></a><br>
</div>
    <div style="text-align:right">
        <span class="text_history">最近更新日期：2004/03/16</span>
    </div>
<!-- 本文的档头部分 -->
<center><table class="head1" summary="排版：文章档头的说明"><tbody><tr><td class="head1">
由前一章节『<a href="0105beforeserver.html"><font color="lightblue"><B>架站前的技巧分析</B></font></a>』当中，我们已经知道网络基础是很重要的呢！在这个章节当中，我们主要针对网络基础来进行比较深入的谈论。当然啦，光是网络基础里面的
OSI 七层协议，就可以写了满满的一大本书了，我们的目的仅是让大家对于网络基础有点认识就是了！因此，在这个章节中，我试图以较为简单的方式介绍网络的基础概念，这里面包括了
IP, route, TCP, 以及类似三向交握等等的网络基础，希望能够让大家早一点进入状况喔！
^_^</td></tr></tbody></table></center>

<!-- 本文的连结区部分 -->
<div class="block1">
<span class="text_h1">
<br><a href="#before">关于网络</a>：
<br><font size="-0.5">　　：<a href="#before_whatisnetwork">网络是什么</a></font>
<br><font size="-0.5">　　：<a href="#before_functions">网络功能</a></font>
<br><font size="-0.5">　　：<a href="#before_follow">网络的一般运作流程</a></font>
<br><font size="-0.5">　　：<a href="#before_osi">TCP/IP 与 OSI 七层协定</a></font>
<br><a href="#Networklayer">网络层的相关协议</a>：
<br><font size="-0.5">　　：<a href="#Networklayer_unit">传输单位</a></font>
<br><font size="-0.5">　　：<a href="#Networklayer_physical">物理层</a>：</font>
<font size="-0.5"><a href="#Networklayer_physical_media">网络媒体</a>,</font>
<font size="-0.5"><a href="#Networklayer_physical_broadcast">物理广播</a>,</font>
<font size="-0.5"><a href="#Networklayer_physical_collision">封包碰撞</a>,</font>
<br><font size="-0.5">　　：<a href="#Networklayer_data_link">数据连接层</a>：</font>
<font size="-0.5"><a href="#Networklayer_data_link_MAC">MAC</a>,</font>
<font size="-0.5"><a href="#Networklayer_data_link_ARP">ARP</a>,</font>
<font size="-0.5"><a href="#Networklayer_data_link_arp_comm">arp</a>,</font>
<br><a href="#IP">Internet Protocol,
IP 概念</a>：</font></font>
<br><font size="-0.5">　　：<a href="#IP_component">IP 的组成</a></font>
<br><font size="-0.5">　　：<a href="#IP_Networking">网域的概念</a>：<a href="#IP_Networking_loopback">loopback</a>,</font>
<br><font size="-0.5">　　：<a href="#IP_Netmask">Netmask 的用途 (效能)与子网的切分</a></font>
<br><font size="-0.5">　　：<a href="#IP_types">IP 的种类与 IP 的取得方式</a></font>
<br><a href="#route">路由 ( route )
的概念</a>：
<br><font size="-0.5">　　：<a href="#route_route">什么是路由 (route)</a></font>
<br><font size="-0.5">　　：<a href="#route_route_comm">观察主机的路由</a></font>
<br><font size="-0.5">　　：<a href="#route_network_param">一组网络设定需要的参数</a></font>
<br><a href="#packet">封包的格式</a>：
<br><font size="-0.5">　　：<a href="#packet_socket">通讯端口口与 Socket pair</a></font>
<br><font size="-0.5">　　：<a href="#packet_transfer">封包的传送</a></font>
<br><font size="-0.5">　　：<a href="#packet_tcp">TCP,</a> <a href="#packet_tcp_handshake">三向交握</a>,</font>
<br><font size="-0.5">　　：<a href="#packet_udp">UDP</a></font>
<br><font size="-0.5">　　：<a href="#packet_icmp">ICMP</a></font>
<br><font size="-0.5">　　：<a href="#packet_firewall">封包过滤的防火墙概念</a></font>
<br><a href="#DNS">DNS 的基础观念</a>：
<br><a href="#connect_modes">基础网络布线模式</a>：
<br><font size="-0.5">　　：<a href="#connect_compo">基本组件</a></font>
<br><font size="-0.5">　　：<a href="#connect_connetction">联机基本要求</a></font>
<br><a href="#net_media">网络媒体的选择</a>：
<br><a href="#review">重点回顾</a>：
<br><a href="#ex">课后练习</a>：
<br><a href="#Thanks">特别感谢</a>
<br><a href="#reference">参考数据</a>
</span>
</div>

<!-- 本文的正式部分 -->
<hr><a name="before"></a><img src="../../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">关于网络：</span><br>
<ul>Linux 这个操作系统的最大优势就是在网络功能 ( Network ) 啦！这包含他的高稳定度系统资源分配，以及较为安全的网络防备能力！所以很多人都喜欢拿他来进行网络服务器的架设。然而，这些网络功能的优点却同时也是缺点，怎么说呢？因为
Linux 网络功能太强了，所以一旦被 Cracker (网络怪客) 入侵的话，嘿嘿嘿嘿！怎么吃上官司的都不知道！所以啰，上网之前，请先注意：<font color="#000066">『我的网络做好安全防护了吗？</font>』再者，由于
Linux 的设定上面通常使用者比较需要花费多一点心力，毕竟当初他是由一群工程师由于本身兴趣而设计出来的，所以依旧具有相当麻烦的设定工作需要作！这个时候，如果没有较为基础的
<font color="#000066">网络基础</font>
认知的话，那么在 Linux 上面设定网络或者是进行网络除错将是您一生当中最大的梦魇......，所以，这里有几件事情要请您好好的来参考一下：
<br>　
<ul>
<li>
<font color="#000099">熟悉 Linux 操作与 Linux 基础</font>：还是要一再地不断强调，如果您确定您只是想要『<font color="#000066">会使用
Linux 就好』</font>那一类型的使用者，那么真的不要再往下看了，因为主机后续的维护问题会很大，倒不如花个小钱，请个专家来帮您搞定即可！而如果您确定您是『<font color="#000066">想要更了解
Linux 的使用者，并且想要熟悉架设网站</font>』，那么请不要再在网络上询问：『为何我不能使用
FTP 传送数据到主机上？』或者是『为何我不能建立个人网页』之类的傻问题，因为这仅仅牵涉到『<a href="http://linux.vbird.org/linux_server/linux_basic/0210filepermission.php">档案权限与属性</a>』的概念而已，而这些概念都是
Linux 基础里头相当重要的功课！此外，由于远程操控 Linux 主机时，几乎都是使用文字界面来工作，所以，不懂
<a href="http://linux.vbird.org/linux_server/linux_basic/0320bash.php">bash
shell</a> ？哈哈！那么想要干嘛都码不可能！</li>
</ul>
　
<ul>
<li>
<font color="#000099">花几晚的时间将网络基础看一看</font>：这一个章节旨在引导网络新鲜人快速进入网络的世界，所以写的
比较浅显一些些，基本上，还有一堆网络硬件与通讯协议并没有被包含在这篇短文里头。如果您的求知欲已经高过本章节，那么请自行到书局寻找适合您自己的书籍
来阅读！当然，您也可以在因特网上面找到您所需要的数据，例如
Study Area 就是一个很好的网络基础入门网站：<a href="http://www.study-area.org/network/network.htm" target="_blank">http://www.study-area.org/network/network.htm</a>，尤其是
IP 基础那一篇：<a href="http://www.study-area.org/network/network_ipadd.htm" target="_blank">http://www.study-area.org/network/network_ipadd.htm</a>，相当适合入门级新手参考之用！反正，无论如何，在进行服务器架设之前，您都必须要对
Network 有一定的认知啦！</li>
</ul>
　
<ul>
<li>
<font color="#000099">随时掌握主机信息</font>： 这是最麻烦的一点了！因为大家还是常常认为『<font color="#000066">我的网站这么小，没有人会注意的啦！</font>』唉！说过若干次了，就是因为有这种心理存在，我们才会常常听到『<font color="#000066">奇怪！我在早上刚安装完毕，怎么下午就无法以
root 的身份登入了！</font>』请随时注意您主机的信息，好好的爱护他吧！</li>
</ul>
　
<br>反正无论如何，不论是 Linux 还是 Windows 的服务器，了解网络基础为进入服务器架设的第一课，底下的文章请好好的，慢慢的读完！对于未来的学习是很有帮助的！
<br>　
<br>
<hr width="100%"><a name="before_whatisnetwork"></a><font color="#000099">网络是什么：</font>
<br>　
<br>网络是什么呢？简单的说，只要是两部以上的计算机，透过网络线或者是其他的网络媒体(例如无线网卡、专线、Cable缆线等等)连接在一起，以进行
文件传输、讯息传递等等功能，那就形成一个『网络世界』啦！那么网络有没有大小之分呢？基本上，如果您的网络是在您的研究室内几部计算机，或者是大楼内的所
有几百部计算机连接起来的，那么就可以视为一个小型的局域网络<font color="#000066">
( Local Area Network, LAN, 也有翻译成文『局网络』 )</font>，透过 LAN 的再延伸，例如整个城市或国家，就可以称做为<font color="#000066">广域网
( Wide Area Network, WAN ) </font>，而这些无数个的 LAN 与 WAN 都连接在一起，那就是因特网
( <font color="#000066"><b>Internet</b> ) </font>啦！您可以想象成，<font color="#000066">
Internet 仅是将所有的 LAN 与 WAN 连接在一起的一个接口</font>，所以，任何地方的计算机，只要连接上
Internet 之后，就没有什么太大的差异了，也就是说，在地球的另一端的计算机，与在您身旁的计算机，在
Internet 上面，事实上是差不多的！(只不过流量有点限制就是了 ^_^)！此外，需要注意的是，
Internet 并没有专人在维护的，所以他是完全没有王法的地方，您可以在 Internet
上面进行任何的事情！哇！好像很可怕的样子！是这样没错！ Internet 确实是『相当的可怕！』
^_^，就是因为太可怕了，所以我们得要来聊一聊网络的基础呀！
<br>　
<br>
<hr width="100%"><a name="before_functions"></a><font color="#000099">网络的功能</font>：
<br>　
<br>好了，对于所谓的网络有一点认识之后，要来谈一谈：网络有什么功能呢？说穿了，网络真的是很日常生活化的一项工具了！！例如您使用的计算机上
WWW 去浏览时，使用的就是网络功能了；您的公司内部的『网络上的芳邻』分享的档案、打印机，那就是网络功能之一；上网下载软件，使用的
FTP 
也是网络功能之一！呵呵！够生活化了吧！我想，目前的生活中，很难有人不去奇摩雅虎看一看奇摩实时新闻的吧！？还有股票啦、电子信息邮件啦、尤其是现在让
很多人流连忘返的在线网络联机游戏咯等等，哇！好多功能呦！这都是网络帮您达成的呦！当然啦！网络的功能来不止于此，您可以再更深入的研究呦！
<br>　
<br>
<hr width="100%"><a name="before_follow"></a><font color="#000099">网络的一般运作流程：</font>
<br>　
<br>好啦，网络就是几部计算机连接在一起，并且可以互相进行数据与讯息及硬件周边分享(例如分享打印机给他人使用)的一个咚咚，他可以达到的功能相当的多，但是这里就牵涉出来了一个问题，那就是『<font color="#000066">网络是如何运作的呢</font>？』简单的说，就是我们连上
Internet 时，数据是如何传递的呢？底下我们以目前最常见的 ADSL 拨接制的情况稍做说明好了。当您需要联机网络时，那么您的计算机主机就必须要有：
<br>　
<ol>
<li>
<b>网络卡</b>与<b>网络线</b>：在网络的世界里，其实真正工作的应该就是电子讯号啦！而这些电子讯号需要藉由硬件做为媒体来传输，这就是最底层的网络硬件啦！我们这里是以
ADSL 来进行说明的，当然还有所谓的光纤、无线网络等等。无论如何，要连接到
Internet 上面去，首先，就是必须要有『<font color="#000066">连接的媒体</font>』，这个媒体在目前最常见的就是
RJ-45 接头的网络线与网络卡啦！当然啦，每一种媒体都有其规格与负载量，所以选择的时候就需要多加的小心啰！</li>

<br>　
<li>
<b>支持网络媒体的操作系统</b>：还记得我们在 Linux 基础里面提到的 Linux
kernel 吗？没错！空有硬件，但是操作系统核心不支持，那么也是英雄无用武之地的啦！所以，有了网络媒体之后，还需要有可以跟媒体沟通的操作系统来操控硬件才行！目前主流的操作系统
Windows 与 Linux 都能够支持一大堆的网络媒体呢！</li>

<br>　
<li>
<b>合法的网络地址</b>：就跟门牌一样，如果家里没有门牌，那么您的邮件包裹如何送达自己的家里？目前
Internet 主要还是以 IPv4 这个协议的 IP 作为地址的标准，因特网只会认得
IP 的喔！除此之外，要将数据正确无误的送达该 IP 就需要有所谓的『路标』才行，这个数据传输的路标就是我们所谓的『路由,
route』！</li>

<br>　
<li>
<b>数据传输的方法</b>：好了，现在硬件都没有问题了，接着下来就是需要了解『我的数据是怎么传送出去的？！』哇！好麻烦，还要理解资料『封包』的咚咚呀！呵呵！基本上，不用担心，目前的网络已经帮我们定义好很多协议了！所以我们只要了解他的一些基础原理即可！其他的就不需要太担心啦！！</li>
</ol>
　
<br>所以，简单的说，您想要浏览 Internet 上面的数据，就需要有网络卡、并且安装了合适的操作系统，还得要驱动网络卡才行！然后，使用
ADSL 拨接到您的 ISP 去取得合法的 IP 地址之后，这样就可以浏览网络上面的网站数据了。OK！OK！我们来假设一个状态好了，如果您要浏览
奇摩新闻 的话，您是怎样取得上面网页的资料的呢？
<br>　
<ol>
<li>
<font color="#000066">首先，您要取得奇摩雅虎上面的数据，就必须向对方提出一个要求，不然对方怎么知道您要的数据是什么呢？呵呵！那么这个要求的『封包』会先在您的系统上面被『打包』；</font></li>

<li>
<font color="#000066">『打包』完成之后，当然就是要开始来传送咯，传送当然是藉由网络卡来传送啰，所以数据这个时候会被送到网络卡上；</font></li>

<li>
<font color="#000066">而在网络卡将打包的封包传送出去之前，会先监听一下在这个传送的时间点上面，是否有其他的
PC 同时在传送，如果没有的话，封包才可以送出去，否则就无法传送，需要再等下一次的监听之后才能传送！</font></li>

<li>
<font color="#000066">好了，那么开始传送之后，就需要藉助于 route tables
的规则，这个 route table 就有点像是路标，我们的封包就是经过一层又一层的节点(nodes)来送达到目的地！</font></li>

<li>
<font color="#000066">到达目的地之后，再来则是对方的主机将封包收下来，并经过操作系统的解开封包，得到您所要求的数据，然后在
依据要求的内容来给予响应！而这个给予的响应又需要上面的这样一个流程了！这个时候就会变成对方将数据打包-&gt;网络卡-&gt;网络传送
-&gt;....到达您的屏幕前面！</font></li>
</ol>
　
<br>当然，这只是很简单的一个流程例子，但其实里面包含了很多的信息，例如路由(route)、封包概念(TCP
packet)、网络地址(IP)、网络共享媒体的硬件广播等等的一堆基础的咚咚需要理解～底下我们先介绍一下
OSI 七层协议之后，再一个一个分项来介绍各个层阶所需要知道的内容喔！
<br>　
<br>
<hr width="100%"><a name="before_osi"></a><font color="#000099">TCP/IP
与 OSI 网络七层协议：</font>
<br>　
<br>根据上面说明的网络数据运作的流程方式，我们就不难知道，想要进行网络的传输，就必须要有硬件，而且还需要其他网络相关功能的运作之后，才能够连上
Internet 。然而您必须要了解的是，网络相关的硬件开发商可不是只有一家啊，并且，可以运作的操作系统也不是只有一种啊！如果大家都独自玩自己的网络架构，那么可能就会造成
W 牌的操作系统与 L 牌的操作系统之间数据无法进行传输的问题啦！那不就伤脑筋了～呵呵！是啊！所以，为了规范所有的硬件开发商开发出来的产品是可以互容的，也为了让不同的作业平台都可以兼容于
Internet 的传输方式，因此大家所发展的软硬件就得要符合 TCP/IP 这个协议啊！
<br>　
<br>其实现今网络的原型最早是在大约 1970 年代的美国政府委托 Advanced Research
Project Agency (ARPA) 所发展的 ARPANET 网络架构，后来该网络架构经过各大专院校、研究人员的采用，并且将之用于
Unix 系统上。因为这个架构相当的具有实用性，尤其是他的设计是公开的，并非专属于某个私有单位，所以就有越来越多的单位投入
TCP/IP 的使用之中。关于 TCP/IP 的种种技术文件，是由 Internet Network Information
Center (INTERNIC) 所统一整理与维护的，至于 TCP/IP 的标准则主要以 Request
For Comment (RFC) 技术报告的形式公开，您可以在 <a href="ftp://nic.merit.edu/internet/documents/rfc/" target="_blank">ftp://nic.merit.edu/internet/documents/rfc/</a>
下载所有的 RFC 文件喔！
<br>　
<br>TCP/IP 的全名是 <font color="#000066">Transmission Control Protocol
/ Internet Protocol (TCP/IP)</font>，可以分为两部分来说明，亦即 TCP 与
IP ，IP 的工作是在网络层，这个就是我们常常看到的四组 0-255 的十进制数并以小数点『.』隔开的数据，例如
192.168.100.100 这样的组合，就构成了 IP 。要在因特网上面将数据由这部计算机传输到另一部计算机，就得需要
IP 到 IP 的传输了。至于 TCP 则更为复杂，上面说的由 IP 传送到另一个 IP 就是透过
TCP 协定的参与了！关于 TCP/IP 我们将在后面的章节更详细的说明。
<br>　
<br>除了 TCP/IP 这个基础协议之外，为了让所有的软硬件开发者都能够基于同一基准，因此就有
<font color="#000066">OSI
( Reference Model for Open System Interconnetction )</font> 的产生了。说起来，
OSI 只是一个模式 (model) ，他并没有硬性的规范软硬件一定要如何如何，而是提出一个指引的依据而已！这个
OSI 将整个网络运作由最底层的物理层到最上层的数据应用层共分为七大部分，所以我们一般通称为
<font color="#000066">OSI
七层协议</font>，分别规定最底层的物理层到最上层的数据应用层所需要符合的相关依据。如下所示：
<center><img src="0110network_basic_files/osi7layers.jpg" nosave="" width="241" height="241">
<br><font color="#000066">图一、OSI 网络七层协议</font>
<br>　</center>
并且，在这七层协定当中，又粗分为两大群组，一个用在网络的基础(硬件协议与网络地址)方面，主要规定了硬件与网络的最底层相关协议；另一个则是与使用者比较有关的协议，用户与软件开发者可以这些协议来设计自己的应用程序！大致上就如同底下说的：
<br>　
<ul>
<li>
<b>网络基础</b>：物理层、数据连接层、网络层</li>

<li>
<b>使用者方面</b>：传输、会谈、表现及应用层</li>
</ul>
　
<br>我们可以简单的用下表来稍微了解一下所谓的 OSI 七层协议分别负责什么？
<br>　
<center><a name="Table_1"></a><font color="#000066">表一、OSI 七层协议内每层负责的工作</font></center>

<table width="90%" border="" cols="2">
<tbody><tr>
<td width="150">
<center>OSI 七层协议的名称</center>
</td>

<td>
<center>该层负责的工作</center>
</td>
</tr>

<tr>
<td bgcolor="#CCFFFF">
<center>物理层</center>
</td>

<td>既然网络工作实际的运作者是电子讯号以及传递电子讯号的硬设备，那么所有的网络媒体就必须要理解相关的电子讯号了！当然这些硬件配备就需要进行
规范，好让所有的媒体都能够具有理解电压、波长、以及不同网络线规格的相关规范。所以这个层级就规范了包括各个网络媒体之定义、还有网络的连接型态，例如
ethernet 网络卡还有 RJ-45 
网络线等等。当然啦，如果您有兴趣想要发展网络媒体硬件的话，那么您的硬件就需要符合这个层级的规定啦！不然做出来的硬件可就无法与其他的规格品沟通啰！</td>
</tr>

<tr>
<td bgcolor="#CCFFFF">
<center>数据连接层<a name="before_osi_data_connect"></a></center>
</td>

<td>由于传送数据的网络媒体是以是电子讯号进行传送，所以我们的数据要使用这样的讯号传送时，就需要制订各种网络型态的框包(Frame)了，才能确保数据可以在不同的网络媒体进行传送的动作。所以，在这一层当中就制订了
frame 的格式以及通过网络的方式。
<br>　
<br>事实上，每个 frame 都会具有一个 <font color="#000066">Media Access
Control (MAC, 共有 6 bytes 的地址)</font> 的地址，这个地址是来自于网络媒体，简单的来说，就是网络卡的卡号啦！每一张网络卡在出厂的时候就已经具有一个独特而且不会重复的卡号，那就是
MAC (一般也会称为 Hardware Address, 硬件地址)，而 frame 要传送的来源与目的地，就是依据这个
MAC 来进行传送的。至于传送过程当中的框包遗失、重新发送框包、封包的确认等等，也都是在这个层级当中被定义的吶！
<br>　
<br>在这个层级当中，有个重要的协议，那就是 Address Resolution Protocol
(ARP) ，这个 ARP 协议主要就是用来对应 MAC 与 IP 的重要工作喔！后续我们会仔细的说明。</td>
</tr>

<tr>
<td bgcolor="#CCFFFF">
<center>网络层</center>
</td>

<td>刚刚我们在上面提到的 TCP/IP 协议当中，那个 IP 就是网络层这个层级的重要内容了。网络层的主要功能就是要让封包
(packet) 可以在<font color="#000066">不同的网络</font>之间进行传递！请注意，实际上在进行电子讯号传递的是较底层的
MAC 与 frame ，而这个网络层的 packet 则是用来处理网络寻址的。
<br>　
<br>在这个 packet 被发送之前，在发送端的计算机会为这个封包建立表头(header)，Header
里面的信息包含了来源与目的端的地址，还有数据传送的方法与流程等，以作为这个
packet 在网络或者是子网之间进行路由 ( route )的依据。我们常常在设定的网络
IP 以及 route table 都是这一层的规定喔。</td>
</tr>

<tr>
<td bgcolor="#FF99FF">
<center>传送层<a name="before_osi_packet_size"></a></center>
</td>

<td>就像我们要寄信时一样，总是得把数据放入信封再封起来吧。这个传送层的工作之一就是将计算机数据『打包』成为封包(packet)的状态，以提供网络层去进行表头的建立！在这个层级当中，同时会设定控制节点之间的数据传递以及错误检测和修正的方法。
<br>　
<br>由于物理机制上的限制，所以在一次数据的传递中，通常只有数千 byte 
的资料量。为了确保不论多大或者多小的数据都可以正确的到达目的地，因此数据就会在这个层级当中被打包，如果数据太大，就会被拆成数个小封包来传送，并且
同时利用一个检测的手段来使数据正确的到达目的地。而如果数据封包有破损，也能够进行重新发送的工作。</td>
</tr>

<tr>
<td bgcolor="#FF99FF">
<center>会谈层</center>
</td>

<td>在这个层级当中，定义了两个地址之间的信道连接与挂断，也就是计算机与计算机之间的沟通模式。举例来说，
Client 为节点 A 而 Server 为节点 B，那么当数据要在 A 与 B 之间进行传送时，两部计算机会先进行会谈，以确认是否可以进行传送的动作。会谈的过程如下：
<ol>
<li>
<font color="#000066">当节点 A 要对 B 要求建立联机时，A 会先发出『联机请求』的讯息封包，该讯息上面带有
SYN 的符号；</font></li>

<li>
<font color="#000066">节点 B 收到讯息之后，如果确定接受 A 的联机要求，那么就会响应一个『确认请求』的讯息封包给
A ，该讯息上面则带有 SYN/ACK 符号；</font></li>

<li>
<font color="#000066">然后节点 A 再度响应给 B 一个『确认联机』的讯息封包，带有
ACK 的符号，这个时候就进入了数据传送的阶段了！</font></li>

<li>
<font color="#000066">当节点 A 数据传送完毕之后， A 会发送一个『终止联机』的讯息封包，则在得到
B 响应的『确认终止』讯息之后，就结束了该次联机！</font></li>
</ol>
上面即是有名的『<font color="#000066">三向交握, Three-Way Handshack</font>』的工作原理啦！那就是在这一层里面达成的哩！所以我们可以说，在会谈层里面可以提供稳定的可靠的联机渠道！</td>
</tr>

<tr>
<td bgcolor="#FF99FF">
<center>表现层</center>
</td>

<td>我们在应用程序上面所制作出来的数据格式不一定符合网络传输的标准编码格式的！所以，在这个层级当中，主要的动作就是：将来自本地端应用程序的资
料格式转换(或者是重新编码)成为网络的标准格式，然后再交给底下传送层等的协议来进行处理。当然啦，如果是来自远程的数据，那么这个层级也会将网络的标
准编码转换成为应用程序所需的格式，再交给应用程序处理。也就是说，这个层级当中定义了数据的语法以及格式，当应用程序的语法与格式不符时，还可以进行翻
译(重新编码)的工作。</td>
</tr>

<tr>
<td bgcolor="#FF99FF">
<center>应用层</center>
</td>

<td>表现层的工作是将来自应用程序的数据转成网络传输的标准格式，至于应用层则是完全与应用程序有关。</td>
</tr>
</tbody></table>
　
<br>由上面的说明，我们不难理解 OSI 七层协议当中，每一层之间是具有相关性的，并且底层要完备之后，才有办法进行上一层的工作。例如要进行
IP 的设定来说好了，如果没有网络接口，怎么进行 IP 的设定？而如果都没有网络媒体了，怎么进行数据传送？！另外，在每一层的协议中，都仅与该层相对应。目前到这里先说个简单的概念，后续请您继续看完之后，就能大略的了解了！
<br>　
<br>在下一节里面，我们将针对 OSI 七层协议里面的每一层进行说明，以让大家更容易了解整个网络的架构喔！</ul>

<hr><a name="Networklayer"></a><img src="../../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">网络层的相关协议</span><br>
<ul>在 OSI 
七层协议中，最底层的三层被定位为网络层，这三层是最基本的网络架构了！虽然这三层通常已经被整合在操作系统与硬件里面了，所以我们根本不需要担心这三层
的协议，不过，如果能够知道这些基础概念，对于未来在进行网络追踪时，帮助是很大的！底下我们就分别来谈一谈这三层的主要内容吧！不过，在开始之前，我们
得先来谈一谈整个网络传输单位的定义说～
<br>　
<br>
<hr width="100%"><a name="Networklayer_unit"></a><font color="#000099">传输单位</font>
<br>　
<br>想一想，如果没有电的话，我们的网络是否能够通行无阻？！当然不行！因为网络其实就是电子讯号的传送啊！如果没有电，当然就没有办法传送讯息了。而电子讯号只有
0 跟 1 啊，所以在网络单位的计算上，一般通常是以二进制的 bit 为单位的。那么这个
bit 与我们通常用来计算档案大小的单位 bytes 有什么关连性？其实：
<br>　
<ul><b><font face="细明体">1byte = 8bits</font></b></ul>
　
<br>所以啦，一般来说，我们看到的网络提供者<font color="#000066"> (Internet
Services Provide, ISP)</font> 所宣称他们的 ADSL 传输速度可以达到 下行/上行
512/64 Kbps ( Kbits per second) 时，那个 Kb 指的可不是 bytes 而是 bits
喔！所以 512/64 Kbps 在实际的档案大小传输速度上面，最大理论的传输为 64/8
KBps(KBytes per second)，所以正常下载的速度约在每秒 45~50 KBytes 之间吶！同样的道理，在网络卡或者是一些网络媒体的广告上面，他们都会宣称自己的产品可以自动辨识传输速度为
10/100 Mbps ( Mega-bits per second)，呵呵！该数值还是得再除以 8 才是我们一般常用的档案容量计算的单位
bytes 喔！这样可以了解传输单位的意义了吗？！
<br>　
<br>
<hr width="100%"><a name="Networklayer_physical"></a><font color="#000099">物理层</font>
<br>　
<br>既然网络是由硬件来进行讯号传递的，所以在这里我们就先来谈一谈网络媒体的运作方式吧！不过网络媒体的连接方式有相当多的类型，例如近来比较常见的『星形联机』以及较早期的直线型总线
(bus) ，以及以基地台为基准的无线网络等等类型，不同的类型在讯号的传递上是不太一样的。不过，由于
Bus 类型的联机模式是比较容易理解的一种联机模式，所以底下我们以基本的 Bus
联机模式来进行说明。如下面图示所示： ( 虽然一般家庭网络最常见的联机模式为星形模式，不过基本原理上面还是与
Bus 布线模式相同的 )
<br>　
<center><img src="0110network_basic_files/0110network_basic_2.jpg" nosave="" width="514" height="241">
<br><font color="#000066">图二、以 bus 串连计算机示意图</font></center>
　
<br>所有的计算机都经过同一个网络媒体(就是中间横向的那一条主要缆线)来进行连接。这个网络媒体上面有什么需要注意的地方呢？
<br>　
<ul>
<li>
<a name="Networklayer_physical_media"></a><b><font color="#000099">网络媒体</font></b>：</li>

<br>什么是『<font color="#000066">网络媒体</font>』说穿了，最基础的网络媒体就是『<font color="#000066">网络线</font>』啰，因为我们都是透过网络线来进行电子讯号的交流的嘛
( <i>再次请您留意，这里是以网络线为例，当然网络媒体还有相当多的样式的！</i>)。好了，请注意的是，当所有的计算机要进行数据传递的时候，就是需要使用到这个所谓的网络媒体，而由于所有的计算机都连接在这个网络媒体上面，您可以将这个
Bus 的网络线当成是一个『<font color="#000066">共享媒体</font>』啰！并且，这个共享媒体的传输限制为『<b><font color="#000066">单一时间点上面，只能有一部机器使用这个共享媒体</font></b>』，这个概念相当的重要，先记下来吧！</ul>
　
<br>现在我们知道讯号是藉由网络媒体来进行传递的，而这个媒体在单一时间点上面仅能让一个机器使用！果真如此的话，底下的问题该如何解决呢？
<br>　
<ol>
<li>
<font color="#000066">各计算机怎么知道该时间点上面有没有其他的机器在使用呢？</font></li>

<li>
<font color="#000066">如果 PC1 与 PC2 要相互沟通的话，他们的讯号是怎样传输的，也就是说，
PC1 怎么知道该讯号是要送到 PC2 呢？</font></li>

<li>
<font color="#000066">如果同一个时间里面有两部计算机以上同时使用这个媒体，会产生什么情况？</font></li>
</ol>
　
<br>底下就需要针对上面的问题来说明一下咯：
<br>　
<ul>
<li>
<a name="Networklayer_physical_broadcast"></a>由于这个<font color="#000066">网络共享媒体</font>在每个时间点上面仅能让一部机器使用
( 这个时间可能是几千到几万分之一秒，很短的啦！)，因此，如果 PC 1 这部计算机想要利用这个媒体发送数据出去时，他就必须要确认当时在这个媒体上面没有其他的机器在使用。这个时候
PC1 就会先发送一个讯息封包到这个媒体上面去，告诉这个媒体上面的所有计算机主机说『喂！我要使用这个媒体了』！而其他的
PC2 ~ PC5 在接到这样的讯息封包后，就会暂时停顿自己的网络工作，让 PC1 可以顺利的使用网络媒体传送数据(这个停顿也是很短的啦！您感觉不出来的
^_^ )。PC 1 发送讯息封包的这个行为就是所谓的『<b><font color="#000066">物理广播</font></b>』(<font color="#000066">Physical
Broadcast</font>) 了，而这个动作也是最底层的动作吶！</li>
</ul>
　
<ul>
<li>
知道了物理广播 ( Physical broadcast ) 的动作之后，再来，如果 PC1 与 PC
3 同时都想要使用网络媒体呢？呵呵！这个时候，就要看是谁先传送出广播信息的，当然是先抢先赢！例如：当
PC1 比 PC3 早一步向网络共享媒体送出物理广播信息，那么 PC3 就会先停顿，直到等到
PC1 将该次工作完毕之后，才会发送物理广播信息了。咦！您有没有发现这个地方很奇怪啊？！既然
PC 1 已经先抢先赢，万一 PC 1 要传送的数据高达 100 MB ，那么 PC 3 不是等到捉狂了？
呵呵！回到刚刚我们提到的 OSI 七层协议里面的『<a href="#before_osi_packet_size">传送层</a>』的地方，里面说到了：由于网络物理机制的关系
( 网络线的负荷啦、所有的网络周边啦等等的物理机器 ) ，每次进行网络传输时，该次的『封包大小』是有限制的！所以，如果
PC 1 的数据真的高达 100 MB 时，他也无法一次就将 100 MB 的数据打包成为一个
packet 的，网络媒体没有办法传输那么大的封包，所以当然就得将 100 MB拆开成为数个小
packet 再一次一次的传送出去啦！而每次的 physical broadcast 仅针对该次的
packet 发送而已，如果这个 packet 发送完，得再继续进行一次 physical broadcast
才能够再发送下一个 packet 喔！因此，这个 100MB 的传送得要 PC1 在这个共享媒体上面发送多次的
physical broadcast 才行哩！所以啦，如上面的例子来看，假设 PC1 要传输 100MB
而 PC3 要传输 10MB 时，他们是可以同时进行传输的，只是在网络媒体的使用上面，就会不断的进行物理广播，PC1
与 PC3 两个抢来抢去的，持续的将一个一个 packet 发送出去！这个时候网络媒体就很忙啦！</li>
</ul>
　
<ul>
<li>
持续上面的例子，那么 PC1 与 PC3 
可不可能『刚好』同时发出物理广播消息呢？！当然可能啦！在一个很繁忙的共享网络媒体当中，由于可能使用者众多，加上使用者可能正在大量的传送档案数据，
这个时候就容易发生同时发送物理广播信息的问题了！当发生在同一个网络媒体上面有两部主机以上同时发送物理广播的讯息时，两部主机该次的物理广播消息就会
无效，两部主机将不会进行数据的传送。不过也不需要太担心这样的情况，因为两部主机均会等待一段时间之后才再次进行物理广播的动作！而在等待的时间上面，
是『<font color="#000066">在一段时间里面随机取一个时间点</font>』来再次进行物理广播，(<i><font color="#000066">例如在千分之一秒的时间内，两部主机均随机取一个时间点，一部主机可能刚好选五千分之一秒，另一部选三千分之一秒，这样就避过再次同时发出物理广播消息的问题</font>。</i>
)由于是随机取样的，因此应该不太容易再造成同时进行物理广播的现象。万一真的不幸又同时物理广播，那么又会等待下一次....依序下去，好像超过
16 次以后，如果还真的很不幸(因为机率真的太低了)再次同时进行物理广播，那么就抱歉啦！您的网络媒体将瘫痪掉！不过也别担心，重新
reset ( 整个网络给他关机再开机 ) 就好啦！ ^_^""</li>
</ul>
　
<ul>
<li>
<a name="Networklayer_physical_collision"></a>由上面的情况来看，网络媒体上面似乎在某一个时间点时只会有一个封包在进行传送喔，那么有没有可能发生一个网络共享媒体上面同时发送封包的状况呢？当然有啦！现在您假设
PC1 到 PC5 的距离是很远(假设 50 m 好了)，那么当 PC1 与 PC5 发送出物理广播，提醒大家说要传送信息的时候，由于
PC1 与 PC5 的距离太远了，因此响应的时间比较长，那么这个时候可能就会造成主机的误判，认为当时媒体上面没有任何的机器在传送数据，所以就造成
PC1 与 PC5 同时传送出数据在媒体上面，这个时候就会发生所谓的『<b><font color="#000066">封包碰撞
( collision )</font></b>』的情况了！因为网络媒体上面单一时间内仅能允许一个机器使用的嘛！所以封包碰撞就会造成该封包的损毁现象呢！比较麻烦啦！因为封包损毁了，所以
PC1 与 PC5 又得再次将该次的 packet 重新发送一次，又得要物理广播.....而为了避免<font color="#000066">封包碰撞</font>的问题，所以目前网络上面都会使用一种称为
<font color="#000066">CSMA/CD
( Carrier Sense Multiple-Access / Collision Detect )</font> 的技术来避免因封包碰撞造成数据损毁的问题！不过，由于选择的媒体不同，所以还是很有可能会造成碰撞的啦！</li>

<br>　</ul>
上面提到的几个说明点，全部都是针对硬件的设计，您当然不需要知道硬件是怎么设计的，但是最好还是需要知道上述的这些原理，以后才会知道如果出了问题，要如何去解决！
<br>　
<br>在谈完了网络共享媒体之后，再来谈一谈目前最常见的网络配备，那就是以太网络的网络卡
( Ethernet ) 。目前我们在计算机主机后面看到的类似电话线接头，但是比较大一点的，里头具有八条线的插槽，那就是以太网络卡。这个网络卡最大的特色是他具有一个焊死在上面的地址
( 某些 Notebook 上面 PCMCIA 的网络卡是可调的 ) ，那就是 <font color="#000066">Media
Access Control (MAC)</font> ，也常常被我们称为<font color="#000066">硬件地址
( Hardware Address )</font>。让我们翻回到 OSI 七层协议里面的<a href="#before_osi_data_connect">数据连接层</a>，在该层级中说明，每个框包
( frame ) 要传送出去，必须要以硬件地址为传输的来源与目标，这就是网络卡与网络卡之间数据传输的最底层信息了。例如同样上面的图示，假设
PC 1 要将数据传送到 PC 2 上面去时，那么数据封包就必须要先取得 PC 2 主机的网络卡的
MAC 之后，才能够将数据传送给 PC2 呢！这个部分就需要在数据连接层来进行说明了。
<br>&nbsp;　
<br>
<hr width="100%"><a name="Networklayer_data_link"></a><font color="#000099">数据连接层</font>
<br>　
<br>在 TCP/IP 与 OSI 七层协议那个小节当中，我们知道网络世界上面使用来辨识计算机主机的是
IP ，这个 IP 是在 OSI 的第三层，也就是网络层的东西。而由上面的物理层的介绍，我们也可以知道其实数据封包由这个主机到下一个主机，使用的是
MAC 这个网络卡卡号 ( Hardware address ) 来进行传送的，那么 IP 与 MAC 有什么关系啊？！举个例子来说，同样的以上面图二为例好了，假设
PC 1 的 IP 是 192.168.1.1 而 PC2 的 IP 是 192.168.1.2 ，那么数据要由 PC
1 传送到 PC 2 的时后，到底是怎么进行传送的？其实也不难啦！因为数据要传送就得知道网络卡卡号，因此
PC1 必须要先知道 PC2 的 Hardware Address 之后，才能将数据由 PC1 的网络卡传送给
PC2 的网络卡上。也就是说， <font color="#000066">IP 必须要与 MAC ( 就是
Hardware address 啦 ) 对应起来才行</font>！这个时候，就需要使用到 <font color="#000066">Address
Resolution Protocol (ARP)</font> 协定了。底下我们就介绍一下 MAC 的格式，以及
ARP 的内容。
<br>　
<ul>
<li>
<a name="Networklayer_data_link_MAC"></a><b><font color="#000066">关于
MAC：</font></b></li>

<br>在目前我们使用的以太网络卡上面，其实在出厂的时后就已经焊死一个网络卡的卡号在上面了，因为这个卡号是跟随着硬件的，所以一般我们也称为硬件地址
(<font color="#000066">Hardware address</font>)，而且每一张网络卡上面的卡号都不会重复！事实上，他是被称为
<font color="#000066">Media
Access Control, MAC </font>的啦！MAC 的格式是六组 16 进位 (bytes) 的数据组合起来的，所以他共占掉
6 bytes ，基本的格式为：
<ul><font face="细明体"><font color="#000066">aa:bb:cc:dd:ee:ff</font></font></ul>
MAC 是以太网络当中，数据传输的重要依据喔！此外，MAC 在未来架设防火墙的时后，用来管制某张特定的网络卡是否能够通过封包过滤规则的重要设定内容！所以，请先对
MAC 有一个完整的了解吶。那么在 Linux 与 Windows 2000 底下，要怎么知道我的网络卡
MAC 呢？
<table width="550" bgcolor="#000000" border="" cols="1">
<tbody><tr>
<td><font face="细明体"><font color="#FFFFCC"><font size="-1">1. 在 Linux
底下：</font></font></font>
<br><font face="细明体"><font size="-1"><font color="#FFFFFF">[root@test
root]#</font><font color="#FFFF00"> ifconfig</font></font></font>
<br><font face="细明体"><font size="-1"><font color="#FFFFFF">eth0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Link encap:Ethernet&nbsp; </font><font color="#FFFF00">HWaddr <b>00:05:D3:43:E4:80</b></font></font></font>
<br><font face="细明体"><font color="#FFFFFF"><font size="-1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
inet addr:192.168.1.100&nbsp; Bcast:192.168.1.255&nbsp; Mask:255.255.255.0</font></font></font>
<br><font face="细明体"><font color="#FFFFFF"><font size="-1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
UP BROADCAST RUNNING MULTICAST&nbsp; MTU:1500&nbsp; Metric:1</font></font></font>
<br><font face="细明体"><font color="#FFFFFF"><font size="-1">.....</font></font></font>
<br><font face="细明体"><font color="#FFFFFF"><font size="-1">　</font></font></font>
<br><font face="细明体"><font color="#FFFFCC"><font size="-1">2. 在 Windows
2000 底下：</font></font></font>
<br><font face="细明体"><font size="-1"><font color="#FFFFFF">C:\&gt; </font><font color="#FFFF00">ipconfig
/all</font></font></font>
<p><font face="细明体"><font color="#FFFFFF"><font size="-1">Windows 2000
IP Configuration</font></font></font>
<br><font face="细明体"><font color="#FFFFFF"><font size="-1">.....</font></font></font>
<br><font face="细明体"><font size="-1"><font color="#FFFFFF">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Physical Address. . . . . . . . . :</font><b><font color="#FFFF00"> 00-05-D3-43-E4-80</font></b></font></font>
<br><font face="细明体"><font color="#FFFFFF"><font size="-1">.....</font></font></font></p></td>
</tr>
</tbody></table>
如同上面所示，在 Linux 底下，主要的格式是以『:』隔开的，在 Windows 底下，则是以『-』来隔开！无论如何，反正记得他是六组16进位的数据组成的就是了！使用的观察方式可以直接以
ifconfig 以及 ipconfig 来下达指令。
<br>　
<li>
<a name="Networklayer_data_link_ARP"></a><b><font color="#000066">关于
Address Resolution Protocol, ARP：</font></b></li>

<br>现今最常用的网络传输是使用 TCP/IP 来进行的，所以每一部主机当然要有一个
IP 才行！然而我们知道数据其实是使用 MAC 在不同的网络卡之间互相传递，因此，必须要设定一个
IP 与 MAC 对应的方法才行，此时就有 ARP 协定的产生了。ARP 这个协议在目前主要的操作系统里面都存在着，例如
Linux 主机里面就有一个 ARP table 来纪录 IP 与 MAC 的对应信息。所以，当前面图二中，
PC 1 (192.168.1.1) 要将数据传送到 PC2(192.168.1.2) ，那么 PC1 就会参考自己本身系统内的
arp table ，找到 192.168.1.2 对应的 MAC 之后，再将数据传送到那个 MAC 去！
<br>　</ul>
<font color="#000066">ARP table 主要记录的是 IP 与 MAC 的对应</font>，那么
ARP 表格是怎么产生的呢？这就需要讨论到<a name="Networklayer_data_link_logical_broadcast"></a><b><font color="#000066">逻辑广播
( logical broadcast ) </font></b>的动作了！请注意，逻辑广播与 Physical
broadcast ( 物理广播 ) 是不一样的， Physical broadcast 是主机想要在网络共享媒体上面传送数据时，用来确认网络媒体是否可以利用的一个动作，而逻辑广播的动作之一则是在找到
IP 与 MAC 的对应，也就是说『<font color="#000066">物理广播主要是针对在同一个物理网段内的共享网络媒体之动作，逻辑广播主要是针对网络层的软件地址而言来进行的动作</font>』，不样将两者搞混了。好了，那么主机是怎么建立
ARP table 的呢？我们同样以 PC 1 ( 192.168.1.1 ) 要传送数据给 PC 2 (192.168.1.2
) 为例好了：
<br>　
<ol>
<li>
在 PC1 首次进行数据传输的时候，由于 ARP table 当中没有相关的数据 ( 因为刚刚连上网络嘛！
) ，所以 PC 1 不知道 192.168.1.2 这个 IP 对应的是那个 MAC ，当然也就无法传递数据了。这个时候
PC 1 就会对『<font color="#000066">同一网域的全部计算机进行逻辑广播( logical
broadcast )</font>』，此时 PC 1 会发送一个带有本身的 MAC 与目标 IP (在这个例子中，也就是
192.168.1.2 ) 的逻辑广播封包给网域内的全部计算机( 在图二的例子中，包括 PC
2 ~ PC 5 均会收到这个逻辑广播封包 ) ；</li>

<br>　
<li>
在 PC 2 ~ PC 5 接到这个逻辑广播封包之后，由于这个逻辑广播封包的要求响应是
192.168.1.2 ，因为 PC 3 ~ PC 5 并不是这个 IP 的所有人，因此就会将这个逻辑广播封包丢弃不理。而
PC 2 收到这个逻辑广播封包时发现该封包要求的 IP 是自己的，此时他就会发送一个回应封包
( 该响应封包里面就含有 PC2 自己的 MAC ) 给 PC 1&nbsp; ；</li>

<br>　
<li>
PC 1 在收到这个响应封包之后，就知道了 PC2 这个 192.168.1.2 IP 对应的 MAC
了，此时 PC 1 这部主机的 ARP table 就会主动的将 IP 与 MAC 的对应给他写入表格中啦！而既然已经知道了
IP 对应 MAC 了，因此 PC1 就可以开始将资料传送给 PC 2 了！</li>

<br>　
<li>
未来，当 PC 1 要将资料再传给 PC 2 时，他会先由自己本身的 ARP table 里面去找寻是否有该主机的
IP 对应的 MAC 信息，如果找到了 PC 2 (192.168.1.2) 对应的 MAC ，那么 PC
1 将不会发送逻辑广播封包，而是直接依据 ARP table 里面的信息来将数据直接传送给
PC 2 的网络卡呢！也就是说：</li>

<ul>
<li>
<font color="#000066">如果 ARP table 有纪录的话，那么数据就会直接的传送到该目的地去，而不会进行『逻辑广播』；</font></li>

<li>
<font color="#000066">如果 ARP table 没有纪录的话，那么主机就又会对全部的同一网域内的计算机进行『逻辑广播』。</font></li>
</ul>
　</ol>
此外，请特别注意，<font color="#000066">ARP table 是动态的信息</font>，他会随时随着您的网域里面计算机的
IP 更动而变化，所以，即使您常常更动您的计算机 IP，不要担心，因为 ARP table
会自动的重新对应 IP 与 MAC 的表格内容！( 所以每次重新启动，原先 ARP table
的内容就不见去啰！ )那么我怎么查出来目前我的 Linux 主机里面的 ARP table
的纪录呢？呵呵！可以使用 arp 这个指令喔！<a name="Networklayer_data_link_arp_comm"></a>
<table width="550" bgcolor="#000000" border="" cols="1">
<tbody><tr>
<td><font face="细明体"><font size="-1"><font color="#FFFFFF">[root@test
root]# </font><font color="#FFFF00">arp [-and] hostname</font></font></font>
<br><font face="细明体"><font size="-1"><font color="#FFFFFF">[root@test
root]#</font><font color="#FFFF00"> arp -s hostname(IP) Hardware_address</font></font></font>
<br><font face="细明体"><font color="#FF6666"><font size="-1">参数说明：</font></font></font>
<br><font face="细明体"><font color="#FFFF99"><font size="-1">-a ：显示出目前主机所有的
IP 对应 MAC 状态</font></font></font>
<br><font face="细明体"><font color="#FFFF99"><font size="-1">-n ：将主机名以
IP 的型态显示</font></font></font>
<br><font face="细明体"><font color="#FFFF99"><font size="-1">-d ：将 hostname
的 hardware_address 由 ARP table 当中删除掉</font></font></font>
<br><font face="细明体"><font color="#FFFF99"><font size="-1">-s ：设定某个
IP 或 hostname 的 MAC 到 ARP table 当中</font></font></font>
<br><font face="细明体"><font color="#FF6666"><font size="-1">范例：</font></font></font>
<br><font face="细明体"><font size="-1"><font color="#FFFFFF">[root@test
root]# </font><font color="#FFFF00">arp</font></font></font>
<br><font face="细明体"><font color="#FFFFFF"><font size="-1">Address&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
HWtype&nbsp; HWaddress&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Flags Mask&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Iface</font></font></font>
<br><font face="细明体"><font color="#FFFFFF"><font size="-1">localhost&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ether&nbsp;&nbsp;
 08:00:20:C5:89:4D&nbsp;&nbsp; 
C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
eth0</font></font></font>
<br><font face="细明体"><font size="-1"><font color="#FFFFFF">[root@test
root]# </font><font color="#FFFF00">arp -n</font></font></font>
<br><font face="细明体"><font color="#FFFFFF"><font size="-1">Address&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
HWtype&nbsp; HWaddress&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Flags Mask&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Iface</font></font></font>
<br><font face="细明体"><font color="#FFFFFF"><font size="-1">192.168.1.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ether&nbsp;&nbsp;
 08:00:20:C5:89:4D&nbsp;&nbsp; 
C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
eth0</font></font></font>
<br><font face="细明体"><font size="-1"><font color="#FFFFFF">[root@test
root]#</font><font color="#FFFF00"> arp -s 192.168.1.100&nbsp;&nbsp; 01:00:2D:23:A1:0E</font></font></font></td>
</tr>
</tbody></table>
一般来说，使用 arp 这个指令就可以查到您的 Linux 主机上面的 arp 表了！善用
Linux 的指令吧！当然， Windows 2000 里面也同时存在一个 arp 的指令，可以尝试看看喔！
<br>　
<br>在谈完了 OSI 七层协议里面的物理层与数据连接层之后，接下来就是最重要的网络层了！不过，因为网络层里面的
IP 实在太重要了，所以我们将他独立出一个小节来继续介绍。当然，底下就独立的来介绍与
IP 相关的一些概念，包含了 Netmask, Broadcast, Gateway 以及网域的概念等等。</ul>

<hr><a name="IP"></a><img src="../../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">Internet Protocol, IP 概</span><br>
<ul>认识了最底层的网络共享媒体与数据链路层的 ARP 及 MAC 概念之后，接下来要跟大家介绍的就是那个可爱又可恨的网络门牌『<font color="#000066">Internet
Protocol, IP</font>』了，IP 是所有网络的基础，没有了他，您的网络将只是一堆废铁啊！赶紧来认识一下吧！
<br>　
<br>
<hr width="100%"><a name="IP_component"></a><font color="#000099">IP 的组成：</font>
<br>　
<br>我们目前在网络上使用的 IP 协议是第四版，也就是被称为<font color="#000066">
IPv4 </font>的一个协定。在这个协议当中，最重要的就是 IP 的组成了。<font color="#000066">IP
主要是由 32 bits 的资料所组成的一组数据</font>，也就是 32 组 0 跟 1 所组成的数据数据，因为只有零跟一，所以
IP 的组成当然就是计算机认识的二进制的表示方式了。不过，因为人类对于二进制实在是不怎么熟悉，所以为了顺应人们对于十进制的依赖性，因此，就将
32 bits 的 IP 分成四小段，每段含有 8 个 bits ，将 8 个 bits 计算成为十进制，并且每一段中间以小数点隔开，那就成了目前大家所熟悉的
IP 的书写模样了。如下所示：
<br>　
<table width="400" bgcolor="#000000" border="" cols="1">
<tbody><tr>
<td><font face="细明体"><font color="#FFFFCC"><font size="-1">IP 的表示式：</font></font></font>
<br><font face="细明体"><font size="-1"><font color="#FFFFFF">00000000.00000000.00000000.00000000
</font><font color="#FFFF00">==&gt;0.0.0.0</font></font></font>
<br><font face="细明体"><font size="-1"><font color="#FFFFFF">11111111.11111111.11111111.11111111
</font><font color="#FFFF00">==&gt;255.255.255.255</font></font></font></td>
</tr>
</tbody></table>
　
<br>所以 IP 最小可以由 0.0.0.0 一直到 255.255.255.255 哩！事实上， IP 的组成当中，除了以
32 bits 的组成方式来说明外，还具有所谓的『网域』的概念存在。底下就来谈一谈什么是网域吧！
<br>　
<br>
<hr width="100%"><a name="IP_Networking"></a><font color="#000099">网域的概念</font>
<br>　
<br>事实上 IP 的 32 bits 数据中，可以分为 HOST_ID 与 Net_ID 两部份，我们先以
192.168.0.0 ~ 192.168.0.255 这个 C Class 的网域当作例子来说明好了：
<br>　
<table width="400" bgcolor="#000000" border="" cols="1">
<tbody><tr>
<td><font face="细明体"><font color="#FFFFCC"><font size="-1">192.168.0.0~192.168.0.255
这个 C Class 的说明：</font></font></font>
<br><font face="细明体"><font color="#FFFFFF"><font size="-1">11000000.10101000.00000000.00000000</font></font></font>
<br><font face="细明体"><font color="#FFFFFF"><font size="-1">11000000.10101000.00000000.11111111</font></font></font>
<br><font face="细明体"><font color="#FFFF00"><font size="-1">|----------Net_ID---------|-host--|</font></font></font></td>
</tr>
</tbody></table>
　
<br>在 C Class 的范例当中，前面三组数字 (192.168.0) 称为 Net_ID，最后面一组数字则称为
Host_ID。同一个网域当中的定义是『<font color="#000066">在同一个物理网段内，主机的
IP 具有相同的 Net_ID ，并且具有独特的 Host_ID</font>』，那么这些 IP 群就是同一个网域内的
IP 网段啦！ ( <i><font color="#000066">注：什么物理网段呢？举例来说，上图二所有的主机都是使用同一个网络媒体串在一起，这个时候这些主机在实体装置上面其实是联机在一起的，那么就可以称为这些主机在同一个物理网段内了！同时并请注意，同一个物理网段之内，可以依据不同的
IP 的设定，而设定成多个『IP 网段』喔！&nbsp;</font></i> ) 例如上面例子当中的
192.168.0.1, 192.168.0.2, ...., 192.168.0.255 这些 IP 就是同一个网域内的
IP 群(同一个网域也称为同一个网段！)，请注意，同一个 Net_ID 内，不能具有相同的
Host_ID ，例如上图二当中， PC 1 与 PC 5 不能同时具有 192.168.0.1 这个 IP
，否则就会发生 IP 冲突，可能会造成两部主机都没有办法使用网络的问题！那么同一个网域该怎么设定，与将
IP 设定在同一个网域之内有什么好处呢？
<br>　
<ul>
<li>
<font color="#000066">在同一个网段内，Net_ID 是不变的，而 Host_ID 则是不可重复，此外，
Host_ID 在二进制的表示法当中，不可同时为 0 也不可同时为 1 ，例如上面的例子当中，
192.168.0.0 ( Host_ID 全部为 0 )以及 192.168.0.255 ( Host_ID 全部为 1 )
不可用来作为网段内主机的 IP 设定，也就是说，这个网段内可用来设定主机的
IP 是由 192.168.0.1 到 192.168.0.254；</font></li>

<li>
<font color="#000066">在同一个网域之内，每一部主机都可以藉由<a href="#Networklayer_data_link_logical_broadcast">逻辑广播
( logical broadcast )</a> 取得网域内其他主机的 MAC 对应 IP；</font></li>

<li>
<font color="#000066">由上面的逻辑广播动作取得 MAC 之后(亦即 <a href="#Networklayer_data_link_ARP">ARP</a>
协议)，在同一个网域之内，主机的数据可以直接透过彼此的 NIC ( Network Interface
Card, 网络卡 ) 进行传送；</font></li>

<li>
<font color="#000066">在同一个物理网段之内，如果两部主机设定成不同的 IP
网段，则两部主机无法直接以逻辑广播进行数据的传递 ( 在没有设定特殊 route
规则的情况下 )。</font></li>
</ul>
　
<br>所以说，我们家里的所有计算机当然都设定在同一个网域内是最方便的，因为如此一来每一部计算机都可以直接进行数据的交流，而不必经由
Router ( 路由器 ) 来进行封包的沟通呢！( Router 这部份在后续才会提及！ )。好了，刚刚我们上面说的是
C Class 的网域，那么有没有其他 Class 的网域呢？而且他们又是怎么区分的呢？目前
Internet 将整个 IP 简单的方类成为三个网段，分别设定为所谓的 A, B, C 三个
Class ，他们的分类原则如下：
<br>　
<table width="500" bgcolor="#000000" border="" cols="1">
<tbody><tr>
<td><font face="细明体"><font color="#FFFFCC"><font size="-1">以二进制说明
Network 第一个数字的定义：</font></font></font>
<br><font face="细明体"><font size="-1"><font color="#FFFFFF">A Class : 0xxxxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx　</font><font color="#FFFF00">==&gt;开头是
0&nbsp;</font></font></font>
<br><font face="细明体"><font color="#FFFF00"><font size="-1">　　　　　|--net--|---------host------------|</font></font></font>
<br><font face="细明体"><font size="-1"><font color="#FFFFFF">B Class : 10xxxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx　</font><font color="#FFFF00">==&gt;开头是
10</font></font></font>
<br><font face="细明体"><font color="#FFFF00"><font size="-1">　　　　　|------net-------|------host------|</font></font></font>
<br><font face="细明体"><font size="-1"><font color="#FFFFFF">C Class : 110xxxxx.xxxxxxxx.xxxxxxxx.xxxxxxxx　</font><font color="#FFFF00">==&gt;开头是
110</font></font></font>
<br><font face="细明体"><font color="#FFFF00"><font size="-1">　　　　　|-----------net-----------|-host--|</font></font></font>
<br><font face="细明体"><font color="#FFFF00"><font size="-1">　</font></font></font>
<br><font face="细明体"><font color="#FFFFCC"><font size="-1">以十进制说明
Network 的定义：</font></font></font>
<br><font face="细明体"><font color="#FFFFFF"><font size="-1">A Class :&nbsp;&nbsp;
0.xx.xx.xx ~ 126.xx.xx.xx</font></font></font>
<br><font face="细明体"><font color="#FFFFFF"><font size="-1">B Class : 128.xx.xx.xx
~ 191.xx.xx.xx</font></font></font>
<br><font face="细明体"><font color="#FFFFFF"><font size="-1">C Class : 192.xx.xx.xx
~ 223.xx.xx.xx</font></font></font></td>
</tr>
</tbody></table>
　
<br><a name="IP_Networking_loopback"></a>在上表中，可能您会觉得很奇怪，咦！那个
127.xx.xx.xx 怎么不见了？！他应该也是 A Class 的一段吧？！没错，是不见了，因为这个网段被拿去给操作系统做为<font color="#000066">内部循环网络
( loopback )</font> 之用了！在各个操作系统当中，不管该主机的硬件有没有网络卡，为了让作业确认自己的网络没有问题，所以将
127.xx.xx.xx 这个 A Class 的网段拿到操作系统当中，来做为内部的回路测试！所以啦，这个
127.0.0.1 就不可以用来做为网络网域的设定了。
<br>　
<br>
<hr width="100%"><a name="IP_Netmask"></a><font color="#000099">Netmask
的用途 (效能) 与子网的切分</font>
<br>　
<br>在上一小节当中提到的 A, B, C 三个层级的网域是由 IP 协定预设分配的，在这样的层级当中，我们可以发现
A Class 可以用于设定计算机主机的 IP 数量 ( Host ) 真的是很多，在同一个 A
Class 的网域内，主机的数量可以达到『 <font color="#000066">256 X 256 X
256 - 2(HostID全为0或1) = 16777214</font>』，不过，这样的设定情况对于一般网络的效能却是不太好的！为什么呢？让我们回到
OSI 七层协议里面的<a href="#Networklayer_physical">共享媒体</a>上面，还记得共享媒体上面主机
A 要发送数据出去的时后，需要先进行『<a href="#Networklayer_physical_broadcast">物理广播</a>』来确认媒体上面没有人在使用吧？而其他的主机在接收到这样的物理广播封包之后，就得要先将手边关于网络的工作停顿下来等主机
A 将动作做完之后，其他的主机才能进行下一次的物理广播。所以如果我们是以
A Class 的架构来架设我们的网络的话，那么当一部主机要传送数据时，其他的所有主机都得要停顿的吶！而且，如此大型的网域内，肯定更容易发生<a href="#Networklayer_physical_collision">封包碰撞
( Collision ) </a>的问题，而且在进行<a href="#Networklayer_data_link_logical_broadcast">逻辑广播</a>的时后，响应的计算机主机数量也实在是太多了！如此一来，整个网络的效能将会变的很糟糕！所以，一般来说，我们最多都仅设定
C Class 做为整个局域网络的架构，其实就连 C Class 也都太大了！不过不打紧，只要记得一个网域内不要超过
30 部以上的主机数量，那样网络的效能就会比较好一点～
<br>　
<br>其实，除了 C Class 之外，我们还是可以继续将网络切的更细的！上个章节我们提到
IP 分为 Net_ID 与 Host_ID，其中 C Class 的 Net_ID 占了 24 bits ，而其实我们还可以将这样的网域切的更细，就是让第一个
Host_ID 被拿来作为 Net_ID ，所以，整个 Net_ID 就有 25 bits ，至于 Host_ID
则减少为 7 bits 。在这样的情况下，原来的一个 C Class 的网域就可以被切分为两个子域，而每个子域就有『
<font color="#000066">256/2
- 2 = 126</font> 』个可用的 IP 了！这样一来，在这个网域当中的主机在进行逻辑广播时，响应的主机数量就少了一半，当然对于网络的效能多多少少有点好处的啦！
<br>　
<br>好了，知道了子网切分的大致情况后，现在要谈的是，那么到底是什么参数来达成子网的切分呢？呵呵！那就是
Netmask ( 子网掩码 ) 的用途啦！这个 Netmask 是用来定义出网域的最重要的一个参数了！不过他也最难理解了～
@_@。为了帮助大家比较容易记忆住 Netmask 的设定依据，底下我们介绍一个比较容易记忆的方法。同样以
192.168.0.0~192.168.0.255 这个网域为范例好了，如下所示，这个 IP 网段可以分为
Net_ID 与 Host_ID，既然 Net_ID 是不可变的，那就假设他所占据的 bits 已经被用光了
( 全部为 1 )，而 Host_ID 是可变的，就将他想成是保留着 ( 全部为 0 )，所以，
Netmask 的表示就成为：
<br>　
<table width="400" bgcolor="#000000" border="" cols="1">
<tbody><tr>
<td><font face="细明体"><font color="#FFFFCC"><font size="-1">192.168.0.0~192.168.0.255
这个 C Class 的说明：</font></font></font>
<br><font face="细明体"><font color="#FFFFFF"><font size="-1">11000000.10101000.00000000.00000000</font></font></font>
<br><font face="细明体"><font color="#FFFFFF"><font size="-1">11000000.10101000.00000000.11111111</font></font></font>
<br><font face="细明体"><font color="#FFFF00"><font size="-1">|----------Net_ID---------|-host--|</font></font></font>
<br><font face="细明体"><font color="#FFFF00"><font size="-1">11111111.11111111.11111111.00000000&nbsp;
&lt;== Netmask 二进制</font></font></font>
<br><font face="细明体"><font color="#FFFF00"><font size="-1">&nbsp; 255&nbsp;&nbsp;
.&nbsp; 255&nbsp;&nbsp; .&nbsp; 255&nbsp;&nbsp; .&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&lt;== Netmask 十进制</font></font></font></td>
</tr>
</tbody></table>
　
<br>将他转成十进制的话，就成为『<font color="#000066">255.255.255.0</font>』啦！这样记忆简单多了吧！照这样的记忆方法，那么
A, B, C Class 的 Netmask 表示就成为这样：
<br>　
<table width="500" bgcolor="#000000" border="" cols="1">
<tbody><tr>
<td><font face="细明体"><font color="#FFFF00"><font size="-1">Netmask 表示方式：</font></font></font>
<br><font face="细明体"><font color="#FFFFFF"><font size="-1">A Class : 11111111.00000000.00000000.00000000
==&gt; 255.&nbsp; 0.&nbsp; 0.&nbsp; 0</font></font></font>
<br><font face="细明体"><font color="#FFFFFF"><font size="-1">B Class : 11111111.11111111.00000000.00000000
==&gt; 255.255.&nbsp; 0.&nbsp; 0</font></font></font>
<br><font face="细明体"><font color="#FFFFFF"><font size="-1">C Class : 11111111.11111111.11111111.00000000
==&gt; 255.255.255.&nbsp; 0</font></font></font></td>
</tr>
</tbody></table>
　
<br>所以说， 192.168.0.0~192.168.0.255 这个 C Class 的网域中，他的 Netmask
就是 255.255.255.0 了！再来，我们刚刚提到了当 Host_ID 全部为 0 以及全部为
1 的时后该 IP 是不可以使用的，因为 Host_ID 全部为 0 的时后，表示 IP 是该网段的
Network ，至于全部为 1 的时后就表示该网段最后一个 IP ，也称为 Broadcast
，所以说，在 192.168.0.0 ~ 192.168.0.255 这个 IP 网段里面的相关网络参数就有：
<br>　
<table width="500" bgcolor="#000000" border="" cols="1">
<tbody><tr>
<td><font face="细明体"><font size="-1"><font color="#FFFF00">Netmask:&nbsp;&nbsp;
255.255.255.0&nbsp;</font><font color="#FFFFFF">&nbsp; &lt;==网域定义中，最重要的参数</font></font></font>
<br><font face="细明体"><font size="-1"><font color="#FFFF00">Network:&nbsp;&nbsp;
192.168.0.0&nbsp;&nbsp;&nbsp;&nbsp;</font><font color="#FFFFFF"> &lt;==第一个
IP</font></font></font>
<br><font face="细明体"><font size="-1"><font color="#FFFF00">Broadcast:
192.168.0.255&nbsp;</font><font color="#FFFFFF">&nbsp; &lt;==最后一个 IP</font></font></font>
<br><font face="细明体"><font color="#FFFFFF"><font size="-1">可用的 IP 数：</font></font></font>
<br><font face="细明体"><font color="#FFFF00"><font size="-1">192.168.0.1
~ 192.168.0.254</font></font></font></td>
</tr>
</tbody></table>
　
<br>一般来说，如果我们知道了 Network 以及 Netmask 之后，就可以定义出该网域的所有
IP 了！因为由 Netmask 就可以推算出来 Broadcast 的 IP 啊！因此，我们常常会以
Network 以及 Netmask 来表示一个网域，例如这样的写法：
<br>　
<table width="500" bgcolor="#000000" border="" cols="1">
<tbody><tr>
<td><font face="细明体"><font color="#FFFF00"><font size="-1">Network/Netmask</font></font></font>
<br><font face="细明体"><font color="#FFFF00"><font size="-1">192.168.0.0/255.255.255.0</font></font></font>
<br><font face="细明体"><font color="#FFFF00"><font size="-1">192.168.0.0/24</font></font></font></td>
</tr>
</tbody></table>
　
<br>另外，既然 Netmask 里面的 Net_ID 都是 1 ，那么 C Class 共有 24 bits
的 Net_ID ，所以啦，就有类似上面 192.168.0.0/24 这样的写法啰！这就是一般网域的表示方法。好了，刚刚提到
C Class 还可以继续进行子域 ( Subnet ) 的切分啊，以 192.168.0.0/24 这个情况为例，他要如何再细分为两个子域呢？我们已经知道
Host_ID 可以拿来当作 Net_ID，那么 Net_ID 使用了 25 bits 时，就会如下所示：
<br>　
<table width="400" bgcolor="#000000" border="" cols="1">
<tbody><tr>
<td><font face="细明体"><font color="#FFFFCC"><font size="-1">原本的 C Class：</font></font></font>
<br><font face="细明体"><font color="#FFFFFF"><font size="-1">11000000.10101000.00000000.00000000</font></font></font>
<br><font face="细明体"><font color="#FFFFFF"><font size="-1">11000000.10101000.00000000.11111111</font></font></font>
<br><font face="细明体"><font color="#FFFF00"><font size="-1">|----------Net_ID---------|-host--|</font></font></font>
<br><font face="细明体"><font color="#FFFF00"><font size="-1">　</font></font></font>
<br><font face="细明体"><font color="#FFFFCC"><font size="-1">切成两个子网</font></font></font>
<br><font face="细明体"><font color="#FFFFCC"><font size="-1">子网一：</font></font></font>
<br><font face="细明体"><font size="-1"><font color="#FFFF00">11000000.10101000.00000000.00000000&nbsp;</font><font color="#FFFFFF">
&lt;==Network</font></font></font>
<br><font face="细明体"><font size="-1"><font color="#FFFF00">11000000.10101000.00000000.01111111&nbsp;</font><font color="#FFFFFF">
&lt;==Broadcast</font></font></font>
<br><font face="细明体"><font color="#FFFF00"><font size="-1">|----------Net_ID----------|-host-|</font></font></font>
<br><font face="细明体"><font size="-1"><font color="#FFFF00">11111111.11111111.11111111.10000000
</font><font color="#FFFFFF">&lt;==Netmask
二进制</font></font></font>
<br><font face="细明体"><font size="-1"><font color="#FFFF00">&nbsp; 255&nbsp;&nbsp;
.&nbsp; 255&nbsp;&nbsp; .&nbsp; 255&nbsp;&nbsp; .&nbsp; 128&nbsp; </font><font color="#FFFFFF">&lt;==Netmask
十进制</font></font></font>
<br><font face="细明体"><font color="#FFFFFF"><font size="-1">所有 IP 与网域表示式：</font></font></font>
<br><font face="细明体"><font color="#FFFF00"><font size="-1">192.168.0.0
~ 192.168.0.127</font></font></font>
<br><font face="细明体"><font size="-1"><font color="#FFFF00">192.168.0.0/25
</font><font color="#FFFFFF">或</font><font color="#FFFF00">
192.168.0.0/255.255.255.128</font></font></font>
<br><font face="细明体"><font color="#FFFF00"><font size="-1">　</font></font></font>
<br><font face="细明体"><font color="#FFFFCC"><font size="-1">子网二：</font></font></font>
<br><font face="细明体"><font size="-1"><font color="#FFFF00">11000000.10101000.00000000.10000000&nbsp;</font><font color="#FFFFFF">
&lt;==Network</font></font></font>
<br><font face="细明体"><font size="-1"><font color="#FFFF00">11000000.10101000.00000000.11111111&nbsp;</font><font color="#FFFFFF">
&lt;==Broadcast</font></font></font>
<br><font face="细明体"><font color="#FFFF00"><font size="-1">|----------Net_ID----------|-host-|</font></font></font>
<br><font face="细明体"><font size="-1"><font color="#FFFF00">11111111.11111111.11111111.10000000&nbsp;</font><font color="#FFFFFF">
&lt;==Netmask 二进制</font></font></font>
<br><font face="细明体"><font size="-1"><font color="#FFFF00">&nbsp; 255&nbsp;&nbsp;
.&nbsp; 255&nbsp;&nbsp; .&nbsp; 255&nbsp;&nbsp; .&nbsp; 128&nbsp; </font><font color="#FFFFFF">&lt;==Netmask
十进制</font></font></font>
<br><font face="细明体"><font color="#FFFFFF"><font size="-1">所有 IP 与网域表示式：</font></font></font>
<br><font face="细明体"><font color="#FFFF00"><font size="-1">192.168.0.128
~ 192.168.0.255</font></font></font>
<br><font face="细明体"><font size="-1"><font color="#FFFF00">192.168.0.128/25</font><font color="#FFFFFF">
或</font><font color="#FFFF00"> 192.168.0.128/255.255.255.128</font></font></font></td>
</tr>
</tbody></table>
　
<br>所以说，当再细分下去时，就会得到两个子域，而两个子域还可以再细分下去喔
(Net_ID 用掉 26 bits ....)。呵呵！如果您真的能够理解 IP, Network, Broadcast,
Netmask 的话，恭喜您，未来的服务器学习之路已经顺畅了一半啦！ ^_^
<br>　
<br>
<hr width="100%"><a name="IP_types"></a><font color="#000099">IP 的种类与
IP 的取得方式</font>
<br>　
<br>接下来要跟大家谈一谈也是很容易造成大家困扰的一个部分，那就是 IP 的种类！很多朋友常常听到什么『真实IP,
实体 IP, 虚拟 IP, 假的 IP....』烦都烦死了～其实不要太紧张啦！实际上，在
IPv4 里面就只有两种 IP 的种类，一种称为 <b><font color="#000066">Public
IP</font> </b>，翻译成为公共的或者是公开的 IP，另一种则是 <b><font color="#000066">Private
IP</font></b>，翻译成为『<font color="#000066">私有 IP</font>』或者是『<font color="#000066">内部保留
IP</font>』。那么这两种 IP 要怎么分呢？很简单，只要『<font color="#000066">能够直接而不必透过其他机制就能与
Internet 上面的主机进行沟通的，那就是 public IP；无法直接与 Internet 上面沟通的，那就是
Private IP</font>』。这是一个很简单的分辨方法啦！
<br>　
<br>早在 IPv4 规划的时候就担心 IP 会有不足的情况，而且为了应付某些私有网络的网络设定，于是就有了私有
IP ( Private IP ) 的产生了。私有 IP 也分别在 A, B, C 三个 Class 当中各保留一段作为私有
IP 网段，那就是：
<br>　
<ul>
<li>
<font face="细明体"><font color="#000066">A Class：10.0.0.0&nbsp;&nbsp;&nbsp;
- 10.255.255.255</font></font></li>

<li>
<font face="细明体"><font color="#000066">B Class：172.16.0.0&nbsp; - 172.31.255.255</font></font></li>

<li>
<font face="细明体"><font color="#000066">C Class：192.168.0.0 - 192.168.255.255</font></font></li>
</ul>
　
<br><font color="#000000">由于这三个 Class 的 IP 是预留使用的，所以</font><font color="#000066">并不能直接作为
Internet 上面的连接之用</font><font color="#000000">，不然的话，到处都有相同的
IP 啰！那怎么行！网络岂不混乱？所以啰，这三个 IP 网段就只做为内部私有网域的
IP 沟通之用，也就是说，他有底下的几个限制：</font>
<br><font color="#000000">　</font>
<ul>
<li>
<font color="#000066">私有地址的路由信息不能对外散播 （就是内部网络咯）；</font></li>

<li>
<font color="#000066">使用私有地址作为来源或目的地址的封包，不能透过 Internet
来转送 （呵呵！当然啰！不然网络会混乱）；</font></li>

<li>
<font color="#000066">关于私有地址的参考纪录(如DNS)，只能限于内部网络使用（一样的原理啦！）</font></li>
</ul>
<font color="#000000">　</font>
<br><font color="#000000">这个私有 IP 有什么好处呢？呵呵！由于他的私有路由不能对外直接提供信息，所以呢，</font>您<font color="#000066">的虚拟网络将不会直接被
Internet 上面的 Cracker 所攻击</font><font color="#000099">！</font><font color="#000000">但是，当然啰，</font>您<font color="#000066">也就无法以私有
IP 来『直接上网』</font><font color="#000000">啰！所以相当适合一些尚未具有
Public IP 的企业内部用来规划其网络之设定之用！否则当</font>您<font color="#000000">随便指定一些可能是
Public IP 的网段来规划</font>您<font color="#000000">的企业内部的网络设定时，万一哪一天真的连上
Internet 了，那么启不是可能会造成跟 Internet 上面的 Public IP 相同了吗？！这可不是闹着玩的，要将</font>您<font color="#000000">原先规划的
IP 网段整个重新调整过呢！哈哈！累死了！那么万一</font>您<font color="#000000">又要将这些私有
IP 送上 Internet 呢？呵呵！这个简单，设定一个简单的防火墙加上 NAT ( Network
Address Transfer ) 主机设定，</font>您<font color="#000066">就可以透过
IP 伪装(不要急，这个在后面也会提到！)来使</font>您<font color="#000066">的私有
IP 的计算机也可以连上 Internet 啰(虽然不是真的直接，但是很像『直接上网』呢！)</font>
<br><font color="#000066">　</font>
<br><font color="#000000">好了，那么除了这个预留的 IP 网段的问题之外，还有没有什么其他的怪东西呢？呵呵！当然是有啦！不然我干嘛花时间来唬
XX 呢！？没错，还有一个奇怪的 A Class 的网域，那就是 lo 这个奇怪的网域啦
( 注意：是小写的 o 而不是零喔！ )这个 lo 的网络是当初被用来作为测试操作系统内部循环所用的一个网域！简单的说，如果</font>您<font color="#000000">没有安装网络卡在</font>您<font color="#000000">的机器上面，但是</font>您<font color="#000000">又希望可以测试一下在</font>您<font color="#000000">的机器上面设定的数据到底可不可以被执行，这个时候怎么办，嘿嘿！就是利用这个所谓的内部循环网络啦！这个网段在
127.0.0.0/8 这个 A Class ，而且默认的主机 ( localhost ) 的 IP 是 127.0.0.1
呦！所以啰，当</font>您<font color="#000000">启动了</font>您<font color="#000000">的
WWW 服务器，然后在</font>您<font color="#000000">的主机的 X-Window 上面执行
http://localhost 就可以直接看到</font>您<font color="#000000">的主页啰！而且不需要安装网络卡呢！测试很方便吧！此外，</font>您<font color="#000000">的内部使用的
mail 怎么运送邮件呢？例如</font>您<font color="#000000">的主机系统如何
mail 给 root 这个人呢？嘿嘿！也就是使用这一个内部循环啦！当要测试</font>您<font color="#000000">的
TCP/IP 封包与状态是否正常时，可以使用这个呦！( 所以哪一天有人问</font>您<font color="#000000">：嘿！</font>您<font color="#000000">的主机上面没有网络卡，那么</font>您<font color="#000000">可以测试</font>您<font color="#000000">的
WWW 服务器设定是否正确吗？这个时候可得回答：当然可以啰！使用 127.0.0.1
这个 Address 呀！ ^_^... )</font>
<br><font color="#000000">　</font>
<br><font color="#000000">理解了 IP 的种类之后，我们已经知道了要连上 Internet
就得要取得 Public IP 才可以，至于 private IP 则是用在内部的私有网络之用的！那么该如何取得
Public IP 呢？目前在台湾地区有几个可取得 Public IP 的方法：</font>
<br><font color="#000000">　</font>
<ul>
<li>
<font color="#000066">固定制手动设定</font><font color="#000000">：我们可以取得固定的
Public IP ，取得的管道可以是学术网络、或者是向 ISP 注册固定的 Public IP。不过，在使用固定的
Public IP 时，您必须要手动的在您的操作系统设定好网络参数；</font></li>

<li>
<font color="#000066">浮动式拨接</font><font color="#000000">：除了上述的方法之外，传统的以调制解调器拨接，以及目前很流行的
ADSL 拨接，都是另一个取得 Public IP 的方法，只不过由于这种拨接的方法中，取得的
IP 是由 ISP 随机提供的，因此每次拨接到 ISP 后取得的 IP 可能都不是固定的，所以也有人称这种取得
IP 的方式为浮动式；</font></li>

<li>
<font color="#000066">缆线, Cable modem</font><font color="#000000">：利用单向或者是双向
Cable 也可以向 ISP 注册取得 Public IP；</font></li>
</ul>
<font color="#000000">　</font>
<br><font color="#000000">请记得，IP 就只有 Public 与 Private IP 这两种，而由于取得
IP 的方法不同，可能又有人喜欢宣称浮动式、固定制、动态等等的 IP ，这很容易造成刚刚接触网络的朋友们的困扰！所以这里仅告诉大家记得『Public
与 Private IP』而已！您只要记得他就对了！其他的，以后自然就会理解的啦！
^_^</font></ul>

<hr><a name="route"></a><img src="../../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">路由 ( route ) 的概念</span><br>
<ul>
<a name="route_route"></a><font color="#000099">什么是路由
( Route )</font>
<br>　
<br>在前面关于数据传送的所有介绍都是在『<font color="#000066">同一个网域</font>』里面的情况，我们都是以图二的案例来说明的。那么万一我们的数据需要跨网域时，数据是怎么传送的呢？这个时候就需要讨论到路由
( route ) 的概念了。例如下面的图例所示，Network A 与 Network B 是分开的两个网域，而他们是藉由
Server A 那部主机来进行硬件的链接。当 Network A 的 PC 01 要跟 Network B
的 PC 11 进行数据的传输时，他需要什么样的传输方式呢？
<br>　
<center><img src="0110network_basic_files/route_1.jpg" nosave="" width="460" height="498">
<br><font color="#000066">图三、简易的路由示意图</font></center>
　
<br>由上面的图示中，我们可以知道 Network A 为 192.168.0.0/24 这个网域，而
Network B 为 192.168.1.0/24 这个网域，这两个网域是不能直接相通的！所以
PC 01 可以透过逻辑广播以及 ARP table 来与 PC 02 传输数据，不过 PC 01 却无法直接与
PC 11 相互沟通的，因为这两部主机在不同的网域里面啊！那么就无法以 broadcast
的方式来达到传送讯息封包了。
<br>　
<br>事实上，两部主机之间能不能进行数据的传输，除了 MAC 、 ARP 以及 IP 等参数是否正确之外，还需要很重要的一个参数，那就是<font color="#000066">路由
( route )</font>！目前的操作系统都很亲切的，已经将同一个网段的网域建立的基本的路由了，所以当我们在同一个网段内时，就无须考虑路由，而可以直接藉由
ARP 的对应，而直接以网络卡 (NIC) 进行数据的传输。但是，万一发生了类似上面的架构当中的
PC 01 与 PC 11 的状况时，那么 PC 01 就需要藉由一部<font color="#000066">路由器
(Router) </font>来帮他达成数据的传送了！
<br>　
<ul>
<li>
<font color="#000066">Gateway / Router </font>：网关/路由器的功能就是在负责不同网域之间的封包转递
( IP Forwarder )，由于路由器具有 IP Forwarder 的功能，并且具有管理路由的能力，所以可以将来自不同网域之间的封包进行转递的功能。</li>
</ul>
　
<br>以 PC 01 要将数据传送到 PC 11 的案例来说明：
<br>　
<ol>
<li>
<font color="#000066">当 PC 01 的数据被打包之后，其封包资料上面就至少具有来源地与目的地的
IP 地址；</font></li>

<li>
<font color="#000066">首先， PC 01 会先分析该封包的目的地 IP 地址是否在同一个网域当中，如果该封包是在同一个网域当中，则
PC 01 可以藉由他本身的 ARP 表以及逻辑广播来取得目的地 IP 的 MAC ，并进一步来进行该封包的传送；</font></li>

<li>
<font color="#000066">不过在这个例子当中，因为 PC 11 并不在 PC 01 所在的网域之内，此时
PC 01 会找自己本身的路由表 ( Route table )，看看 PC 11 在不在自己的路由表之内的某个规则中，若有，则依照该规则传送到下一个主机去(通常就是
Router 啦！)；</font></li>

<li>
<font color="#000066">在我们这个例子当中，并没有给予 PC 01 特殊的路由规则，所以
PC 01 是找不到 PC 11 所在的网域的路由规则的，此时 PC 01 将会把该封包数据直接丢给在
PC01 本身路由规则当中的『<b>默认路由器, default gateway</b>』主机，也就是
192.168.0.254 那部 Gateway (GW) 上面去，由于 Server A 的 192.168.0.254
接口与 PC 01 是在同一个网域之内，所以 PC 01 是可以直接与 Server A 传送资料的
(<i>注：也就是说， Gateway 与您的主机之间，必须要在同一个网段之内才行！</i>)；</font></li>

<li>
<font color="#000066">Server A 的 192.168.0.254 收到该封包之后，会依照
Server A 自己本身的路由表找到 192.168.1.1 这部主机的路由规则！刚好在自己的另一个接口
192.168.1.254 的同一个网段内，所以透过 IP Forwarder 的功能，将该封包由
192.168.1.254 传送到 192.168.1.1 那部 PC 11 上面去！</font></li>
</ol>
　
<br>大致的情况就是这样，所以啦，每一部主机里面都会存在着一个路由表 ( Route
table )，数据的传递将依据这个路由表进行传送！而一旦封包已经经由路由表的规则传送出去后，那么主机本身就已经不再管封包的流向了，因为该封包的流向将是下一个主机
(也就是那部 Router )来进行传送，而 Router 在传送时，也是依据 Router 自己的路由表来判断该封包应该经由哪里传送出去的！例如底下的图例：
<br>　
<center><img src="0110network_basic_files/route_2.jpg" nosave="" width="577" height="158">
<br><font color="#000066">图四、路由的概念</font></center>
　
<br>PC 01 要将资料送到 Server Bingo 去，则依据自己的路由表，将该封包送到
Server A 去，Server A 再继续送到 Server B ，然后在一个一个的接力给他送下去，最后总是可以到达
Server Bingo 的。
<br>　
<br>当然，上面的案例是一个很简单的路由概念，事实上， Internet 上面的路由协议与变化是相当复杂的，因为
Internet 
上面的路由并不是静态的，他可以随时因为环境的变化而修订每个封包的传送方向。举例来说，数年前在新竹因为土木施工导致台湾西部整个网络缆线的中断。不过
南北的网络竟然还是能通，为什么呢？因为路由已经判断出西部缆线的终止，因此他自动的导向台湾东部的花莲路线，虽然如此一来绕了一大圈，而且造成网络的大
塞车，不过封包还是能通就是了！这个例子仅是想告诉大家，我们上面提的路由仅是一个很简单的静态路由情况，如果想要更深入的了解
route ，请自行参考相关书籍喔！ ^_^ 。
<br>　
<br>
<hr width="100%"><a name="route_route_comm"></a><font color="#000099">观察主机的路由</font>
<br>　
<br>既然路由是这么的重要，而且『<font color="#000066">路由一旦设定错误，将会造成某些封包完全无法正确的送出去</font>！』所以我们当然需要好好的来观察一下我们主机的路由表啦！还是请再注意一下，<b><font color="#000066">每一部主机都有自己的路由表喔</font></b>！观察路由表的指令很简单，就是
route ，这个指令挺难的，我们在后面章节再继续的介绍，这里仅说明一些比较简单的用法：
<br>　
<table width="550" bgcolor="#000000" border="" cols="1">
<tbody><tr>
<td><font face="细明体"><font size="-1"><font color="#FFFFFF">[root@test
root]# </font><font color="#FFFF00">route [-n]</font></font></font>
<br><font face="细明体"><font color="#FF6666"><font size="-1">参数说明：</font></font></font>
<br><font face="细明体"><font color="#FFFF99"><font size="-1">-n :将主机名以
IP 的方式显示</font></font></font>
<br><font face="细明体"><font color="#FF6666"><font size="-1">范例：</font></font></font>
<br><font face="细明体"><font size="-1"><font color="#FFFFFF">[root@test
root]#</font><font color="#FFFF00"> route</font></font></font>
<br><font face="细明体"><font color="#FFFFFF"><font size="-1">Kernel IP routing
table</font></font></font>
<br><font face="细明体"><font color="#FFFFFF"><font size="-1">Destination&nbsp;&nbsp;&nbsp;&nbsp;
Gateway&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Genmask&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Flags Metric Ref&nbsp; Use Iface</font></font></font>
<br><font face="细明体"><font color="#FFFFFF"><font size="-1">192.168.0.0&nbsp;&nbsp;&nbsp;&nbsp;
*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
255.255.255.0&nbsp;&nbsp; U&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 eth0</font></font></font>
<br><font face="细明体"><font color="#FFFFFF"><font size="-1">127.0.0.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
255.0.0.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; U&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 lo</font></font></font>
<br><font face="细明体"><font color="#FFFFFF"><font size="-1">default&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
192.168.0.254&nbsp;&nbsp; 0.0.0.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
UG&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0 eth0</font></font></font>
<br><font face="细明体"><font color="#FFFFFF"><font size="-1">　</font></font></font>
<br><font face="细明体"><font size="-1"><font color="#FFFFFF">[root@test
root]# </font><font color="#FFFF00">route -n</font></font></font>
<br><font face="细明体"><font color="#FFFFFF"><font size="-1">Kernel IP routing
table</font></font></font>
<br><font face="细明体"><font color="#FFFFFF"><font size="-1">Destination&nbsp;&nbsp;&nbsp;&nbsp;
Gateway&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Genmask&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Flags Metric Ref&nbsp; Use Iface</font></font></font>
<br><font face="细明体"><font color="#FFFFFF"><font size="-1">192.168.0.0&nbsp;&nbsp;&nbsp;&nbsp;
0.0.0.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 255.255.255.0&nbsp;&nbsp;
U&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0 eth0</font></font></font>
<br><font face="细明体"><font color="#FFFFFF"><font size="-1">127.0.0.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0.0.0.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 255.0.0.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
U&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0 lo</font></font></font>
<br><font face="细明体"><font color="#FFFFFF"><font size="-1">0.0.0.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
192.168.0.254&nbsp;&nbsp; 0.0.0.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
UG&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0 eth0</font></font></font></td>
</tr>
</tbody></table>
　
<br>在上面的例子当中，我们以 PC 01 的状态来进行说明。由于 PC 01 为 192.168.0.0/24
这个网域，所以主机已经建立了这个网域的路由了，那就是『 <font color="#000066">192.168.0.0
* 255.255.255.0 ... </font>』那一行所显示的讯息！当您下达 route 时，屏幕上说明了这部机器上面共有三个路由规则，第一栏为『<font color="#000066">目的地的网域</font>』，例如
192.168.0.0 就是一个网域咯，最后一栏显示的是『<font color="#000066">要去到这个目的地要使用哪一个网络接口</font>！』例如
eth0 就是网络卡的装置代号啦。如果我们要传送的封包在路由规则里面的 192.168.0.0/255.255.255.0
或者 127.0.0.0/255.0.0.0 里面时，因为第二栏 Gateway 为 * ，所以就会直接以后面的网络接口来传送出去，而不透过
Gateway 咯！
<br>　
<br>万一我们要传送的封包目的地 IP 不在路由规则里面，那么就会将封包传送到『default』所在的那个路由规则去，也就是
192.168.0.254 那个 Gateway 喔！所以，几<font color="#000066">乎每一部主机都会有一个
default gateway 来帮他们负责所有非网域内的封包转递</font>！这是很重要的概念喔！^_^！关于更多的路由功能与设定方法，我们在后面的『<a href="http://linux.vbird.org/linux_server/0110network_basic/0230router.php">简易
Router 架设</a>』当中会再次的提及呢！
<br>　
<br>
<hr width="100%"><a name="route_network_param"></a><font color="#000099">一组网络设定需要的参数</font>
<br>　
<br>由上面的介绍中，我们知道一部主机要能够使用网络，必须要有 IP ，而 IP
的设定当中，就必须要有 IP, Network, Broadcast, Netmask 等参数，此外，还需要考虑到路由里面的
Default Gateway 才能够正确的将非同网域的封包给他传送出去，所以说，一组合理的网络设定需要哪些数据呢？呵呵！就是：
<br>　
<ol>
<li>
<font color="#000099">IP；</font></li>

<li>
<font color="#000099">network；</font></li>

<li>
<font color="#000099">netmask；</font></li>

<li>
<font color="#000099">broadcast；</font></li>

<li>
<font color="#000099">gateway</font></li>
</ol>
　
<br>没错！就是这些数据！如果您是使用 ADSL 拨接来上网的话，上面这些数据都是由
ISP 直接给您的，那您只要使用拨接程序进行拨接到 ISP 的工作之后，这些数据就自动的在您的主机上面设定完成了！但是如果是固定制
( 如学术网络 ) 的话，那么就得自行使用上面的参数来设定您的主机啰！缺一不可呢！以
192.168.0.0 这个 C Class 为例的话，那么您就必须要在您的主机上面设定好底下的参数：
<br>　
<ol>
<li>
<font color="#000099">IP：由 192.168.0.1~254</font></li>

<li>
<font color="#000099">Network：192.168.0.0</font></li>

<li>
<font color="#000099">Netmask：255.255.255.0</font></li>

<li>
<font color="#000099">Broadcast：192.168.0.255</font></li>

<li>
<font color="#000099">Gateway ：每个人的设定都不同，请询问您的网络管理员！呵呵！就是</font>您<font color="#000099">自己啦！</font></li>
</ol>
</ul>

<hr><a name="packet"></a><img src="../../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">封包的格式</span><br>
<ul>终于给他来到了封包格式的地方了！上面的咚咚大多是在网络最底层的基础知识，得自行好好的理解理解！第一次看不懂没关系，多看几次，并且实际配合
实做，就比较容易进入状况了！假设您已经知道了网络最底层的
IP 
以及相关的参数的意义，那么应该知道的是，网络层的协议只是提供路由的判断，以确定封包的传送路径，但是这些协议并没有管理可能由于网络媒体的损坏问题，
或者是网络的负荷过重以及其他不可预期的情况，而造成封包损毁或者被丢弃的状态。为了使封包的传送过程中更具有稳定性与可靠性，我们就得提供一套机制来让
数据可以没有错误的到达到目的地。
<br>　
<br>在 TCP/IP 这个协议组合当中，<font color="#000066">TCP ( Transmission
Control Protocol ) </font>就是用来做为传送的一个协议，当然啦，还有一个
UDP 的协定呢！在 TCP 这个协议当中，他提供了较为稳定而且可靠的联机状态，至于
UDP 则是一个比较没有这么可靠的联机型态了。底下我们就来谈一谈吧！
<br>　
<br>
<hr width="100%"><a name="packet_socket"></a><font color="#000099">通讯端口口与
Socket pair</font>
<br>　
<br>在开始说明 TCP 封包之前，我们先来了解一些常见的信息吧！首先提到的是<font color="#000066">通讯端口口
( Port )</font> 这个玩意儿。通讯端口口的产生都是来自于操作系统的某些程序
( 您也可以想成是程序, process ) 的执行结果。举例来说，当我们想要连上奇摩雅虎这个网站来浏览
WWW 的信息时，那么我们的浏览器 (Netscap 还是 IE 都好啦！ ) 就需要在我们的计算机上面随机开启一个大于
1024 以上的通讯端口口来进行该次的联机，当然啦，在奇摩雅虎的 WWW 主机上面，因为要启动
WWW 的服务，不然怎么让 Client 端连进来？所以，他就会启动 WWW 服务器软件，而这个
WWW 服务器软件就会在奇摩雅虎的主机上面开启一个端口口来等待 Client 端的连接，这个埠口此时就称为在<font color="#000066">监听
( LISTEN )</font> 了！而当两个埠口连接上并且正确的建立起联机之后，那么资料就可以开始在这两个埠口之间进行传送了！
<br>　
<br>或许您会觉得很奇怪，怎么上面提到的在 Client 端的埠口需要随机选取一个大于
1024 以上的埠口来进行这次的联机呢？这是因为小于 1023 以内的埠口大多已经预留给特殊的服务
( Services ) 来进行该服务的启动了，例如上面提到的 WWW 服务器，预设的监听埠口就是
80 这个埠号。目前有相当多的常见 ( Well Known ) 的端口口就是保留给系统特定的服务器软件用的，而这些埠号与服务的名称对应在
Linux 系统当中，都是写在<b><font color="#000066"> /etc/services </font></b>里面，底下列出一些常见的
Services 与埠号的对应：
<br>　
<ul>
<li>
<font face="细明体"><font color="#000066">21-20:FTP ( ftp-data )</font></font></li>

<li>
<font face="细明体"><font color="#000066">22&nbsp;&nbsp; :SSH</font></font></li>

<li>
<font face="细明体"><font color="#000066">23&nbsp;&nbsp; :Telnet</font></font></li>

<li>
<font face="细明体"><font color="#000066">25&nbsp;&nbsp; :SMTP ( e-mail
)</font></font></li>

<li>
<font face="细明体"><font color="#000066">80&nbsp;&nbsp; :WWW</font></font></li>

<li>
<font face="细明体"><font color="#000066">110&nbsp; :POP3 ( e-mail )</font></font></li>
</ul>
　
<br>另外一点比较值得注意的是，<font color="#000066">小于 1023 以下的埠口要启动时，启动者的身份必须要是
root 才行</font>！这个限制挺重要的，大家不要忘记了喔！
<br>　
<table width="90%" bgcolor="#FFCCCC" border="" cols="1">
<tbody><tr>
<td><font color="#000066">曾经有一个朋友问过我说：『一部主机上面这么多服务，那我们跟这部主机进行联机时，该主机怎么知道我们要的数据是
WWW 还是 FTP 啊？！』呵呵！这就是 port 的不同的结果啦！因为每种 Client
软件他们所需要的数据都不相同，例如上面提到的 Netscape 以及 IE 他们所需要的数据是
WWW ，所以该软件默认就会向主机的 80 port 索求数据；而如果您是使用 cuteftp
来进行与主机的 FTP 数据索求时， cuteftp 这个 Client 软件当然默认就是向主机的
FTP 相关埠口 ( 预设就是 port 21 ) 进行连接的动作啦！所以当然就可以正确无误的取得
Client 端所需要的数据了。</font>
<br><font color="#000066">　</font>
<br><font color="#000066">举个例子来说，一部主机就好像是一间多功能银行，该银行内的每个负责不同业务的窗口就好像是通讯端口口，而我们民众就好像是
Client 端来的封包。当您进入银行想要缴纳信用卡账单时，一到门口服务人员就会指示您直接到该窗口去缴纳，当然，如果您是要领钱，服务人员就会请您到领钱的窗口去填写数据，您是不会跑错的对吧！
^_^。万一跑错了怎么办？呵呵！当然该窗口就会告诉</font>您<font color="#000066">『我不负责这个业务，您请回去！』，呵呵！所以该次的联机就会『无法成功』咯！</font></td>
</tr>
</tbody></table>
　
<br>谈过了通讯端口口后，再来聊一聊每个封包的基本内容有哪些数据呢？这就得要谈论到
<font color="#000066">Socket
Pair ( 成对的承口 )</font>了！当本机发送出封包时，主机是根据 IP 来判别来源与目的地的行进路线，并且，也需要
port number 来告知 Client 与 Server 是以哪一个埠口来进行联机的对吧！所以呢，一个联机封包就必须至少会包含底下四个信息：
<br>　
<ul>
<li>
<font color="#000066">来源 IP ( Source Address )</font></li>

<li>
<font color="#000066">目的 IP ( Destination Address )</font></li>

<li>
<font color="#000066">来源埠口 ( Source Port )</font></li>

<li>
<font color="#000066">目的埠口 ( Destination Port )</font></li>
</ul>
　
<br>这四个封包的基本信息是相当重要的！您得必须要了解喔！
<br>　
<br>
<hr width="100%"><a name="packet_transfer"></a><font color="#000099">封包的传送</font>
<br>　
<br>知道了几个重要的端口口与相关的信息后，先来了解一下什么是封包呢？封包上面有哪些信息呢？其实封包就很像我们在邮寄信件的时候那个邮件的模样了！信纸总是得放入信封吧？而信封上面总是得写上发信人住址，受信人住址与姓名啊！所以，一封邮件主要会有两个部分，分别是：『<font color="#000066">信封表面的信息部分、与信封内部的信件内容！</font>』。同样的，网络的信息封包主要也是分为两个部分，一个是表头
( Header ) 的部分，另一个则是内容 ( messages ) 的部分啦！而一个封包要传送到哪里去，都是藉由
Header 的讯息部分来进行分析而传送的啦！那么 Header 有哪些重要的信息呢？主要就如同上面提到的，至少会有来源与目标
IP 、来源与目标 Port等等！
<br>　
<br>好了，假设因特网与您的主机网络的设定都没有问题了，也解决了路由的问题了，那么请问真正的封包是怎么在两部主机之间进行传送的呢？事实上，封包的传送是相当复杂的，而且封包的状态不同
(TCP/UDP) 也会有不一样的传送机制。这里我们仅举一个『<font color="#000066">相对比较可靠的封包传送方式</font>』来介绍。如下图所示：
<br>　
<center><img src="0110network_basic_files/transfer_packet.jpg" nosave="" width="253" height="215">
<br><a name="fig_5"></a><font color="#000066">图五、较可靠的封包传送状态</font>
<br>　</center>
当发送封包者发送出一个封包给接受者后，接受者在『正确的接到』这个封包之后，会回复一个响应封包
( Acknowledgment ) 
给发送者，告诉他接受者已经收到了！当发送端收到这个响应封包后，才会继续发送下一个封包出去，否则就会将刚刚的封包重新发送一次！这种封包的传递方式因
为考虑到对方接到的封包的状态，所以算是比较可靠的一种方式。目前因特网上面常见的封包是
TCP 与 UDP ，其中 TCP 的联机方式中，会考虑到较多的参数，他是一种联机模式(Connection
Oriented)的可靠传输，至于 UDP 则省略了图五当中那个响应封包的步骤，所以是一种非面向连接的非可靠传输。在一个
TCP 
封包的传送过程中，因为至少需要传送与响应等封包来确定传送出去的数据没有问题，所以他是相当可靠的一种传输方式，不过就是传输与响应之间的时间可能会拖
比较久一点。至于
UDP 封包就因为少了那个确认的动作，所以虽然他是较不可靠一点，但是速度上就比
TCP 封包要来的快了！底下我们将继续介绍 TCP, UDP 以及 ICMP 等封包信息的内容喔！
<br>　
<br>
<hr width="100%"><a name="packet_tcp"></a><font color="#000099">TCP, 三向交握,</font>
<br>　
<br>好了，了解了联机步骤之后，也知道 TCP 与 UDP 封包的建立是有差异存在的！在这个小节当中，我们先就
TCP 封包 Header 的内容作个简单的介绍吧！ TCP 封包的 Header 内容主要如下：
<br>　
<center><font color="#000066">表二、TCP 封包的 Header 信息</font></center>

<center><table style="border-collapse: collapse;" id="AutoNumber1" width="614" border="" bordercolor="#111111" cellpadding="0" cellspacing="0">
<tbody><tr>
<td colspan="5" width="299" align="CENTER"><font color="#000099">Source Port(16)</font></td>

<td colspan="5" width="298" align="CENTER"><font color="#000099">Destination
Port(16)</font></td>
</tr>

<tr>
<td colspan="10" width="598" align="CENTER"><font color="#000099">Sequence
Number(32)</font></td>
</tr>

<tr>
<td colspan="10" width="598" align="CENTER"><font color="#000099">Acknowledgment
Number(32)</font></td>
</tr>

<tr>
<td width="94" align="CENTER"><font color="#000099">Data Offset(4)</font></td>

<td width="91" align="CENTER"><font color="#000099">Reserved(6)</font></td>

<td width="20"><font color="#000099">U</font>
<br><font color="#000099">G</font>
<br><font color="#000099">R</font></td>

<td width="20"><font color="#000099">A</font>
<br><font color="#000099">C</font>
<br><font color="#000099">K</font></td>

<td width="20"><font color="#000099">P</font>
<br><font color="#000099">S</font>
<br><font color="#000099">H</font></td>

<td width="20"><font color="#000099">R</font>
<br><font color="#000099">S</font>
<br><font color="#000099">T</font></td>

<td width="20"><font color="#000099">S</font>
<br><font color="#000099">Y</font>
<br><font color="#000099">N</font></td>

<td width="20"><font color="#000099">F</font>
<br><font color="#000099">I</font>
<br><font color="#000099">N</font></td>

<td width="299">
<center><font color="#000099">Window(16)</font></center>
</td>
</tr>

<tr>
<td colspan="5" width="299" align="CENTER"><font color="#000099">Checksum(16)</font></td>

<td colspan="5" width="299" align="CENTER"><font color="#000099">Urgent Pointer(16)</font></td>
</tr>

<tr>
<td colspan="10" width="598">
<center><font color="#000099">Options</font></center>
</td>
</tr>

<tr>
<td colspan="10" width="598">
<center><font color="#000099">Data</font>
<br><font color="#000099">......</font>
<br><font color="#000099">Message</font></center>
</td>
</tr>
</tbody></table></center>
　
<br>上面的信息都相当的重要，稍微了解一下各个数据：
<br>　
<ul>
<li>
<b><font color="#000066">Source Port &amp; Destination Port ( 来源埠口
&amp; 目标端口口 )</font></b>：来源与目标的端口口，这个容易了解吧！上面才刚刚提过那个<a href="#packet_socket">埠口</a>的观念呢！再次的给他强调一下，
Linux 的 daemon 名称对应 Port number 是记录在 /etc/services 里面的喔！而且，小于
1024 以下的 Port 只有 root 身份才能启用，至于一般 Client 发起的联机，通常是使用大于
1024 以上的埠口！</li>

<br>　
<li>
<b><font color="#000066">Sequence Number ( 封包序号 )</font></b>：在前面的
<a href="#before_osi">OSI
七层协议</a>里面提到过，由于种种的限制，所以一次传送的封包大小大约仅有数千
bytes ，但是我们的资料可能大于这个封包所可以允许的最大容量，所以就得要将我们的数据给他拆成数个封包来进行传送到目的地主机的动作了。那么对方主机怎么知道这些封包是有关连性的呢？就得藉由这个
Sequence Number 来辅助了。当发送端要发送封包时，会为这个封包设定一个序号，然后再依据要传送的数据长度，依序的增加序号。也就是说，我们可以使用递增的值来替下一个封包做为他序号的设定！</li>

<br>　
<li>
<b><font color="#000066">Acknowledgment Number ( 回应序号 ) </font></b>：由刚刚<a href="#fig_5">图五</a>的封包传输过程中，我们知道在接受端接收了封包之后，会响应发送端一个响应封包，那个响应的信息就是在这里啦！当接收端收到
TCP 封包并且通过检验确认接收该封包后，就会依照原 TCP 封包的发送序号再加上数据长度以产生一个响应的序号，而附在回应给发送端的响应封包上面，这样发送端就可以知道接收端已经正确的接收成功该
TCP 封包了！所以说， Sequence 与 Acknowledgment number 是 TCP 封包之所以可靠的保证啊！因为他可以用来检测封包是否正确的被接受者所接收呢！</li>

<br>　
<li>
<b><font color="#000066">Data Offset (资料补偿)</font></b>：这是用来记录表头长度用的一个字段。</li>

<br>　
<li>
<b><font color="#000066">Reserved (保留)</font></b>：未使用的保留字段。</li>

<br>　
<li>
<b><font color="#000066">Control Flag (控制标志码)</font></b>：控制标志码在
TCP 封包的联机过程当中，是相当重要的一个标志，先来说一说这六个句柄，然后再来讨论吧：</li>

<ul>
<li>
<font color="#000066">Urgent data </font>：如果 URG 为 1 时，表示这是一个紧急的封包数据，接收端应该优先处理；</li>

<li>
<font color="#000066"><b>Acknowledge field significant</b> </font>：刚刚上面不是说到那个
Acknowledgment 吗？当 ACK 这个 Flag 为 1 时，表示这个封包的 Acknowledge
Number 是有效的，也就是我们上面提到的那个回应封包咯。</li>

<li>
<font color="#000066">Push function</font> ：如果 PSH 为 1 的时候，该封包连同传送缓冲区的其它封包应立即进行传送，而无需等待缓冲区满了才送。接收端必须尽快将此数据交给程序处理。</li>

<li>
<font color="#000066">Reset</font> ：如果 RST 为 1 的时候，表示联机会被马上结束，而无需等待终止确认手续。</li>

<li>
<font color="#000066"><b>Synchronize sequence number</b> </font>：这就是
SYN 标志啦！当 SYN 为 1 时，那就表示发送端要求双方进行同步处理，也就是要求建立联机的意思，这个
SYN 是相当重要的一个 Flag 喔！</li>

<li>
<font color="#000066">No more data fro sender (Finish)</font> ：如果封包的
FIN 为 1 的时候，就表示传送结束，然后双方发出结束响应，进而正式进入 TCP
传送的终止流程。</li>
</ul>
　
<li>
<b><font color="#000066">Window (滑动窗口)</font></b>：与接收者的缓冲区大小有关的一个参数。</li>

<br>　
<li>
<b><font color="#000066">Checksum(确认)</font></b>：当数据要由发送端送出前，会进行一个检验的动作，并将该动作的检验值标注在这个字段上；而接收者收到这个封包之后，会再次的对封包进行验证，并且比对原发送的
Checksum 值是否相符，如果相符就接受，若不符就会假设该封包已经损毁，进而要求对方重新发送此封包！</li>

<br>　
<li>
<b><font color="#000066">Urgent Pointer</font></b>：指示紧急数据所在位置的字段。</li>

<br>　
<li>
<b><font color="#000066">Option</font></b>：当需要 client 与 Server 同步动作的程序，例如
Telnet ，那么要处理好两端的交互模式，就会用到这个字段来指定数据封包的大小咯，不过，这个字段还是比较少用的！</li>
</ul>
　
<br><a name="packet_tcp_handshake"></a>了解了 TCP 封包的格式之后，再来我们谈一谈里面几个重要的信息吧！事实上，TCP
之所以被称为面向连接的可靠传输，其实是靠上面提到的 Control Flag 来控制封包的旗标，以使
Client 与 Server 端建立起联机的机制。以下图为例：
<br>　
<center><img src="0110network_basic_files/handshak.jpg" nosave="" width="149" height="215">
<br><font color="#000066">图六、TCP 封包的三向交握</font></center>
　
<br>在上图中，SYN 与 ACK 就是 Control Flag 的开关来让 TCP 封包含有的相关信息！Client
端与 Server 端在经过了要求主动建立、回复确认封包、再次确认，最后建立起两边的相关埠口的联机，由于为了建立起最终的联机，需要进行三次封包的要求与确认，因此我们也称这个建立联机前的步骤为『<font color="#000066">三向交握,
Three-way handshake</font>』了。这个动作在建立联机以及防火墙的设定里面是相当重要的喔！
<br>　
<br>
<hr width="100%"><a name="packet_udp"></a><font color="#000099">UDP</font>
<br>　
<br>UDP 的全名是：『<font color="#000066">User Datagram Protocol, 用户数据流协议</font>』，UDP
与 TCP 不一样， UDP 不提供可靠的传输模式，因为他不是面向连接的一个机制，这是因为在
UDP 的传送过程中，例如<a href="#fig_5">图五</a>当中，接受端在接受到封包之后，不会回复响应封包
( ACK ) 给发送端，所以封包并没有像 TCP 封包有较为严密的验证机制。至于 UDP
的表头资料如下表所示：
<br>　
<center><font color="#000066">表三、UDP 封包的 Header 信息</font></center>

<center><table style="border-collapse: collapse;" id="AutoNumber1" width="614" border="" bordercolor="#111111" cellpadding="0" cellspacing="0">
<tbody><tr>
<td colspan="5" width="299" align="CENTER"><font color="#000099">UDP Source
Port(16)</font></td>

<td colspan="5" width="298" align="CENTER"><font color="#000099">UDP Destination
Port(16)</font></td>
</tr>

<tr>
<td colspan="5" width="299" align="CENTER"><font color="#000099">Message
Length(16)</font></td>

<td colspan="5" width="299" align="CENTER"><font color="#000099">UDP checksum(16)</font></td>
</tr>

<tr>
<td colspan="10" width="598">
<center><font color="#000099">Data</font>
<br><font color="#000099">......</font>
<br><font color="#000099">Message</font></center>
</td>
</tr>
</tbody></table></center>
　
<br>如上所示，UDP 封包仅提供 UDP 使用的埠口(port)，表头所占用的信息要比
TCP 少很多，由于每个封包的大小是有限制的，所以一个 UDP 封包，基本上来说，他所能容纳的数据
(Data/Message) 就会比 TCP 封包来的多一些。此外，由于 UDP 封包不需要等待响应封包
(ACK) ，所以传输速度上比较快一点。快虽快，毕竟 UDP 封包比较不够可靠，因此他适用于可靠性要求不高的场合，比如等一下要谈的
DNS 传送当中。
<br>　
<br>TCP 与 UDP 在传输可靠性、传输量以及传输速度上是各有其优缺点的，所以各有其适用的场合！
<br>　
<br>
<hr width="100%"><a name="packet_icmp"></a><font color="#000099">ICMP</font>
<br>　
<br>ICMP 的全称是『 <font color="#000066">Internet Control Message Protocol
</font>』。基本上，ICMP
是一个错误侦测与回报的机制，最大的功能就是可以确保我们网络的联机状态，与联机的正确性！不过
ICMP 本身并没有传送的能力，需要藉由 IP 来进行传送。ICMP 有相当多的类别可以侦测与回报，底下是比较常见的几个
ICMP 的类别 (Type)：
<br>　
<br><font color="#000066">表四、ICMP 的各项类别所代表的意义</font>
<table width="600" border="" cols="3">
<tbody><tr bgcolor="#FFFFCC">
<td width="70">
<center><font color="#000066">类别代号</font></center>
</td>

<td width="150">
<center><font color="#000066">类别名称</font></center>
</td>

<td width="380">
<center><font color="#000066">意义</font></center>
</td>
</tr>

<tr>
<td><font color="#000066">0</font></td>

<td><font color="#000066">Echo Reply</font></td>

<td><font color="#000066">代表一个响应信息</font></td>
</tr>

<tr>
<td><font color="#000066">3</font></td>

<td><font color="#000066">Distination Unreachable</font></td>

<td><font color="#000066">表示目的地不可到达</font></td>
</tr>

<tr>
<td><font color="#000066">4</font></td>

<td><font color="#000066">Source Quench</font></td>

<td><font color="#000066">当 router 的负载过时，这个类别码可以用来让发送端停止继续发送讯息</font></td>
</tr>

<tr>
<td><font color="#000066">5</font></td>

<td><font color="#000066">Redirect</font></td>

<td><font color="#000066">用来重新导向路由路径的信息</font></td>
</tr>

<tr>
<td><font color="#000066">8</font></td>

<td><font color="#000066">Echo Request</font></td>

<td><font color="#000066">请求响应消息</font></td>
</tr>

<tr>
<td><font color="#000066">11</font></td>

<td><font color="#000066">Time Exceeded for a Datagram</font></td>

<td><font color="#000066">当数据封包在某些路由传送的现象中造成逾时状态，此类别码可告知来源该封包已被忽略的讯息</font></td>
</tr>

<tr>
<td><font color="#000066">12</font></td>

<td><font color="#000066">Parameter Problem on a Datagram</font></td>

<td><font color="#000066">当一个 ICMP 封包重复之前的错误时，会回复来源主机关于参数错误的讯息</font></td>
</tr>

<tr>
<td><font color="#000066">13</font></td>

<td><font color="#000066">Timestamp Request</font></td>

<td><font color="#000066">要求对方送出时间讯息，用以计算路由时间的差异，以满足同步性协议的要求</font></td>
</tr>

<tr>
<td><font color="#000066">14</font></td>

<td><font color="#000066">Timestamp Replay</font></td>

<td><font color="#000066">此讯息纯粹是响应 Timestamp Request 用的</font></td>
</tr>

<tr>
<td><font color="#000066">15</font></td>

<td><font color="#000066">Information Request</font></td>

<td><font color="#000066">在 RARP 协议应用之前，此讯息是用来在开机时取得网络信息</font></td>
</tr>

<tr>
<td><font color="#000066">16</font></td>

<td><font color="#000066">Information Reply&nbsp;</font></td>

<td><font color="#000066">用以响应 Infromation Request 讯息</font></td>
</tr>

<tr>
<td><font color="#000066">17</font></td>

<td><font color="#000066">Address Mask Request</font></td>

<td><font color="#000066">这讯息是用来查询子网 mask 设定信息</font></td>
</tr>

<tr>
<td><font color="#000066">18</font></td>

<td><font color="#000066">Address Mask Reply</font></td>

<td><font color="#000066">响应子网 mask 查询讯息的</font></td>
</tr>
</tbody></table>
　
<br>在 ICMP 的应用当中，比较有名的就是 <a href="http://linux.vbird.org/linux_server/0110network_basic/0140networkcommand.php#ping">ping</a>
与 <a href="http://linux.vbird.org/linux_server/0110network_basic/0140networkcommand.php#traceroute">traceroute</a> 了，这两个指令可以用来让我们检查整个网络的问题点呢！关于指令的详细用法，我们在后面章节的『<a href="http://linux.vbird.org/linux_server/0110network_basic/0140networkcommand.php">Linux
网络常用指令</a>』当中再继续的介绍。
<br>　
<br>
<hr width="100%"><a name="packet_firewall"></a><font color="#000099">封包过滤的防火墙概念</font>
<br>　
<br>由上面的说明当中，我们知道数据的传送其实就是封包的发出与接受的动作啦！并且不同的封包上面都有不一样的表头
( header )，此外，封包上面通常都会具有四个基本的信息，那就是 <a href="#packet_socket">socket
pair</a> 里面提到的『来源与目的的 IP 以及来源与目的端的 port number』 。当然啦，如果是可靠性联机的
TCP 封包，还包含 Control Flag 里面的 SYN/ACK 等等重要的信息呢！好了，开始动一动脑筋，有没有想到『<font color="#000066">网络防火墙</font>』的字眼啊？！网络防火墙可以抵挡掉一些可能有问题的封包，那么在
Linux 系统上面是怎么挡掉封包的呢？其实说来也是很简单，既然封包的表头上面已经有这么多的重要信息，那么我就利用一些防火墙机制与软件来进行封包表头的分析，并且设定分析的规则，当发现某些特定的
IP 、特定的埠口或者是特定的封包信息(SYN/ACK等等)，那么就将该封包给他丢弃，那就是最基本的防火墙原理了！
<br>　
<br>举例来说，大家都知道 Telnet 这个服务器是挺危险的，而 Telnet 使用的
port number 为 23 ，所以，当我们使用软件去分析要送进我们主机的封包时，只要发现该封包的目的地是我们主机的
port 23 ，就将该封包丢掉去！那就是最基本的防火墙案例啦！更多的防火墙信息我们会在后头的『<a href="http://linux.vbird.org/linux_server/0110network_basic/0250simple_firewall.php">简易防火墙</a>』与『<a href="http://linux.vbird.org/linux_server/0110network_basic/0240network-secure-1.php">认识网络安全</a>』当中进行更多的说明喔！</ul>

<hr><a name="DNS"></a><img src="../../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">DNS 的基础观念</span><br>
<blockquote>除了上面提到的最基本的网络基础概念之外，这里还必须要先谈一个基本的观念，否则后续的主机名查询设定挺难说明白的！好了，我们知道计算机在网络上面要找寻主机的时后，是利用
IP 来寻址，而以 TCP/UDP/ICMP 等数据来进行传送的，并且传送的过程中还会去检验封包的信息。总归一句话，网络是靠
TCP/IP 家族来达成的，所以必须要知道 IP 之后，计算机才能够连上网络以及传送数据。
<br>　
<br>问题是，计算机网络是依据人类的需要来建立的，不过人类对于 IP 这一类的数字并不具有敏感性，即使
IP 已经被简化为十进制了，但是人类就是对数字没有办法啊！怎么办？！没关系，反正计算机都有主机名嘛！那么我就将主机名与他的
IP 对应起来，未来要连接上该计算机时，只要知道该计算机的主机名就好了，因为
IP 已经对应到主机名了嘛！所以人类也容易记忆文字类的主机名，计算机也可以藉由对应来找到他必须要知道的
IP ，啊！真是皆大欢喜啊！
<br>　
<br>这个主机名 (Hostname) 对应 IP 的系统，就是鼎鼎有名的 <font color="#000066">Domain
Name System (DNS)</font> 咯！也就是说， DNS 这个服务的最大功能就是在进行『<font color="#000066">主机名与该主机的
IP 的对应</font>』的一项协定。DNS 在网络环境当中是相当常被使用到的一项协议喔！举个例子来说，像鸟哥我常常会连到奇摩雅虎的
WWW 网站去看最新的新闻，那么我一定需要将奇摩雅虎的 WWW 网站的 IP 背下来吗？！天吶，鸟哥的忘性这么好，怎么可能将
IP 背下来？！不过，如果是要将奇摩站的主机名背下来的话，那就容易的多了！不就是
<a href="http://tw.yahoo.com/" target="_blank">http://tw.yahoo.com</a>
吗？！而既然计算机主机只认识 IP 而已，因此当我在浏览器上面输入了『<a href="http://tw.yahoo.com/" target="_blank">http://tw.yahoo.com</a>』的时后，我的计算机首先就会藉由向
DNS 主机查询 tw.yahoo.com 的 IP 后，再将查询到的 IP 结果回应给我的浏览器，那么我的浏览器就可以藉由该
IP 来连接上主机啦！
<br>　
<br>发现了吗？<font color="#000066">我的计算机必须要向 DNS 主机查询 Hostname
对应 IP 的信息喔！那么那部 DNS 主机的 IP 就必须要在我的计算机里面设定好才行，并且必须要是输入
IP 喔，</font>不然我的计算机怎么连到 DNS 主机去要求数据呢？呵呵！在 Linux
里面，DNS 主机 IP 的设定就是在 /etc/resolv.conf 这个档案里面啦！
<br>　
<br>目前各大 ISP 都有提供他们的 DNS 主机 IP 给他们的用户，好设定客户自己计算机的
DNS 查询主机，不过，如果您忘记了或者是您使用的环境中并没有提供 DNS 主机呢？呵呵！没有关系，那就设定中华电信那个最大的
DNS 主机吧！ IP 是 168.95.1.1 咯！要设定好 DNS 之后，未来上网浏览时，才能使用主机名喔！不然就得一定需要使用
IP 才能上网呢！DNS 是很重要的，他的原理也顶复杂的，更详细的原理我们在后面的『<a href="http://linux.vbird.org/linux_server/0110network_basic/0350dns.php">DNS
服务器架设</a>』里面进行更多更详细的说明喔！这里仅提个大纲！</blockquote>

<hr><a name="connect_modes"></a><img src="../../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">网络布线模式：</span><br>
<ul>呀！真累人的网络基础啊！谈完了一些基本的观念之后，接着下来就是实作的部分啰！首先，要让网络能通，自然就需要将所有的计算机以『<font color="#000066">网络的联机媒体</font>』连接起来，这里指的媒体就是『<font color="#000066">网络线、集线器或交换器(
Hub 或 Switch )、网络卡</font>』等等的硬件配备啦！当然啦，由于选择的媒体不同，布线情况也会有所差异！这里
VBird 以目前最常见于一般小型企业或家庭 LAN 里面的布线『<font color="#000066">星形联机</font>』来进行说明。这种架构基本上<font color="#000066">『就是以一个
Hub 或者是 Switch 为中心，进而将所有的计算机连接起来</font>』，以提供各个计算机的网络功能！这种架构的最大优点在于除错较容易！我们底下列出一个很简单的家庭星形架构的联机：
<br>　
<blockquote>
<center><img src="0110network_basic_files/0110network_basic_1.jpg" nosave="" width="474" height="179">
<br><font color="#000066">图七、星形网络联机的概要</font></center>
</blockquote>
<font color="#000066">　</font>
<br>
<hr width="100%"><a name="connect_compo"></a><font color="#000099">基本组件</font><font color="#000066">：</font>
<br><font color="#000000">　</font>
<br><font color="#000000">在图七里面，有哪些基本的网络组件呢？我们先来谈一谈定义吧！
^_^</font>
<br><font color="#000000">　</font>
<ul>
<li>
<font color="#000066">Host ( 主机 )</font><font color="#000000">：只要是连接在网络上面的主要设备，几乎都可以称为主机
(HOST) 。例如服务器 (server), 路由器 ( Router ), 网络打印机, 终端机以及工作站,
还有其他相关的联机控制器材等等，都可以被称为是 Host 哩。</font></li>
</ul>
<font color="#000000">　</font>
<ul>
<li>
<font color="#000066">Node ( 节点 )</font><font color="#000000">：连接在网络上的所有非网络线部分的设备，都可以称为节点，例如上面图七的
PC, ISP 主机，调制解调器, 交换器, 等等，全部都算是 node 喔！当我们要成功的完成
client 与 Server 的联机时，那么在这条联机上的所有 node 都必须没有问题才行！例如交换器要能正确的工作，Server
要能提供正常的服务等等。当我们在进行网络除错时，就是由一个一个的 Node 来着手测试的！</font></li>

<br><font color="#000000">　</font>
<li>
<font color="#000066">Client ( 客户端 )</font><font color="#000000">：向服务器发送出数据索求封包的
host 就可以称为是 Client 了！举例来说，当 Linux PC 3 向其他服务器要求数据时，那么这部计算机就是
client 啦！而当 Linux NAT 服务器，向 ISP 大型主机要求数据时，在当时的行为他也算是
Client 喔！所以他的身份是很复杂的，不但提供 Client 服务，同时如果他向其他主机要求数据，他就成为
Client 咯！</font></li>
</ul>
<font color="#000000">　</font>
<ul>
<li>
<font color="#000066">Interface ( 网络接口 )</font><font color="#000000">：网络接口不一定是网络卡喔！举例来说，当我们使用
ADSL 拨接到 ISP 后，会取得一个额外的网络接口 ( ppp0 )，该接口实际上是没有硬件的
( 其实是架构在网络卡上面的啦！ )，此外，如果架设一个网络卡多个 IP 的设定时
( IP aliases )，也会在一张网络卡上面产生多个网络接口的喔！</font></li>
</ul>
<font color="#000000">　</font>
<ul>
<li>
<font color="#000066">Network adapter, Network Interface Card, NIC ( 网络卡
)</font><font color="#000000">：呵呵！这个指的就是实际的硬件咯！</font></li>

<br><font color="#000000">　</font>
<li>
<font color="#000066">Server ( 服务器 )</font><font color="#000000">：当主机有对网络提供服务时，例如
WWW, FTP... ，那么该 host 就可以称为 Server 了！</font></li>

<br><font color="#000000">　</font>
<li>
<font color="#000066">Workstation ( 工作站 )</font><font color="#000000">：简单的来说，只要没有对网络提供服务的，就可以称为工作站了！例如
Windows PC1, Windows PC2...，不过，事实上工作站对于某些环境来说，还是有差别的。例如某些提供很强大的运算能力的主机，偶而也会被称为『工作站』，实时他仍然有提供网络服务！</font></li>
</ul>
<font color="#000000">　</font>
<br>
<hr width="100%"><a name="connect_connetction"></a><font color="#000099">联机基本要求</font>
<br>　
<br>好了，如果硬件联机都已经建立了起来，那么我的计算机要经过 Internet 联机到远程的主机时，至少需要哪些正确的网络设定之后，才能够进行联机呢？之前的几个小节都是提到网络基础的设定，这里要稍微介绍的则是主机设定时需要注意的事项：
<br>　
<ol>
<li>
<font color="#000066">Linux 核心必须有支持网络卡：</font></li>

<br>我们在之前的『<a href="http://linux.vbird.org/linux_server/linux_basic/">鸟哥的 Linux 私房菜 -- 基础学习篇</a>』提过了，要让硬件正确无误的工作，您的核心
(Kernel) 就必须要支持该硬件才行，也就是说，需要硬件的驱动程序啦！所以啰，请先确定您购买的网络卡是被
Linux 所支持的，不然的话，您就得向厂商要求驱动程序，然后在自己的 Linux
系统上面编译好才行！
<br>　
<li>
<font color="#000066">网络卡必须具有合法的 IP 以及正确的网络参数设定：</font></li>

<br>再来，由于我们目前的网络基础是由<font color="#3333FF"> </font><font color="#000066">IP
( Internet Protocol ) </font>进行沟通的 ( 由于这个 IP 是经由操作系统的软件给的，所以又称为<font color="#000066">
软件地址( software address )</font><font color="#000000"> ，而由前面的基础介绍后，我们也知道要成功的连上网络，就需要五个主要的参数才行：IP,
Network, Netmask, Broadcast, Gateway，这些数据都必须要能正确的设定在您的系统上；</font>
<br>　
<li>
<font color="#000066">数据封包的传送：</font></li>

<br>嗯！终于连上网络了，不过要能真正的传输数据得需要了解到刚刚上面才提到的『<a href="#packet">封包格式</a>』内容啦！封包的传送需要将正确的联机建立起来，而联机的建立与
Socket pair 有关，所以我们必须在 Client 端安装正确的 Client 软件，如果是
Server 的话，就得要启动正确的服务，以开启所需要的联机埠口，以用来建立联机并且进行数据的传输啰！
<br>　
<li>
<font color="#000066">经过节点、 Router 或 Gateway 主机：</font></li>

<br>好了，由于我们是经由 Hub/Switch 进行连接的，所以我们的封包数据一定会经过这个节点才会传送出去！这个时候不禁要想一想，
Hub 好还是 Switch 好？这两者有什么不同呢？其实最大的不同来自于『共享网络媒体』与『网络媒体对应』的架构上面！然后由于封包本身记录的
socket pair 让我们的封包就可以藉由一个又一个的 router 传送到目的地！
<br>　</ol>
所以，基本上我们在传送一个数据的时候，他的机制是挺复杂的，不过也可以想得很简单！就是：
<br>　
<ol>
<li>
<font color="#000066">操作系统先依据软件给的 IP 来将数据打包成为待传送的封包，例如
TCP 封包，上面并记录了来源与目的的 IP 与 port；</font></li>

<li>
<font color="#000066">根据封包上面的目的地 IP 资料，并经由 本机上面的 route
table 来取得下一个 router 的信息( 若在同一网域内，则 router 可视为本机的网络卡
)，然后将数据送到 router 上面去；</font></li>

<li>
<font color="#000066">重复 router 的行为，最后送到目的地端的 PC，而对方主机接收</font>您<font color="#000066">的
TCP 封包！</font></li>
</ol>
</ul>

<hr><a name="net_media"></a><img src="../../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">网络媒体的选择：</span><br>
<ul><font color="#000000">终于可以来谈一谈硬件的选择部分了！网络媒体的选择不简单啊，因为必须要依据您的网络特色与负荷来进行选择才好！底下谈一些比较简单的注意事项吧！</font>
<br><font color="#000000">　</font>
<ul>
<li>
<b><font color="#000066">网络线的类别与等级：</font></b></li>

<br>最常见的网络媒体当然就是网络线啦！目前主流的网络线应该是 RJ-45 接头的网络线了，至于早期的网络线则以同轴电缆线为主。因为同轴电缆线最大的传输速度仅达
10Mbps ，所以已经较少见了，因此底下我们仅针对 RJ-45 的网络线来说明。RJ-45
网络线如下所示：
<center><img src="0110network_basic_files/rj45.png" nosave="" width="291" height="195"></center>
RJ-45网络线是有等级的，而对于一般家庭或小型企业使用者而言，<font color="#000066">应该选择
CAT5 这个等级才好</font>！嗯！？网络线也有等级之分？是呀！刚刚不是说过了吗？那个网络媒体是很重要的，而由于网络媒体中跑的讯号其实就是电子啦！由于电子讯号在行进的时候会产生一些电磁效应(
这里指的是 cross talk )，这些 cross talk 就会影响整个传输的效能！为了避免
cross talk 的干扰，人们想出了很多的方法来解决他！有所谓的『双绞线, Twisted
Pair』、或提供屏蔽『Shielded, STP』等功能，来让网络线的 cross talk 干扰降低，并提升整体的网络传输速度负载量！
而依据给予的不同的屏闭等级来将网络线分级！目前最常见的应该就是 CAT5 这一级啦！最大的传输量可以到达
100 Mbps 而最大传输距离可达 91m 呢！所以，请注意『<font color="#000066">在选择网络线的时候，至少您的网络线等级要达到
CAT5 才行！</font>』，否则即使您的网络卡可以到达的传输量为 100 Mbps ，但是网络线只有
10 Mbps 时，呵呵！那么最大的传输量将会仅成为 10 Mbps 呦！
<br>　
<ul>
<li>
<font color="#000066">RJ-45 网络线的种类(并行线与跳线)：</font></li>

<br>RJ-45 网络线内部共有 8 条线路，根据线路排列顺序的不同而将 RJ-45 分成两种接头的格式，这两种接头的
8 条缆线排列顺序分别如下所示：
<br>　
<table width="500" border="" cols="2">
<tbody><tr>
<td width="100">
<center><font face="细明体">接头名称</font></center>
</td>

<td><font face="细明体">　1　　2　　3　　4　　5　　6　　7　　8</font></td>
</tr>

<tr>
<td bgcolor="#CCFFFF">
<center><font face="细明体">568A</font></center>
</td>

<td bgcolor="#CCFFFF"><font face="细明体">白绿　绿　白橙　蓝　白蓝　橙　白棕　棕</font></td>
</tr>

<tr>
<td bgcolor="#66FFFF">
<center><font face="细明体">568B</font></center>
</td>

<td bgcolor="#66FFFF"><font face="细明体">白橙　橙　白绿　蓝　白蓝　绿　白棕　棕</font></td>
</tr>
</tbody></table>
　
<br>在网络媒体当中跑的是电子讯号，由于电子讯号需要是一个回路才能通(例如正极接负极)，所以说这些讯号自然就需要成对啰！好了，那么由于设备的不同，因此网络线的接脚也会跟着不同的，所以就有这两种接头的制作了。<font color="#000066">当一条网络线的两端使用同一种接头(同时为
568A 或同时为 568B)时，则称该网络线为并行线，而如果网络线的两端分别是 568A
与 568B 的话，那么就称该网络线为『跳线！』</font>。一般来说，我们都使用『并行线』连接计算机主机与
Hub/Switch；不过，<font color="#000066">当计算机主机要与另一部计算机主机使用网络卡对网络卡的连接而不透过
Hub/Switch 时，那么就需要使用跳线才行喔</font>！这挺重要的！</ul>
　
<li>
<b><font color="#000066">网络卡的选购依据：</font></b></li>

<br><font color="#000000">网络卡的选购依据当然是『</font><font color="#000066">Linux
能够支持的网络卡芯片</font><font color="#000000">』为第一优先啦！要不然的话您还得自行编译网络卡的驱动模块，很伤脑筋的。另外，目前的主流网络卡流量为『可以自动分辨
10/100 Mbps 的流量』，除此之外，如果您的主机是预计要用来架设 Server 的，并且网络流量还不小的话，那么网络卡的好坏还是需要留意的呢！您要考虑的是：</font>
<br><font color="#000000">　</font>
<ol>
<li>
<font color="#000066">预计大型网站的架设</font>：如果您是想要使用您的 Linux
来帮您架设大型主机的话，例如每天实时上线人数都可达到上百人的大型网站，这个时候就得要好一点的卡啦！因为好的网络卡可以节省
CPU 的利用率，并且在系统资源的分配以及其他的网络相关资源配比方面会比较完善，不容易造成网络当机或者是死亡！所以买一块好一点的
10/100 Mbps 的 3Com or Intel 之类的网络卡，是千万省不得的！</li>

<br>　
<li>
<font color="#000066">一般家用或者是小流量的网站</font>：如果您的野心没有这么大，而是希望可以好好的学习
Linux 而已，并且使用的是 512 Kbps 的 ADSL 拨接系统，呵呵！那么太好的网络卡对您的帮助就没有那样重要啦！这个时候便宜的
200~300 块的网络卡( 尽量买所谓的螃蟹卡 ) 就可以用得很开心啦！我目前也都是使用螃蟹卡在我的宿网上面呢！</li>
</ol>
　
<br>为什么称为螃蟹卡呢？这是因为该芯片组是 RealTek 出品的商品，该芯片组的
Mark 长的有点像螃蟹，所以就被通称为螃蟹卡了！ ^_^在 Linux 里面，螃蟹卡的模块是
8139 呢！我们在后面的章节会持续介绍喔！
<br><font color="#000000">　</font>
<li>
<b><font color="#000066">Switch 还是 Hub ：</font></b></li>

<br>好了，刚刚上面星形联机的图示当中，也提到了现在多半以 Hub/Switch 做为网络媒体，那么这两者之间有何差异呢？
Hub/Switch 中文翻译成为『集线器/交换器』。Hub 还比较好理解，基本上，他仅是将所有的网络线给他连接在一起，并没有考虑到其他的因素！因此，每部计算机只要连上
Hub 之后，感觉上就好像连上 Bus 一样啦，所以<font color="#000066"> Hub 是一个『网络共享媒体</font>』喔！！那么『瞎米系』
Switch 呀！？为什么 Switch 通常比 Hub 要贵上非常的多呢？他们的功能有哪里不同？<font color="#000066">最基础的不同在于
Switch 内部多了一个可以记录插上 Switch 的主机的网络卡的 MAC 与 switch port
对应的记忆数据区( table )啦</font>！也就是说， switch 会记录他的 port 与该
port 连接的主机那块网络卡的 MAC 哩，这样有什么好处呢？这样说好了，当您的星形联机的网域之中有一部计算机在进行<a href="#Networklayer_physical_broadcast">物理广播</a>的时候(请注意，物理广播主要是以
MAC 为传递的对象)：
<br>　
<ul>
<li>
<font color="#000066">如果使用的中间链接媒体是 Hub 的时候，那么所有连接到这部
Hub 上面的主机都会接到该广播封包；</font></li>

<li>
<font color="#000066">而如果使用的链接媒体是 Switch 时，由于上面的 table
已经记录了 MAC 对应 Port 的数据，所以该封包将会『直接』经由该 port 来送出去给目的地主机！</font></li>
</ul>
　
<br>由于这样的关系，因此在进行物理广播的时候，就已经去除了可能产生封包碰撞的状态了！所以说，
<font color="#000066">Switch
其实已经不是一个『共享媒体』</font>了喔！因此上， Switch 与 Hub 所能承受的流量或许相同，但是
Switch 却可以达到比较好的传输功能，用在大型的网域当中，嘿嘿！当然是 Switch
比较棒啦！这也是为什么 Switch 会比较贵的原因呀！再强调一次， <font color="#000066">Hub
仍然属于『共享媒体』的一种，然而 Switch 几乎可以看做是『非共享媒体』了</font>！现在的
Switch 有的还包含了 <font color="#000066">Auto MDI/MDIX</font> 的自动判别网络线的功能，所以由
Switch 连接到主机网络卡的网络线，不论使用并行线或跳线，具有 <font color="#000066">Auto
MDI/MDIX</font> 的 Switch 都可以自动辨别，省却了用户要购买网络线时候的困扰呢！所以说，如果不考虑价格(其实现在便宜一点的
Switch 也都低于 1000 大洋以内了！)购买 Switch 是一个不错的方案喔！
<br>　
<li>
<b><font color="#000066">整体流量的考虑：</font></b></li>

<br>特别留意一件事情，那就是在您的网络里面，<font color="#000066">网络流量的限制是在『流量最小的那个装置』所控制的</font>，而不是所有装置的平均流量喔！所以在您购买网络线、网络卡、Switch/Hub
等等的网络设备时，是需要一并考虑所有的配备的，最好还能够与自己的网络环境相配合，这样才能达到比较好的搭配！</ul>
</ul>

<hr><a name="review"></a><img src="../../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">重点回顾：</span><br>
<ul>
<li>
<font color="#000066">OSI 七层协议为一个网络模型 ( model ) ，并非硬性规定。这七层协议可以协助软硬件开发有一个基本的准则；</font></li>

<li>
<font color="#000066">现今的网络基础是架构在 TCP/IP 这个通讯协议上面；</font></li>

<li>
<font color="#000066">数据连接层里重要的信息为 MAC (Media Access Control)，亦可称为硬件地址，而
ARP Table 可以用来对应 MAC 与软件地址 ( IP ) ；</font></li>

<li>
<font color="#000066">网络的传输单位使用 bit 而不是 byte ；</font></li>

<li>
<font color="#000066">在网络媒体方面， Hub 为共享媒体，因此可能会有封包碰撞的问题，至于
Switch 由于加入了 port 与 MAC 的对应，因此已经克服了封包碰撞的问题，也就是说，Switch
并不是共享媒体；</font></li>

<li>
<font color="#000066">Physical broadcast 与 Logical broadcast 功能不并相同，物体广播在侦测网络媒体，
Logical broadcast 则主要针对网络层的软件地址进行广播；</font></li>

<li>
<font color="#000066">IP 为 32 bits 所组成的，为了适应人类的记忆，因此转成四组十进制的数据；</font></li>

<li>
<font color="#000066">IP 主要分为 Host ID 与 Net ID 两部份，加上 Netmask
这个参数后，可以设定『网域』的概念；</font></li>

<li>
<font color="#000066">IP 只有两种，就是 Public IP 与 Private IP ，中文应该翻译为
公共 IP 与 私有(或保留) IP，私有 IP 与私有路由不可以直接连接到 Internet
上；</font></li>

<li>
<font color="#000066">每一部主机都有自己的路由表，这个路由表规定了封包的传送途径，在路由表当中，最重要者为默认的通讯闸
( Gateway/Router )；</font></li>

<li>
<font color="#000066">一般来说，一部主机里面的网络参数应该具备有：IP, Netmask,
Network, Broadcast, Gateway 等；</font></li>

<li>
<font color="#000066">目前常见的资料封包格式有 TCP/UDP/ICMP 等，TCP 为较准确的封包格式，透过多种确认手段来使封包可以准确的到达目的地，至于
UDP 则略过这些确认手续，因此传送速度较快。</font></li>

<li>
<font color="#000066">在主机的 port 当中，只有 root 可以启用小于 1023 以下的
port ；</font></li>

<li>
<font color="#000066">DNS 主要的目的在于进行 Hostname 对应 IP 的功能；</font></li>

<li>
<font color="#000066">RJ-45 网络线依据接头线路的排列，可分为并行线与跳线；</font></li>
</ul>

<hr><a name="ex"></a><img src="../../image/logo.png" alt="大标题的图示" width="35" align="middle" height="34"><span class="text_h1">课后练习：</span><br>
<ul>
<li>
请简述 OSI 网络七层协议每一层的功能；</li>

<li>
在 ISP 提供的网络服务中，他们提到传输速度为 1.5M/382K ，请问这个数据的单位为何？</li>

<li>
什么是 MAC ( Media Access Control ) ，MAC 主要的功能是什么？</li>

<li>
请解释什么是物理广播 ( Physical Broadcast ) ，他与逻辑广播 ( Logical Broadcast
) 有什么不同？</li>

<li>
什么是封包碰撞？为什么会发生封包碰撞？</li>

<li>
ARP Table 的作用为何？如何在我的 Linux 察看我的 ARP 表格？</li>

<li>
简略说明 Netmask 的作用与优点；</li>

<li>
我有一组网域为： 192.168.0.0/28 ，请问这个网域的 Network, Netmask, Broadcast
各为多少？而可以使用的 IP 数量与范围各是多少？</li>

<li>
承上题，如果网域是 192.168.0.128/29 呢？</li>

<li>
我要将 192.168.100.0/24 这个 C Class 的网域分为 4 个子域，请问这四个子域要如何表示？</li>

<li>
如何观察 Linux 主机上面的路由信息 ( route table )？</li>

<li>
TCP 封包上面的 SYN 与 ACK 标志代表的意义为何？</li>

<li>
什么是三向交握？在哪一种封包格式上面才会有三向交握？</li>

<br><a href="http://linux.vbird.org/linux_server/0110network_basic/1000results.php#0110network_basic">前往参考用解答</a></ul>

<hr width="100%"><a name="Thanks"></a><font color="#000099"><font size="+1">特别感谢：</font></font>
<blockquote>本文在 2002/07 发出之后，收到相当多朋友的关心，也从而发现了自己误会的一些基础的网络理论，真的是感谢好朋友
Netman 兄与 ZMAN 兄的指导！这篇短文在 2003/08/03 做了相当大幅度的修订，与原来的文章
( 上次更新日期 2002/09 ) 已经有一定程度的差异了，希望网友们如果有时间的话，能够再次的阅读，以厘清一些基本概念喔！</blockquote>

<hr width="100%"><a name="reference"></a><font color="#000099"><font size="+1">参考数据</font></font>：
<ul>
<li>
Study Area 之网络基础：<a href="http://www.study-area.org/network/network.htm" target="_blank">http://www.study-area.org/network/network.htm</a></li>

<li>
Request For Comment (RFC) 技术文件：<a href="ftp://nic.merit.edu/internet/documents/rfc" target="_blank">ftp://nic.merit.edu/internet/documents/rfc</a></li>

<li>
Hub 与 Switch 的迷思：<a href="http://www.study-area.org/tips/hub_switch.htm" target="_blank">http://www.study-area.org/tips/hub_switch.htm</a></li>

<li>
BBS 上的问答收集</li>
</ul>

<center><font face="标楷体"><font color="#3333FF"><font size="+1"><a href="0110network_basic.html" target="_self">简易网络基础架构</a></font></font></font></center>

<hr width="100%"><font face="新细明体"><font color="#000066"><font size="-1">2002/07/18：第一次完成日期！</font></font></font>
<br><font face="新细明体"><font color="#000066"><font size="-1">2002/09/26：修改了部分可能引起误解的文章部分！</font></font></font>
<br><font face="新细明体"><font color="#000066"><font size="-1">2003/08/03：重新编排版面，并且重新检视文章内容，修订文章！</font></font></font>
<br><font face="新细明体"><font color="#000066"><font size="-1">2003/08/20：增加重点回顾与课后练习</font></font></font>
<br><font face="新细明体"><font color="#000066"><font size="-1">2003/09/06：加入<a href="http://linux.vbird.org/linux_server/1000results.php#0110network_basic">参考用解答</a></font></font></font>
<br><font face="新细明体"><font color="#000066"><font size="-1">2004/03/16：修订
N-Way 的错误，订正为 Auto MDI/MDIX 的功能！</font></font></font>
<hr width="100%">
    </td>
    <td style="width: 16px; font-size: 6px;">　</td></tr>
<tr><td style="width: 16px; height: 16px;">　</td>
    <td style="width: 866px; height: 16px;">　</td>
    <td style="width: 16px; height: 16px;">　</td></tr>
</tbody></table>

<div style="padding-top: 0px; text-align: center;">
<span style="font-size: 80%;">
	<a href="http://linux.vbird.org/" target="_top" title="前往鸟哥的首页">http://linux.vbird.org</a>
	is designed by <a href="mailto:vbird@mail.vbird.idv.tw" title="联络鸟哥(我不要广告信！)">VBird</a>
		during 2001-2011. <a href="http://www.ksu.edu.tw/" target="_blank">ksu.edu</a></span>
         ﻿<div id="apDiv4">
      <p>本网页主要以Firefox配合解析度 1024x768 作为设计依据&nbsp;&nbsp;&nbsp;&nbsp; 鸟哥自由软件整合应用研究室</p></div></div>
</div>
</center>
</body></html>
