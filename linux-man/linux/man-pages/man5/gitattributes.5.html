
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
        "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
    <link rel="stylesheet" type="text/css" href="../../../style.css" title="style" />
    <link rel="stylesheet" type="text/css" href="../style.css" title="style" />
    <meta http-equiv="content-type" content="text/html;charset=utf-8" />

    <title>gitattributes(5) - Linux manual page</title>
</head>

<body>

<div class="page-top"><a id="top_of_page"></a></div>
<!--%%%TOP_BAR%%%-->
    <div class="nav-bar">
        <table class="nav-table">
            <tr>
                <td class="nav-cell">
                    <p class="nav-text">
                        <a href="http://man7.org/index.html">man7.org</a> &gt; Linux &gt; <a href="../index.html">man-pages</a>
                    </p>
                </td>
                <td class="training-cell">
                    <p class="training-text"><a class="training-link" href="http://man7.org/training/">Linux/UNIX system programming training</a></p>
                </td>
            </tr>
        </table>
    </div>

<hr class="nav-end" />

<!--%%%PAGE_START%%%-->


<table class="sec-table">
<tr>
    <td>
        <p class="section-dir">
<a href="#NAME">NAME</a> | <a href="#SYNOPSIS">SYNOPSIS</a> | <a href="#DESCRIPTION">DESCRIPTION</a> | <a href="#EFFECTS">EFFECTS</a> | <a href="#USING_MACRO_ATTRIBUTES">USING&nbsp;MACRO&nbsp;ATTRIBUTES</a> | <a href="#DEFINING_MACRO_ATTRIBUTES">DEFINING&nbsp;MACRO&nbsp;ATTRIBUTES</a> | <a href="#EXAMPLE">EXAMPLE</a> | <a href="#SEE_ALSO">SEE&nbsp;ALSO</a> | <a href="#GIT">GIT</a> | <a href="#COLOPHON">COLOPHON</a>
        </p>
    </td>
    <td class="search-box">
        <div class="man-search-box">

            <form method="get" action="http://www.google.com/search">
                <fieldset class="man-search">
                    <input type="text" name="q" size="10" maxlength="255" value="" />
                    <input type="hidden" name="sitesearch" value="man7.org/linux/man-pages" />
                    <input type="submit" name="sa" value="Search online pages" />
                </fieldset>
            </form>

        </div>
    </td>
    <td> </td>
</tr>
</table>

<pre>
<span class="headline">GITATTRIBUTES(5)                 Git Manual                 GITATTRIBUTES(5)</span>
</pre>
<h2><a id="NAME" href="#NAME"></a>NAME  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       gitattributes - defining attributes per path
</pre>
<h2><a id="SYNOPSIS" href="#SYNOPSIS"></a>SYNOPSIS  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       $GIT_DIR/info/attributes, .gitattributes
</pre>
<h2><a id="DESCRIPTION" href="#DESCRIPTION"></a>DESCRIPTION  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       A <b>gitattributes </b>file is a simple text file that gives <b>attributes </b>to
       pathnames.

       Each line in <b>gitattributes </b>file is of form:

           pattern attr1 attr2 ...

       That is, a pattern followed by an attributes list, separated by
       whitespaces. Leading and trailing whitespaces are ignored. Lines that
       begin with <i>#</i> are ignored. Patterns that begin with a double quote are
       quoted in C style. When the pattern matches the path in question, the
       attributes listed on the line are given to the path.

       Each attribute can be in one of these states for a given path:

       Set
           The path has the attribute with special value "true"; this is
           specified by listing only the name of the attribute in the
           attribute list.

       Unset
           The path has the attribute with special value "false"; this is
           specified by listing the name of the attribute prefixed with a
           dash <b>- </b>in the attribute list.

       Set to a value
           The path has the attribute with specified string value; this is
           specified by listing the name of the attribute followed by an
           equal sign <b>= </b>and its value in the attribute list.

       Unspecified
           No pattern matches the path, and nothing says if the path has or
           does not have the attribute, the attribute for the path is said
           to be Unspecified.

       When more than one pattern matches the path, a later line overrides
       an earlier line. This overriding is done per attribute. The rules how
       the pattern matches paths are the same as in <b>.gitignore </b>files; see
       <a href="gitignore.5.html">gitignore(5)</a>. Unlike <b>.gitignore</b>, negative patterns are forbidden.

       When deciding what attributes are assigned to a path, Git consults
       <b>$GIT_DIR/info/attributes </b>file (which has the highest precedence),
       <b>.gitattributes </b>file in the same directory as the path in question,
       and its parent directories up to the toplevel of the work tree (the
       further the directory that contains <b>.gitattributes </b>is from the path
       in question, the lower its precedence). Finally global and
       system-wide files are considered (they have the lowest precedence).

       When the <b>.gitattributes </b>file is missing from the work tree, the path
       in the index is used as a fall-back. During checkout process,
       <b>.gitattributes </b>in the index is used and then the file in the working
       tree is used as a fall-back.

       If you wish to affect only a single repository (i.e., to assign
       attributes to files that are particular to one user’s workflow for
       that repository), then attributes should be placed in the
       <b>$GIT_DIR/info/attributes </b>file. Attributes which should be
       version-controlled and distributed to other repositories (i.e.,
       attributes of interest to all users) should go into <b>.gitattributes</b>
       files. Attributes that should affect all repositories for a single
       user should be placed in a file specified by the <b>core.attributesFile</b>
       configuration option (see <a href="../man1/git-config.1.html">git-config(1)</a>). Its default value is
       $XDG_CONFIG_HOME/git/attributes. If $XDG_CONFIG_HOME is either not
       set or empty, $HOME/.config/git/attributes is used instead.
       Attributes for all users on a system should be placed in the
       <b>$(prefix)/etc/gitattributes </b>file.

       Sometimes you would need to override a setting of an attribute for a
       path to <b>Unspecified </b>state. This can be done by listing the name of
       the attribute prefixed with an exclamation point <b>!</b>.
</pre>
<h2><a id="EFFECTS" href="#EFFECTS"></a>EFFECTS  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       Certain operations by Git can be influenced by assigning particular
       attributes to a path. Currently, the following operations are
       attributes-aware.

   <b>Checking-out and checking-in</b>
       These attributes affect how the contents stored in the repository are
       copied to the working tree files when commands such as <i>git checkout</i>
       and <i>git merge</i> run. They also affect how Git stores the contents you
       prepare in the working tree in the repository upon <i>git add</i> and <i>git</i>
       <i>commit</i>.

       <b>text</b>
           This attribute enables and controls end-of-line normalization.
           When a text file is normalized, its line endings are converted to
           LF in the repository. To control what line ending style is used
           in the working directory, use the <b>eol </b>attribute for a single file
           and the <b>core.eol </b>configuration variable for all text files. Note
           that <b>core.autocrlf </b>overrides <b>core.eol</b>

           Set
               Setting the <b>text </b>attribute on a path enables end-of-line
               normalization and marks the path as a text file. End-of-line
               conversion takes place without guessing the content type.

           Unset
               Unsetting the <b>text </b>attribute on a path tells Git not to
               attempt any end-of-line conversion upon checkin or checkout.

           Set to string value "auto"
               When <b>text </b>is set to "auto", the path is marked for automatic
               end-of-line conversion. If Git decides that the content is
               text, its line endings are converted to LF on checkin. When
               the file has been committed with CRLF, no conversion is done.

           Unspecified
               If the <b>text </b>attribute is unspecified, Git uses the
               <b>core.autocrlf </b>configuration variable to determine if the file
               should be converted.

           Any other value causes Git to act as if <b>text </b>has been left
           unspecified.

       <b>eol</b>
           This attribute sets a specific line-ending style to be used in
           the working directory. It enables end-of-line conversion without
           any content checks, effectively setting the <b>text </b>attribute.

           Set to string value "crlf"
               This setting forces Git to normalize line endings for this
               file on checkin and convert them to CRLF when the file is
               checked out.

           Set to string value "lf"
               This setting forces Git to normalize line endings to LF on
               checkin and prevents conversion to CRLF when the file is
               checked out.

       <b>Backwards compatibility with crlf attribute</b>
           For backwards compatibility, the <b>crlf </b>attribute is interpreted as
           follows:

               crlf            text
               -crlf           -text
               crlf=input      eol=lf

       <b>End-of-line conversion</b>
           While Git normally leaves file contents alone, it can be
           configured to normalize line endings to LF in the repository and,
           optionally, to convert them to CRLF when files are checked out.

           If you simply want to have CRLF line endings in your working
           directory regardless of the repository you are working with, you
           can set the config variable "core.autocrlf" without using any
           attributes.

               [core]
                       autocrlf = true

           This does not force normalization of text files, but does ensure
           that text files that you introduce to the repository have their
           line endings normalized to LF when they are added, and that files
           that are already normalized in the repository stay normalized.

           If you want to ensure that text files that any contributor
           introduces to the repository have their line endings normalized,
           you can set the <b>text </b>attribute to "auto" for <i>all</i> files.

               *       text=auto

           The attributes allow a fine-grained control, how the line endings
           are converted. Here is an example that will make Git normalize
           .txt, .vcproj and .sh files, ensure that .vcproj files have CRLF
           and .sh files have LF in the working directory, and prevent .jpg
           files from being normalized regardless of their content.

               *               text=auto
               *.txt           text
               *.vcproj        text eol=crlf
               *.sh            text eol=lf
               *.jpg           -text

               <b>Note</b>
               When <b>text=auto </b>conversion is enabled in a cross-platform
               project using push and pull to a central repository the text
               files containing CRLFs should be normalized.

           From a clean working directory:

               $ echo "* text=auto" &gt;.gitattributes
               $ git read-tree --empty   # Clean index, force re-scan of working directory
               $ git add .
               $ git status        # Show files that will be normalized
               $ git commit -m "Introduce end-of-line normalization"

           If any files that should not be normalized show up in <i>git status</i>,
           unset their <b>text </b>attribute before running <i>git add -u</i>.

               manual.pdf      -text

           Conversely, text files that Git does not detect can have
           normalization enabled manually.

               weirdchars.txt  text

           If <b>core.safecrlf </b>is set to "true" or "warn", Git verifies if the
           conversion is reversible for the current setting of
           <b>core.autocrlf</b>. For "true", Git rejects irreversible conversions;
           for "warn", Git only prints a warning but accepts an irreversible
           conversion. The safety triggers to prevent such a conversion done
           to the files in the work tree, but there are a few exceptions.
           Even though...

           ·   <i>git add</i> itself does not touch the files in the work tree, the
               next checkout would, so the safety triggers;

           ·   <i>git apply</i> to update a text file with a patch does touch the
               files in the work tree, but the operation is about text files
               and CRLF conversion is about fixing the line ending
               inconsistencies, so the safety does not trigger;

           ·   <i>git diff</i> itself does not touch the files in the work tree, it
               is often run to inspect the changes you intend to next <i>git</i>
               <i>add</i>. To catch potential problems early, safety triggers.

       <b>ident</b>
           When the attribute <b>ident </b>is set for a path, Git replaces <b>$Id$ </b>in
           the blob object with <b>$Id:</b>, followed by the 40-character
           hexadecimal blob object name, followed by a dollar sign <b>$ </b>upon
           checkout. Any byte sequence that begins with <b>$Id: </b>and ends with <b>$</b>
           in the worktree file is replaced with <b>$Id$ </b>upon check-in.

       <b>filter</b>
           A <b>filter </b>attribute can be set to a string value that names a
           filter driver specified in the configuration.

           A filter driver consists of a <b>clean </b>command and a <b>smudge </b>command,
           either of which can be left unspecified. Upon checkout, when the
           <b>smudge </b>command is specified, the command is fed the blob object
           from its standard input, and its standard output is used to
           update the worktree file. Similarly, the <b>clean </b>command is used to
           convert the contents of worktree file upon checkin. By default
           these commands process only a single blob and terminate. If a
           long running <b>process </b>filter is used in place of <b>clean </b>and/or
           <b>smudge </b>filters, then Git can process all blobs with a single
           filter command invocation for the entire life of a single Git
           command, for example <b>git add --all</b>. If a long running <b>process</b>
           filter is configured then it always takes precedence over a
           configured single blob filter. See section below for the
           description of the protocol used to communicate with a <b>process</b>
           filter.

           One use of the content filtering is to massage the content into a
           shape that is more convenient for the platform, filesystem, and
           the user to use. For this mode of operation, the key phrase here
           is "more convenient" and not "turning something unusable into
           usable". In other words, the intent is that if someone unsets the
           filter driver definition, or does not have the appropriate filter
           program, the project should still be usable.

           Another use of the content filtering is to store the content that
           cannot be directly used in the repository (e.g. a UUID that
           refers to the true content stored outside Git, or an encrypted
           content) and turn it into a usable form upon checkout (e.g.
           download the external content, or decrypt the encrypted content).

           These two filters behave differently, and by default, a filter is
           taken as the former, massaging the contents into more convenient
           shape. A missing filter driver definition in the config, or a
           filter driver that exits with a non-zero status, is not an error
           but makes the filter a no-op passthru.

           You can declare that a filter turns a content that by itself is
           unusable into a usable content by setting the
           filter.&lt;driver&gt;.required configuration variable to <b>true</b>.

           For example, in .gitattributes, you would assign the <b>filter</b>
           attribute for paths.

               *.c     filter=indent

           Then you would define a "filter.indent.clean" and
           "filter.indent.smudge" configuration in your .git/config to
           specify a pair of commands to modify the contents of C programs
           when the source files are checked in ("clean" is run) and checked
           out (no change is made because the command is "cat").

               [filter "indent"]
                       clean = indent
                       smudge = cat

           For best results, <b>clean </b>should not alter its output further if it
           is run twice ("clean→clean" should be equivalent to "clean"), and
           multiple <b>smudge </b>commands should not alter <b>clean</b>'s output
           ("smudge→smudge→clean" should be equivalent to "clean"). See the
           section on merging below.

           The "indent" filter is well-behaved in this regard: it will not
           modify input that is already correctly indented. In this case,
           the lack of a smudge filter means that the clean filter <i>must</i>
           accept its own output without modifying it.

           If a filter <i>must</i> succeed in order to make the stored contents
           usable, you can declare that the filter is <b>required</b>, in the
           configuration:

               [filter "crypt"]
                       clean = openssl enc ...
                       smudge = openssl enc -d ...
                       required

           Sequence "%f" on the filter command line is replaced with the
           name of the file the filter is working on. A filter might use
           this in keyword substitution. For example:

               [filter "p4"]
                       clean = git-p4-filter --clean %f
                       smudge = git-p4-filter --smudge %f

           Note that "%f" is the name of the path that is being worked on.
           Depending on the version that is being filtered, the
           corresponding file on disk may not exist, or may have different
           contents. So, smudge and clean commands should not try to access
           the file on disk, but only act as filters on the content provided
           to them on standard input.

       <b>Long Running Filter Process</b>
           If the filter command (a string value) is defined via
           <b>filter.&lt;driver&gt;.process </b>then Git can process all blobs with a
           single filter invocation for the entire life of a single Git
           command. This is achieved by using a packet format (pkt-line, see
           technical/protocol-common.txt) based protocol over standard input
           and standard output as follows. All packets, except for the
           "*CONTENT" packets and the "0000" flush packet, are considered
           text and therefore are terminated by a LF.

           Git starts the filter when it encounters the first file that
           needs to be cleaned or smudged. After the filter started Git
           sends a welcome message ("git-filter-client"), a list of
           supported protocol version numbers, and a flush packet. Git
           expects to read a welcome response message ("git-filter-server"),
           exactly one protocol version number from the previously sent
           list, and a flush packet. All further communication will be based
           on the selected version. The remaining protocol description below
           documents "version=2". Please note that "version=42" in the
           example below does not exist and is only there to illustrate how
           the protocol would look like with more than one version.

           After the version negotiation Git sends a list of all
           capabilities that it supports and a flush packet. Git expects to
           read a list of desired capabilities, which must be a subset of
           the supported capabilities list, and a flush packet as response:

               packet:          git&gt; git-filter-client
               packet:          git&gt; version=2
               packet:          git&gt; version=42
               packet:          git&gt; 0000
               packet:          git&lt; git-filter-server
               packet:          git&lt; version=2
               packet:          git&lt; 0000
               packet:          git&gt; capability=clean
               packet:          git&gt; capability=smudge
               packet:          git&gt; capability=not-yet-invented
               packet:          git&gt; 0000
               packet:          git&lt; capability=clean
               packet:          git&lt; capability=smudge
               packet:          git&lt; 0000

           Supported filter capabilities in version 2 are "clean" and
           "smudge".

           Afterwards Git sends a list of "key=value" pairs terminated with
           a flush packet. The list will contain at least the filter command
           (based on the supported capabilities) and the pathname of the
           file to filter relative to the repository root. Right after the
           flush packet Git sends the content split in zero or more pkt-line
           packets and a flush packet to terminate content. Please note,
           that the filter must not send any response before it received the
           content and the final flush packet. Also note that the "value" of
           a "key=value" pair can contain the "=" character whereas the key
           would never contain that character.

               packet:          git&gt; command=smudge
               packet:          git&gt; pathname=path/testfile.dat
               packet:          git&gt; 0000
               packet:          git&gt; CONTENT
               packet:          git&gt; 0000

           The filter is expected to respond with a list of "key=value"
           pairs terminated with a flush packet. If the filter does not
           experience problems then the list must contain a "success"
           status. Right after these packets the filter is expected to send
           the content in zero or more pkt-line packets and a flush packet
           at the end. Finally, a second list of "key=value" pairs
           terminated with a flush packet is expected. The filter can change
           the status in the second list or keep the status as is with an
           empty list. Please note that the empty list must be terminated
           with a flush packet regardless.

               packet:          git&lt; status=success
               packet:          git&lt; 0000
               packet:          git&lt; SMUDGED_CONTENT
               packet:          git&lt; 0000
               packet:          git&lt; 0000  # empty list, keep "status=success" unchanged!

           If the result content is empty then the filter is expected to
           respond with a "success" status and a flush packet to signal the
           empty content.

               packet:          git&lt; status=success
               packet:          git&lt; 0000
               packet:          git&lt; 0000  # empty content!
               packet:          git&lt; 0000  # empty list, keep "status=success" unchanged!

           In case the filter cannot or does not want to process the
           content, it is expected to respond with an "error" status.

               packet:          git&lt; status=error
               packet:          git&lt; 0000

           If the filter experiences an error during processing, then it can
           send the status "error" after the content was (partially or
           completely) sent.

               packet:          git&lt; status=success
               packet:          git&lt; 0000
               packet:          git&lt; HALF_WRITTEN_ERRONEOUS_CONTENT
               packet:          git&lt; 0000
               packet:          git&lt; status=error
               packet:          git&lt; 0000

           In case the filter cannot or does not want to process the content
           as well as any future content for the lifetime of the Git
           process, then it is expected to respond with an "abort" status at
           any point in the protocol.

               packet:          git&lt; status=abort
               packet:          git&lt; 0000

           Git neither stops nor restarts the filter process in case the
           "error"/"abort" status is set. However, Git sets its exit code
           according to the <b>filter.&lt;driver&gt;.required </b>flag, mimicking the
           behavior of the <b>filter.&lt;driver&gt;.clean </b>/ <b>filter.&lt;driver&gt;.smudge</b>
           mechanism.

           If the filter dies during the communication or does not adhere to
           the protocol then Git will stop the filter process and restart it
           with the next file that needs to be processed. Depending on the
           <b>filter.&lt;driver&gt;.required </b>flag Git will interpret that as error.

           After the filter has processed a blob it is expected to wait for
           the next "key=value" list containing a command. Git will close
           the command pipe on exit. The filter is expected to detect EOF
           and exit gracefully on its own. Git will wait until the filter
           process has stopped.

           A long running filter demo implementation can be found in
           <b>contrib/long-running-filter/example.pl </b>located in the Git core
           repository. If you develop your own long running filter process
           then the <b>GIT_TRACE_PACKET </b>environment variables can be very
           helpful for debugging (see <a href="../man1/git.1.html">git(1)</a>).

           Please note that you cannot use an existing <b>filter.&lt;driver&gt;.clean</b>
           or <b>filter.&lt;driver&gt;.smudge </b>command with <b>filter.&lt;driver&gt;.process</b>
           because the former two use a different inter process
           communication protocol than the latter one.

       <b>Interaction between checkin/checkout attributes</b>
           In the check-in codepath, the worktree file is first converted
           with <b>filter </b>driver (if specified and corresponding driver
           defined), then the result is processed with <b>ident </b>(if specified),
           and then finally with <b>text </b>(again, if specified and applicable).

           In the check-out codepath, the blob content is first converted
           with <b>text</b>, and then <b>ident </b>and fed to <b>filter</b>.

       <b>Merging branches with differing checkin/checkout attributes</b>
           If you have added attributes to a file that cause the canonical
           repository format for that file to change, such as adding a
           clean/smudge filter or text/eol/ident attributes, merging
           anything where the attribute is not in place would normally cause
           merge conflicts.

           To prevent these unnecessary merge conflicts, Git can be told to
           run a virtual check-out and check-in of all three stages of a
           file when resolving a three-way merge by setting the
           <b>merge.renormalize </b>configuration variable. This prevents changes
           caused by check-in conversion from causing spurious merge
           conflicts when a converted file is merged with an unconverted
           file.

           As long as a "smudge→clean" results in the same output as a
           "clean" even on files that are already smudged, this strategy
           will automatically resolve all filter-related conflicts. Filters
           that do not act in this way may cause additional merge conflicts
           that must be resolved manually.

   <b>Generating diff text</b>
       <b>diff</b>
           The attribute <b>diff </b>affects how Git generates diffs for particular
           files. It can tell Git whether to generate a textual patch for
           the path or to treat the path as a binary file. It can also
           affect what line is shown on the hunk header <b>@@ -k,l +n,m @@</b>
           line, tell Git to use an external command to generate the diff,
           or ask Git to convert binary files to a text format before
           generating the diff.

           Set
               A path to which the <b>diff </b>attribute is set is treated as text,
               even when they contain byte values that normally never appear
               in text files, such as NUL.

           Unset
               A path to which the <b>diff </b>attribute is unset will generate
               <b>Binary files differ </b>(or a binary patch, if binary patches are
               enabled).

           Unspecified
               A path to which the <b>diff </b>attribute is unspecified first gets
               its contents inspected, and if it looks like text and is
               smaller than core.bigFileThreshold, it is treated as text.
               Otherwise it would generate <b>Binary files differ</b>.

           String
               Diff is shown using the specified diff driver. Each driver
               may specify one or more options, as described in the
               following section. The options for the diff driver "foo" are
               defined by the configuration variables in the "diff.foo"
               section of the Git config file.

       <b>Defining an external diff driver</b>
           The definition of a diff driver is done in <b>gitconfig</b>, not
           <b>gitattributes </b>file, so strictly speaking this manual page is a
           wrong place to talk about it. However...

           To define an external diff driver <b>jcdiff</b>, add a section to your
           <b>$GIT_DIR/config </b>file (or <b>$HOME/.gitconfig </b>file) like this:

               [diff "jcdiff"]
                       command = j-c-diff

           When Git needs to show you a diff for the path with <b>diff</b>
           attribute set to <b>jcdiff</b>, it calls the command you specified with
           the above configuration, i.e. <b>j-c-diff</b>, with 7 parameters, just
           like <b>GIT_EXTERNAL_DIFF </b>program is called. See <a href="../man1/git.1.html">git(1)</a> for details.

       <b>Defining a custom hunk-header</b>
           Each group of changes (called a "hunk") in the textual diff
           output is prefixed with a line of the form:

               @@ -k,l +n,m @@ TEXT

           This is called a <i>hunk header</i>. The "TEXT" portion is by default a
           line that begins with an alphabet, an underscore or a dollar
           sign; this matches what GNU <i>diff -p</i> output uses. This default
           selection however is not suited for some contents, and you can
           use a customized pattern to make a selection.

           First, in .gitattributes, you would assign the <b>diff </b>attribute for
           paths.

               *.tex   diff=tex

           Then, you would define a "diff.tex.xfuncname" configuration to
           specify a regular expression that matches a line that you would
           want to appear as the hunk header "TEXT". Add a section to your
           <b>$GIT_DIR/config </b>file (or <b>$HOME/.gitconfig </b>file) like this:

               [diff "tex"]
                       xfuncname = "^(\\\\(sub)*section\\{.*)$"

           Note. A single level of backslashes are eaten by the
           configuration file parser, so you would need to double the
           backslashes; the pattern above picks a line that begins with a
           backslash, and zero or more occurrences of <b>sub </b>followed by
           <b>section </b>followed by open brace, to the end of line.

           There are a few built-in patterns to make this easier, and <b>tex </b>is
           one of them, so you do not have to write the above in your
           configuration file (you still need to enable this with the
           attribute mechanism, via <b>.gitattributes</b>). The following built in
           patterns are available:

           ·   <b>ada </b>suitable for source code in the Ada language.

           ·   <b>bibtex </b>suitable for files with BibTeX coded references.

           ·   <b>cpp </b>suitable for source code in the C and C++ languages.

           ·   <b>csharp </b>suitable for source code in the C# language.

           ·   <b>css </b>suitable for cascading style sheets.

           ·   <b>fortran </b>suitable for source code in the Fortran language.

           ·   <b>fountain </b>suitable for Fountain documents.

           ·   <b>html </b>suitable for HTML/XHTML documents.

           ·   <b>java </b>suitable for source code in the Java language.

           ·   <b>matlab </b>suitable for source code in the MATLAB language.

           ·   <b>objc </b>suitable for source code in the Objective-C language.

           ·   <b>pascal </b>suitable for source code in the Pascal/Delphi
               language.

           ·   <b>perl </b>suitable for source code in the Perl language.

           ·   <b>php </b>suitable for source code in the PHP language.

           ·   <b>python </b>suitable for source code in the Python language.

           ·   <b>ruby </b>suitable for source code in the Ruby language.

           ·   <b>tex </b>suitable for source code for LaTeX documents.

       <b>Customizing word diff</b>
           You can customize the rules that <b>git diff --word-diff </b>uses to
           split words in a line, by specifying an appropriate regular
           expression in the "diff.*.wordRegex" configuration variable. For
           example, in TeX a backslash followed by a sequence of letters
           forms a command, but several such commands can be run together
           without intervening whitespace. To separate them, use a regular
           expression in your <b>$GIT_DIR/config </b>file (or <b>$HOME/.gitconfig</b>
           file) like this:

               [diff "tex"]
                       wordRegex = "\\\\[a-zA-Z]+|[{}]|\\\\.|[^\\{}[:space:]]+"

           A built-in pattern is provided for all languages listed in the
           previous section.

       <b>Performing text diffs of binary files</b>
           Sometimes it is desirable to see the diff of a text-converted
           version of some binary files. For example, a word processor
           document can be converted to an ASCII text representation, and
           the diff of the text shown. Even though this conversion loses
           some information, the resulting diff is useful for human viewing
           (but cannot be applied directly).

           The <b>textconv </b>config option is used to define a program for
           performing such a conversion. The program should take a single
           argument, the name of a file to convert, and produce the
           resulting text on stdout.

           For example, to show the diff of the exif information of a file
           instead of the binary information (assuming you have the exif
           tool installed), add the following section to your
           <b>$GIT_DIR/config </b>file (or <b>$HOME/.gitconfig </b>file):

               [diff "jpg"]
                       textconv = exif

               <b>Note</b>
               The text conversion is generally a one-way conversion; in
               this example, we lose the actual image contents and focus
               just on the text data. This means that diffs generated by
               textconv are <i>not</i> suitable for applying. For this reason, only
               <b>git diff </b>and the <b>git log </b>family of commands (i.e., log,
               whatchanged, show) will perform text conversion. <b>git</b>
               <b>format-patch </b>will never generate this output. If you want to
               send somebody a text-converted diff of a binary file (e.g.,
               because it quickly conveys the changes you have made), you
               should generate it separately and send it as a comment <i>in</i>
               <i>addition to</i> the usual binary diff that you might send.

           Because text conversion can be slow, especially when doing a
           large number of them with <b>git log -p</b>, Git provides a mechanism to
           cache the output and use it in future diffs. To enable caching,
           set the "cachetextconv" variable in your diff driver’s config.
           For example:

               [diff "jpg"]
                       textconv = exif
                       cachetextconv = true

           This will cache the result of running "exif" on each blob
           indefinitely. If you change the textconv config variable for a
           diff driver, Git will automatically invalidate the cache entries
           and re-run the textconv filter. If you want to invalidate the
           cache manually (e.g., because your version of "exif" was updated
           and now produces better output), you can remove the cache
           manually with <b>git update-ref -d refs/notes/textconv/jpg </b>(where
           "jpg" is the name of the diff driver, as in the example above).

       <b>Choosing textconv versus external diff</b>
           If you want to show differences between binary or
           specially-formatted blobs in your repository, you can choose to
           use either an external diff command, or to use textconv to
           convert them to a diff-able text format. Which method you choose
           depends on your exact situation.

           The advantage of using an external diff command is flexibility.
           You are not bound to find line-oriented changes, nor is it
           necessary for the output to resemble unified diff. You are free
           to locate and report changes in the most appropriate way for your
           data format.

           A textconv, by comparison, is much more limiting. You provide a
           transformation of the data into a line-oriented text format, and
           Git uses its regular diff tools to generate the output. There are
           several advantages to choosing this method:

            1. Ease of use. It is often much simpler to write a binary to
               text transformation than it is to perform your own diff. In
               many cases, existing programs can be used as textconv filters
               (e.g., exif, odt2txt).

            2. Git diff features. By performing only the transformation step
               yourself, you can still utilize many of Git’s diff features,
               including colorization, word-diff, and combined diffs for
               merges.

            3. Caching. Textconv caching can speed up repeated diffs, such
               as those you might trigger by running <b>git log -p</b>.

       <b>Marking files as binary</b>
           Git usually guesses correctly whether a blob contains text or
           binary data by examining the beginning of the contents. However,
           sometimes you may want to override its decision, either because a
           blob contains binary data later in the file, or because the
           content, while technically composed of text characters, is opaque
           to a human reader. For example, many postscript files contain
           only ASCII characters, but produce noisy and meaningless diffs.

           The simplest way to mark a file as binary is to unset the diff
           attribute in the <b>.gitattributes </b>file:

               *.ps -diff

           This will cause Git to generate <b>Binary files differ </b>(or a binary
           patch, if binary patches are enabled) instead of a regular diff.

           However, one may also want to specify other diff driver
           attributes. For example, you might want to use <b>textconv </b>to
           convert postscript files to an ASCII representation for human
           viewing, but otherwise treat them as binary files. You cannot
           specify both <b>-diff </b>and <b>diff=ps </b>attributes. The solution is to use
           the <b>diff.*.binary </b>config option:

               [diff "ps"]
                 textconv = ps2ascii
                 binary = true

   <b>Performing a three-way merge</b>
       <b>merge</b>
           The attribute <b>merge </b>affects how three versions of a file are
           merged when a file-level merge is necessary during <b>git merge</b>, and
           other commands such as <b>git revert </b>and <b>git cherry-pick</b>.

           Set
               Built-in 3-way merge driver is used to merge the contents in
               a way similar to <i>merge</i> command of <b>RCS </b>suite. This is suitable
               for ordinary text files.

           Unset
               Take the version from the current branch as the tentative
               merge result, and declare that the merge has conflicts. This
               is suitable for binary files that do not have a well-defined
               merge semantics.

           Unspecified
               By default, this uses the same built-in 3-way merge driver as
               is the case when the <b>merge </b>attribute is set. However, the
               <b>merge.default </b>configuration variable can name different merge
               driver to be used with paths for which the <b>merge </b>attribute is
               unspecified.

           String
               3-way merge is performed using the specified custom merge
               driver. The built-in 3-way merge driver can be explicitly
               specified by asking for "text" driver; the built-in "take the
               current branch" driver can be requested with "binary".

       <b>Built-in merge drivers</b>
           There are a few built-in low-level merge drivers defined that can
           be asked for via the <b>merge </b>attribute.

           text
               Usual 3-way file level merge for text files. Conflicted
               regions are marked with conflict markers <b>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</b>, <b>======= </b>and
               <b>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</b>. The version from your branch appears before the
               <b>======= </b>marker, and the version from the merged branch
               appears after the <b>======= </b>marker.

           binary
               Keep the version from your branch in the work tree, but leave
               the path in the conflicted state for the user to sort out.

           union
               Run 3-way file level merge for text files, but take lines
               from both versions, instead of leaving conflict markers. This
               tends to leave the added lines in the resulting file in
               random order and the user should verify the result. Do not
               use this if you do not understand the implications.

       <b>Defining a custom merge driver</b>
           The definition of a merge driver is done in the <b>.git/config </b>file,
           not in the <b>gitattributes </b>file, so strictly speaking this manual
           page is a wrong place to talk about it. However...

           To define a custom merge driver <b>filfre</b>, add a section to your
           <b>$GIT_DIR/config </b>file (or <b>$HOME/.gitconfig </b>file) like this:

               [merge "filfre"]
                       name = feel-free merge driver
                       driver = filfre %O %A %B %L %P
                       recursive = binary

           The <b>merge.*.name </b>variable gives the driver a human-readable name.

           The ‘merge.*.driver` variable’s value is used to construct a
           command to run to merge ancestor’s version (<b>%O</b>), current version
           (<b>%A</b>) and the other branches’ version (<b>%B</b>). These three tokens are
           replaced with the names of temporary files that hold the contents
           of these versions when the command line is built. Additionally,
           %L will be replaced with the conflict marker size (see below).

           The merge driver is expected to leave the result of the merge in
           the file named with <b>%A </b>by overwriting it, and exit with zero
           status if it managed to merge them cleanly, or non-zero if there
           were conflicts.

           The <b>merge.*.recursive </b>variable specifies what other merge driver
           to use when the merge driver is called for an internal merge
           between common ancestors, when there are more than one. When left
           unspecified, the driver itself is used for both internal merge
           and the final merge.

           The merge driver can learn the pathname in which the merged
           result will be stored via placeholder <b>%P</b>.

       <b>conflict-marker-size</b>
           This attribute controls the length of conflict markers left in
           the work tree file during a conflicted merge. Only setting to the
           value to a positive integer has any meaningful effect.

           For example, this line in <b>.gitattributes </b>can be used to tell the
           merge machinery to leave much longer (instead of the usual
           7-character-long) conflict markers when merging the file
           <b>Documentation/git-merge.txt </b>results in a conflict.

               Documentation/git-merge.txt     conflict-marker-size=32

   <b>Checking whitespace errors</b>
       <b>whitespace</b>
           The <b>core.whitespace </b>configuration variable allows you to define
           what <i>diff</i> and <i>apply</i> should consider whitespace errors for all
           paths in the project (See <a href="../man1/git-config.1.html">git-config(1)</a>). This attribute gives
           you finer control per path.

           Set
               Notice all types of potential whitespace errors known to Git.
               The tab width is taken from the value of the <b>core.whitespace</b>
               configuration variable.

           Unset
               Do not notice anything as error.

           Unspecified
               Use the value of the <b>core.whitespace </b>configuration variable
               to decide what to notice as error.

           String
               Specify a comma separate list of common whitespace problems
               to notice in the same format as the <b>core.whitespace</b>
               configuration variable.

   <b>Creating an archive</b>
       <b>export-ignore</b>
           Files and directories with the attribute <b>export-ignore </b>won’t be
           added to archive files.

       <b>export-subst</b>
           If the attribute <b>export-subst </b>is set for a file then Git will
           expand several placeholders when adding this file to an archive.
           The expansion depends on the availability of a commit ID, i.e.,
           if <a href="../man1/git-archive.1.html">git-archive(1)</a> has been given a tree instead of a commit or a
           tag then no replacement will be done. The placeholders are the
           same as those for the option <b>--pretty=format: </b>of <a href="../man1/git-log.1.html">git-log(1)</a>,
           except that they need to be wrapped like this:
           <b>$Format:PLACEHOLDERS$ </b>in the file. E.g. the string <b>$Format:%H$</b>
           will be replaced by the commit hash.

   <b>Packing objects</b>
       <b>delta</b>
           Delta compression will not be attempted for blobs for paths with
           the attribute <b>delta </b>set to false.

   <b>Viewing files in GUI tools</b>
       <b>encoding</b>
           The value of this attribute specifies the character encoding that
           should be used by GUI tools (e.g. <a href="../man1/gitk.1.html">gitk(1)</a> and <a href="../man1/git-gui.1.html">git-gui(1)</a>) to
           display the contents of the relevant file. Note that due to
           performance considerations <a href="../man1/gitk.1.html">gitk(1)</a> does not use this attribute
           unless you manually enable per-file encodings in its options.

           If this attribute is not set or has an invalid value, the value
           of the <b>gui.encoding </b>configuration variable is used instead (See
           <a href="../man1/git-config.1.html">git-config(1)</a>).
</pre>
<h2><a id="USING_MACRO_ATTRIBUTES" href="#USING_MACRO_ATTRIBUTES"></a>USING MACRO ATTRIBUTES  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       You do not want any end-of-line conversions applied to, nor textual
       diffs produced for, any binary file you track. You would need to
       specify e.g.

           *.jpg -text -diff

       but that may become cumbersome, when you have many attributes. Using
       macro attributes, you can define an attribute that, when set, also
       sets or unsets a number of other attributes at the same time. The
       system knows a built-in macro attribute, <b>binary</b>:

           *.jpg binary

       Setting the "binary" attribute also unsets the "text" and "diff"
       attributes as above. Note that macro attributes can only be "Set",
       though setting one might have the effect of setting or unsetting
       other attributes or even returning other attributes to the
       "Unspecified" state.
</pre>
<h2><a id="DEFINING_MACRO_ATTRIBUTES" href="#DEFINING_MACRO_ATTRIBUTES"></a>DEFINING MACRO ATTRIBUTES  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       Custom macro attributes can be defined only in top-level
       gitattributes files (<b>$GIT_DIR/info/attributes</b>, the <b>.gitattributes</b>
       file at the top level of the working tree, or the global or
       system-wide gitattributes files), not in <b>.gitattributes </b>files in
       working tree subdirectories. The built-in macro attribute "binary" is
       equivalent to:

           [attr]binary -diff -merge -text
</pre>
<h2><a id="EXAMPLE" href="#EXAMPLE"></a>EXAMPLE  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       If you have these three <b>gitattributes </b>file:

           (in $GIT_DIR/info/attributes)

           a*      foo !bar -baz

           (in .gitattributes)
           abc     foo bar baz

           (in t/.gitattributes)
           ab*     merge=filfre
           abc     -foo -bar
           *.c     frotz

       the attributes given to path <b>t/abc </b>are computed as follows:

        1. By examining <b>t/.gitattributes </b>(which is in the same directory as
           the path in question), Git finds that the first line matches.
           <b>merge </b>attribute is set. It also finds that the second line
           matches, and attributes <b>foo </b>and <b>bar </b>are unset.

        2. Then it examines <b>.gitattributes </b>(which is in the parent
           directory), and finds that the first line matches, but
           <b>t/.gitattributes </b>file already decided how <b>merge</b>, <b>foo </b>and <b>bar</b>
           attributes should be given to this path, so it leaves <b>foo </b>and <b>bar</b>
           unset. Attribute <b>baz </b>is set.

        3. Finally it examines <b>$GIT_DIR/info/attributes</b>. This file is used
           to override the in-tree settings. The first line is a match, and
           <b>foo </b>is set, <b>bar </b>is reverted to unspecified state, and <b>baz </b>is
           unset.

       As the result, the attributes assignment to <b>t/abc </b>becomes:

           foo     set to true
           bar     unspecified
           baz     set to false
           merge   set to string value "filfre"
           frotz   unspecified
</pre>
<h2><a id="SEE_ALSO" href="#SEE_ALSO"></a>SEE ALSO  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       <a href="../man1/git-check-attr.1.html">git-check-attr(1)</a>.
</pre>
<h2><a id="GIT" href="#GIT"></a>GIT  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       Part of the <a href="../man1/git.1.html">git(1)</a> suite
</pre>
<h2><a id="COLOPHON" href="#COLOPHON"></a>COLOPHON  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       This page is part of the <i>git</i> (Git distributed version control system)
       project.  Information about the project can be found at 
       ⟨<a href="http://git-scm.com/">http://git-scm.com/</a>⟩.  If you have a bug report for this manual page,
       see ⟨<a href="http://git-scm.com/community">http://git-scm.com/community</a>⟩.  This page was obtained from the
       project's upstream Git repository ⟨<a href="https://github.com/git/git.git">https://github.com/git/git.git</a>⟩ on
       2017-07-05.  If you discover any rendering problems in this HTML ver‐
       sion of the page, or you believe there is a better or more up-to-date
       source for the page, or you have corrections or improvements to the
       information in this COLOPHON (which is <i>not</i> part of the original man‐
       ual page), send a mail to man-pages@man7.org

<span class="footline">Git 2.13.2.556.g5116f7           07/05/2017                 GITATTRIBUTES(5)</span>
</pre>

<hr class="end-man-text" />
<p>Pages that refer to this page: 
    <a href="../man1/git-archive.1.html">git-archive(1)</a>,&nbsp; 
    <a href="../man1/git-check-attr.1.html">git-check-attr(1)</a>,&nbsp; 
    <a href="../man1/git-commit.1.html">git-commit(1)</a>,&nbsp; 
    <a href="../man1/git-commit-tree.1.html">git-commit-tree(1)</a>,&nbsp; 
    <a href="../man1/git-config.1.html">git-config(1)</a>,&nbsp; 
    <a href="../man1/git-cvsserver.1.html">git-cvsserver(1)</a>,&nbsp; 
    <a href="../man1/git-diff.1.html">git-diff(1)</a>,&nbsp; 
    <a href="../man1/git-diff-files.1.html">git-diff-files(1)</a>,&nbsp; 
    <a href="../man1/git-diff-index.1.html">git-diff-index(1)</a>,&nbsp; 
    <a href="../man1/git-diff-tree.1.html">git-diff-tree(1)</a>,&nbsp; 
    <a href="../man1/git-format-patch.1.html">git-format-patch(1)</a>,&nbsp; 
    <a href="../man1/git-grep.1.html">git-grep(1)</a>,&nbsp; 
    <a href="../man1/git-log.1.html">git-log(1)</a>,&nbsp; 
    <a href="../man1/git-merge.1.html">git-merge(1)</a>,&nbsp; 
    <a href="../man1/git-pull.1.html">git-pull(1)</a>,&nbsp; 
    <a href="../man1/git-rebase.1.html">git-rebase(1)</a>,&nbsp; 
    <a href="../man1/git-show.1.html">git-show(1)</a>,&nbsp; 
    <a href="../man7/gitglossary.7.html">gitglossary(7)</a>
</p>
<hr/>

 
<hr class="start-footer" />

<div class="footer"> 

<table class="colophon-table">
    <tr>
    <td class="pub-info">
        <p>
            HTML rendering created 2017-07-13
            by <a href="http://man7.org/mtk/index.html">Michael Kerrisk</a>, 
            author of 
            <a href="http://man7.org/tlpi/"><em>The Linux Programming Interface</em></a>, 
            maintainer of the 
            <a href="https://www.kernel.org/doc/man-pages/">Linux <em>man-pages</em> project</a>.
        </p>
        <p>
            For details of in-depth
            <strong>Linux/UNIX system programming training courses</strong>
            that I teach, look <a href="http://man7.org/training/">here</a>.
        </p>
        <p>
            Hosting by <a href="http://www.jambit.com/index_en.html">jambit GmbH</a>.
        </p>
        <p>
            <a href="http://validator.w3.org/check?uri=referer">
            <img src="http://www.w3.org/Icons/valid-xhtml11"
                alt="Valid XHTML 1.1" height="31" width="88" />
            </a>
        </p>
    </td>
    <td class="colophon-divider">
    </td>
    <td class="tlpi-cover">
        <a href="http://man7.org/tlpi/"><img src="../../../tlpi/cover/TLPI-front-cover-vsmall.png" alt="Cover of TLPI" /></a>
    </td>
    </tr>
</table>

</div>

<hr class="end-footer" />



<!--BEGIN-SITETRACKING-->
<!-- SITETRACKING.man7.org_linux_man-pages -->

<!-- Start of StatCounter Code (xhtml) -->

<script type="text/javascript">
//<![CDATA[
var sc_project=7422636; 
var sc_invisible=1; 
var sc_security="9b6714ff"; 
//]]>
</script>
<script type="text/javascript"
src="../../../../www.statcounter.com/counter/counter_xhtml.js"></script>
<noscript><div class="statcounter"><a title="website
statistics" href="http://statcounter.com/"
class="statcounter"><img class="statcounter"
src="http://c.statcounter.com/7422636/0/9b6714ff/1/"
alt="website statistics" /></a></div></noscript>

<!-- End of StatCounter Code -->


<!-- Start of Google Analytics Code -->

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-9830363-8']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<!-- End of Google Analytics Code -->

<!--END-SITETRACKING-->

</body>
</html>
