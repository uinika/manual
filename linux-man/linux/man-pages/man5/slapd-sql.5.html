
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
        "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
    <link rel="stylesheet" type="text/css" href="../../../style.css" title="style" />
    <link rel="stylesheet" type="text/css" href="../style.css" title="style" />
    <meta http-equiv="content-type" content="text/html;charset=utf-8" />

    <title>slapd-sql(5) - Linux manual page</title>
</head>

<body>

<div class="page-top"><a id="top_of_page"></a></div>
<!--%%%TOP_BAR%%%-->
    <div class="nav-bar">
        <table class="nav-table">
            <tr>
                <td class="nav-cell">
                    <p class="nav-text">
                        <a href="http://man7.org/index.html">man7.org</a> &gt; Linux &gt; <a href="../index.html">man-pages</a>
                    </p>
                </td>
                <td class="training-cell">
                    <p class="training-text"><a class="training-link" href="http://man7.org/training/">Linux/UNIX system programming training</a></p>
                </td>
            </tr>
        </table>
    </div>

<hr class="nav-end" />

<!--%%%PAGE_START%%%-->


<table class="sec-table">
<tr>
    <td>
        <p class="section-dir">
<a href="#NAME">NAME</a> | <a href="#SYNOPSIS">SYNOPSIS</a> | <a href="#DESCRIPTION">DESCRIPTION</a> | <a href="#CONFIGURATION">CONFIGURATION</a> | <a href="#DATA_SOURCE_CONFIGURATION">DATA&nbsp;SOURCE&nbsp;CONFIGURATION</a> | <a href="#SCOPING_CONFIGURATION">SCOPING&nbsp;CONFIGURATION</a> | <a href="#STATEMENT_CONFIGURATION">STATEMENT&nbsp;CONFIGURATION</a> | <a href="#HELPER_CONFIGURATION">HELPER&nbsp;CONFIGURATION</a> | <a href="#METAINFORMATION_USED">METAINFORMATION&nbsp;USED</a> | <a href="#TYPICAL_SQL_BACKEND_OPERATION">TYPICAL&nbsp;SQL&nbsp;BACKEND&nbsp;OPERATION</a> | <a href="#COMMON_TECHNIQUES">COMMON&nbsp;TECHNIQUES</a> | <a href="#CAVEATS">CAVEATS</a> | <a href="#BUGS">BUGS</a> | <a href="#PROXY_CACHE_OVERLAY">PROXY&nbsp;CACHE&nbsp;OVERLAY</a> | <a href="#EXAMPLES">EXAMPLES</a> | <a href="#ACCESS_CONTROL">ACCESS&nbsp;CONTROL</a> | <a href="#FILES">FILES</a> | <a href="#SEE_ALSO">SEE&nbsp;ALSO</a> | <a href="#COLOPHON">COLOPHON</a>
        </p>
    </td>
    <td class="search-box">
        <div class="man-search-box">

            <form method="get" action="http://www.google.com/search">
                <fieldset class="man-search">
                    <input type="text" name="q" size="10" maxlength="255" value="" />
                    <input type="hidden" name="sitesearch" value="man7.org/linux/man-pages" />
                    <input type="submit" name="sa" value="Search online pages" />
                </fieldset>
            </form>

        </div>
    </td>
    <td> </td>
</tr>
</table>

<pre>
<span class="headline">SLAPD-SQL(5)                 File Formats Manual                SLAPD-SQL(5)</span>
</pre>
<h2><a id="NAME" href="#NAME"></a>NAME  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       slapd-sql - SQL backend to slapd
</pre>
<h2><a id="SYNOPSIS" href="#SYNOPSIS"></a>SYNOPSIS  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       ETCDIR/slapd.conf
</pre>
<h2><a id="DESCRIPTION" href="#DESCRIPTION"></a>DESCRIPTION  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       The primary purpose of this <a href="../man8/slapd.8.html">slapd(8)</a> backend is to PRESENT
       information stored in some RDBMS as an LDAP subtree without any
       programming (some SQL and maybe stored procedures can't be considered
       programming, anyway ;).

       That is, for example, when you (some ISP) have account information
       you use in an RDBMS, and want to use modern solutions that expect
       such information in LDAP (to authenticate users, make email lookups
       etc.).  Or you want to synchronize or distribute information between
       different sites/applications that use RDBMSes and/or LDAP.  Or
       whatever else...

       It is NOT designed as a general-purpose backend that uses RDBMS
       instead of BerkeleyDB (as the standard BDB backend does), though it
       can be used as such with several limitations.  You can take a look at
       <b>http://www.openldap.org/faq/index.cgi?file=378 </b>(OpenLDAP
       FAQ-O-Matic/General LDAP FAQ/Directories vs. conventional databases)
       to find out more on this point.

       The idea (detailed below) is to use some meta-information to
       translate LDAP queries to SQL queries, leaving relational schema
       untouched, so that old applications can continue using it without any
       modifications.  This allows SQL and LDAP applications to inter-
       operate without replication, and exchange data as needed.

       The SQL backend is designed to be tunable to virtually any relational
       schema without having to change source (through that meta-information
       mentioned).  Also, it uses ODBC to connect to RDBMSes, and is highly
       configurable for SQL dialects RDBMSes may use, so it may be used for
       integration and distribution of data on different RDBMSes, OSes,
       hosts etc., in other words, in highly heterogeneous environment.

       This backend is <i>experimental</i>.
</pre>
<h2><a id="CONFIGURATION" href="#CONFIGURATION"></a>CONFIGURATION  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       These <b>slapd.conf </b>options apply to the SQL backend database, which
       means that they must follow a "database sql" line and come before any
       subsequent "backend" or "database" lines.  Other database options not
       specific to this backend are described in the <a href="slapd.conf.5.html">slapd.conf(5)</a> manual
       page.
</pre>
<h2><a id="DATA_SOURCE_CONFIGURATION" href="#DATA_SOURCE_CONFIGURATION"></a>DATA SOURCE CONFIGURATION  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       <b>dbname &lt;datasource name&gt;</b>
              The name of the ODBC datasource to use.

       <b>dbhost &lt;hostname&gt;</b>
       <b>dbpasswd &lt;password&gt;</b>
       <b>dbuser &lt;username&gt;</b>
              The three above options are generally unneeded, because this
              information is taken from the datasource specified by the
              <b>dbname </b>directive.  They allow to override datasource settings.
              Also, several RDBMS' drivers tend to require explicit passing
              of user/password, even if those are given in datasource (Note:
              <b>dbhost </b>is currently ignored).
</pre>
<h2><a id="SCOPING_CONFIGURATION" href="#SCOPING_CONFIGURATION"></a>SCOPING CONFIGURATION  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       These options specify SQL query templates for scoping searches.

       <b>subtree_cond &lt;SQL expression&gt;</b>
              Specifies a where-clause template used to form a subtree
              search condition (dn="(.+,)?&lt;dn&gt;$").  It may differ from one
              SQL dialect to another (see samples).  By default, it is
              constructed based on the knowledge about how to normalize DN
              values (e.g.  <b>"&lt;upper_func&gt;(ldap_entries.dn) LIKE</b>
              <b>CONCAT('%',?)"</b>); see <b>upper_func</b>, <b>upper_needs_cast</b>,
              <b>concat_pattern </b>and <b>strcast_func </b>in "HELPER CONFIGURATION" for
              details.

       <b>children_cond &lt;SQL expression&gt;</b>
              Specifies a where-clause template used to form a children
              search condition (dn=".+,&lt;dn&gt;$").  It may differ from one SQL
              dialect to another (see samples).  By default, it is
              constructed based on the knowledge about how to normalize DN
              values (e.g.  <b>"&lt;upper_func&gt;(ldap_entries.dn) LIKE</b>
              <b>CONCAT('%,',?)"</b>); see <b>upper_func</b>, <b>upper_needs_cast</b>,
              <b>concat_pattern </b>and <b>strcast_func </b>in "HELPER CONFIGURATION" for
              details.

       <b>use_subtree_shortcut { YES | no }</b>
              Do not use the subtree condition when the searchBase is the
              database suffix, and the scope is subtree; rather collect all
              entries.
</pre>
<h2><a id="STATEMENT_CONFIGURATION" href="#STATEMENT_CONFIGURATION"></a>STATEMENT CONFIGURATION  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       These options specify SQL query templates for loading schema mapping
       meta-information, adding and deleting entries to ldap_entries, etc.
       All these and subtree_cond should have the given default values.  For
       the current value it is recommended to look at the sources, or in the
       log output when slapd starts with "-d 5" or greater.  Note that the
       parameter number and order must not be changed.

       <b>oc_query &lt;SQL expression&gt;</b>
              The query that is used to collect the objectClass mapping data
              from table <i>ldap_oc_mappings</i>; see "METAINFORMATION USED" for
              details.  The default is <b>"SELECT id, name, keytbl, keycol,</b>
              <b>create_proc, delete_proc, expect_return FROM</b>
              <b>ldap_oc_mappings"</b>.

       <b>at_query &lt;SQL expression&gt;</b>
              The query that is used to collect the attributeType mapping
              data from table <i>ldap_attr_mappings</i>; see "METAINFORMATION USED"
              for details.  The default is <b>"SELECT name, sel_expr,</b>
              <b>from_tbls, join_where, add_proc, delete_proc, param_order,</b>
              <b>expect_return FROM ldap_attr_mappings WHERE oc_map_id=?"</b>.

       <b>id_query &lt;SQL expression&gt;</b>
              The query that is used to map a DN to an entry in table
              <i>ldap_entries</i>; see "METAINFORMATION USED" for details.  The
              default is <b>"SELECT id,keyval,oc_map_id,dn FROM ldap_entries</b>
              <b>WHERE &lt;DN match expr&gt;"</b>, where <b>&lt;DN match expr&gt; </b>is constructed
              based on the knowledge about how to normalize DN values (e.g.
              <b>"dn=?" </b>if no means to uppercase strings are available;
              typically, <b>"&lt;upper_func&gt;(dn)=?" </b>is used); see <b>upper_func</b>,
              <b>upper_needs_cast</b>, <b>concat_pattern </b>and <b>strcast_func </b>in "HELPER
              CONFIGURATION" for details.

       <b>insentry_stmt &lt;SQL expression&gt;</b>
              The statement that is used to insert a new entry in table
              <i>ldap_entries</i>; see "METAINFORMATION USED" for details.  The
              default is <b>"INSERT INTO ldap_entries (dn, oc_map_id, parent,</b>
              <b>keyval) VALUES (?, ?, ?, ?)"</b>.

       <b>delentry_stmt &lt;SQL expression&gt;</b>
              The statement that is used to delete an existing entry from
              table <i>ldap_entries</i>; see "METAINFORMATION USED" for details.
              The default is <b>"DELETE FROM ldap_entries WHERE id=?"</b>.

       <b>delobjclasses_stmt &lt;SQL expression&gt;</b>
              The statement that is used to delete an existing entry's ID
              from table <i>ldap_objclasses</i>; see "METAINFORMATION USED" for
              details.  The default is <b>"DELETE FROM ldap_entry_objclasses</b>
              <b>WHERE entry_id=?"</b>.
</pre>
<h2><a id="HELPER_CONFIGURATION" href="#HELPER_CONFIGURATION"></a>HELPER CONFIGURATION  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       These statements are used to modify the default behavior of the
       backend according to issues of the dialect of the RDBMS.  The first
       options essentially refer to string and DN normalization when
       building filters.  LDAP normalization is more than upper- (or
       lower-)casing everything; however, as a reasonable trade-off, for
       case-sensitive RDBMSes the backend can be instructed to uppercase
       strings and DNs by providing the <b>upper_func </b>directive.  Some RDBMSes,
       to use functions on arbitrary data types, e.g. string constants,
       requires a cast, which is triggered by the <b>upper_needs_cast</b>
       directive.  If required, a string cast function can be provided as
       well, by using the <b>strcast_func </b>directive.  Finally, a custom string
       concatenation pattern may be required; it is provided by the
       <b>concat_pattern </b>directive.

       <b>upper_func &lt;SQL function name&gt;</b>
              Specifies the name of a function that converts a given value
              to uppercase.  This is used for case insensitive matching when
              the RDBMS is case sensitive.  It may differ from one SQL
              dialect to another (e.g. <b>UCASE</b>, <b>UPPER </b>or whatever; see
              samples).  By default, none is used, i.e. strings are not
              uppercased, so matches may be case sensitive.

       <b>upper_needs_cast { NO | yes }</b>
              Set this directive to <b>yes </b>if <b>upper_func </b>needs an explicit cast
              when applied to literal strings.  A cast in the form <b>CAST</b>
              <b>(&lt;arg&gt; AS VARCHAR(&lt;max DN length&gt;)) </b>is used, where <b>&lt;max DN</b>
              <b>length&gt; </b>is builtin in back-sql; see macro <b>BACKSQL_MAX_DN_LEN</b>
              (currently 255; note that slapd's builtin limit, in macro
              <b>SLAP_LDAPDN_MAXLEN</b>, is set to 8192).  This is <i>experimental</i> and
              may change in future releases.

       <b>strcast_func &lt;SQL function name&gt;</b>
              Specifies the name of a function that converts a given value
              to a string for appropriate ordering.  This is used in "SELECT
              DISTINCT" statements for strongly typed RDBMSes with little
              implicit casting (like PostgreSQL), when a literal string is
              specified.  This is <i>experimental</i> and may change in future
              releases.

       <b>concat_pattern &lt;pattern&gt;</b>
              This statement defines the <b>pattern </b>that is used to concatenate
              strings.  The <b>pattern </b>MUST contain two question marks, '?',
              that will be replaced by the two strings that must be
              concatenated.  The default value is <b>CONCAT(?,?)</b>; a form that
              is known to be highly portable (IBM db2, PostgreSQL) is <b>?||?</b>,
              but an explicit cast may be required when operating on literal
              strings: <b>CAST(?||? AS VARCHAR(&lt;length&gt;))</b>.  On some RDBMSes
              (IBM db2, MSSQL) the form <b>?+?  </b>is known to work as well.
              Carefully check the documentation of your RDBMS or stay with
              the examples for supported ones.  This is <i>experimental</i> and may
              change in future releases.

       <b>aliasing_keyword &lt;string&gt;</b>
              Define the aliasing keyword.  Some RDBMSes use the word "<i>AS</i>"
              (the default), others don't use any.

       <b>aliasing_quote &lt;string&gt;</b>
              Define the quoting char of the aliasing keyword.  Some RDBMSes
              don't require any (the default), others may require single or
              double quotes.

       <b>has_ldapinfo_dn_ru { NO | yes }</b>
              Explicitly inform the backend whether the dn_ru column (DN in
              reverse uppercased form) is present in table <i>ldap_entries</i>.
              Overrides automatic check (this is required, for instance, by
              PostgreSQL/unixODBC).  This is <i>experimental</i> and may change in
              future releases.

       <b>fail_if_no_mapping { NO | yes }</b>
              When set to <b>yes </b>it forces <i>attribute</i> write operations to fail
              if no appropriate mapping between LDAP attributes and SQL data
              is available.  The default behavior is to ignore those changes
              that cannot be mapped.  It has no impact on objectClass
              mapping, i.e. if the <i>structuralObjectClass</i> of an entry cannot
              be mapped to SQL by looking up its name in ldap_oc_mappings,
              an <i>add</i> operation will fail regardless of the
              <b>fail_if_no_mapping </b>switch; see section "METAINFORMATION USED"
              for details.  This is <i>experimental</i> and may change in future
              releases.

       <b>allow_orphans { NO | yes }</b>
              When set to <b>yes </b>orphaned entries (i.e. without the parent
              entry in the database) can be added.  This option should be
              used with care, possibly in conjunction with some special rule
              on the RDBMS side that dynamically creates the missing parent.

       <b>baseObject [ &lt;filename&gt; ]</b>
              Instructs the database to create and manage an in-memory
              baseObject entry instead of looking for one in the RDBMS.  If
              the (optional) <b>&lt;filename&gt; </b>argument is given, the entry is read
              from that file in <a href="ldif.5.html">LDIF(5)</a> format; otherwise, an entry with
              objectClass <b>extensibleObject </b>is created based on the contents
              of the RDN of the <i>baseObject</i>.  This is particularly useful
              when <i>ldap_entries</i> information is stored in a view rather than
              in a table, and <b>union </b>is not supported for views, so that the
              view can only specify one rule to compute the entry structure
              for one objectClass.  This topic is discussed further in
              section "METAINFORMATION USED".  This is <i>experimental</i> and may
              change in future releases.

       <b>create_needs_select { NO | yes }</b>
              Instructs the database whether or not entry creation in table
              <i>ldap_entries</i> needs a subsequent select to collect the
              automatically assigned ID, instead of being returned by a
              stored procedure.

       <b>fetch_attrs &lt;attrlist&gt;</b>
       <b>fetch_all_attrs { NO | yes }</b>
              The first statement allows one to provide a list of attributes
              that must always be fetched in addition to those requested by
              any specific operation, because they are required for the
              proper usage of the backend.  For instance, all attributes
              used in ACLs should be listed here.  The second statement is a
              shortcut to require all attributes to be always loaded.  Note
              that the dynamically generated attributes, e.g.
              <i>hasSubordinates</i>, <i>entryDN</i> and other implementation dependent
              attributes are <b>NOT </b>generated at this point, for consistency
              with the rest of slapd.  This may change in the future.

       <b>check_schema { YES | no }</b>
              Instructs the database to check schema adherence of entries
              after modifications, and structural objectClass chain when
              entries are built.  By default it is set to <b>yes</b>.

       <b>sqllayer &lt;name&gt; [...]</b>
              Loads the layer <b>&lt;name&gt; </b>onto a stack of helpers that are used
              to map DNs from LDAP to SQL representation and vice-versa.
              Subsequent args are passed to the layer configuration routine.
              This is <i>highly experimental</i> and should be used with extreme
              care.  The API of the layers is not frozen yet, so it is
              unpublished.

       <b>autocommit { NO | yes }</b>
              Activates autocommit; by default, it is off.
</pre>
<h2><a id="METAINFORMATION_USED" href="#METAINFORMATION_USED"></a>METAINFORMATION USED  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       Almost everything mentioned later is illustrated in examples located
       in the <b>servers/slapd/back-sql/rdbms_depend/ </b>directory in the OpenLDAP
       source tree, and contains scripts for generating sample database for
       Oracle, MS SQL Server, mySQL and more (including PostgreSQL and IBM
       db2).

       The first thing that one must arrange is what set of LDAP object
       classes can present your RDBMS information.

       The easiest way is to create an objectClass for each entity you had
       in ER-diagram when designing your relational schema.  Any relational
       schema, no matter how normalized it is, was designed after some model
       of your application's domain (for instance, accounts, services etc.
       in ISP), and is used in terms of its entities, not just tables of
       normalized schema.  It means that for every attribute of every such
       instance there is an effective SQL query that loads its values.

       Also you might want your object classes to conform to some of the
       standard schemas like inetOrgPerson etc.

       Nevertheless, when you think it out, we must define a way to
       translate LDAP operation requests to (a series of) SQL queries.  Let
       us deal with the SEARCH operation.

       Example: Let's suppose that we store information about persons
       working in our organization in two tables:

         PERSONS              PHONES
         ----------           -------------
         id integer           id integer
         first_name varchar   pers_id integer references persons(id)
         last_name varchar    phone
         middle_name varchar
         ...

       (PHONES contains telephone numbers associated with persons).  A
       person can have several numbers, then PHONES contains several records
       with corresponding pers_id, or no numbers (and no records in PHONES
       with such pers_id).  An LDAP objectclass to present such information
       could look like this:

         person
         -------
         MUST cn
         MAY telephoneNumber $ firstName $ lastName
         ...

       To fetch all values for cn attribute given person ID, we construct
       the query:

         SELECT CONCAT(persons.first_name,' ',persons.last_name)
             AS cn FROM persons WHERE persons.id=?

       for telephoneNumber we can use:

         SELECT phones.phone AS telephoneNumber FROM persons,phones
             WHERE persons.id=phones.pers_id AND persons.id=?

       If we wanted to service LDAP requests with filters like
       (telephoneNumber=123*), we would construct something like:

         SELECT ... FROM persons,phones
             WHERE persons.id=phones.pers_id
                 AND persons.id=?
                 AND phones.phone like '%1%2%3%'

       (note how the telephoneNumber match is expanded in multiple wildcards
       to account for interspersed ininfluential chars like spaces, dashes
       and so; this occurs by design because telephoneNumber is defined
       after a specially recognized syntax).  So, if we had information
       about what tables contain values for each attribute, how to join
       these tables and arrange these values, we could try to automatically
       generate such statements, and translate search filters to SQL WHERE
       clauses.

       To store such information, we add three more tables to our schema and
       fill it with data (see samples):

         ldap_oc_mappings (some columns are not listed for clarity)
         ---------------
         id=1
         name="person"
         keytbl="persons"
         keycol="id"

       This table defines a mapping between objectclass (its name held in
       the "name" column), and a table that holds the primary key for
       corresponding entities.  For instance, in our example, the person
       entity, which we are trying to present as "person" objectclass,
       resides in two tables (persons and phones), and is identified by the
       persons.id column (that we will call the primary key for this
       entity).  Keytbl and keycol thus contain "persons" (name of the
       table), and "id" (name of the column).

         ldap_attr_mappings (some columns are not listed for clarity)
         -----------
         id=1
         oc_map_id=1
         name="cn"
         sel_expr="CONCAT(persons.first_name,' ',persons.last_name)"
         from_tbls="persons"
         join_where=NULL
         ************
         id=&lt;n&gt;
         oc_map_id=1
         name="telephoneNumber"
         sel_expr="phones.phone"
         from_tbls="persons,phones"
         join_where="phones.pers_id=persons.id"

       This table defines mappings between LDAP attributes and SQL queries
       that load their values.  Note that, unlike LDAP schema, these are not
       <b>attribute types </b>- the attribute "cn" for "person" objectclass can
       have its values in different tables than "cn" for some other
       objectclass, so attribute mappings depend on objectclass mappings
       (unlike attribute types in LDAP schema, which are indifferent to
       objectclasses).  Thus, we have oc_map_id column with link to
       oc_mappings table.

       Now we cut the SQL query that loads values for a given attribute into
       3 parts.  First goes into sel_expr column - this is the expression we
       had between SELECT and FROM keywords, which defines WHAT to load.
       Next is table list - text between FROM and WHERE keywords.  It may
       contain aliases for convenience (see examples).  The last is part of
       the where clause, which (if it exists at all) expresses the condition
       for joining the table containing values with the table containing the
       primary key (foreign key equality and such).  If values are in the
       same table as the primary key, then this column is left NULL (as for
       cn attribute above).

       Having this information in parts, we are able to not only construct
       queries that load attribute values by id of entry (for this we could
       store SQL query as a whole), but to construct queries that load id's
       of objects that correspond to a given search filter (or at least part
       of it).  See below for examples.

         ldap_entries
         ------------
         id=1
         dn=&lt;dn you choose&gt;
         oc_map_id=...
         parent=&lt;parent record id&gt;
         keyval=&lt;value of primary key&gt;

       This table defines mappings between DNs of entries in your LDAP tree,
       and values of primary keys for corresponding relational data.  It has
       recursive structure (parent column references id column of the same
       table), which allows you to add any tree structure(s) to your flat
       relational data.  Having id of objectclass mapping, we can determine
       table and column for primary key, and keyval stores value of it, thus
       defining the exact tuple corresponding to the LDAP entry with this
       DN.

       Note that such design (see exact SQL table creation query) implies
       one important constraint - the key must be an integer.  But all that
       I know about well-designed schemas makes me think that it's not very
       narrow ;) If anyone needs support for different types for keys - he
       may want to write a patch, and submit it to OpenLDAP ITS, then I'll
       include it.

       Also, several users complained that they don't really need very
       structured trees, and they don't want to update one more table every
       time they add or delete an instance in the relational schema.  Those
       people can use a view instead of a real table for ldap_entries,
       something like this (by Robin Elfrink):

         CREATE VIEW ldap_entries (id, dn, oc_map_id, parent, keyval)
             AS
                 SELECT 0, UPPER('o=MyCompany,c=NL'),
                     3, 0, 'baseObject' FROM unixusers WHERE userid='root'
             UNION
                 SELECT (1000000000+userid),
                     UPPER(CONCAT(CONCAT('cn=',gecos),',o=MyCompany,c=NL')),
                     1, 0, userid FROM unixusers
             UNION
                 SELECT (2000000000+groupnummer),
                     UPPER(CONCAT(CONCAT('cn=',groupnaam),',o=MyCompany,c=NL')),
                     2, 0, groupnummer FROM groups;

       If your RDBMS does not support <b>unions </b>in views, only one objectClass
       can be mapped in <b>ldap_entries</b>, and the baseObject cannot be created;
       in this case, see the <b>baseObject </b>directive for a possible workaround.
</pre>
<h2><a id="TYPICAL_SQL_BACKEND_OPERATION" href="#TYPICAL_SQL_BACKEND_OPERATION"></a>TYPICAL SQL BACKEND OPERATION  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       Having meta-information loaded, the SQL backend uses these tables to
       determine a set of primary keys of candidates (depending on search
       scope and filter).  It tries to do it for each objectclass registered
       in ldap_objclasses.

       Example: for our query with filter (telephoneNumber=123*) we would
       get the following query generated (which loads candidate IDs)

         SELECT ldap_entries.id,persons.id, 'person' AS objectClass,
                ldap_entries.dn AS dn
           FROM ldap_entries,persons,phones
          WHERE persons.id=ldap_entries.keyval
            AND ldap_entries.objclass=?
            AND ldap_entries.parent=?
            AND phones.pers_id=persons.id
            AND (phones.phone LIKE '%1%2%3%')

       (for ONELEVEL search) or "... AND dn=?" (for BASE search) or "... AND
       dn LIKE '%?'" (for SUBTREE)

       Then, for each candidate, we load the requested attributes using per-
       attribute queries like

         SELECT phones.phone AS telephoneNumber
           FROM persons,phones
          WHERE persons.id=? AND phones.pers_id=persons.id

       Then, we use test_filter() from the frontend API to test the entry
       for a full LDAP search filter match (since we cannot effectively make
       sense of SYNTAX of corresponding LDAP schema attribute, we translate
       the filter into the most relaxed SQL condition to filter candidates),
       and send it to the user.

       ADD, DELETE, MODIFY and MODRDN operations are also performed on per-
       attribute meta-information (add_proc etc.).  In those fields one can
       specify an SQL statement or stored procedure call which can add, or
       delete given values of a given attribute, using the given entry
       keyval (see examples -- mostly PostgreSQL, ORACLE and MSSQL - since
       as of this writing there are no stored procs in MySQL).

       We just add more columns to ldap_oc_mappings and ldap_attr_mappings,
       holding statements to execute (like create_proc, add_proc, del_proc
       etc.), and flags governing the order of parameters passed to those
       statements.  Please see samples to find out what are the parameters
       passed, and other information on this matter - they are self-
       explanatory for those familiar with the concepts expressed above.
</pre>
<h2><a id="COMMON_TECHNIQUES" href="#COMMON_TECHNIQUES"></a>COMMON TECHNIQUES  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       First of all, let's recall that among other major differences to the
       complete LDAP data model, the above illustrated concept does not
       directly support such features as multiple objectclasses per entry,
       and referrals.  Fortunately, they are easy to adopt in this scheme.
       The SQL backend requires that one more table is added to the schema:
       ldap_entry_objectclasses(entry_id,oc_name).

       That table contains any number of objectclass names that
       corresponding entries will possess, in addition to that mentioned in
       mapping.  The SQL backend automatically adds attribute mapping for
       the "objectclass" attribute to each objectclass mapping that loads
       values from this table.  So, you may, for instance, have a mapping
       for inetOrgPerson, and use it for queries for "person" objectclass...

       Referrals used to be implemented in a loose manner by adding an extra
       table that allowed any entry to host a "ref" attribute, along with a
       "referral" extra objectClass in table ldap_entry_objclasses.  In the
       current implementation, referrals are treated like any other user-
       defined schema, since "referral" is a structural objectclass.  The
       suggested practice is to define a "referral" entry in
       ldap_oc_mappings, holding a naming attribute, e.g. "ou" or "cn", a
       "ref" attribute, containing the url; in case multiple referrals per
       entry are needed, a separate table for urls can be created, where
       urls are mapped to the respective entries.  The use of the naming
       attribute usually requires to add an "extensibleObject" value to
       ldap_entry_objclasses.
</pre>
<h2><a id="CAVEATS" href="#CAVEATS"></a>CAVEATS  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       As previously stated, this backend should not be considered a
       replacement of other data storage backends, but rather a gateway to
       existing RDBMS storages that need to be published in LDAP form.

       The <b>hasSubordintes </b>operational attribute is honored by back-sql in
       search results and in compare operations; it is partially honored
       also in filtering.  Owing to design limitations, a (brain-dead?)
       filter of the form <b>(!(hasSubordinates=TRUE)) </b>will give no results
       instead of returning all the leaf entries, because it actually
       expands into <b>... AND NOT (1=1)</b>.  If you need to find all the leaf
       entries, please use <b>(hasSubordinates=FALSE) </b>instead.

       A directoryString value of the form "__First___Last_" (where
       underscores mean spaces, ASCII 0x20 char) corresponds to its
       prettified counterpart "First_Last"; this is not currently honored by
       back-sql if non-prettified data is written via RDBMS; when non-
       prettified data is written through back-sql, the prettified values
       are actually used instead.
</pre>
<h2><a id="BUGS" href="#BUGS"></a>BUGS  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       When the <b>ldap_entry_objclasses </b>table is empty, filters on the
       <b>objectClass </b>attribute erroneously result in no candidates.  A
       workaround consists in adding at least one row to that table, no
       matter if valid or not.
</pre>
<h2><a id="PROXY_CACHE_OVERLAY" href="#PROXY_CACHE_OVERLAY"></a>PROXY CACHE OVERLAY  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       The proxy cache overlay allows caching of LDAP search requests
       (queries) in a local database.  See <a href="slapo-pcache.5.html">slapo-pcache(5)</a> for details.
</pre>
<h2><a id="EXAMPLES" href="#EXAMPLES"></a>EXAMPLES  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       There are example SQL modules in the slapd/back-sql/rdbms_depend/
       directory in the OpenLDAP source tree.
</pre>
<h2><a id="ACCESS_CONTROL" href="#ACCESS_CONTROL"></a>ACCESS CONTROL  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       The <b>sql </b>backend honors access control semantics as indicated in
       <a href="slapd.access.5.html">slapd.access(5)</a> (including the <b>disclose </b>access privilege when enabled
       at compile time).
</pre>
<h2><a id="FILES" href="#FILES"></a>FILES  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       ETCDIR/slapd.conf
              default slapd configuration file
</pre>
<h2><a id="SEE_ALSO" href="#SEE_ALSO"></a>SEE ALSO  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       <a href="slapd.conf.5.html">slapd.conf(5)</a>, <a href="../man8/slapd.8.html">slapd(8)</a>.
</pre>
<h2><a id="COLOPHON" href="#COLOPHON"></a>COLOPHON  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       This page is part of the <i>OpenLDAP</i> (an open source implementation of
       the Lightweight Directory Access Protocol) project.  Information
       about the project can be found at ⟨<a href="http://www.openldap.org/">http://www.openldap.org/</a>⟩.  If you
       have a bug report for this manual page, see 
       ⟨<a href="http://www.openldap.org/its/">http://www.openldap.org/its/</a>⟩.  This page was obtained from the
       project's upstream Git repository 
       ⟨git://git.openldap.org/openldap.git⟩ on 2017-07-05.  If you discover
       any rendering problems in this HTML version of the page, or you
       believe there is a better or more up-to-date source for the page, or
       you have corrections or improvements to the information in this
       COLOPHON (which is <i>not</i> part of the original manual page), send a mail
       to man-pages@man7.org

<span class="footline">OpenLDAP LDVERSION               RELEASEDATE                    SLAPD-SQL(5)</span>
</pre>

<hr class="end-man-text" />
<p>Pages that refer to this page: 
    <a href="slapd.backends.5.html">slapd.backends(5)</a>,&nbsp; 
    <a href="slapo-pcache.5.html">slapo-pcache(5)</a>
</p>
<hr/>

 
<hr class="start-footer" />

<div class="footer"> 

<table class="colophon-table">
    <tr>
    <td class="pub-info">
        <p>
            HTML rendering created 2017-07-13
            by <a href="http://man7.org/mtk/index.html">Michael Kerrisk</a>, 
            author of 
            <a href="http://man7.org/tlpi/"><em>The Linux Programming Interface</em></a>, 
            maintainer of the 
            <a href="https://www.kernel.org/doc/man-pages/">Linux <em>man-pages</em> project</a>.
        </p>
        <p>
            For details of in-depth
            <strong>Linux/UNIX system programming training courses</strong>
            that I teach, look <a href="http://man7.org/training/">here</a>.
        </p>
        <p>
            Hosting by <a href="http://www.jambit.com/index_en.html">jambit GmbH</a>.
        </p>
        <p>
            <a href="http://validator.w3.org/check?uri=referer">
            <img src="http://www.w3.org/Icons/valid-xhtml11"
                alt="Valid XHTML 1.1" height="31" width="88" />
            </a>
        </p>
    </td>
    <td class="colophon-divider">
    </td>
    <td class="tlpi-cover">
        <a href="http://man7.org/tlpi/"><img src="../../../tlpi/cover/TLPI-front-cover-vsmall.png" alt="Cover of TLPI" /></a>
    </td>
    </tr>
</table>

</div>

<hr class="end-footer" />



<!--BEGIN-SITETRACKING-->
<!-- SITETRACKING.man7.org_linux_man-pages -->

<!-- Start of StatCounter Code (xhtml) -->

<script type="text/javascript">
//<![CDATA[
var sc_project=7422636; 
var sc_invisible=1; 
var sc_security="9b6714ff"; 
//]]>
</script>
<script type="text/javascript"
src="../../../../www.statcounter.com/counter/counter_xhtml.js"></script>
<noscript><div class="statcounter"><a title="website
statistics" href="http://statcounter.com/"
class="statcounter"><img class="statcounter"
src="http://c.statcounter.com/7422636/0/9b6714ff/1/"
alt="website statistics" /></a></div></noscript>

<!-- End of StatCounter Code -->


<!-- Start of Google Analytics Code -->

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-9830363-8']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<!-- End of Google Analytics Code -->

<!--END-SITETRACKING-->

</body>
</html>
