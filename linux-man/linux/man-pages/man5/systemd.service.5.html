
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
        "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
    <link rel="stylesheet" type="text/css" href="../../../style.css" title="style" />
    <link rel="stylesheet" type="text/css" href="../style.css" title="style" />
    <meta http-equiv="content-type" content="text/html;charset=utf-8" />

    <title>systemd.service(5) - Linux manual page</title>
</head>

<body>

<div class="page-top"><a id="top_of_page"></a></div>
<!--%%%TOP_BAR%%%-->
    <div class="nav-bar">
        <table class="nav-table">
            <tr>
                <td class="nav-cell">
                    <p class="nav-text">
                        <a href="http://man7.org/index.html">man7.org</a> &gt; Linux &gt; <a href="../index.html">man-pages</a>
                    </p>
                </td>
                <td class="training-cell">
                    <p class="training-text"><a class="training-link" href="http://man7.org/training/">Linux/UNIX system programming training</a></p>
                </td>
            </tr>
        </table>
    </div>

<hr class="nav-end" />

<!--%%%PAGE_START%%%-->


<table class="sec-table">
<tr>
    <td>
        <p class="section-dir">
<a href="#NAME">NAME</a> | <a href="#SYNOPSIS">SYNOPSIS</a> | <a href="#DESCRIPTION">DESCRIPTION</a> | <a href="#AUTOMATIC_DEPENDENCIES">AUTOMATIC&nbsp;DEPENDENCIES</a> | <a href="#OPTIONS">OPTIONS</a> | <a href="#COMMAND_LINES">COMMAND&nbsp;LINES</a> | <a href="#EXAMPLES">EXAMPLES</a> | <a href="#SEE_ALSO">SEE&nbsp;ALSO</a> | <a href="#NOTES">NOTES</a> | <a href="#COLOPHON">COLOPHON</a>
        </p>
    </td>
    <td class="search-box">
        <div class="man-search-box">

            <form method="get" action="http://www.google.com/search">
                <fieldset class="man-search">
                    <input type="text" name="q" size="10" maxlength="255" value="" />
                    <input type="hidden" name="sitesearch" value="man7.org/linux/man-pages" />
                    <input type="submit" name="sa" value="Search online pages" />
                </fieldset>
            </form>

        </div>
    </td>
    <td> </td>
</tr>
</table>

<pre>
<span class="headline">SYSTEMD.SERVICE(5)             systemd.service            SYSTEMD.SERVICE(5)</span>
</pre>
<h2><a id="NAME" href="#NAME"></a>NAME  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       systemd.service - Service unit configuration
</pre>
<h2><a id="SYNOPSIS" href="#SYNOPSIS"></a>SYNOPSIS  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       <i>service</i>.service
</pre>
<h2><a id="DESCRIPTION" href="#DESCRIPTION"></a>DESCRIPTION  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       A unit configuration file whose name ends in .service encodes
       information about a process controlled and supervised by systemd.

       This man page lists the configuration options specific to this unit
       type. See <a href="systemd.unit.5.html">systemd.unit(5)</a> for the common options of all unit
       configuration files. The common configuration items are configured in
       the generic "[Unit]" and "[Install]" sections. The service specific
       configuration options are configured in the "[Service]" section.

       Additional options are listed in <a href="systemd.exec.5.html">systemd.exec(5)</a>, which define the
       execution environment the commands are executed in, and in
       <a href="systemd.kill.5.html">systemd.kill(5)</a>, which define the way the processes of the service
       are terminated, and in <a href="systemd.resource-control.5.html">systemd.resource-control(5)</a>, which configure
       resource control settings for the processes of the service.

       If a service is requested under a certain name but no unit
       configuration file is found, systemd looks for a SysV init script by
       the same name (with the .service suffix removed) and dynamically
       creates a service unit from that script. This is useful for
       compatibility with SysV. Note that this compatibility is quite
       comprehensive but not 100%. For details about the incompatibilities,
       see the <b>Incompatibilities with SysV</b><b></b>[1] document.
</pre>
<h2><a id="AUTOMATIC_DEPENDENCIES" href="#AUTOMATIC_DEPENDENCIES"></a>AUTOMATIC DEPENDENCIES  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       Services with <i>Type=dbus</i> set automatically acquire dependencies of
       type <i>Requires=</i> and <i>After=</i> on dbus.socket.

       Socket activated services are automatically ordered after their
       activating .socket units via an automatic <i>After=</i> dependency. Services
       also pull in all .socket units listed in <i>Sockets=</i> via automatic
       <i>Wants=</i> and <i>After=</i> dependencies.

       Unless <i>DefaultDependencies=</i> in the "[Unit]" is set to <b>false</b>, service
       units will implicitly have dependencies of type <i>Requires=</i> and <i>After=</i>
       on sysinit.target, a dependency of type <i>After=</i> on basic.target as
       well as dependencies of type <i>Conflicts=</i> and <i>Before=</i> on
       shutdown.target. These ensure that normal service units pull in basic
       system initialization, and are terminated cleanly prior to system
       shutdown. Only services involved with early boot or late system
       shutdown should disable this option.

       Instanced service units (i.e. service units with an "@" in their
       name) are assigned by default a per-template slice unit (see
       <a href="systemd.slice.5.html">systemd.slice(5)</a>), named after the template unit, containing all
       instances of the specific template. This slice is normally stopped at
       shutdown, together with all template instances. If that is not
       desired, set <i>DefaultDependencies=no</i> in the template unit, and either
       define your own per-template slice unit file that also sets
       <i>DefaultDependencies=no</i>, or set <i>Slice=system.slice</i> (or another
       suitable slice) in the template unit. Also see
       <a href="systemd.resource-control.5.html">systemd.resource-control(5)</a>.

       Additional implicit dependencies may be added as result of execution
       and resource control parameters as documented in <a href="systemd.exec.5.html">systemd.exec(5)</a> and
       <a href="systemd.resource-control.5.html">systemd.resource-control(5)</a>.
</pre>
<h2><a id="OPTIONS" href="#OPTIONS"></a>OPTIONS  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       Service files must include a "[Service]" section, which carries
       information about the service and the process it supervises. A number
       of options that may be used in this section are shared with other
       unit types. These options are documented in <a href="systemd.exec.5.html">systemd.exec(5)</a>,
       <a href="systemd.kill.5.html">systemd.kill(5)</a> and <a href="systemd.resource-control.5.html">systemd.resource-control(5)</a>. The options specific
       to the "[Service]" section of service units are the following:

       <i>Type=</i>
           Configures the process start-up type for this service unit. One
           of <b>simple</b>, <b>forking</b>, <b>oneshot</b>, <b>dbus</b>, <b>notify </b>or <b>idle</b>.

           If set to <b>simple </b>(the default if neither <i>Type=</i> nor <i>BusName=</i>, but
           <i>ExecStart=</i> are specified), it is expected that the process
           configured with <i>ExecStart=</i> is the main process of the service. In
           this mode, if the process offers functionality to other processes
           on the system, its communication channels should be installed
           before the daemon is started up (e.g. sockets set up by systemd,
           via socket activation), as systemd will immediately proceed
           starting follow-up units.

           If set to <b>forking</b>, it is expected that the process configured
           with <i>ExecStart=</i> will call <b>fork() </b>as part of its start-up. The
           parent process is expected to exit when start-up is complete and
           all communication channels are set up. The child continues to run
           as the main daemon process. This is the behavior of traditional
           UNIX daemons. If this setting is used, it is recommended to also
           use the <i>PIDFile=</i> option, so that systemd can identify the main
           process of the daemon. systemd will proceed with starting
           follow-up units as soon as the parent process exits.

           Behavior of <b>oneshot </b>is similar to <b>simple</b>; however, it is expected
           that the process has to exit before systemd starts follow-up
           units.  <i>RemainAfterExit=</i> is particularly useful for this type of
           service. This is the implied default if neither <i>Type=</i> nor
           <i>ExecStart=</i> are specified.

           Behavior of <b>dbus </b>is similar to <b>simple</b>; however, it is expected
           that the daemon acquires a name on the D-Bus bus, as configured
           by <i>BusName=</i>. systemd will proceed with starting follow-up units
           after the D-Bus bus name has been acquired. Service units with
           this option configured implicitly gain dependencies on the
           dbus.socket unit. This type is the default if <i>BusName=</i> is
           specified.

           Behavior of <b>notify </b>is similar to <b>simple</b>; however, it is expected
           that the daemon sends a notification message via <a href="../man3/sd_notify.3.html">sd_notify(3)</a> or
           an equivalent call when it has finished starting up. systemd will
           proceed with starting follow-up units after this notification
           message has been sent. If this option is used, <i>NotifyAccess=</i> (see
           below) should be set to open access to the notification socket
           provided by systemd. If <i>NotifyAccess=</i> is missing or set to <b>none</b>,
           it will be forcibly set to <b>main</b>. Note that currently <i>Type=</i><b>notify</b>
           will not work if used in combination with <i>PrivateNetwork=</i><b>yes</b>.

           Behavior of <b>idle </b>is very similar to <b>simple</b>; however, actual
           execution of the service binary is delayed until all active jobs
           are dispatched. This may be used to avoid interleaving of output
           of shell services with the status output on the console. Note
           that this type is useful only to improve console output, it is
           not useful as a general unit ordering tool, and the effect of
           this service type is subject to a 5s time-out, after which the
           service binary is invoked anyway.

       <i>RemainAfterExit=</i>
           Takes a boolean value that specifies whether the service shall be
           considered active even when all its processes exited. Defaults to
           <b>no</b>.

       <i>GuessMainPID=</i>
           Takes a boolean value that specifies whether systemd should try
           to guess the main PID of a service if it cannot be determined
           reliably. This option is ignored unless <b>Type=forking </b>is set and
           <b>PIDFile= </b>is unset because for the other types or with an
           explicitly configured PID file, the main PID is always known. The
           guessing algorithm might come to incorrect conclusions if a
           daemon consists of more than one process. If the main PID cannot
           be determined, failure detection and automatic restarting of a
           service will not work reliably. Defaults to <b>yes</b>.

       <i>PIDFile=</i>
           Takes an absolute file name pointing to the PID file of this
           daemon. Use of this option is recommended for services where
           <i>Type=</i> is set to <b>forking</b>. systemd will read the PID of the main
           process of the daemon after start-up of the service. systemd will
           not write to the file configured here, although it will remove
           the file after the service has shut down if it still exists.

       <i>BusName=</i>
           Takes a D-Bus bus name that this service is reachable as. This
           option is mandatory for services where <i>Type=</i> is set to <b>dbus</b>.

       <i>ExecStart=</i>
           Commands with their arguments that are executed when this service
           is started. The value is split into zero or more command lines
           according to the rules described below (see section "Command
           Lines" below).

           Unless <i>Type=</i> is <b>oneshot</b>, exactly one command must be given. When
           <i>Type=oneshot</i> is used, zero or more commands may be specified.
           Commands may be specified by providing multiple command lines in
           the same directive, or alternatively, this directive may be
           specified more than once with the same effect. If the empty
           string is assigned to this option, the list of commands to start
           is reset, prior assignments of this option will have no effect.
           If no <i>ExecStart=</i> is specified, then the service must have
           <i>RemainAfterExit=yes</i> and at least one <i>ExecStop=</i> line set.
           (Services lacking both <i>ExecStart=</i> and <i>ExecStop=</i> are not valid.)

           For each of the specified commands, the first argument must be an
           absolute path to an executable. Optionally, if this file name is
           prefixed with "@", the second token will be passed as "argv[0]"
           to the executed process, followed by the further arguments
           specified. If the absolute filename is prefixed with "-", an exit
           code of the command normally considered a failure (i.e. non-zero
           exit status or abnormal exit due to signal) is ignored and
           considered success. If the absolute path is prefixed with "+"
           then it is executed with full privileges.  "@", "-", and "+" may
           be used together and they can appear in any order.

           If more than one command is specified, the commands are invoked
           sequentially in the order they appear in the unit file. If one of
           the commands fails (and is not prefixed with "-"), other lines
           are not executed, and the unit is considered failed.

           Unless <i>Type=forking</i> is set, the process started via this command
           line will be considered the main process of the daemon.

       <i>ExecStartPre=</i>, <i>ExecStartPost=</i>
           Additional commands that are executed before or after the command
           in <i>ExecStart=</i>, respectively. Syntax is the same as for
           <i>ExecStart=</i>, except that multiple command lines are allowed and
           the commands are executed one after the other, serially.

           If any of those commands (not prefixed with "-") fail, the rest
           are not executed and the unit is considered failed.

           <i>ExecStart=</i> commands are only run after all <i>ExecStartPre=</i> commands
           that were not prefixed with a "-" exit successfully.

           <i>ExecStartPost=</i> commands are only run after the commands specified
           in <i>ExecStart=</i> have been invoked successfully, as determined by
           <i>Type=</i> (i.e. the process has been started for <i>Type=simple</i> or
           <i>Type=idle</i>, the last <i>ExecStart=</i> process exited successfully for
           <i>Type=oneshot</i>, the initial process exited successfully for
           <i>Type=forking</i>, "READY=1" is sent for <i>Type=notify</i>, or the <i>BusName=</i>
           has been taken for <i>Type=dbus</i>).

           Note that <i>ExecStartPre=</i> may not be used to start long-running
           processes. All processes forked off by processes invoked via
           <i>ExecStartPre=</i> will be killed before the next service process is
           run.

           Note that if any of the commands specified in <i>ExecStartPre=</i>,
           <i>ExecStart=</i>, or <i>ExecStartPost=</i> fail (and are not prefixed with
           "-", see above) or time out before the service is fully up,
           execution continues with commands specified in <i>ExecStopPost=</i>, the
           commands in <i>ExecStop=</i> are skipped.

       <i>ExecReload=</i>
           Commands to execute to trigger a configuration reload in the
           service. This argument takes multiple command lines, following
           the same scheme as described for <i>ExecStart=</i> above. Use of this
           setting is optional. Specifier and environment variable
           substitution is supported here following the same scheme as for
           <i>ExecStart=</i>.

           One additional, special environment variable is set: if known,
           <i>$MAINPID</i> is set to the main process of the daemon, and may be
           used for command lines like the following:

               /bin/kill -HUP $MAINPID

           Note however that reloading a daemon by sending a signal (as with
           the example line above) is usually not a good choice, because
           this is an asynchronous operation and hence not suitable to order
           reloads of multiple services against each other. It is strongly
           recommended to set <i>ExecReload=</i> to a command that not only
           triggers a configuration reload of the daemon, but also
           synchronously waits for it to complete.

       <i>ExecStop=</i>
           Commands to execute to stop the service started via <i>ExecStart=</i>.
           This argument takes multiple command lines, following the same
           scheme as described for <i>ExecStart=</i> above. Use of this setting is
           optional. After the commands configured in this option are run,
           it is implied that the service is stopped, and any processes
           remaining for it are terminated according to the <i>KillMode=</i>
           setting (see <a href="systemd.kill.5.html">systemd.kill(5)</a>). If this option is not specified,
           the process is terminated by sending the signal specified in
           <i>KillSignal=</i> when service stop is requested. Specifier and
           environment variable substitution is supported (including
           <i>$MAINPID</i>, see above).

           Note that it is usually not sufficient to specify a command for
           this setting that only asks the service to terminate (for
           example, by queuing some form of termination signal for it), but
           does not wait for it to do so. Since the remaining processes of
           the services are killed according to <i>KillMode=</i> and <i>KillSignal=</i> as
           described above immediately after the command exited, this may
           not result in a clean stop. The specified command should hence be
           a synchronous operation, not an asynchronous one.

           Note that the commands specified in <i>ExecStop=</i> are only executed
           when the service started successfully first. They are not invoked
           if the service was never started at all, or in case its start-up
           failed, for example because any of the commands specified in
           <i>ExecStart=</i>, <i>ExecStartPre=</i> or <i>ExecStartPost=</i> failed (and weren't
           prefixed with "-", see above) or timed out. Use <i>ExecStopPost=</i> to
           invoke commands when a service failed to start up correctly and
           is shut down again.

           It is recommended to use this setting for commands that
           communicate with the service requesting clean termination. When
           the commands specified with this option are executed it should be
           assumed that the service is still fully up and is able to react
           correctly to all commands. For post-mortem clean-up steps use
           <i>ExecStopPost=</i> instead.

       <i>ExecStopPost=</i>
           Additional commands that are executed after the service is
           stopped. This includes cases where the commands configured in
           <i>ExecStop=</i> were used, where the service does not have any
           <i>ExecStop=</i> defined, or where the service exited unexpectedly. This
           argument takes multiple command lines, following the same scheme
           as described for <i>ExecStart=</i>. Use of these settings is optional.
           Specifier and environment variable substitution is supported.
           Note that – unlike <i>ExecStop=</i> – commands specified with this
           setting are invoked when a service failed to start up correctly
           and is shut down again.

           It is recommended to use this setting for clean-up operations
           that shall be executed even when the service failed to start up
           correctly. Commands configured with this setting need to be able
           to operate even if the service failed starting up half-way and
           left incompletely initialized data around. As the service's
           processes have been terminated already when the commands
           specified with this setting are executed they should not attempt
           to communicate with them.

           Note that all commands that are configured with this setting are
           invoked with the result code of the service, as well as the main
           process' exit code and status, set in the <i>$SERVICE_RESULT</i>,
           <i>$EXIT_CODE</i> and <i>$EXIT_STATUS</i> environment variables, see
           <a href="systemd.exec.5.html">systemd.exec(5)</a> for details.

       <i>RestartSec=</i>
           Configures the time to sleep before restarting a service (as
           configured with <i>Restart=</i>). Takes a unit-less value in seconds, or
           a time span value such as "5min 20s". Defaults to 100ms.

       <i>TimeoutStartSec=</i>
           Configures the time to wait for start-up. If a daemon service
           does not signal start-up completion within the configured time,
           the service will be considered failed and will be shut down
           again. Takes a unit-less value in seconds, or a time span value
           such as "5min 20s". Pass "infinity" to disable the timeout logic.
           Defaults to <i>DefaultTimeoutStartSec=</i> from the manager
           configuration file, except when <i>Type=oneshot</i> is used, in which
           case the timeout is disabled by default (see
           <a href="systemd-system.conf.5.html">systemd-system.conf(5)</a>).

       <i>TimeoutStopSec=</i>
           Configures the time to wait for stop. If a service is asked to
           stop, but does not terminate in the specified time, it will be
           terminated forcibly via <b>SIGTERM</b>, and after another timeout of
           equal duration with <b>SIGKILL </b>(see <i>KillMode=</i> in <a href="systemd.kill.5.html">systemd.kill(5)</a>).
           Takes a unit-less value in seconds, or a time span value such as
           "5min 20s". Pass "infinity" to disable the timeout logic.
           Defaults to <i>DefaultTimeoutStopSec=</i> from the manager configuration
           file (see <a href="systemd-system.conf.5.html">systemd-system.conf(5)</a>).

       <i>TimeoutSec=</i>
           A shorthand for configuring both <i>TimeoutStartSec=</i> and
           <i>TimeoutStopSec=</i> to the specified value.

       <i>RuntimeMaxSec=</i>
           Configures a maximum time for the service to run. If this is used
           and the service has been active for longer than the specified
           time it is terminated and put into a failure state. Note that
           this setting does not have any effect on <i>Type=oneshot</i> services,
           as they terminate immediately after activation completed. Pass
           "infinity" (the default) to configure no runtime limit.

       <i>WatchdogSec=</i>
           Configures the watchdog timeout for a service. The watchdog is
           activated when the start-up is completed. The service must call
           <a href="../man3/sd_notify.3.html">sd_notify(3)</a> regularly with "WATCHDOG=1" (i.e. the "keep-alive
           ping"). If the time between two such calls is larger than the
           configured time, then the service is placed in a failed state and
           it will be terminated with <b>SIGABRT</b>. By setting <i>Restart=</i> to
           <b>on-failure</b>, <b>on-watchdog</b>, <b>on-abnormal </b>or <b>always</b>, the service will
           be automatically restarted. The time configured here will be
           passed to the executed service process in the <i>WATCHDOG_USEC=</i>
           environment variable. This allows daemons to automatically enable
           the keep-alive pinging logic if watchdog support is enabled for
           the service. If this option is used, <i>NotifyAccess=</i> (see below)
           should be set to open access to the notification socket provided
           by systemd. If <i>NotifyAccess=</i> is not set, it will be implicitly
           set to <b>main</b>. Defaults to 0, which disables this feature. The
           service can check whether the service manager expects watchdog
           keep-alive notifications. See <a href="../man3/sd_watchdog_enabled.3.html">sd_watchdog_enabled(3)</a> for details.
           <a href="../man3/sd_event_set_watchdog.3.html">sd_event_set_watchdog(3)</a> may be used to enable automatic watchdog
           notification support.

       <i>Restart=</i>
           Configures whether the service shall be restarted when the
           service process exits, is killed, or a timeout is reached. The
           service process may be the main service process, but it may also
           be one of the processes specified with <i>ExecStartPre=</i>,
           <i>ExecStartPost=</i>, <i>ExecStop=</i>, <i>ExecStopPost=</i>, or <i>ExecReload=</i>. When
           the death of the process is a result of systemd operation (e.g.
           service stop or restart), the service will not be restarted.
           Timeouts include missing the watchdog "keep-alive ping" deadline
           and a service start, reload, and stop operation timeouts.

           Takes one of <b>no</b>, <b>on-success</b>, <b>on-failure</b>, <b>on-abnormal</b>,
           <b>on-watchdog</b>, <b>on-abort</b>, or <b>always</b>. If set to <b>no </b>(the default), the
           service will not be restarted. If set to <b>on-success</b>, it will be
           restarted only when the service process exits cleanly. In this
           context, a clean exit means an exit code of 0, or one of the
           signals <b>SIGHUP</b>, <b>SIGINT</b>, <b>SIGTERM </b>or <b>SIGPIPE</b>, and additionally,
           exit statuses and signals specified in <i>SuccessExitStatus=</i>. If set
           to <b>on-failure</b>, the service will be restarted when the process
           exits with a non-zero exit code, is terminated by a signal
           (including on core dump, but excluding the aforementioned four
           signals), when an operation (such as service reload) times out,
           and when the configured watchdog timeout is triggered. If set to
           <b>on-abnormal</b>, the service will be restarted when the process is
           terminated by a signal (including on core dump, excluding the
           aforementioned four signals), when an operation times out, or
           when the watchdog timeout is triggered. If set to <b>on-abort</b>, the
           service will be restarted only if the service process exits due
           to an uncaught signal not specified as a clean exit status. If
           set to <b>on-watchdog</b>, the service will be restarted only if the
           watchdog timeout for the service expires. If set to <b>always</b>, the
           service will be restarted regardless of whether it exited cleanly
           or not, got terminated abnormally by a signal, or hit a timeout.

           <b>Table 1. Exit causes and the effect of the </b><i>Restart=</i> settings on
           them
           ┌──────────────┬────┬────────┬────────────┬────────────┬─────────────┬──────────┬─────────────┐
           │<b>Restart       </b>│ <b>no </b>│ <b>always </b>│ <b>on-success </b>│ <b>on-failure </b>│ <b>on-abnormal </b>│ <b>on-abort </b>│ <b>on-watchdog </b>│
           │<b>settings/Exit </b>│    │        │            │            │             │          │             │
           │<b>causes        </b>│    │        │            │            │             │          │             │
           ├──────────────┼────┼────────┼────────────┼────────────┼─────────────┼──────────┼─────────────┤
           │Clean exit    │    │ X      │ X          │            │             │          │             │
           │code or       │    │        │            │            │             │          │             │
           │signal        │    │        │            │            │             │          │             │
           ├──────────────┼────┼────────┼────────────┼────────────┼─────────────┼──────────┼─────────────┤
           │Unclean exit  │    │ X      │            │ X          │             │          │             │
           │code          │    │        │            │            │             │          │             │
           ├──────────────┼────┼────────┼────────────┼────────────┼─────────────┼──────────┼─────────────┤
           │Unclean       │    │ X      │            │ X          │ X           │ X        │             │
           │signal        │    │        │            │            │             │          │             │
           ├──────────────┼────┼────────┼────────────┼────────────┼─────────────┼──────────┼─────────────┤
           │Timeout       │    │ X      │            │ X          │ X           │          │             │
           ├──────────────┼────┼────────┼────────────┼────────────┼─────────────┼──────────┼─────────────┤
           │Watchdog      │    │ X      │            │ X          │ X           │          │ X           │
           └──────────────┴────┴────────┴────────────┴────────────┴─────────────┴──────────┴─────────────┘
           As exceptions to the setting above, the service will not be
           restarted if the exit code or signal is specified in
           <i>RestartPreventExitStatus=</i> (see below) or the service is stopped
           with <b>systemctl stop </b>or an equivalent operation. Also, the
           services will always be restarted if the exit code or signal is
           specified in <i>RestartForceExitStatus=</i> (see below).

           Note that service restart is subject to unit start rate limiting
           configured with <i>StartLimitIntervalSec=</i> and <i>StartLimitBurst=</i>, see
           <a href="systemd.unit.5.html">systemd.unit(5)</a> for details.

           Setting this to <b>on-failure </b>is the recommended choice for
           long-running services, in order to increase reliability by
           attempting automatic recovery from errors. For services that
           shall be able to terminate on their own choice (and avoid
           immediate restarting), <b>on-abnormal </b>is an alternative choice.

       <i>SuccessExitStatus=</i>
           Takes a list of exit status definitions that, when returned by
           the main service process, will be considered successful
           termination, in addition to the normal successful exit code 0 and
           the signals <b>SIGHUP</b>, <b>SIGINT</b>, <b>SIGTERM</b>, and <b>SIGPIPE</b>. Exit status
           definitions can either be numeric exit codes or termination
           signal names, separated by spaces. For example:

               SuccessExitStatus=1 2 8 SIGKILL

           ensures that exit codes 1, 2, 8 and the termination signal
           <b>SIGKILL </b>are considered clean service terminations.

           Note that if a process has a signal handler installed and exits
           by calling <a href="../man2/_exit.2-2.html">_exit(2)</a> in response to a signal, the information
           about the signal is lost. Programs should instead perform cleanup
           and kill themselves with the same signal instead. See <b>Proper</b>
           <b>handling of SIGINT/SIGQUIT — How to be a proper program</b><b></b>[2].

           This option may appear more than once, in which case the list of
           successful exit statuses is merged. If the empty string is
           assigned to this option, the list is reset, all prior assignments
           of this option will have no effect.

       <i>RestartPreventExitStatus=</i>
           Takes a list of exit status definitions that, when returned by
           the main service process, will prevent automatic service
           restarts, regardless of the restart setting configured with
           <i>Restart=</i>. Exit status definitions can either be numeric exit
           codes or termination signal names, and are separated by spaces.
           Defaults to the empty list, so that, by default, no exit status
           is excluded from the configured restart logic. For example:

               RestartPreventExitStatus=1 6 SIGABRT

           ensures that exit codes 1 and 6 and the termination signal
           <b>SIGABRT </b>will not result in automatic service restarting. This
           option may appear more than once, in which case the list of
           restart-preventing statuses is merged. If the empty string is
           assigned to this option, the list is reset and all prior
           assignments of this option will have no effect.

       <i>RestartForceExitStatus=</i>
           Takes a list of exit status definitions that, when returned by
           the main service process, will force automatic service restarts,
           regardless of the restart setting configured with <i>Restart=</i>. The
           argument format is similar to <i>RestartPreventExitStatus=</i>.

       <i>PermissionsStartOnly=</i>
           Takes a boolean argument. If true, the permission-related
           execution options, as configured with <i>User=</i> and similar options
           (see <a href="systemd.exec.5.html">systemd.exec(5)</a> for more information), are only applied to
           the process started with <i>ExecStart=</i>, and not to the various other
           <i>ExecStartPre=</i>, <i>ExecStartPost=</i>, <i>ExecReload=</i>, <i>ExecStop=</i>, and
           <i>ExecStopPost=</i> commands. If false, the setting is applied to all
           configured commands the same way. Defaults to false.

       <i>RootDirectoryStartOnly=</i>
           Takes a boolean argument. If true, the root directory, as
           configured with the <i>RootDirectory=</i> option (see <a href="systemd.exec.5.html">systemd.exec(5)</a>
           for more information), is only applied to the process started
           with <i>ExecStart=</i>, and not to the various other <i>ExecStartPre=</i>,
           <i>ExecStartPost=</i>, <i>ExecReload=</i>, <i>ExecStop=</i>, and <i>ExecStopPost=</i>
           commands. If false, the setting is applied to all configured
           commands the same way. Defaults to false.

       <i>NonBlocking=</i>
           Set the <b>O_NONBLOCK </b>flag for all file descriptors passed via
           socket-based activation. If true, all file descriptors &gt;= 3 (i.e.
           all except stdin, stdout, stderr), excluding those passed in via
           the file descriptor storage logic (see <i>FileDescriptorStoreMax=</i>
           for details), will have the <b>O_NONBLOCK </b>flag set and hence are in
           non-blocking mode. This option is only useful in conjunction with
           a socket unit, as described in <a href="systemd.socket.5.html">systemd.socket(5)</a> and has no
           effect on file descriptors which were previously saved in the
           file-descriptor store for example. Defaults to false.

       <i>NotifyAccess=</i>
           Controls access to the service status notification socket, as
           accessible via the <a href="../man3/sd_notify.3.html">sd_notify(3)</a> call. Takes one of <b>none </b>(the
           default), <b>main</b>, <b>exec </b>or <b>all</b>. If <b>none</b>, no daemon status updates
           are accepted from the service processes, all status update
           messages are ignored. If <b>main</b>, only service updates sent from the
           main process of the service are accepted. If <b>exec</b>, only service
           updates sent from any of the main or control processes
           originating from one of the <i>Exec*=</i> commands are accepted. If <b>all</b>,
           all services updates from all members of the service's control
           group are accepted. This option should be set to open access to
           the notification socket when using <i>Type=notify</i> or <i>WatchdogSec=</i>
           (see above). If those options are used but <i>NotifyAccess=</i> is not
           configured, it will be implicitly set to <b>main</b>.

           Note that <b>sd_notify() </b>notifications may be attributed to units
           correctly only if either the sending process is still around at
           the time PID 1 processes the message, or if the sending process
           is explicitly runtime-tracked by the service manager. The latter
           is the case if the service manager originally forked off the
           process, i.e. on all processes that match <b>main </b>or <b>exec</b>.
           Conversely, if an auxiliary process of the unit sends an
           <b>sd_notify() </b>message and immediately exits, the service manager
           might not be able to properly attribute the message to the unit,
           and thus will ignore it, even if <i>NotifyAccess=</i><b>all </b>is set for it.

       <i>Sockets=</i>
           Specifies the name of the socket units this service shall inherit
           socket file descriptors from when the service is started.
           Normally, it should not be necessary to use this setting, as all
           socket file descriptors whose unit shares the same name as the
           service (subject to the different unit name suffix of course) are
           passed to the spawned process.

           Note that the same socket file descriptors may be passed to
           multiple processes simultaneously. Also note that a different
           service may be activated on incoming socket traffic than the one
           which is ultimately configured to inherit the socket file
           descriptors. Or, in other words: the <i>Service=</i> setting of .socket
           units does not have to match the inverse of the <i>Sockets=</i> setting
           of the .service it refers to.

           This option may appear more than once, in which case the list of
           socket units is merged. If the empty string is assigned to this
           option, the list of sockets is reset, and all prior uses of this
           setting will have no effect.

       <i>FailureAction=</i>
           Configure the action to take when the service enters a failed
           state. Takes the same values as the unit setting
           <i>StartLimitAction=</i> and executes the same actions (see
           <a href="systemd.unit.5.html">systemd.unit(5)</a>). Defaults to <b>none</b>.

       <i>FileDescriptorStoreMax=</i>
           Configure how many file descriptors may be stored in the service
           manager for the service using <a href="../man3/sd_pid_notify_with_fds.3.html">sd_pid_notify_with_fds(3)</a>'s
           "FDSTORE=1" messages. This is useful for implementing services
           that can restart after an explicit request or a crash without
           losing state. Any open sockets and other file descriptors which
           should not be closed during the restart may be stored this way.
           Application state can either be serialized to a file in /run, or
           better, stored in a <a href="../man2/memfd_create.2.html">memfd_create(2)</a> memory file descriptor.
           Defaults to 0, i.e. no file descriptors may be stored in the
           service manager. All file descriptors passed to the service
           manager from a specific service are passed back to the service's
           main process on the next service restart. Any file descriptors
           passed to the service manager are automatically closed when
           <b>POLLHUP </b>or <b>POLLERR </b>is seen on them, or when the service is fully
           stopped and no job is queued or being executed for it.

       <i>USBFunctionDescriptors=</i>
           Configure the location of a file containing <b>USB FunctionFS</b><b></b>[3]
           descriptors, for implementation of USB gadget functions. This is
           used only in conjunction with a socket unit with
           <i>ListenUSBFunction=</i> configured. The contents of this file are
           written to the ep0 file after it is opened.

       <i>USBFunctionStrings=</i>
           Configure the location of a file containing USB FunctionFS
           strings. Behavior is similar to <i>USBFunctionDescriptors=</i> above.

       Check <a href="systemd.exec.5.html">systemd.exec(5)</a> and <a href="systemd.kill.5.html">systemd.kill(5)</a> for more settings.
</pre>
<h2><a id="COMMAND_LINES" href="#COMMAND_LINES"></a>COMMAND LINES  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       This section describes command line parsing and variable and
       specifier substitutions for <i>ExecStart=</i>, <i>ExecStartPre=</i>,
       <i>ExecStartPost=</i>, <i>ExecReload=</i>, <i>ExecStop=</i>, and <i>ExecStopPost=</i> options.

       Multiple command lines may be concatenated in a single directive by
       separating them with semicolons (these semicolons must be passed as
       separate words). Lone semicolons may be escaped as "\;".

       Each command line is split on whitespace, with the first item being
       the command to execute, and the subsequent items being the arguments.
       Double quotes ("...") and single quotes ('...') may be used to wrap a
       whole item (the opening quote may appear only at the beginning or
       after whitespace that is not quoted, and the closing quote must be
       followed by whitespace or the end of line), in which case everything
       until the next matching quote becomes part of the same argument.
       Quotes themselves are removed. C-style escapes are also supported.
       The table below contains the list of known escape patterns. Only
       escape patterns which match the syntax in the table are allowed;
       other patterns may be added in the future and unknown patterns will
       result in a warning. In particular, any backslashes should be
       doubled. Finally, a trailing backslash ("\") may be used to merge
       lines.

       This syntax is inspired by shell syntax, but only the meta-characters
       and expansions described in the following paragraphs are understood,
       and the expansion of variables is different. Specifically,
       redirection using "&lt;", "&lt;&lt;", "&gt;", and "&gt;&gt;", pipes using "|", running
       programs in the background using "&amp;", and <i>other elements of shell</i>
       <i>syntax are not supported</i>.

       The command to execute must be an absolute path name. It may contain
       spaces, but control characters are not allowed.

       The command line accepts "%" specifiers as described in
       <a href="systemd.unit.5.html">systemd.unit(5)</a>. Note that the first argument of the command line
       (i.e. the program to execute) may not include specifiers.

       Basic environment variable substitution is supported. Use "${FOO}" as
       part of a word, or as a word of its own, on the command line, in
       which case it will be replaced by the value of the environment
       variable including all whitespace it contains, resulting in a single
       argument. Use "$FOO" as a separate word on the command line, in which
       case it will be replaced by the value of the environment variable
       split at whitespace, resulting in zero or more arguments. For this
       type of expansion, quotes are respected when splitting into words,
       and afterwards removed.

       Example:

           Environment="ONE=one" 'TWO=two two'
           ExecStart=/bin/echo $ONE $TWO ${TWO}

       This will execute <b>/bin/echo </b>with four arguments: "one", "two", "two",
       and "two two".

       Example:

           Environment=ONE='one' "TWO='two two' too" THREE=
           ExecStart=/bin/echo ${ONE} ${TWO} ${THREE}
           ExecStart=/bin/echo $ONE $TWO $THREE

       This results in echo being called twice, the first time with
       arguments "'one'", "'two two' too", "", and the second time with
       arguments "one", "two two", "too".

       To pass a literal dollar sign, use "$$". Variables whose value is not
       known at expansion time are treated as empty strings. Note that the
       first argument (i.e. the program to execute) may not be a variable.

       Variables to be used in this fashion may be defined through
       <i>Environment=</i> and <i>EnvironmentFile=</i>. In addition, variables listed in
       the section "Environment variables in spawned processes" in
       <a href="systemd.exec.5.html">systemd.exec(5)</a>, which are considered "static configuration", may be
       used (this includes e.g.  <i>$USER</i>, but not <i>$TERM</i>).

       Note that shell command lines are not directly supported. If shell
       command lines are to be used, they need to be passed explicitly to a
       shell implementation of some kind. Example:

           ExecStart=/bin/sh -c 'dmesg | tac'

       Example:

           ExecStart=/bin/echo one ; /bin/echo "two two"

       This will execute <b>/bin/echo </b>two times, each time with one argument:
       "one" and "two two", respectively. Because two commands are
       specified, <i>Type=oneshot</i> must be used.

       Example:

           ExecStart=/bin/echo / &gt;/dev/null &amp; \; \
           /bin/ls

       This will execute <b>/bin/echo </b>with five arguments: "/", "&gt;/dev/null",
       "&amp;", ";", and "/bin/ls".

       <b>Table 2. C escapes supported in command lines and environment</b>
       <b>variables</b>
       ┌────────┬─────────────────────────┐
       │<b>Literal </b>│ <b>Actual value            </b>│
       ├────────┼─────────────────────────┤
       │"\a"    │ bell                    │
       ├────────┼─────────────────────────┤
       │"\b"    │ backspace               │
       ├────────┼─────────────────────────┤
       │"\f"    │ form feed               │
       ├────────┼─────────────────────────┤
       │"\n"    │ newline                 │
       ├────────┼─────────────────────────┤
       │"\r"    │ carriage return         │
       ├────────┼─────────────────────────┤
       │"\t"    │ tab                     │
       ├────────┼─────────────────────────┤
       │"\v"    │ vertical tab            │
       ├────────┼─────────────────────────┤
       │"\\"    │ backslash               │
       ├────────┼─────────────────────────┤
       │"\""    │ double quotation mark   │
       ├────────┼─────────────────────────┤
       │"\'"    │ single quotation mark   │
       ├────────┼─────────────────────────┤
       │"\s"    │ space                   │
       ├────────┼─────────────────────────┤
       │"\x<i>xx</i>"  │ character number <i>xx</i> in  │
       │        │ hexadecimal encoding    │
       ├────────┼─────────────────────────┤
       │"\<i>nnn</i>"  │ character number <i>nnn</i> in │
       │        │ octal encoding          │
       └────────┴─────────────────────────┘
</pre>
<h2><a id="EXAMPLES" href="#EXAMPLES"></a>EXAMPLES  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       <b>Example 1. Simple service</b>

       The following unit file creates a service that will execute
       /usr/sbin/foo-daemon. Since no <i>Type=</i> is specified, the default
       <i>Type=</i><b>simple </b>will be assumed. systemd will assume the unit to be
       started immediately after the program has begun executing.

           [Unit]
           Description=Foo

           [Service]
           ExecStart=/usr/sbin/foo-daemon

           [Install]
           WantedBy=multi-user.target

       Note that systemd assumes here that the process started by systemd
       will continue running until the service terminates. If the program
       daemonizes itself (i.e. forks), please use <i>Type=</i><b>forking </b>instead.

       Since no <i>ExecStop=</i> was specified, systemd will send SIGTERM to all
       processes started from this service, and after a timeout also
       SIGKILL. This behavior can be modified, see <a href="systemd.kill.5.html">systemd.kill(5)</a> for
       details.

       Note that this unit type does not include any type of notification
       when a service has completed initialization. For this, you should use
       other unit types, such as <i>Type=</i><b>notify </b>if the service understands
       systemd's notification protocol, <i>Type=</i><b>forking </b>if the service can
       background itself or <i>Type=</i><b>dbus </b>if the unit acquires a DBus name once
       initialization is complete. See below.

       <b>Example 2. Oneshot service</b>

       Sometimes, units should just execute an action without keeping active
       processes, such as a filesystem check or a cleanup action on boot.
       For this, <i>Type=</i><b>oneshot </b>exists. Units of this type will wait until the
       process specified terminates and then fall back to being inactive.
       The following unit will perform a cleanup action:

           [Unit]
           Description=Cleanup old Foo data

           [Service]
           Type=oneshot
           ExecStart=/usr/sbin/foo-cleanup

           [Install]
           WantedBy=multi-user.target

       Note that systemd will consider the unit to be in the state
       "starting" until the program has terminated, so ordered dependencies
       will wait for the program to finish before starting themselves. The
       unit will revert to the "inactive" state after the execution is done,
       never reaching the "active" state. That means another request to
       start the unit will perform the action again.

       <i>Type=</i><b>oneshot </b>are the only service units that may have more than one
       <i>ExecStart=</i> specified. They will be executed in order until either
       they are all successful or one of them fails.

       <b>Example 3. Stoppable oneshot service</b>

       Similarly to the oneshot services, there are sometimes units that
       need to execute a program to set up something and then execute
       another to shut it down, but no process remains active while they are
       considered "started". Network configuration can sometimes fall into
       this category. Another use case is if a oneshot service shall not be
       executed each time when they are pulled in as a dependency, but only
       the first time.

       For this, systemd knows the setting <i>RemainAfterExit=</i><b>yes</b>, which causes
       systemd to consider the unit to be active if the start action exited
       successfully. This directive can be used with all types, but is most
       useful with <i>Type=</i><b>oneshot </b>and <i>Type=</i><b>simple</b>. With <i>Type=</i><b>oneshot</b>, systemd
       waits until the start action has completed before it considers the
       unit to be active, so dependencies start only after the start action
       has succeeded. With <i>Type=</i><b>simple</b>, dependencies will start immediately
       after the start action has been dispatched. The following unit
       provides an example for a simple static firewall.

           [Unit]
           Description=Simple firewall

           [Service]
           Type=oneshot
           RemainAfterExit=yes
           ExecStart=/usr/local/sbin/simple-firewall-start
           ExecStop=/usr/local/sbin/simple-firewall-stop

           [Install]
           WantedBy=multi-user.target

       Since the unit is considered to be running after the start action has
       exited, invoking <b>systemctl start </b>on that unit again will cause no
       action to be taken.

       <b>Example 4. Traditional forking services</b>

       Many traditional daemons/services background (i.e. fork, daemonize)
       themselves when starting. Set <i>Type=</i><b>forking </b>in the service's unit file
       to support this mode of operation. systemd will consider the service
       to be in the process of initialization while the original program is
       still running. Once it exits successfully and at least a process
       remains (and <i>RemainAfterExit=</i><b>no</b>), the service is considered started.

       Often, a traditional daemon only consists of one process. Therefore,
       if only one process is left after the original process terminates,
       systemd will consider that process the main process of the service.
       In that case, the <i>$MAINPID</i> variable will be available in <i>ExecReload=</i>,
       <i>ExecStop=</i>, etc.

       In case more than one process remains, systemd will be unable to
       determine the main process, so it will not assume there is one. In
       that case, <i>$MAINPID</i> will not expand to anything. However, if the
       process decides to write a traditional PID file, systemd will be able
       to read the main PID from there. Please set <i>PIDFile=</i> accordingly.
       Note that the daemon should write that file before finishing with its
       initialization. Otherwise, systemd might try to read the file before
       it exists.

       The following example shows a simple daemon that forks and just
       starts one process in the background:

           [Unit]
           Description=Some simple daemon

           [Service]
           Type=forking
           ExecStart=/usr/sbin/my-simple-daemon -d

           [Install]
           WantedBy=multi-user.target

       Please see <a href="systemd.kill.5.html">systemd.kill(5)</a> for details on how you can influence the
       way systemd terminates the service.

       <b>Example 5. DBus services</b>

       For services that acquire a name on the DBus system bus, use
       <i>Type=</i><b>dbus </b>and set <i>BusName=</i> accordingly. The service should not fork
       (daemonize). systemd will consider the service to be initialized once
       the name has been acquired on the system bus. The following example
       shows a typical DBus service:

           [Unit]
           Description=Simple DBus service

           [Service]
           Type=dbus
           BusName=org.example.simple-dbus-service
           ExecStart=/usr/sbin/simple-dbus-service

           [Install]
           WantedBy=multi-user.target

       For <i>bus-activatable</i> services, do not include a "[Install]" section in
       the systemd service file, but use the <i>SystemdService=</i> option in the
       corresponding DBus service file, for example
       (/usr/share/dbus-1/system-services/org.example.simple-dbus-service.service):

           [D-BUS Service]
           Name=org.example.simple-dbus-service
           Exec=/usr/sbin/simple-dbus-service
           User=root
           SystemdService=simple-dbus-service.service

       Please see <a href="systemd.kill.5.html">systemd.kill(5)</a> for details on how you can influence the
       way systemd terminates the service.

       <b>Example 6. Services that notify systemd about their initialization</b>

       <i>Type=</i><b>simple </b>services are really easy to write, but have the major
       disadvantage of systemd not being able to tell when initialization of
       the given service is complete. For this reason, systemd supports a
       simple notification protocol that allows daemons to make systemd
       aware that they are done initializing. Use <i>Type=</i><b>notify </b>for this. A
       typical service file for such a daemon would look like this:

           [Unit]
           Description=Simple notifying service

           [Service]
           Type=notify
           ExecStart=/usr/sbin/simple-notifying-service

           [Install]
           WantedBy=multi-user.target

       Note that the daemon has to support systemd's notification protocol,
       else systemd will think the service has not started yet and kill it
       after a timeout. For an example of how to update daemons to support
       this protocol transparently, take a look at <a href="../man3/sd_notify.3.html">sd_notify(3)</a>. systemd
       will consider the unit to be in the 'starting' state until a
       readiness notification has arrived.

       Please see <a href="systemd.kill.5.html">systemd.kill(5)</a> for details on how you can influence the
       way systemd terminates the service.
</pre>
<h2><a id="SEE_ALSO" href="#SEE_ALSO"></a>SEE ALSO  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       <a href="../man1/systemd.1.html">systemd(1)</a>, <a href="../man1/systemctl.1.html">systemctl(1)</a>, <a href="systemd.unit.5.html">systemd.unit(5)</a>, <a href="systemd.exec.5.html">systemd.exec(5)</a>,
       <a href="systemd.resource-control.5.html">systemd.resource-control(5)</a>, <a href="systemd.kill.5.html">systemd.kill(5)</a>, <a href="../man7/systemd.directives.7.html">systemd.directives(7)</a>
</pre>
<h2><a id="NOTES" href="#NOTES"></a>NOTES  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
        1. Incompatibilities with SysV
           <a href="https://www.freedesktop.org/wiki/Software/systemd/Incompatibilities">https://www.freedesktop.org/wiki/Software/systemd/Incompatibilities</a>

        2. Proper handling of SIGINT/SIGQUIT — How to be a proper program
           <a href="http://www.cons.org/cracauer/sigint.html">http://www.cons.org/cracauer/sigint.html</a>

        3. USB FunctionFS
           <a href="https://www.kernel.org/doc/Documentation/usb/functionfs.txt">https://www.kernel.org/doc/Documentation/usb/functionfs.txt</a>
</pre>
<h2><a id="COLOPHON" href="#COLOPHON"></a>COLOPHON  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       This page is part of the <i>systemd</i> (systemd system and service manager)
       project.  Information about the project can be found at 
       ⟨<a href="http://www.freedesktop.org/wiki/Software/systemd">http://www.freedesktop.org/wiki/Software/systemd</a>⟩.  If you have a bug
       report for this manual page, see 
       ⟨<a href="http://www.freedesktop.org/wiki/Software/systemd/#bugreports">http://www.freedesktop.org/wiki/Software/systemd/#bugreports</a>⟩.  This
       page was obtained from the project's upstream Git repository 
       ⟨<a href="https://github.com/systemd/systemd.git">https://github.com/systemd/systemd.git</a>⟩ on 2017-07-05.  If you dis‐
       cover any rendering problems in this HTML version of the page, or you
       believe there is a better or more up-to-date source for the page, or
       you have corrections or improvements to the information in this
       COLOPHON (which is <i>not</i> part of the original manual page), send a mail
       to man-pages@man7.org

<span class="footline">systemd 234                                               SYSTEMD.SERVICE(5)</span>
</pre>

<hr class="end-man-text" />
<p>Pages that refer to this page: 
    <a href="../man1/systemctl.1.html">systemctl(1)</a>,&nbsp; 
    <a href="../man1/systemd.1.html">systemd(1)</a>,&nbsp; 
    <a href="../man1/systemd-run.1.html">systemd-run(1)</a>,&nbsp; 
    <a href="../man1/systemd-socket-activate.1.html">systemd-socket-activate(1)</a>,&nbsp; 
    <a href="../man3/sd-daemon.3.html">sd-daemon(3)</a>,&nbsp; 
    <a href="../man3/sd_event_set_watchdog.3.html">sd_event_set_watchdog(3)</a>,&nbsp; 
    <a href="../man3/sd_is_fifo.3.html">sd_is_fifo(3)</a>,&nbsp; 
    <a href="../man3/sd_listen_fds.3.html">sd_listen_fds(3)</a>,&nbsp; 
    <a href="../man3/sd_notify.3.html">sd_notify(3)</a>,&nbsp; 
    <a href="../man3/sd_watchdog_enabled.3.html">sd_watchdog_enabled(3)</a>,&nbsp; 
    <a href="systemd.exec.5.html">systemd.exec(5)</a>,&nbsp; 
    <a href="systemd.kill.5.html">systemd.kill(5)</a>,&nbsp; 
    <a href="systemd.mount.5.html">systemd.mount(5)</a>,&nbsp; 
    <a href="systemd.path.5.html">systemd.path(5)</a>,&nbsp; 
    <a href="systemd.resource-control.5.html">systemd.resource-control(5)</a>,&nbsp; 
    <a href="systemd.scope.5.html">systemd.scope(5)</a>,&nbsp; 
    <a href="systemd.slice.5.html">systemd.slice(5)</a>,&nbsp; 
    <a href="systemd.socket.5.html">systemd.socket(5)</a>,&nbsp; 
    <a href="systemd-system.conf.5.html">systemd-system.conf(5)</a>,&nbsp; 
    <a href="systemd.timer.5.html">systemd.timer(5)</a>,&nbsp; 
    <a href="systemd.unit.5.html">systemd.unit(5)</a>,&nbsp; 
    <a href="../man7/daemon.7.html">daemon(7)</a>,&nbsp; 
    <a href="../man7/systemd.directives.7.html">systemd.directives(7)</a>,&nbsp; 
    <a href="../man7/systemd.index.7.html">systemd.index(7)</a>,&nbsp; 
    <a href="../man7/systemd.special.7.html">systemd.special(7)</a>,&nbsp; 
    <a href="../man8/pam_systemd.8.html">pam_systemd(8)</a>,&nbsp; 
    <a href="../man8/systemd-activate.8.html">systemd-activate(8)</a>,&nbsp; 
    <a href="../man8/systemd-socket-proxyd.8.html">systemd-socket-proxyd(8)</a>,&nbsp; 
    <a href="../man8/systemd-sysv-generator.8.html">systemd-sysv-generator(8)</a>
</p>
<hr/>

 
<hr class="start-footer" />

<div class="footer"> 

<table class="colophon-table">
    <tr>
    <td class="pub-info">
        <p>
            HTML rendering created 2017-07-13
            by <a href="http://man7.org/mtk/index.html">Michael Kerrisk</a>, 
            author of 
            <a href="http://man7.org/tlpi/"><em>The Linux Programming Interface</em></a>, 
            maintainer of the 
            <a href="https://www.kernel.org/doc/man-pages/">Linux <em>man-pages</em> project</a>.
        </p>
        <p>
            For details of in-depth
            <strong>Linux/UNIX system programming training courses</strong>
            that I teach, look <a href="http://man7.org/training/">here</a>.
        </p>
        <p>
            Hosting by <a href="http://www.jambit.com/index_en.html">jambit GmbH</a>.
        </p>
        <p>
            <a href="http://validator.w3.org/check?uri=referer">
            <img src="http://www.w3.org/Icons/valid-xhtml11"
                alt="Valid XHTML 1.1" height="31" width="88" />
            </a>
        </p>
    </td>
    <td class="colophon-divider">
    </td>
    <td class="tlpi-cover">
        <a href="http://man7.org/tlpi/"><img src="../../../tlpi/cover/TLPI-front-cover-vsmall.png" alt="Cover of TLPI" /></a>
    </td>
    </tr>
</table>

</div>

<hr class="end-footer" />



<!--BEGIN-SITETRACKING-->
<!-- SITETRACKING.man7.org_linux_man-pages -->

<!-- Start of StatCounter Code (xhtml) -->

<script type="text/javascript">
//<![CDATA[
var sc_project=7422636; 
var sc_invisible=1; 
var sc_security="9b6714ff"; 
//]]>
</script>
<script type="text/javascript"
src="../../../../www.statcounter.com/counter/counter_xhtml.js"></script>
<noscript><div class="statcounter"><a title="website
statistics" href="http://statcounter.com/"
class="statcounter"><img class="statcounter"
src="http://c.statcounter.com/7422636/0/9b6714ff/1/"
alt="website statistics" /></a></div></noscript>

<!-- End of StatCounter Code -->


<!-- Start of Google Analytics Code -->

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-9830363-8']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<!-- End of Google Analytics Code -->

<!--END-SITETRACKING-->

</body>
</html>
