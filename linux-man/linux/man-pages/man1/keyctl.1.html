
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
        "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
    <link rel="stylesheet" type="text/css" href="../../../style.css" title="style" />
    <link rel="stylesheet" type="text/css" href="../style.css" title="style" />
    <meta http-equiv="content-type" content="text/html;charset=utf-8" />

    <title>keyctl(1) - Linux manual page</title>
</head>

<body>

<div class="page-top"><a id="top_of_page"></a></div>
<!--%%%TOP_BAR%%%-->
    <div class="nav-bar">
        <table class="nav-table">
            <tr>
                <td class="nav-cell">
                    <p class="nav-text">
                        <a href="http://man7.org/index.html">man7.org</a> &gt; Linux &gt; <a href="../index.html">man-pages</a>
                    </p>
                </td>
                <td class="training-cell">
                    <p class="training-text"><a class="training-link" href="http://man7.org/training/">Linux/UNIX system programming training</a></p>
                </td>
            </tr>
        </table>
    </div>

<hr class="nav-end" />

<!--%%%PAGE_START%%%-->


<table class="sec-table">
<tr>
    <td>
        <p class="section-dir">
<a href="#NAME">NAME</a> | <a href="#SYNOPSIS">SYNOPSIS</a> | <a href="#DESCRIPTION">DESCRIPTION</a> | <a href="#KEY_IDENTIFIERS">KEY&nbsp;IDENTIFIERS</a> | <a href="#COMMAND_SYNTAX">COMMAND&nbsp;SYNTAX</a> | <a href="#ERRORS">ERRORS</a> | <a href="#SEE_ALSO">SEE&nbsp;ALSO</a> | <a href="#COLOPHON">COLOPHON</a>
        </p>
    </td>
    <td class="search-box">
        <div class="man-search-box">

            <form method="get" action="http://www.google.com/search">
                <fieldset class="man-search">
                    <input type="text" name="q" size="10" maxlength="255" value="" />
                    <input type="hidden" name="sitesearch" value="man7.org/linux/man-pages" />
                    <input type="submit" name="sa" value="Search online pages" />
                </fieldset>
            </form>

        </div>
    </td>
    <td> </td>
</tr>
</table>

<pre>
<span class="headline">KEYCTL(1)              Linux Key Management Utilities              KEYCTL(1)</span>
</pre>
<h2><a id="NAME" href="#NAME"></a>NAME  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       keyctl - key management facility control
</pre>
<h2><a id="SYNOPSIS" href="#SYNOPSIS"></a>SYNOPSIS  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       <b>keyctl </b>--version
       <b>keyctl </b>show [-x] [&lt;keyring&gt;]
       <b>keyctl </b>add &lt;type&gt; &lt;desc&gt; &lt;data&gt; &lt;keyring&gt;
       <b>keyctl </b>padd &lt;type&gt; &lt;desc&gt; &lt;keyring&gt;
       <b>keyctl </b>request &lt;type&gt; &lt;desc&gt; [&lt;dest_keyring&gt;]
       <b>keyctl </b>request2 &lt;type&gt; &lt;desc&gt; &lt;info&gt; [&lt;dest_keyring&gt;]
       <b>keyctl </b>prequest2 &lt;type&gt; &lt;desc&gt; [&lt;dest_keyring&gt;]
       <b>keyctl </b>update &lt;key&gt; &lt;data&gt;
       <b>keyctl </b>pupdate &lt;key&gt;
       <b>keyctl </b>newring &lt;name&gt; &lt;keyring&gt;
       <b>keyctl </b>revoke &lt;key&gt;
       <b>keyctl </b>clear &lt;keyring&gt;
       <b>keyctl </b>link &lt;key&gt; &lt;keyring&gt;
       <b>keyctl </b>unlink &lt;key&gt; [&lt;keyring&gt;]
       <b>keyctl </b>search &lt;keyring&gt; &lt;type&gt; &lt;desc&gt; [&lt;dest_keyring&gt;]
       <b>keyctl </b>read &lt;key&gt;
       <b>keyctl </b>pipe &lt;key&gt;
       <b>keyctl </b>print &lt;key&gt;
       <b>keyctl </b>list &lt;keyring&gt;
       <b>keyctl </b>rlist &lt;keyring&gt;
       <b>keyctl </b>describe &lt;keyring&gt;
       <b>keyctl </b>rdescribe &lt;keyring&gt; [sep]
       <b>keyctl </b>chown &lt;key&gt; &lt;uid&gt;
       <b>keyctl </b>chgrp &lt;key&gt; &lt;gid&gt;
       <b>keyctl </b>setperm &lt;key&gt; &lt;mask&gt;
       <b>keyctl </b>new_session
       <b>keyctl </b>session
       <b>keyctl </b>session - [&lt;prog&gt; &lt;arg1&gt; &lt;arg2&gt; ...]
       <b>keyctl </b>session &lt;name&gt; [&lt;prog&gt; &lt;arg1&gt; &lt;arg2&gt; ...]
       <b>keyctl </b>instantiate &lt;key&gt; &lt;data&gt; &lt;keyring&gt;
       <b>keyctl </b>pinstantiate &lt;key&gt; &lt;keyring&gt;
       <b>keyctl </b>negate &lt;key&gt; &lt;timeout&gt; &lt;keyring&gt;
       <b>keyctl </b>reject &lt;key&gt; &lt;timeout&gt; &lt;error&gt; &lt;keyring&gt;
       <b>keyctl </b>timeout &lt;key&gt; &lt;timeout&gt;
       <b>keyctl </b>security &lt;key&gt;
       <b>keyctl </b>reap [-v]
       <b>keyctl </b>purge &lt;type&gt;
       <b>keyctl </b>purge [-i] [-p] &lt;type&gt; &lt;desc&gt;
       <b>keyctl </b>purge -s &lt;type&gt; &lt;desc&gt;
       <b>keyctl </b>get_persistent &lt;keyring&gt; [&lt;uid&gt;]
       <b>keyctl </b>dh_compute &lt;private&gt; &lt;prime&gt; &lt;base&gt;
</pre>
<h2><a id="DESCRIPTION" href="#DESCRIPTION"></a>DESCRIPTION  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       This program is used to control the key management facility in
       various ways using a variety of subcommands.
</pre>
<h2><a id="KEY_IDENTIFIERS" href="#KEY_IDENTIFIERS"></a>KEY IDENTIFIERS  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       The key identifiers passed to or returned from keyctl are, in
       general, positive integers. There are, however, some special values
       with special meanings that can be passed as arguments:

       No key: <b>0</b>

       Thread keyring: <b>@t </b>or <b>-1</b>
              Each thread may have its own keyring. This is searched first,
              before all others. The thread keyring is replaced by (v)fork,
              exec and clone.

       Process keyring: <b>@p </b>or <b>-2</b>
              Each process (thread group) may have its own keyring. This is
              shared between all members of a group and will be searched
              after the thread keyring. The process keyring is replaced by
              (v)fork and exec.

       Session keyring: <b>@s </b>or <b>-3</b>
              Each process subscribes to a session keyring that is inherited
              across (v)fork, exec and clone. This is searched after the
              process keyring. Session keyrings can be named and an extant
              keyring can be joined in place of a process's current session
              keyring.

       User specific keyring: <b>@u </b>or <b>-4</b>
              This keyring is shared between all the processes owned by a
              particular user. It isn't searched directly, but is normally
              linked to from the session keyring.

       User default session keyring: <b>@us </b>or <b>-5</b>
              This is the default session keyring for a particular user.
              Login processes that change to a particular user will bind to
              this session until another session is set.

       Group specific keyring: <b>@g </b>or <b>-6</b>
              This is a place holder for a group specific keyring, but is
              not actually implemented yet in the kernel.

       Assumed request_key authorisation key: <b>@a </b>or <b>-7</b>
              This selects the authorisation key provided to the
              <b>request_key</b>() helper to permit it to access the callers
              keyrings and instantiate the target key.

       Keyring by name: <b>%:&lt;name&gt;</b>
              A named keyring.  This will be searched for in the process's
              keyrings and in <i>/proc/keys</i>.

       Key by name: <b>%&lt;type&gt;:&lt;name&gt;</b>
              A named key of the given type.  This will be searched for in
              the process's keyrings and in <i>/proc/keys</i>.
</pre>
<h2><a id="COMMAND_SYNTAX" href="#COMMAND_SYNTAX"></a>COMMAND SYNTAX  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       Any non-ambiguous shortening of a command name may be used in lieu of
       the full command name. This facility should not be used in scripting
       as new commands may be added in future that then cause ambiguity.

   <b>Display the package version number</b>
       <b>keyctl --version</b>

       This command prints the package version number and build date and
       exits:

              $ keyctl --version
              keyctl from keyutils-1.5.3 (Built 2011-08-24)

   <b>Show process keyrings</b>
       <b>keyctl show [-x] [&lt;keyring&gt;]</b>

       By default this command recursively shows what keyrings a process is
       subscribed to and what keys and keyrings they contain.  If a keyring
       is specified then that keyring will be dumped instead.  If <b>-x </b>is
       specified then the keyring IDs will be dumped in hex instead of
       decimal.

   <b>Add a key to a keyring</b>
       <b>keyctl add </b>&lt;type&gt; &lt;desc&gt; &lt;data&gt; &lt;keyring&gt;
       <b>keyctl padd </b>&lt;type&gt; &lt;desc&gt; &lt;keyring&gt;

       This command creates a key of the specified type and description;
       instantiates it with the given data and attaches it to the specified
       keyring. It then prints the new key's ID on stdout:

              $ keyctl add user mykey stuff @u
              26

       The <b>padd </b>variant of the command reads the data from stdin rather than
       taking it from the command line:

              $ echo -n stuff | keyctl padd user mykey @u 26

   <b>Request a key</b>
       <b>keyctl request </b>&lt;type&gt; &lt;desc&gt; [&lt;dest_keyring&gt;]
       <b>keyctl request2 </b>&lt;type&gt; &lt;desc&gt; &lt;info&gt; [&lt;dest_keyring&gt;]
       <b>keyctl prequest2 </b>&lt;type&gt; &lt;desc&gt; [&lt;dest_keyring&gt;]

       These three commands request the lookup of a key of the given type
       and description. The process's keyrings will be searched, and if a
       match is found the matching key's ID will be printed to stdout; and
       if a destination keyring is given, the key will be added to that
       keyring also.

       If there is no key, the first command will simply return the error
       ENOKEY and fail. The second and third commands will create a partial
       key with the type and description, and call out to <i>/sbin/request-key</i>
       with that key and the extra information supplied. This will then
       attempt to instantiate the key in some manner, such that a valid key
       is obtained.

       The third command is like the second, except that the callout
       information is read from stdin rather than being passed on the
       command line.

       If a valid key is obtained, the ID will be printed and the key
       attached as if the original search had succeeded.

       If there wasn't a valid key obtained, a temporary negative key will
       be attached to the destination keyring if given and the error
       "Requested key not available" will be given.

              $ keyctl request2 user debug:hello wibble
              23
              $ echo -n wibble | keyctl prequest2 user debug:hello
              23
              $ keyctl request user debug:hello
              23

   <b>Update a key</b>
       <b>keyctl update </b>&lt;key&gt; &lt;data&gt;
       <b>keyctl pupdate </b>&lt;key&gt;

       This command replaces the data attached to a key with a new set of
       data. If the type of the key doesn't support update then error
       "Operation not supported" will be returned.

              $ keyctl update 23 zebra

       The <b>pupdate </b>variant of the command reads the data from stdin rather
       than taking it from the command line:

              $ echo -n zebra | keyctl pupdate 23

   <b>Create a keyring</b>
       <b>keyctl newring </b>&lt;name&gt; &lt;keyring&gt;

       This command creates a new keyring of the specified name and attaches
       it to the specified keyring. The ID of the new keyring will be
       printed to stdout if successful.

              $ keyctl newring squelch @us
              27

   <b>Revoke a key</b>
       <b>keyctl revoke </b>&lt;key&gt;

       This command marks a key as being revoked. Any further operations on
       that key (apart from unlinking it) will return error "Key has been
       revoked".

              $ keyctl revoke 26
              $ keyctl describe 26
              keyctl_describe: Key has been revoked

   <b>Clear a keyring</b>
       <b>keyctl clear </b>&lt;keyring&gt;

       This command unlinks all the keys attached to the specified keyring.
       Error "Not a directory" will be returned if the key specified is not
       a keyring.

              $ keyctl clear 27

   <b>Link a key to a keyring</b>
       <b>keyctl link </b>&lt;key&gt; &lt;keyring&gt;

       This command makes a link from the key to the keyring if there's
       enough capacity to do so. Error "Not a directory" will be returned if
       the destination is not a keyring. Error "Permission denied" will be
       returned if the key doesn't have link permission or the keyring
       doesn't have write permission. Error "File table overflow" will be
       returned if the keyring is full. Error "Resource deadlock avoided"
       will be returned if an attempt was made to introduce a recursive
       link.

              $ keyctl link 23 27
              $ keyctl link 27 27
              keyctl_link: Resource deadlock avoided

   <b>Unlink a key from a keyring or the session keyring tree</b>
       <b>keyctl unlink </b>&lt;key&gt; [&lt;keyring&gt;]

       If the keyring is specified, this command removes a link to the key
       from the keyring. Error "Not a directory" will be returned if the
       destination is not a keyring. Error "Permission denied" will be
       returned if the keyring doesn't have write permission. Error "No such
       file or directory" will be returned if the key is not linked to by
       the keyring.

       If the keyring is not specified, this command performs a depth-first
       search of the session keyring tree and removes all the links to the
       nominated key that it finds (and that it is permitted to remove).  It
       prints the number of successful unlinks before exiting.

              $ keyctl unlink 23 27

   <b>Search a keyring</b>
       <b>keyctl search </b>&lt;keyring&gt; &lt;type&gt; &lt;desc&gt; [&lt;dest_keyring&gt;]

       This command non-recursively searches a keyring for a key of a
       particular type and description. If found, the ID of the key will be
       printed on stdout and the key will be attached to the destination
       keyring if present. Error "Requested key not available" will be
       returned if the key is not found.

              $ keyctl search @us user debug:hello
              23
              $ keyctl search @us user debug:bye
              keyctl_search: Requested key not available

   <b>Read a key</b>
       <b>keyctl read </b>&lt;key&gt;
       <b>keyctl pipe </b>&lt;key&gt;
       <b>keyctl print </b>&lt;key&gt;

       These commands read the payload of a key. "read" prints it on stdout
       as a hex dump, "pipe" dumps the raw data to stdout and "print" dumps
       it to stdout directly if it's entirely printable or as a hexdump
       preceded by ":hex:" if not.

       If the key type does not support reading of the payload, then error
       "Operation not supported" will be returned.

              $ keyctl read 26
              1 bytes of data in key:
              62
              $ keyctl print 26
              b
              $ keyctl pipe 26
              $

   <b>List a keyring</b>
       <b>keyctl list </b>&lt;keyring&gt;
       <b>keyctl rlist </b>&lt;keyring&gt;

       These commands list the contents of a key as a keyring. "list" pretty
       prints the contents and "rlist" just produces a space-separated list
       of key IDs.

       No attempt is made to check that the specified keyring is a keyring.

              $ keyctl list @us
              2 keys in keyring:
                     22: vrwsl----------  4043    -1 keyring: _uid.4043
                     23: vrwsl----------  4043  4043 user: debug:hello
              $ keyctl rlist @us
              22 23

   <b>Describe a key</b>
       <b>keyctl describe </b>&lt;keyring&gt;
       <b>keyctl rdescribe </b>&lt;keyring&gt; [sep]

       These commands fetch a description of a keyring. "describe" pretty
       prints the description in the same fashion as the "list" command;
       "rdescribe" prints the raw data returned from the kernel.

              $ keyctl describe @us
                     -5: vrwsl----------  4043    -1 keyring: _uid_ses.4043
              $ keyctl rdescribe @us
              keyring;4043;-1;3f1f0000;_uid_ses.4043

       The raw string is "&lt;type&gt;;&lt;uid&gt;;&lt;gid&gt;;&lt;perms&gt;;&lt;description&gt;", where
       <i>uid</i> and <i>gid</i> are the decimal user and group IDs, <i>perms</i> is the
       permissions mask in hex, <i>type</i> and <i>description</i> are the type name and
       description strings (neither of which will contain semicolons).

   <b>Change the access controls on a key</b>
       <b>keyctl chown </b>&lt;key&gt; &lt;uid&gt;
       <b>keyctl chgrp </b>&lt;key&gt; &lt;gid&gt;

       These two commands change the UID and GID associated with evaluating
       a key's permissions mask. The UID also governs which quota a key is
       taken out of.

       The chown command is not currently supported; attempting it will earn
       the error "Operation not supported" at best.

       For non-superuser users, the GID may only be set to the process's GID
       or a GID in the process's groups list. The superuser may set any GID
       it likes.

              $ sudo keyctl chown 27 0
              keyctl_chown: Operation not supported
              $ sudo keyctl chgrp 27 0

   <b>Set the permissions mask on a key</b>
       <b>keyctl setperm </b>&lt;key&gt; &lt;mask&gt;

       This command changes the permission control mask on a key. The mask
       may be specified as a hex number if it begins "0x", an octal number
       if it begins "0" or a decimal number otherwise.

       The hex numbers are a combination of:

              Possessor UID       GID       Other     Permission Granted
              ========  ========  ========  ========  ==================
              01000000  00010000  00000100  00000001  View
              02000000  00020000  00000200  00000002  Read
              04000000  00040000  00000400  00000004  Write
              08000000  00080000  00000800  00000008  Search
              10000000  00100000  00001000  00000010  Link
              20000000  00200000  00002000  00000020  Set Attribute
              3f000000  003f0000  00003f00  0000003f  All

       <i>View</i> permits the type, description and other parameters of a key to
       be viewed.

       <i>Read</i> permits the payload (or keyring list) to be read if supported by
       the type.

       <i>Write</i> permits the payload (or keyring list) to be modified or
       updated.

       <i>Search</i> on a key permits it to be found when a keyring to which it is
       linked is searched.

       <i>Link</i> permits a key to be linked to a keyring.

       <i>Set Attribute</i> permits a key to have its owner, group membership,
       permissions mask and timeout changed.

              $ keyctl setperm 27 0x1f1f1f00

   <b>Start a new session with fresh keyrings</b>
       <b>keyctl session</b>
       <b>keyctl session </b>- [&lt;prog&gt; &lt;arg1&gt; &lt;arg2&gt; ...]
       <b>keyctl session </b>&lt;name&gt; [&lt;prog&gt; &lt;arg1&gt; &lt;arg2&gt; ...]

       These commands join or create a new keyring and then run a shell or
       other program with that keyring as the session key.

       The variation with no arguments just creates an anonymous session
       keyring and attaches that as the session keyring; it then exec's
       $SHELL.

       The variation with a dash in place of a name creates an anonymous
       session keyring and attaches that as the session keyring; it then
       exec's the supplied command, or $SHELL if one isn't supplied.

       The variation with a name supplied creates or joins the named keyring
       and attaches that as the session keyring; it then exec's the supplied
       command, or $SHELL if one isn't supplied.

              $ keyctl rdescribe @s
              keyring;4043;-1;3f1f0000;_uid_ses.4043

              $ keyctl session
              Joined session keyring: 28

              $ keyctl rdescribe @s
              keyring;4043;4043;3f1f0000;_ses.24082

              $ keyctl session -
              Joined session keyring: 29
              $ keyctl rdescribe @s
              keyring;4043;4043;3f1f0000;_ses.24139

              $ keyctl session - keyctl rdescribe @s
              Joined session keyring: 30
              keyring;4043;4043;3f1f0000;_ses.24185

              $ keyctl session fish
              Joined session keyring: 34
              $ keyctl rdescribe @s
              keyring;4043;4043;3f1f0000;fish

              $ keyctl session fish keyctl rdesc @s
              Joined session keyring: 35
              keyring;4043;4043;3f1f0000;fish

   <b>Instantiate a key</b>
       <b>keyctl instantiate </b>&lt;key&gt; &lt;data&gt; &lt;keyring&gt;
       <b>keyctl pinstantiate </b>&lt;key&gt; &lt;keyring&gt;
       <b>keyctl negate </b>&lt;key&gt; &lt;timeout&gt; &lt;keyring&gt;
       <b>keyctl reject </b>&lt;key&gt; &lt;timeout&gt; &lt;error&gt; &lt;keyring&gt;

       These commands are used to attach data to a partially set up key (as
       created by the kernel and passed to <i>/sbin/request-key</i>).
       "instantiate" marks a key as being valid and attaches the data as the
       payload.  "negate" and "reject" mark a key as invalid and sets a
       timeout on it so that it'll go away after a while.  This prevents a
       lot of quickly sequential requests from slowing the system down
       overmuch when they all fail, as all subsequent requests will then
       fail with error "Requested key not found" (if negated) or the
       specified error (if rejected) until the negative key has expired.

       Reject's error argument can either be a UNIX error number or one of
       '<b>rejected</b>', '<b>expired</b>' or '<b>revoked</b>'.

       The newly instantiated key will be attached to the specified keyring.

       These commands may only be run from the program run by request-key -
       a special authorisation key is set up by the kernel and attached to
       the request-key's session keyring. This special key is revoked once
       the key to which it refers has been instantiated one way or another.

              $ keyctl instantiate $1 "Debug $3" $4
              $ keyctl negate $1 30 $4
              $ keyctl reject $1 30 64 $4

       The <b>pinstantiate </b>variant of the command reads the data from stdin
       rather than taking it from the command line:

              $ echo -n "Debug $3" | keyctl pinstantiate $1 $4

   <b>Set the expiry time on a key</b>
       <b>keyctl timeout </b>&lt;key&gt; &lt;timeout&gt;

       This command is used to set the timeout on a key, or clear an
       existing timeout if the value specified is zero. The timeout is given
       as a number of seconds into the future.

              $ keyctl timeout $1 45

   <b>Retrieve a key's security context</b>
       <b>keyctl security </b>&lt;key&gt;

       This command is used to retrieve a key's LSM security context.  The
       label is printed on stdout.

              $ keyctl security @s
              unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023

   <b>Give the parent process a new session keyring</b>
       <b>keyctl new_session</b>

       This command is used to give the invoking process (typically a shell)
       a new session keyring, discarding its old session keyring.

              $  keyctl session foo
              Joined session keyring: 723488146
              $  keyctl show
              Session Keyring
                     -3 --alswrv      0     0  keyring: foo
              $  keyctl new_session
              490511412
              $  keyctl show
              Session Keyring
                     -3 --alswrv      0     0  keyring: _ses

       Note that this affects the <i>parent</i> of the process that invokes the
       system call, and so may only affect processes with matching
       credentials.  Furthermore, the change does not take effect till the
       parent process next transitions from kernel space to user space -
       typically when the <b>wait</b>() system call returns.

   <b>Remove dead keys from the session keyring tree</b>
       <b>keyctl reap</b>

       This command performs a depth-first search of the caller's session
       keyring tree and attempts to unlink any key that it finds that is
       inaccessible due to expiry, revocation, rejection or negation.  It
       does not attempt to remove live keys that are unavailable simply due
       to a lack of granted permission.

       A key that is designated reapable will only be removed from a keyring
       if the caller has Write permission on that keyring, and only keyrings
       that grant Search permission to the caller will be searched.

       The command prints the number of keys reaped before it exits.  If the
       <b>-v </b>flag is passed then the reaped keys are listed as they're being
       reaped, together with the success or failure of the unlink.

   <b>Remove matching keys from the session keyring tree</b>
       <b>keyctl </b>purge &lt;type&gt;
       <b>keyctl </b>purge [-i] [-p] &lt;type&gt; &lt;desc&gt;
       <b>keyctl </b>purge -s &lt;type&gt; &lt;desc&gt;

       These commands perform a depth-first search to find matching keys in
       the caller's session keyring tree and attempts to unlink them.  The
       number of keys successfully unlinked is printed at the end.

       The keyrings must grant Read and View permission to the caller to be
       searched, and the keys to be removed must also grant View permission.
       Keys can only be removed from keyrings that grant Write permission.

       The first variant purges all keys of the specified type.

       The second variant purges all keys of the specified type that also
       match the given description literally.  The -i flag allows a case-
       independent match and the -p flag allows a prefix match.

       The third variant purges all keys of the specified type and matching
       description using the key type's comparator in the kernel to match
       the description.  This permits the key type to match a key with a
       variety of descriptions.

   <b>Get persistent keyring</b>
       <b>keyctl </b>get_persistent &lt;keyring&gt; [&lt;uid&gt;]

       This command gets the persistent keyring for either the current UID
       or the specified UID and attaches it to the nominated keyring.  The
       persistent keyring's ID will be printed on stdout.

       The kernel will create the keyring if it doesn't exist and every time
       this command is called, will reset the expiration timeout on the
       keyring to the value in:

              /proc/sys/kernel/keys/persistent_keyring_expiry

       (by default three days).  Should the timeout be reached, the
       persistent keyring will be removed and everything it pins can then be
       garbage collected.

       If a UID other than the process's real or effective UIDs is
       specified, then an error will be given if the process does not have
       the CAP_SETUID capability.

   <b>Compute a Diffie-Hellman shared secret or public key</b>
       <b>keyctl </b>dh_compute &lt;private&gt; &lt;prime&gt; &lt;base&gt;

       This command computes either a Diffie-Hellman shared secret or the
       public key corresponding to the provided private key using the
       payloads of three keys. The computation is:

              base ^ private (mod prime)

       The three inputs must be user keys with read permission. If the
       provided base key contains the shared generator value, the public key
       will be computed.  If the provided base key contains the remote
       public key value, the shared secret will be computed.

       The result is printed to stdout as a hex dump.

              $ keyctl dh_compute $1 $2 $3
              8 bytes of data in result:
              00010203 04050607
</pre>
<h2><a id="ERRORS" href="#ERRORS"></a>ERRORS  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       There are a number of common errors returned by this program:

       "Not a directory" - a key wasn't a keyring.

       "Requested key not found" - the looked for key isn't available.

       "Key has been revoked" - a revoked key was accessed.

       "Key has expired" - an expired key was accessed.

       "Permission denied" - permission was denied by a UID/GID/mask
       combination.
</pre>
<h2><a id="SEE_ALSO" href="#SEE_ALSO"></a>SEE ALSO  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       <a href="keyctl.1.html">keyctl(1)</a>, <a href="../man2/keyctl.2.html">keyctl(2)</a>, <a href="../man2/request_key.2.html">request_key(2)</a>, <a href="../man3/keyctl.3.html">keyctl(3)</a>, <a href="../man5/request-key.conf.5.html">request-key.conf(5)</a>,
       <a href="../man7/keyrings.7.html">keyrings(7)</a>, <a href="../man8/request-key.8.html">request-key(8)</a>
</pre>
<h2><a id="COLOPHON" href="#COLOPHON"></a>COLOPHON  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       This page is part of the <i>keyutils</i> (key management utilities) project.
       Information about the project can be found at [unknown -- if you
       know, please contact man-pages@man7.org] If you have a bug report for
       this manual page, send it to keyrings@linux-nfs.org.  This page was
       obtained from the project's upstream Git repository 
       ⟨<a href="http://git.kernel.org/pub/scm/linux/kernel/git/dhowells/keyutils.git">http://git.kernel.org/pub/scm/linux/kernel/git/dhowells/keyutils.git</a>⟩
       on 2017-07-05.  If you discover any rendering problems in this HTML
       version of the page, or you believe there is a better or more up-to-
       date source for the page, or you have corrections or improvements to
       the information in this COLOPHON (which is <i>not</i> part of the original
       manual page), send a mail to man-pages@man7.org

<span class="footline">Linux                            20 Feb 2014                       KEYCTL(1)</span>
</pre>

<hr class="end-man-text" />
<p>Pages that refer to this page: 
    <a href="keyctl.1.html">keyctl(1)</a>,&nbsp; 
    <a href="systemd-ask-password.1.html">systemd-ask-password(1)</a>,&nbsp; 
    <a href="../man2/add_key.2.html">add_key(2)</a>,&nbsp; 
    <a href="../man2/keyctl.2.html">keyctl(2)</a>,&nbsp; 
    <a href="../man2/request_key.2.html">request_key(2)</a>,&nbsp; 
    <a href="../man3/keyctl.3.html">keyctl(3)</a>,&nbsp; 
    <a href="../man3/keyctl_chown.3.html">keyctl_chown(3)</a>,&nbsp; 
    <a href="../man3/keyctl_clear.3.html">keyctl_clear(3)</a>,&nbsp; 
    <a href="../man3/keyctl_describe.3.html">keyctl_describe(3)</a>,&nbsp; 
    <a href="../man3/keyctl_dh_compute.3.html">keyctl_dh_compute(3)</a>,&nbsp; 
    <a href="../man3/keyctl_get_keyring_ID.3.html">keyctl_get_keyring_ID(3)</a>,&nbsp; 
    <a href="../man3/keyctl_get_persistent.3.html">keyctl_get_persistent(3)</a>,&nbsp; 
    <a href="../man3/keyctl_get_security.3.html">keyctl_get_security(3)</a>,&nbsp; 
    <a href="../man3/keyctl_instantiate.3.html">keyctl_instantiate(3)</a>,&nbsp; 
    <a href="../man3/keyctl_invalidate.3.html">keyctl_invalidate(3)</a>,&nbsp; 
    <a href="../man3/keyctl_join_session_keyring.3.html">keyctl_join_session_keyring(3)</a>,&nbsp; 
    <a href="../man3/keyctl_link.3.html">keyctl_link(3)</a>,&nbsp; 
    <a href="../man3/keyctl_read.3.html">keyctl_read(3)</a>,&nbsp; 
    <a href="../man3/keyctl_revoke.3.html">keyctl_revoke(3)</a>,&nbsp; 
    <a href="../man3/keyctl_search.3.html">keyctl_search(3)</a>,&nbsp; 
    <a href="../man3/keyctl_session_to_parent.3.html">keyctl_session_to_parent(3)</a>,&nbsp; 
    <a href="../man3/keyctl_setperm.3.html">keyctl_setperm(3)</a>,&nbsp; 
    <a href="../man3/keyctl_set_reqkey_keyring.3.html">keyctl_set_reqkey_keyring(3)</a>,&nbsp; 
    <a href="../man3/keyctl_set_timeout.3.html">keyctl_set_timeout(3)</a>,&nbsp; 
    <a href="../man3/keyctl_update.3.html">keyctl_update(3)</a>,&nbsp; 
    <a href="../man5/request-key.conf.5.html">request-key.conf(5)</a>,&nbsp; 
    <a href="../man7/keyrings.7.html">keyrings(7)</a>,&nbsp; 
    <a href="../man7/keyutils.7.html">keyutils(7)</a>,&nbsp; 
    <a href="../man7/persistent-keyring.7.html">persistent-keyring(7)</a>,&nbsp; 
    <a href="../man7/process-keyring.7.html">process-keyring(7)</a>,&nbsp; 
    <a href="../man7/session-keyring.7.html">session-keyring(7)</a>,&nbsp; 
    <a href="../man7/thread-keyring.7.html">thread-keyring(7)</a>,&nbsp; 
    <a href="../man7/user-keyring.7.html">user-keyring(7)</a>,&nbsp; 
    <a href="../man7/user-session-keyring.7.html">user-session-keyring(7)</a>,&nbsp; 
    <a href="../man8/e4crypt.8.html">e4crypt(8)</a>,&nbsp; 
    <a href="../man8/pam_keyinit.8.html">pam_keyinit(8)</a>,&nbsp; 
    <a href="../man8/request-key.8.html">request-key(8)</a>
</p>
<hr/>

 
<hr class="start-footer" />

<div class="footer"> 

<table class="colophon-table">
    <tr>
    <td class="pub-info">
        <p>
            HTML rendering created 2017-07-13
            by <a href="http://man7.org/mtk/index.html">Michael Kerrisk</a>, 
            author of 
            <a href="http://man7.org/tlpi/"><em>The Linux Programming Interface</em></a>, 
            maintainer of the 
            <a href="https://www.kernel.org/doc/man-pages/">Linux <em>man-pages</em> project</a>.
        </p>
        <p>
            For details of in-depth
            <strong>Linux/UNIX system programming training courses</strong>
            that I teach, look <a href="http://man7.org/training/">here</a>.
        </p>
        <p>
            Hosting by <a href="http://www.jambit.com/index_en.html">jambit GmbH</a>.
        </p>
        <p>
            <a href="http://validator.w3.org/check?uri=referer">
            <img src="http://www.w3.org/Icons/valid-xhtml11"
                alt="Valid XHTML 1.1" height="31" width="88" />
            </a>
        </p>
    </td>
    <td class="colophon-divider">
    </td>
    <td class="tlpi-cover">
        <a href="http://man7.org/tlpi/"><img src="../../../tlpi/cover/TLPI-front-cover-vsmall.png" alt="Cover of TLPI" /></a>
    </td>
    </tr>
</table>

</div>

<hr class="end-footer" />



<!--BEGIN-SITETRACKING-->
<!-- SITETRACKING.man7.org_linux_man-pages -->

<!-- Start of StatCounter Code (xhtml) -->

<script type="text/javascript">
//<![CDATA[
var sc_project=7422636; 
var sc_invisible=1; 
var sc_security="9b6714ff"; 
//]]>
</script>
<script type="text/javascript"
src="../../../../www.statcounter.com/counter/counter_xhtml.js"></script>
<noscript><div class="statcounter"><a title="website
statistics" href="http://statcounter.com/"
class="statcounter"><img class="statcounter"
src="http://c.statcounter.com/7422636/0/9b6714ff/1/"
alt="website statistics" /></a></div></noscript>

<!-- End of StatCounter Code -->


<!-- Start of Google Analytics Code -->

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-9830363-8']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<!-- End of Google Analytics Code -->

<!--END-SITETRACKING-->

</body>
</html>
