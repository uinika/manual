
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
        "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
    <link rel="stylesheet" type="text/css" href="../../../style.css" title="style" />
    <link rel="stylesheet" type="text/css" href="../style.css" title="style" />
    <meta http-equiv="content-type" content="text/html;charset=utf-8" />

    <title>mdadm(8) - Linux manual page</title>
</head>

<body>

<div class="page-top"><a id="top_of_page"></a></div>
<!--%%%TOP_BAR%%%-->
    <div class="nav-bar">
        <table class="nav-table">
            <tr>
                <td class="nav-cell">
                    <p class="nav-text">
                        <a href="http://man7.org/index.html">man7.org</a> &gt; Linux &gt; <a href="../index.html">man-pages</a>
                    </p>
                </td>
                <td class="training-cell">
                    <p class="training-text"><a class="training-link" href="http://man7.org/training/">Linux/UNIX system programming training</a></p>
                </td>
            </tr>
        </table>
    </div>

<hr class="nav-end" />

<!--%%%PAGE_START%%%-->


<table class="sec-table">
<tr>
    <td>
        <p class="section-dir">
<a href="#NAME">NAME</a> | <a href="#SYNOPSIS">SYNOPSIS</a> | <a href="#DESCRIPTION">DESCRIPTION</a> | <a href="#MODES">MODES</a> | <a href="#OPTIONS">OPTIONS</a> | <a href="#Options_for_selecting_a_mode_are:">Options&nbsp;for&nbsp;selecting&nbsp;a&nbsp;mode&nbsp;are:</a> | <a href="#Options_that_are_not_mode-specific_are:">Options&nbsp;that&nbsp;are&nbsp;not&nbsp;mode-specific&nbsp;are:</a> | <a href="#For_create,_build,_or_grow:">For&nbsp;create,&nbsp;build,&nbsp;or&nbsp;grow:</a> | <a href="#For_assemble:">For&nbsp;assemble:</a> | <a href="#For_Manage_mode:">For&nbsp;Manage&nbsp;mode:</a> | <a href="#For_Misc_mode:">For&nbsp;Misc&nbsp;mode:</a> | <a href="#For_Incremental_Assembly_mode:">For&nbsp;Incremental&nbsp;Assembly&nbsp;mode:</a> | <a href="#For_Monitor_mode:">For&nbsp;Monitor&nbsp;mode:</a> | <a href="#ASSEMBLE_MODE">ASSEMBLE&nbsp;MODE</a> | <a href="#BUILD_MODE">BUILD&nbsp;MODE</a> | <a href="#CREATE_MODE">CREATE&nbsp;MODE</a> | <a href="#MANAGE_MODE">MANAGE&nbsp;MODE</a> | <a href="#MISC_MODE">MISC&nbsp;MODE</a> | <a href="#MONITOR_MODE">MONITOR&nbsp;MODE</a> | <a href="#GROW_MODE">GROW&nbsp;MODE</a> | <a href="#INCREMENTAL_MODE">INCREMENTAL&nbsp;MODE</a> | <a href="#ENVIRONMENT">ENVIRONMENT</a> | <a href="#EXAMPLES">EXAMPLES</a> | <a href="#FILES">FILES</a> | <a href="#DEVICE_NAMES">DEVICE&nbsp;NAMES</a> | <a href="#NOTE">NOTE</a> | <a href="#SEE_ALSO">SEE&nbsp;ALSO</a> | <a href="#COLOPHON">COLOPHON</a>
        </p>
    </td>
    <td class="search-box">
        <div class="man-search-box">

            <form method="get" action="http://www.google.com/search">
                <fieldset class="man-search">
                    <input type="text" name="q" size="10" maxlength="255" value="" />
                    <input type="hidden" name="sitesearch" value="man7.org/linux/man-pages" />
                    <input type="submit" name="sa" value="Search online pages" />
                </fieldset>
            </form>

        </div>
    </td>
    <td> </td>
</tr>
</table>

<pre>
<span class="headline">MDADM(8)                   System Manager's Manual                  MDADM(8)</span>
</pre>
<h2><a id="NAME" href="#NAME"></a>NAME  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       mdadm - manage MD devices <i>aka</i> Linux Software RAID
</pre>
<h2><a id="SYNOPSIS" href="#SYNOPSIS"></a>SYNOPSIS  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       <b>mdadm </b><i>[mode] &lt;raiddevice&gt; [options] &lt;component-devices&gt;</i>
</pre>
<h2><a id="DESCRIPTION" href="#DESCRIPTION"></a>DESCRIPTION  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       RAID devices are virtual devices created from two or more real block
       devices.  This allows multiple devices (typically disk drives or
       partitions thereof) to be combined into a single device to hold (for
       example) a single filesystem.  Some RAID levels include redundancy
       and so can survive some degree of device failure.

       Linux Software RAID devices are implemented through the md (Multiple
       Devices) device driver.

       Currently, Linux supports <b>LINEAR </b>md devices, <b>RAID0 </b>(striping), <b>RAID1</b>
       (mirroring), <b>RAID4</b>, <b>RAID5</b>, <b>RAID6</b>, <b>RAID10</b>, <b>MULTIPATH</b>, <b>FAULTY</b>, and
       <b>CONTAINER</b>.

       <b>MULTIPATH </b>is not a Software RAID mechanism, but does involve multiple
       devices: each device is a path to one common physical storage device.
       New installations should not use md/multipath as it is not well
       supported and has no ongoing development.  Use the Device Mapper
       based multipath-tools instead.

       <b>FAULTY </b>is also not true RAID, and it only involves one device.  It
       provides a layer over a true device that can be used to inject
       faults.

       <b>CONTAINER </b>is different again.  A <b>CONTAINER </b>is a collection of devices
       that are managed as a set.  This is similar to the set of devices
       connected to a hardware RAID controller.  The set of devices may
       contain a number of different RAID arrays each utilising some (or
       all) of the blocks from a number of the devices in the set.  For
       example, two devices in a 5-device set might form a RAID1 using the
       whole devices.  The remaining three might have a RAID5 over the first
       half of each device, and a RAID0 over the second half.

       With a <b>CONTAINER</b>, there is one set of metadata that describes all of
       the arrays in the container.  So when <i>mdadm</i> creates a <b>CONTAINER</b>
       device, the device just represents the metadata.  Other normal arrays
       (RAID1 etc) can be created inside the container.
</pre>
<h2><a id="MODES" href="#MODES"></a>MODES  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       mdadm has several major modes of operation:

       <b>Assemble</b>
              Assemble the components of a previously created array into an
              active array.  Components can be explicitly given or can be
              searched for.  <i>mdadm</i> checks that the components do form a bona
              fide array, and can, on request, fiddle superblock information
              so as to assemble a faulty array.

       <b>Build  </b>Build an array that doesn't have per-device metadata
              (superblocks).  For these sorts of arrays, <i>mdadm</i> cannot
              differentiate between initial creation and subsequent assembly
              of an array.  It also cannot perform any checks that
              appropriate components have been requested.  Because of this,
              the <b>Build </b>mode should only be used together with a complete
              understanding of what you are doing.

       <b>Create </b>Create a new array with per-device metadata (superblocks).
              Appropriate metadata is written to each device, and then the
              array comprising those devices is activated.  A 'resync'
              process is started to make sure that the array is consistent
              (e.g. both sides of a mirror contain the same data) but the
              content of the device is left otherwise untouched.  The array
              can be used as soon as it has been created.  There is no need
              to wait for the initial resync to finish.

       <b>Follow or Monitor</b>
              Monitor one or more md devices and act on any state changes.
              This is only meaningful for RAID1, 4, 5, 6, 10 or multipath
              arrays, as only these have interesting state.  RAID0 or Linear
              never have missing, spare, or failed drives, so there is
              nothing to monitor.

       <b>Grow   </b>Grow (or shrink) an array, or otherwise reshape it in some
              way.  Currently supported growth options including changing
              the active size of component devices and changing the number
              of active devices in Linear and RAID levels 0/1/4/5/6,
              changing the RAID level between 0, 1, 5, and 6, and between 0
              and 10, changing the chunk size and layout for RAID 0,4,5,6,10
              as well as adding or removing a write-intent bitmap.

       <b>Incremental Assembly</b>
              Add a single device to an appropriate array.  If the addition
              of the device makes the array runnable, the array will be
              started.  This provides a convenient interface to a <i>hot-plug</i>
              system.  As each device is detected, <i>mdadm</i> has a chance to
              include it in some array as appropriate.  Optionally, when the
              <i>--fail</i> flag is passed in we will remove the device from any
              active array instead of adding it.

              If a <b>CONTAINER </b>is passed to <i>mdadm</i> in this mode, then any
              arrays within that container will be assembled and started.

       <b>Manage </b>This is for doing things to specific components of an array
              such as adding new spares and removing faulty devices.

       <b>Misc   </b>This is an 'everything else' mode that supports operations on
              active arrays, operations on component devices such as erasing
              old superblocks, and information gathering operations.

       <b>Auto-detect</b>
              This mode does not act on a specific device or array, but
              rather it requests the Linux Kernel to activate any auto-
              detected arrays.
</pre>
<h2><a id="OPTIONS" href="#OPTIONS"></a>OPTIONS  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
</pre>
<h2><a id="Options_for_selecting_a_mode_are:" href="#Options_for_selecting_a_mode_are:"></a>Options for selecting a mode are:  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       <b>-A</b>, <b>--assemble</b>
              Assemble a pre-existing array.

       <b>-B</b>, <b>--build</b>
              Build a legacy array without superblocks.

       <b>-C</b>, <b>--create</b>
              Create a new array.

       <b>-F</b>, <b>--follow</b>, <b>--monitor</b>
              Select <b>Monitor </b>mode.

       <b>-G</b>, <b>--grow</b>
              Change the size or shape of an active array.

       <b>-I</b>, <b>--incremental</b>
              Add/remove a single device to/from an appropriate array, and
              possibly start the array.

       <b>--auto-detect</b>
              Request that the kernel starts any auto-detected arrays.  This
              can only work if <i>md</i> is compiled into the kernel — not if it is
              a module.  Arrays can be auto-detected by the kernel if all
              the components are in primary MS-DOS partitions with partition
              type <b>FD</b>, and all use v0.90 metadata.  In-kernel autodetect is
              not recommended for new installations.  Using <i>mdadm</i> to detect
              and assemble arrays — possibly in an <i>initrd</i> — is substantially
              more flexible and should be preferred.

       If a device is given before any options, or if the first option is
       one of <b>--add</b>, <b>--re-add</b>, <b>--add-spare</b>, <b>--fail</b>, <b>--remove</b>, or <b>--replace</b>,
       then the MANAGE mode is assumed.  Anything other than these will
       cause the <b>Misc </b>mode to be assumed.
</pre>
<h2><a id="Options_that_are_not_mode-specific_are:" href="#Options_that_are_not_mode-specific_are:"></a>Options that are not mode-specific are:  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       <b>-h</b>, <b>--help</b>
              Display general help message or, after one of the above
              options, a mode-specific help message.

       <b>--help-options</b>
              Display more detailed help about command line parsing and some
              commonly used options.

       <b>-V</b>, <b>--version</b>
              Print version information for mdadm.

       <b>-v</b>, <b>--verbose</b>
              Be more verbose about what is happening.  This can be used
              twice to be extra-verbose.  The extra verbosity currently only
              affects <b>--detail --scan </b>and <b>--examine --scan</b>.

       <b>-q</b>, <b>--quiet</b>
              Avoid printing purely informative messages.  With this, <i>mdadm</i>
              will be silent unless there is something really important to
              report.

       <b>-f</b>, <b>--force</b>
              Be more forceful about certain operations.  See the various
              modes for the exact meaning of this option in different
              contexts.

       <b>-c</b>, <b>--config=</b>
              Specify the config file or directory.  Default is to use
              <b>/etc/mdadm.conf </b>and <b>/etc/mdadm.conf.d</b>, or if those are missing
              then <b>/etc/mdadm/mdadm.conf </b>and <b>/etc/mdadm/mdadm.conf.d</b>.  If
              the config file given is <b>partitions </b>then nothing will be read,
              but <i>mdadm</i> will act as though the config file contained exactly
                  <b>DEVICE partitions containers</b>
              and will read <b>/proc/partitions </b>to find a list of devices to
              scan, and <b>/proc/mdstat </b>to find a list of containers to
              examine.  If the word <b>none </b>is given for the config file, then
              <i>mdadm</i> will act as though the config file were empty.

              If the name given is of a directory, then <i>mdadm</i> will collect
              all the files contained in the directory with a name ending in
              <b>.conf</b>, sort them lexically, and process all of those files as
              config files.

       <b>-s</b>, <b>--scan</b>
              Scan config file or <b>/proc/mdstat </b>for missing information.  In
              general, this option gives <i>mdadm</i> permission to get any missing
              information (like component devices, array devices, array
              identities, and alert destination) from the configuration file
              (see previous option); one exception is MISC mode when using
              <b>--detail </b>or <b>--stop, </b>in which case <b>--scan </b>says to get a list of
              array devices from <b>/proc/mdstat</b>.

       <b>-e</b>, <b>--metadata=</b>
              Declare the style of RAID metadata (superblock) to be used.
              The default is 1.2 for <b>--create</b>, and to guess for other
              operations.  The default can be overridden by setting the
              <b>metadata </b>value for the <b>CREATE </b>keyword in <b>mdadm.conf</b>.

              Options are:

              0, 0.90
                     Use the original 0.90 format superblock.  This format
                     limits arrays to 28 component devices and limits
                     component devices of levels 1 and greater to 2
                     terabytes.  It is also possible for there to be
                     confusion about whether the superblock applies to a
                     whole device or just the last partition, if that
                     partition starts on a 64K boundary.

              1, 1.0, 1.1, 1.2 default
                     Use the new version-1 format superblock.  This has
                     fewer restrictions.  It can easily be moved between
                     hosts with different endian-ness, and a recovery
                     operation can be checkpointed and restarted.  The
                     different sub-versions store the superblock at
                     different locations on the device, either at the end
                     (for 1.0), at the start (for 1.1) or 4K from the start
                     (for 1.2).  "1" is equivalent to "1.2" (the commonly
                     preferred 1.x format).  "default" is equivalent to
                     "1.2".

              ddf    Use the "Industry Standard" DDF (Disk Data Format)
                     format defined by SNIA.  When creating a DDF array a
                     <b>CONTAINER </b>will be created, and normal arrays can be
                     created in that container.

              imsm   Use the Intel(R) Matrix Storage Manager metadata
                     format.  This creates a <b>CONTAINER </b>which is managed in a
                     similar manner to DDF, and is supported by an option-
                     rom on some platforms:

                     <b><a href="http://www.intel.com/design/chipsets/matrixstorage_sb.htm">http://www.intel.com/design/chipsets/matrixstorage_sb.htm</a> </b>

       <b>--homehost=</b>
              This will override any <b>HOMEHOST </b>setting in the config file and
              provides the identity of the host which should be considered
              the home for any arrays.

              When creating an array, the <b>homehost </b>will be recorded in the
              metadata.  For version-1 superblocks, it will be prefixed to
              the array name.  For version-0.90 superblocks, part of the
              SHA1 hash of the hostname will be stored in the later half of
              the UUID.

              When reporting information about an array, any array which is
              tagged for the given homehost will be reported as such.

              When using Auto-Assemble, only arrays tagged for the given
              homehost will be allowed to use 'local' names (i.e. not ending
              in '_' followed by a digit string).  See below under <b>Auto</b>
              <b>Assembly</b>.

              The special name "<b>any</b>" can be used as a wild card.  If an
              array is created with <b>--homehost=any </b>then the name "<b>any</b>" will
              be stored in the array and it can be assembled in the same way
              on any host.  If an array is assembled with this option, then
              the homehost recorded on the array will be ignored.

       <b>--prefer=</b>
              When <i>mdadm</i> needs to print the name for a device it normally
              finds the name in <b>/dev </b>which refers to the device and is
              shortest.  When a path component is given with <b>--prefer </b><i>mdadm</i>
              will prefer a longer name if it contains that component.  For
              example <b>--prefer=by-uuid </b>will prefer a name in a subdirectory
              of <b>/dev </b>called <b>by-uuid</b>.

              This functionality is currently only provided by <b>--detail </b>and
              <b>--monitor</b>.

       <b>--home-cluster=</b>
              specifies the cluster name for the md device. The md device
              can be assembled only on the cluster which matches the name
              specified. If this option is not provided, mdadm tries to
              detect the cluster name automatically.
</pre>
<h2><a id="For_create,_build,_or_grow:" href="#For_create,_build,_or_grow:"></a>For create, build, or grow:  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       <b>-n</b>, <b>--raid-devices=</b>
              Specify the number of active devices in the array.  This, plus
              the number of spare devices (see below) must equal the number
              of <i>component-devices</i> (including "<b>missing</b>" devices) that are
              listed on the command line for <b>--create</b>.  Setting a value of 1
              is probably a mistake and so requires that <b>--force </b>be
              specified first.  A value of 1 will then be allowed for
              linear, multipath, RAID0 and RAID1.  It is never allowed for
              RAID4, RAID5 or RAID6.
              This number can only be changed using <b>--grow </b>for RAID1, RAID4,
              RAID5 and RAID6 arrays, and only on kernels which provide the
              necessary support.

       <b>-x</b>, <b>--spare-devices=</b>
              Specify the number of spare (eXtra) devices in the initial
              array.  Spares can also be added and removed later.  The
              number of component devices listed on the command line must
              equal the number of RAID devices plus the number of spare
              devices.

       <b>-z</b>, <b>--size=</b>
              Amount (in Kilobytes) of space to use from each drive in RAID
              levels 1/4/5/6.  This must be a multiple of the chunk size,
              and must leave about 128Kb of space at the end of the drive
              for the RAID superblock.  If this is not specified (as it
              normally is not) the smallest drive (or partition) sets the
              size, though if there is a variance among the drives of
              greater than 1%, a warning is issued.

              A suffix of 'K', 'M' or 'G' can be given to indicate
              Kilobytes, Megabytes or Gigabytes respectively.

              Sometimes a replacement drive can be a little smaller than the
              original drives though this should be minimised by IDEMA
              standards.  Such a replacement drive will be rejected by <i>md</i>.
              To guard against this it can be useful to set the initial size
              slightly smaller than the smaller device with the aim that it
              will still be larger than any replacement.

              This value can be set with <b>--grow </b>for RAID level 1/4/5/6
              though <b>CONTAINER </b>based arrays such as those with IMSM metadata
              may not be able to support this.  If the array was created
              with a size smaller than the currently active drives, the
              extra space can be accessed using <b>--grow</b>.  The size can be
              given as <b>max </b>which means to choose the largest size that fits
              on all current drives.

              Before reducing the size of the array (with <b>--grow --size=</b>)
              you should make sure that space isn't needed.  If the device
              holds a filesystem, you would need to resize the filesystem to
              use less space.

              After reducing the array size you should check that the data
              stored in the device is still available.  If the device holds
              a filesystem, then an 'fsck' of the filesystem is a minimum
              requirement.  If there are problems the array can be made
              bigger again with no loss with another <b>--grow --size= </b>command.

              This value cannot be used when creating a <b>CONTAINER </b>such as
              with DDF and IMSM metadata, though it perfectly valid when
              creating an array inside a container.

       <b>-Z</b>, <b>--array-size=</b>
              This is only meaningful with <b>--grow </b>and its effect is not
              persistent: when the array is stopped and restarted the
              default array size will be restored.

              Setting the array-size causes the array to appear smaller to
              programs that access the data.  This is particularly needed
              before reshaping an array so that it will be smaller.  As the
              reshape is not reversible, but setting the size with <b>--array-</b>
              <b>size </b>is, it is required that the array size is reduced as
              appropriate before the number of devices in the array is
              reduced.

              Before reducing the size of the array you should make sure
              that space isn't needed.  If the device holds a filesystem,
              you would need to resize the filesystem to use less space.

              After reducing the array size you should check that the data
              stored in the device is still available.  If the device holds
              a filesystem, then an 'fsck' of the filesystem is a minimum
              requirement.  If there are problems the array can be made
              bigger again with no loss with another <b>--grow --array-size=</b>
              command.

              A suffix of 'K', 'M' or 'G' can be given to indicate
              Kilobytes, Megabytes or Gigabytes respectively.  A value of
              <b>max </b>restores the apparent size of the array to be whatever the
              real amount of available space is.

       <b>-c</b>, <b>--chunk=</b>
              Specify chunk size of kilobytes.  The default when creating an
              array is 512KB.  To ensure compatibility with earlier
              versions, the default when building an array with no
              persistent metadata is 64KB.  This is only meaningful for
              RAID0, RAID4, RAID5, RAID6, and RAID10.

              RAID4, RAID5, RAID6, and RAID10 require the chunk size to be a
              power of 2.  In any case it must be a multiple of 4KB.

              A suffix of 'K', 'M' or 'G' can be given to indicate
              Kilobytes, Megabytes or Gigabytes respectively.

       <b>--rounding=</b>
              Specify rounding factor for a Linear array.  The size of each
              component will be rounded down to a multiple of this size.
              This is a synonym for <b>--chunk </b>but highlights the different
              meaning for Linear as compared to other RAID levels.  The
              default is 64K if a kernel earlier than 2.6.16 is in use, and
              is 0K (i.e. no rounding) in later kernels.

       <b>-l</b>, <b>--level=</b>
              Set RAID level.  When used with <b>--create</b>, options are: linear,
              raid0, 0, stripe, raid1, 1, mirror, raid4, 4, raid5, 5, raid6,
              6, raid10, 10, multipath, mp, faulty, container.  Obviously
              some of these are synonymous.

              When a <b>CONTAINER </b>metadata type is requested, only the
              <b>container </b>level is permitted, and it does not need to be
              explicitly given.

              When used with <b>--build</b>, only linear, stripe, raid0, 0, raid1,
              multipath, mp, and faulty are valid.

              Can be used with <b>--grow </b>to change the RAID level in some
              cases.  See LEVEL CHANGES below.

       <b>-p</b>, <b>--layout=</b>
              This option configures the fine details of data layout for
              RAID5, RAID6, and RAID10 arrays, and controls the failure
              modes for <i>faulty</i>.

              The layout of the RAID5 parity block can be one of
              <b>left-asymmetric</b>, <b>left-symmetric</b>, <b>right-asymmetric</b>,
              <b>right-symmetric</b>, <b>la</b>, <b>ra</b>, <b>ls</b>, <b>rs</b>.  The default is
              <b>left-symmetric</b>.

              It is also possible to cause RAID5 to use a RAID4-like layout
              by choosing <b>parity-first</b>, or <b>parity-last</b>.

              Finally for RAID5 there are DDF-compatible layouts,
              <b>ddf-zero-restart</b>, <b>ddf-N-restart</b>, and <b>ddf-N-continue</b>.

              These same layouts are available for RAID6.  There are also 4
              layouts that will provide an intermediate stage for converting
              between RAID5 and RAID6.  These provide a layout which is
              identical to the corresponding RAID5 layout on the first N-1
              devices, and has the 'Q' syndrome (the second 'parity' block
              used by RAID6) on the last device.  These layouts are:
              <b>left-symmetric-6</b>, <b>right-symmetric-6</b>, <b>left-asymmetric-6</b>,
              <b>right-asymmetric-6</b>, and <b>parity-first-6</b>.

              When setting the failure mode for level <i>faulty,</i> the options
              are: <b>write-transient</b>, <b>wt</b>, <b>read-transient</b>, <b>rt</b>,
              <b>write-persistent</b>, <b>wp</b>, <b>read-persistent</b>, <b>rp</b>, <b>write-all</b>,
              <b>read-fixable</b>, <b>rf</b>, <b>clear</b>, <b>flush</b>, <b>none</b>.

              Each failure mode can be followed by a number, which is used
              as a period between fault generation.  Without a number, the
              fault is generated once on the first relevant request.  With a
              number, the fault will be generated after that many requests,
              and will continue to be generated every time the period
              elapses.

              Multiple failure modes can be current simultaneously by using
              the <b>--grow </b>option to set subsequent failure modes.

              "clear" or "none" will remove any pending or periodic failure
              modes, and "flush" will clear any persistent faults.

              Finally, the layout options for RAID10 are one of 'n', 'o' or
              'f' followed by a small number.  The default is 'n2'.  The
              supported options are:

              <i>'n'</i> signals 'near' copies.  Multiple copies of one data block
              are at similar offsets in different devices.

              <i>'o'</i> signals 'offset' copies.  Rather than the chunks being
              duplicated within a stripe, whole stripes are duplicated but
              are rotated by one device so duplicate blocks are on different
              devices.  Thus subsequent copies of a block are in the next
              drive, and are one chunk further down.

              <i>'f'</i> signals 'far' copies (multiple copies have very different
              offsets).  See md(4) for more detail about 'near', 'offset',
              and 'far'.

              The number is the number of copies of each datablock.  2 is
              normal, 3 can be useful.  This number can be at most equal to
              the number of devices in the array.  It does not need to
              divide evenly into that number (e.g. it is perfectly legal to
              have an 'n2' layout for an array with an odd number of
              devices).

              When an array is converted between RAID5 and RAID6 an
              intermediate RAID6 layout is used in which the second parity
              block (Q) is always on the last device.  To convert a RAID5 to
              RAID6 and leave it in this new layout (which does not require
              re-striping) use <b>--layout=preserve</b>.  This will try to avoid
              any restriping.

              The converse of this is <b>--layout=normalise </b>which will change a
              non-standard RAID6 layout into a more standard arrangement.

       <b>--parity=</b>
              same as <b>--layout </b>(thus explaining the p of <b>-p</b>).

       <b>-b</b>, <b>--bitmap=</b>
              Specify a file to store a write-intent bitmap in.  The file
              should not exist unless <b>--force </b>is also given.  The same file
              should be provided when assembling the array.  If the word
              <b>internal </b>is given, then the bitmap is stored with the metadata
              on the array, and so is replicated on all devices.  If the
              word <b>none </b>is given with <b>--grow </b>mode, then any bitmap that is
              present is removed. If the word <b>clustered </b>is given, the array
              is created for a clustered environment. One bitmap is created
              for each node as defined by the <b>--nodes </b>parameter and are
              stored internally.

              To help catch typing errors, the filename must contain at
              least one slash ('/') if it is a real file (not 'internal' or
              'none').

              Note: external bitmaps are only known to work on ext2 and
              ext3.  Storing bitmap files on other filesystems may result in
              serious problems.

              When creating an array on devices which are 100G or larger,
              <i>mdadm</i> automatically adds an internal bitmap as it will usually
              be beneficial.  This can be suppressed with <b>--bitmap=none .</b>

       <b>--bitmap-chunk=</b>
              Set the chunksize of the bitmap.  Each bit corresponds to that
              many Kilobytes of storage.  When using a file based bitmap,
              the default is to use the smallest size that is at-least 4 and
              requires no more than 2^21 chunks.  When using an <b>internal</b>
              bitmap, the chunksize defaults to 64Meg, or larger if
              necessary to fit the bitmap into the available space.

              A suffix of 'K', 'M' or 'G' can be given to indicate
              Kilobytes, Megabytes or Gigabytes respectively.

       <b>-W</b>, <b>--write-mostly</b>
              subsequent devices listed in a <b>--build</b>, <b>--create</b>, or <b>--add</b>
              command will be flagged as 'write-mostly'.  This is valid for
              RAID1 only and means that the 'md' driver will avoid reading
              from these devices if at all possible.  This can be useful if
              mirroring over a slow link.

       <b>--write-behind=</b>
              Specify that write-behind mode should be enabled (valid for
              RAID1 only).  If an argument is specified, it will set the
              maximum number of outstanding writes allowed.  The default
              value is 256.  A write-intent bitmap is required in order to
              use write-behind mode, and write-behind is only attempted on
              drives marked as <i>write-mostly</i>.

       <b>--failfast</b>
              subsequent devices listed in a <b>--create </b>or <b>--add </b>command will
              be flagged as  'failfast'.  This is valid for RAID1 and RAID10
              only.  IO requests to these devices will be encouraged to fail
              quickly rather than cause long delays due to error handling.
              Also no attempt is made to repair a read error on these
              devices.

              If an array becomes degraded so that the 'failfast' device is
              the only usable device, the 'failfast' flag will then be
              ignored and extended delays will be preferred to complete
              failure.

              The 'failfast' flag is appropriate for storage arrays which
              have a low probability of true failure, but which may
              sometimes cause unacceptable delays due to internal
              maintenance functions.

       <b>--assume-clean</b>
              Tell <i>mdadm</i> that the array pre-existed and is known to be
              clean.  It can be useful when trying to recover from a major
              failure as you can be sure that no data will be affected
              unless you actually write to the array.  It can also be used
              when creating a RAID1 or RAID10 if you want to avoid the
              initial resync, however this practice — while normally safe —
              is not recommended.  Use this only if you really know what you
              are doing.

              When the devices that will be part of a new array were filled
              with zeros before creation the operator knows the array is
              actually clean. If that is the case, such as after running
              badblocks, this argument can be used to tell mdadm the facts
              the operator knows.

              When an array is resized to a larger size with <b>--grow --size=</b>
              the new space is normally resynced in that same way that the
              whole array is resynced at creation.  From Linux version 3.0,
              <b>--assume-clean </b>can be used with that command to avoid the
              automatic resync.

       <b>--backup-file=</b>
              This is needed when <b>--grow </b>is used to increase the number of
              raid-devices in a RAID5 or RAID6 if there are no spare devices
              available, or to shrink, change RAID level or layout.  See the
              GROW MODE section below on RAID-DEVICES CHANGES.  The file
              must be stored on a separate device, not on the RAID array
              being reshaped.

       <b>--data-offset=</b>
              Arrays with 1.x metadata can leave a gap between the start of
              the device and the start of array data.  This gap can be used
              for various metadata.  The start of data is known as the
              <i>data-offset</i>.  Normally an appropriate data offset is computed
              automatically.  However it can be useful to set it explicitly
              such as when re-creating an array which was originally created
              using a different version of <i>mdadm</i> which computed a different
              offset.

              Setting the offset explicitly over-rides the default.  The
              value given is in Kilobytes unless a suffix of 'K', 'M' or 'G'
              is used to explicitly indicate Kilobytes, Megabytes or
              Gigabytes respectively.

              Since Linux 3.4, <b>--data-offset </b>can also be used with <b>--grow</b>
              for some RAID levels (initially on RAID10).  This allows the
              data-offset to be changed as part of the reshape process.
              When the data offset is changed, no backup file is required as
              the difference in offsets is used to provide the same
              functionality.

              When the new offset is earlier than the old offset, the number
              of devices in the array cannot shrink.  When it is after the
              old offset, the number of devices in the array cannot
              increase.

              When creating an array, <b>--data-offset </b>can be specified as
              <b>variable</b>.  In the case each member device is expected to have
              a offset appended to the name, separated by a colon.  This
              makes it possible to recreate exactly an array which has
              varying data offsets (as can happen when different versions of
              <i>mdadm</i> are used to add different devices).

       <b>--continue</b>
              This option is complementary to the <b>--freeze-reshape </b>option
              for assembly. It is needed when <b>--grow </b>operation is
              interrupted and it is not restarted automatically due to
              <b>--freeze-reshape </b>usage during array assembly.  This option is
              used together with <b>-G </b>, ( <b>--grow </b>) command and device for a
              pending reshape to be continued.  All parameters required for
              reshape continuation will be read from array metadata.  If
              initial <b>--grow </b>command had required <b>--backup-file= </b>option to
              be set, continuation option will require to have exactly the
              same backup file given as well.

              Any other parameter passed together with <b>--continue </b>option
              will be ignored.

       <b>-N</b>, <b>--name=</b>
              Set a <b>name </b>for the array.  This is currently only effective
              when creating an array with a version-1 superblock, or an
              array in a DDF container.  The name is a simple textual string
              that can be used to identify array components when assembling.
              If name is needed but not specified, it is taken from the
              basename of the device that is being created.  e.g. when
              creating <i>/dev/md/home</i> the <b>name </b>will default to <i>home</i>.

       <b>-R</b>, <b>--run</b>
              Insist that <i>mdadm</i> run the array, even if some of the
              components appear to be active in another array or filesystem.
              Normally <i>mdadm</i> will ask for confirmation before including such
              components in an array.  This option causes that question to
              be suppressed.

       <b>-f</b>, <b>--force</b>
              Insist that <i>mdadm</i> accept the geometry and layout specified
              without question.  Normally <i>mdadm</i> will not allow creation of
              an array with only one device, and will try to create a RAID5
              array with one missing drive (as this makes the initial resync
              work faster).  With <b>--force</b>, <i>mdadm</i> will not try to be so
              clever.

       <b>-o</b>, <b>--readonly</b>
              Start the array <b>read only </b>rather than read-write as normal.
              No writes will be allowed to the array, and no resync,
              recovery, or reshape will be started.

       <b>-a</b>, <b>--auto{=yes,md,mdp,part,p}{NN}</b>
              Instruct mdadm how to create the device file if needed,
              possibly allocating an unused minor number.  "md" causes a
              non-partitionable array to be used (though since Linux 2.6.28,
              these array devices are in fact partitionable).  "mdp", "part"
              or "p" causes a partitionable array (2.6 and later) to be
              used.  "yes" requires the named md device to have a 'standard'
              format, and the type and minor number will be determined from
              this.  With mdadm 3.0, device creation is normally left up to
              <i>udev</i> so this option is unlikely to be needed.  See DEVICE
              NAMES below.

              The argument can also come immediately after "-a".  e.g.
              "-ap".

              If <b>--auto </b>is not given on the command line or in the config
              file, then the default will be <b>--auto=yes</b>.

              If <b>--scan </b>is also given, then any <i>auto=</i> entries in the config
              file will override the <b>--auto </b>instruction given on the command
              line.

              For partitionable arrays, <i>mdadm</i> will create the device file
              for the whole array and for the first 4 partitions.  A
              different number of partitions can be specified at the end of
              this option (e.g.  <b>--auto=p7</b>).  If the device name ends with a
              digit, the partition names add a 'p', and a number, e.g.
              <i>/dev/md/home1p3</i>.  If there is no trailing digit, then the
              partition names just have a number added, e.g.
              <i>/dev/md/scratch3</i>.

              If the md device name is in a 'standard' format as described
              in DEVICE NAMES, then it will be created, if necessary, with
              the appropriate device number based on that name.  If the
              device name is not in one of these formats, then a unused
              device number will be allocated.  The device number will be
              considered unused if there is no active array for that number,
              and there is no entry in /dev for that number and with a non-
              standard name.  Names that are not in 'standard' format are
              only allowed in "/dev/md/".

              This is meaningful with <b>--create </b>or <b>--build</b>.

       <b>-a</b>, <b>--add</b>
              This option can be used in Grow mode in two cases.

              If the target array is a Linear array, then <b>--add </b>can be used
              to add one or more devices to the array.  They are simply
              catenated on to the end of the array.  Once added, the devices
              cannot be removed.

              If the <b>--raid-disks </b>option is being used to increase the
              number of devices in an array, then <b>--add </b>can be used to add
              some extra devices to be included in the array.  In most cases
              this is not needed as the extra devices can be added as spares
              first, and then the number of raid-disks can be changed.
              However for RAID0, it is not possible to add spares.  So to
              increase the number of devices in a RAID0, it is necessary to
              set the new number of devices, and to add the new devices, in
              the same command.

       <b>--nodes</b>
              Only works when the array is for clustered environment. It
              specifies the maximum number of nodes in the cluster that will
              use this device simultaneously. If not specified, this
              defaults to 4.

       <b>--write-journal</b>
              Specify journal device for the RAID-4/5/6 array. The journal
              device should be a SSD with reasonable lifetime.
</pre>
<h2><a id="For_assemble:" href="#For_assemble:"></a>For assemble:  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       <b>-u</b>, <b>--uuid=</b>
              uuid of array to assemble.  Devices which don't have this uuid
              are excluded

       <b>-m</b>, <b>--super-minor=</b>
              Minor number of device that array was created for.  Devices
              which don't have this minor number are excluded.  If you
              create an array as /dev/md1, then all superblocks will contain
              the minor number 1, even if the array is later assembled as
              /dev/md2.

              Giving the literal word "dev" for <b>--super-minor </b>will cause
              <i>mdadm</i> to use the minor number of the md device that is being
              assembled.  e.g. when assembling <b>/dev/md0</b>, <b>--super-minor=dev</b>
              will look for super blocks with a minor number of 0.

              <b>--super-minor </b>is only relevant for v0.90 metadata, and should
              not normally be used.  Using <b>--uuid </b>is much safer.

       <b>-N</b>, <b>--name=</b>
              Specify the name of the array to assemble.  This must be the
              name that was specified when creating the array.  It must
              either match the name stored in the superblock exactly, or it
              must match with the current <i>homehost</i> prefixed to the start of
              the given name.

       <b>-f</b>, <b>--force</b>
              Assemble the array even if the metadata on some devices
              appears to be out-of-date.  If <i>mdadm</i> cannot find enough
              working devices to start the array, but can find some devices
              that are recorded as having failed, then it will mark those
              devices as working so that the array can be started.  An array
              which requires <b>--force </b>to be started may contain data
              corruption.  Use it carefully.

       <b>-R</b>, <b>--run</b>
              Attempt to start the array even if fewer drives were given
              than were present last time the array was active.  Normally if
              not all the expected drives are found and <b>--scan </b>is not used,
              then the array will be assembled but not started.  With <b>--run</b>
              an attempt will be made to start it anyway.

       <b>--no-degraded</b>
              This is the reverse of <b>--run </b>in that it inhibits the startup
              of array unless all expected drives are present.  This is only
              needed with <b>--scan, </b>and can be used if the physical
              connections to devices are not as reliable as you would like.

       <b>-a</b>, <b>--auto{=no,yes,md,mdp,part}</b>
              See this option under Create and Build options.

       <b>-b</b>, <b>--bitmap=</b>
              Specify the bitmap file that was given when the array was
              created.  If an array has an <b>internal </b>bitmap, there is no need
              to specify this when assembling the array.

       <b>--backup-file=</b>
              If <b>--backup-file </b>was used while reshaping an array (e.g.
              changing number of devices or chunk size) and the system
              crashed during the critical section, then the same
              <b>--backup-file </b>must be presented to <b>--assemble </b>to allow
              possibly corrupted data to be restored, and the reshape to be
              completed.

       <b>--invalid-backup</b>
              If the file needed for the above option is not available for
              any reason an empty file can be given together with this
              option to indicate that the backup file is invalid.  In this
              case the data that was being rearranged at the time of the
              crash could be irrecoverably lost, but the rest of the array
              may still be recoverable.  This option should only be used as
              a last resort if there is no way to recover the backup file.

       <b>-U</b>, <b>--update=</b>
              Update the superblock on each device while assembling the
              array.  The argument given to this flag can be one of
              <b>sparc2.2</b>, <b>summaries</b>, <b>uuid</b>, <b>name</b>, <b>nodes</b>, <b>homehost</b>, <b>home-</b>
              <b>cluster</b>, <b>resync</b>, <b>byteorder</b>, <b>devicesize</b>, <b>no-bitmap</b>, <b>bbl</b>,
              <b>no-bbl</b>, <b>metadata</b>, or <b>super-minor</b>.

              The <b>sparc2.2 </b>option will adjust the superblock of an array
              what was created on a Sparc machine running a patched 2.2
              Linux kernel.  This kernel got the alignment of part of the
              superblock wrong.  You can use the <b>--examine --sparc2.2 </b>option
              to <i>mdadm</i> to see what effect this would have.

              The <b>super-minor </b>option will update the <b>preferred minor </b>field
              on each superblock to match the minor number of the array
              being assembled.  This can be useful if <b>--examine </b>reports a
              different "Preferred Minor" to <b>--detail</b>.  In some cases this
              update will be performed automatically by the kernel driver.
              In particular the update happens automatically at the first
              write to an array with redundancy (RAID level 1 or greater) on
              a 2.6 (or later) kernel.

              The <b>uuid </b>option will change the uuid of the array.  If a UUID
              is given with the <b>--uuid </b>option that UUID will be used as a
              new UUID and will <b>NOT </b>be used to help identify the devices in
              the array.  If no <b>--uuid </b>is given, a random UUID is chosen.

              The <b>name </b>option will change the <i>name</i> of the array as stored in
              the superblock.  This is only supported for version-1
              superblocks.

              The <b>nodes </b>option will change the <i>nodes</i> of the array as stored
              in the bitmap superblock. This option only works for a
              clustered environment.

              The <b>homehost </b>option will change the <i>homehost</i> as recorded in
              the superblock.  For version-0 superblocks, this is the same
              as updating the UUID.  For version-1 superblocks, this
              involves updating the name.

              The <b>home-cluster </b>option will change the cluster name as
              recorded in the superblock and bitmap. This option only works
              for clustered environment.

              The <b>resync </b>option will cause the array to be marked <i>dirty</i>
              meaning that any redundancy in the array (e.g. parity for
              RAID5, copies for RAID1) may be incorrect.  This will cause
              the RAID system to perform a "resync" pass to make sure that
              all redundant information is correct.

              The <b>byteorder </b>option allows arrays to be moved between
              machines with different byte-order.  When assembling such an
              array for the first time after a move, giving
              <b>--update=byteorder </b>will cause <i>mdadm</i> to expect superblocks to
              have their byteorder reversed, and will correct that order
              before assembling the array.  This is only valid with original
              (Version 0.90) superblocks.

              The <b>summaries </b>option will correct the summaries in the
              superblock.  That is the counts of total, working, active,
              failed, and spare devices.

              The <b>devicesize </b>option will rarely be of use.  It applies to
              version 1.1 and 1.2 metadata only (where the metadata is at
              the start of the device) and is only useful when the component
              device has changed size (typically become larger).  The
              version 1 metadata records the amount of the device that can
              be used to store data, so if a device in a version 1.1 or 1.2
              array becomes larger, the metadata will still be visible, but
              the extra space will not.  In this case it might be useful to
              assemble the array with <b>--update=devicesize</b>.  This will cause
              <i>mdadm</i> to determine the maximum usable amount of space on each
              device and update the relevant field in the metadata.

              The <b>metadata </b>option only works on v0.90 metadata arrays and
              will convert them to v1.0 metadata.  The array must not be
              dirty (i.e. it must not need a sync) and it must not have a
              write-intent bitmap.

              The old metadata will remain on the devices, but will appear
              older than the new metadata and so will usually be ignored.
              The old metadata (or indeed the new metadata) can be removed
              by giving the appropriate <b>--metadata= </b>option to
              <b>--zero-superblock</b>.

              The <b>no-bitmap </b>option can be used when an array has an internal
              bitmap which is corrupt in some way so that assembling the
              array normally fails.  It will cause any internal bitmap to be
              ignored.

              The <b>bbl </b>option will reserve space in each device for a bad
              block list.  This will be 4K in size and positioned near the
              end of any free space between the superblock and the data.

              The <b>no-bbl </b>option will cause any reservation of space for a
              bad block list to be removed.  If the bad block list contains
              entries, this will fail, as removing the list could cause data
              corruption.

       <b>--freeze-reshape</b>
              Option is intended to be used in start-up scripts during
              initrd boot phase.  When array under reshape is assembled
              during initrd phase, this option stops reshape after reshape
              critical section is being restored. This happens before file
              system pivot operation and avoids loss of file system context.
              Losing file system context would cause reshape to be broken.

              Reshape can be continued later using the <b>--continue </b>option for
              the grow command.
</pre>
<h2><a id="For_Manage_mode:" href="#For_Manage_mode:"></a>For Manage mode:  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       <b>-t</b>, <b>--test</b>
              Unless a more serious error occurred, <i>mdadm</i> will exit with a
              status of 2 if no changes were made to the array and 0 if at
              least one change was made.  This can be useful when an
              indirect specifier such as <b>missing</b>, <b>detached </b>or <b>faulty </b>is used
              in requesting an operation on the array.  <b>--test </b>will report
              failure if these specifiers didn't find any match.

       <b>-a</b>, <b>--add</b>
              hot-add listed devices.  If a device appears to have recently
              been part of the array (possibly it failed or was removed) the
              device is re-added as described in the next point.  If that
              fails or the device was never part of the array, the device is
              added as a hot-spare.  If the array is degraded, it will
              immediately start to rebuild data onto that spare.

              Note that this and the following options are only meaningful
              on array with redundancy.  They don't apply to RAID0 or
              Linear.

       <b>--re-add</b>
              re-add a device that was previously removed from an array.  If
              the metadata on the device reports that it is a member of the
              array, and the slot that it used is still vacant, then the
              device will be added back to the array in the same position.
              This will normally cause the data for that device to be
              recovered.  However based on the event count on the device,
              the recovery may only require sections that are flagged a
              write-intent bitmap to be recovered or may not require any
              recovery at all.

              When used on an array that has no metadata (i.e. it was built
              with <b>--build) </b>it will be assumed that bitmap-based recovery is
              enough to make the device fully consistent with the array.

              When used with v1.x metadata, <b>--re-add </b>can be accompanied by
              <b>--update=devicesize</b>, <b>--update=bbl</b>, or <b>--update=no-bbl</b>.  See
              the description of these option when used in Assemble mode for
              an explanation of their use.

              If the device name given is <b>missing </b>then <i>mdadm</i> will try to
              find any device that looks like it should be part of the array
              but isn't and will try to re-add all such devices.

              If the device name given is <b>faulty </b>then <i>mdadm</i> will find all
              devices in the array that are marked <b>faulty</b>, remove them and
              attempt to immediately re-add them.  This can be useful if you
              are certain that the reason for failure has been resolved.

       <b>--add-spare</b>
              Add a device as a spare.  This is similar to <b>--add </b>except that
              it does not attempt <b>--re-add </b>first.  The device will be added
              as a spare even if it looks like it could be an recent member
              of the array.

       <b>-r</b>, <b>--remove</b>
              remove listed devices.  They must not be active.  i.e. they
              should be failed or spare devices.

              As well as the name of a device file (e.g.  <b>/dev/sda1</b>) the
              words <b>failed</b>, <b>detached </b>and names like <b>set-A </b>can be given to
              <b>--remove</b>.  The first causes all failed device to be removed.
              The second causes any device which is no longer connected to
              the system (i.e an 'open' returns <b>ENXIO</b>) to be removed.  The
              third will remove a set as describe below under <b>--fail</b>.

       <b>-f</b>, <b>--fail</b>
              Mark listed devices as faulty.  As well as the name of a
              device file, the word <b>detached </b>or a set name like <b>set-A </b>can be
              given.  The former will cause any device that has been
              detached from the system to be marked as failed.  It can then
              be removed.

              For RAID10 arrays where the number of copies evenly divides
              the number of devices, the devices can be conceptually divided
              into sets where each set contains a single complete copy of
              the data on the array.  Sometimes a RAID10 array will be
              configured so that these sets are on separate controllers.  In
              this case all the devices in one set can be failed by giving a
              name like <b>set-A </b>or <b>set-B </b>to <b>--fail</b>.  The appropriate set names
              are reported by <b>--detail</b>.

       <b>--set-faulty</b>
              same as <b>--fail</b>.

       <b>--replace</b>
              Mark listed devices as requiring replacement.  As soon as a
              spare is available, it will be rebuilt and will replace the
              marked device.  This is similar to marking a device as faulty,
              but the device remains in service during the recovery process
              to increase resilience against multiple failures.  When the
              replacement process finishes, the replaced device will be
              marked as faulty.

       <b>--with </b>This can follow a list of <b>--replace </b>devices.  The devices
              listed after <b>--with </b>will be preferentially used to replace the
              devices listed after <b>--replace</b>.  These device must already be
              spare devices in the array.

       <b>--write-mostly</b>
              Subsequent devices that are added or re-added will have the
              'write-mostly' flag set.  This is only valid for RAID1 and
              means that the 'md' driver will avoid reading from these
              devices if possible.

       <b>--readwrite</b>
              Subsequent devices that are added or re-added will have the
              'write-mostly' flag cleared.

       <b>--cluster-confirm</b>
              Confirm the existence of the device. This is issued in
              response to an --add request by a node in a cluster. When a
              node adds a device it sends a message to all nodes in the
              cluster to look for a device with a UUID. This translates to a
              udev notification with the UUID of the device to be added and
              the slot number. The receiving node must acknowledge this
              message with --cluster-confirm. Valid arguments are
              &lt;slot&gt;:&lt;devicename&gt; in case the device is found or
              &lt;slot&gt;:missing in case the device is not found.

       <b>--add-journal</b>
              Recreate journal for RAID-4/5/6 array that lost a journal
              device. In the current implementation, this command cannot add
              a journal to an array that had a failed journal. To avoid
              interrupting on-going write opertions, <b>--add-journal </b>only
              works for array in Read-Only state.

       <b>--failfast</b>
              Subsequent devices that are added or re-added will have the
              'failfast' flag set.  This is only valid for RAID1 and RAID10
              and means that the 'md' driver will avoid long timeouts on
              error handling where possible.

       <b>--nofailfast</b>
              Subsequent devices that are re-added will be re-added without
              the 'failfast' flag set.

       Each of these options requires that the first device listed is the
       array to be acted upon, and the remainder are component devices to be
       added, removed, marked as faulty, etc.  Several different operations
       can be specified for different devices, e.g.
            mdadm /dev/md0 --add /dev/sda1 --fail /dev/sdb1 --remove
            /dev/sdb1
       Each operation applies to all devices listed until the next
       operation.

       If an array is using a write-intent bitmap, then devices which have
       been removed can be re-added in a way that avoids a full
       reconstruction but instead just updates the blocks that have changed
       since the device was removed.  For arrays with persistent metadata
       (superblocks) this is done automatically.  For arrays created with
       <b>--build </b>mdadm needs to be told that this device we removed recently
       with <b>--re-add</b>.

       Devices can only be removed from an array if they are not in active
       use, i.e. that must be spares or failed devices.  To remove an active
       device, it must first be marked as <b>faulty.</b>
</pre>
<h2><a id="For_Misc_mode:" href="#For_Misc_mode:"></a>For Misc mode:  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       <b>-Q</b>, <b>--query</b>
              Examine a device to see (1) if it is an md device and (2) if
              it is a component of an md array.  Information about what is
              discovered is presented.

       <b>-D</b>, <b>--detail</b>
              Print details of one or more md devices.

       <b>--detail-platform</b>
              Print details of the platform's RAID capabilities (firmware /
              hardware topology) for a given metadata format. If used
              without argument, mdadm will scan all controllers looking for
              their capabilities. Otherwise, mdadm will only look at the
              controller specified by the argument in form of an absolute
              filepath or a link, e.g.
              <i>/sys/devices/pci0000:00/0000:00:1f.2</i>.

       <b>-Y</b>, <b>--export</b>
              When used with <b>--detail</b>, <b>--detail-platform</b>, <b>--examine</b>, or
              <b>--incremental </b>output will be formatted as <b>key=value </b>pairs for
              easy import into the environment.

              With <b>--incremental </b>The value <b>MD_STARTED </b>indicates whether an
              array was started (<b>yes</b>) or not, which may include a reason
              (<b>unsafe</b>, <b>nothing</b>, <b>no</b>).  Also the value <b>MD_FOREIGN </b>indicates if
              the array is expected on this host (<b>no</b>), or seems to be from
              elsewhere (<b>yes</b>).

       <b>-E</b>, <b>--examine</b>
              Print contents of the metadata stored on the named device(s).
              Note the contrast between <b>--examine </b>and <b>--detail</b>.  <b>--examine</b>
              applies to devices which are components of an array, while
              <b>--detail </b>applies to a whole array which is currently active.

       <b>--sparc2.2</b>
              If an array was created on a SPARC machine with a 2.2 Linux
              kernel patched with RAID support, the superblock will have
              been created incorrectly, or at least incompatibly with 2.4
              and later kernels.  Using the <b>--sparc2.2 </b>flag with <b>--examine</b>
              will fix the superblock before displaying it.  If this appears
              to do the right thing, then the array can be successfully
              assembled using <b>--assemble --update=sparc2.2</b>.

       <b>-X</b>, <b>--examine-bitmap</b>
              Report information about a bitmap file.  The argument is
              either an external bitmap file or an array component in case
              of an internal bitmap.  Note that running this on an array
              device (e.g.  <b>/dev/md0</b>) does not report the bitmap for that
              array.

       <b>--examine-badblocks</b>
              List the bad-blocks recorded for the device, if a bad-blocks
              list has been configured.  Currently only <b>1.x </b>metadata
              supports bad-blocks lists.

       <b>--dump=</b><i>directory</i>

       <b>--restore=</b><i>directory</i>
              Save metadata from lists devices, or restore metadata to
              listed devices.

       <b>-R</b>, <b>--run</b>
              start a partially assembled array.  If <b>--assemble </b>did not find
              enough devices to fully start the array, it might leaving it
              partially assembled.  If you wish, you can then use <b>--run </b>to
              start the array in degraded mode.

       <b>-S</b>, <b>--stop</b>
              deactivate array, releasing all resources.

       <b>-o</b>, <b>--readonly</b>
              mark array as readonly.

       <b>-w</b>, <b>--readwrite</b>
              mark array as readwrite.

       <b>--zero-superblock</b>
              If the device contains a valid md superblock, the block is
              overwritten with zeros.  With <b>--force </b>the block where the
              superblock would be is overwritten even if it doesn't appear
              to be valid.

       <b>--kill-subarray=</b>
              If the device is a container and the argument to
              --kill-subarray specifies an inactive subarray in the
              container, then the subarray is deleted.  Deleting all
              subarrays will leave an 'empty-container' or spare superblock
              on the drives.  See <b>--zero-superblock </b>for completely removing
              a superblock.  Note that some formats depend on the subarray
              index for generating a UUID, this command will fail if it
              would change the UUID of an active subarray.

       <b>--update-subarray=</b>
              If the device is a container and the argument to
              --update-subarray specifies a subarray in the container, then
              attempt to update the given superblock field in the subarray.
              See below in <b>MISC MODE </b>for details.

       <b>-t</b>, <b>--test</b>
              When used with <b>--detail</b>, the exit status of <i>mdadm</i> is set to
              reflect the status of the device.  See below in <b>MISC MODE </b>for
              details.

       <b>-W</b>, <b>--wait</b>
              For each md device given, wait for any resync, recovery, or
              reshape activity to finish before returning.  <i>mdadm</i> will
              return with success if it actually waited for every device
              listed, otherwise it will return failure.

       <b>--wait-clean</b>
              For each md device given, or each device in /proc/mdstat if
              <b>--scan </b>is given, arrange for the array to be marked clean as
              soon as possible.  <i>mdadm</i> will return with success if the array
              uses external metadata and we successfully waited.  For native
              arrays this returns immediately as the kernel handles dirty-
              clean transitions at shutdown.  No action is taken if safe-
              mode handling is disabled.

       <b>--action=</b>
              Set the "sync_action" for all md devices given to one of <b>idle</b>,
              <b>frozen</b>, <b>check</b>, <b>repair</b>.  Setting to <b>idle </b>will abort any
              currently running action though some actions will
              automatically restart.  Setting to <b>frozen </b>will abort any
              current action and ensure no other action starts
              automatically.

              Details of <b>check </b>and <b>repair </b>can be found it <a href="../man4/md.4.html">md(4)</a> under
              <b>SCRUBBING AND MISMATCHES</b>.
</pre>
<h2><a id="For_Incremental_Assembly_mode:" href="#For_Incremental_Assembly_mode:"></a>For Incremental Assembly mode:  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       <b>--rebuild-map</b>, <b>-r</b>
              Rebuild the map file (<b>/run/mdadm/map</b>) that <i>mdadm</i> uses to help
              track which arrays are currently being assembled.

       <b>--run</b>, <b>-R</b>
              Run any array assembled as soon as a minimal number of devices
              are available, rather than waiting until all expected devices
              are present.

       <b>--scan</b>, <b>-s</b>
              Only meaningful with <b>-R </b>this will scan the <b>map </b>file for arrays
              that are being incrementally assembled and will try to start
              any that are not already started.  If any such array is listed
              in <b>mdadm.conf </b>as requiring an external bitmap, that bitmap
              will be attached first.

       <b>--fail</b>, <b>-f</b>
              This allows the hot-plug system to remove devices that have
              fully disappeared from the kernel.  It will first fail and
              then remove the device from any array it belongs to.  The
              device name given should be a kernel device name such as
              "sda", not a name in <i>/dev</i>.

       <b>--path=</b>
              Only used with --fail.  The 'path' given will be recorded so
              that if a new device appears at the same location it can be
              automatically added to the same array.  This allows the failed
              device to be automatically replaced by a new device without
              metadata if it appears at specified path.   This option is
              normally only set by a <i>udev</i> script.
</pre>
<h2><a id="For_Monitor_mode:" href="#For_Monitor_mode:"></a>For Monitor mode:  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       <b>-m</b>, <b>--mail</b>
              Give a mail address to send alerts to.

       <b>-p</b>, <b>--program</b>, <b>--alert</b>
              Give a program to be run whenever an event is detected.

       <b>-y</b>, <b>--syslog</b>
              Cause all events to be reported through 'syslog'.  The
              messages have facility of 'daemon' and varying priorities.

       <b>-d</b>, <b>--delay</b>
              Give a delay in seconds.  <i>mdadm</i> polls the md arrays and then
              waits this many seconds before polling again.  The default is
              60 seconds.  Since 2.6.16, there is no need to reduce this as
              the kernel alerts <i>mdadm</i> immediately when there is any change.

       <b>-r</b>, <b>--increment</b>
              Give a percentage increment.  <i>mdadm</i> will generate RebuildNN
              events with the given percentage increment.

       <b>-f</b>, <b>--daemonise</b>
              Tell <i>mdadm</i> to run as a background daemon if it decides to
              monitor anything.  This causes it to fork and run in the
              child, and to disconnect from the terminal.  The process id of
              the child is written to stdout.  This is useful with <b>--scan</b>
              which will only continue monitoring if a mail address or alert
              program is found in the config file.

       <b>-i</b>, <b>--pid-file</b>
              When <i>mdadm</i> is running in daemon mode, write the pid of the
              daemon process to the specified file, instead of printing it
              on standard output.

       <b>-1</b>, <b>--oneshot</b>
              Check arrays only once.  This will generate <b>NewArray </b>events
              and more significantly <b>DegradedArray </b>and <b>SparesMissing </b>events.
              Running
                      <b>mdadm --monitor --scan -1</b>
              from a cron script will ensure regular notification of any
              degraded arrays.

       <b>-t</b>, <b>--test</b>
              Generate a <b>TestMessage </b>alert for every array found at startup.
              This alert gets mailed and passed to the alert program.  This
              can be used for testing that alert message do get through
              successfully.

       <b>--no-sharing</b>
              This inhibits the functionality for moving spares between
              arrays.  Only one monitoring process started with <b>--scan </b>but
              without this flag is allowed, otherwise the two could
              interfere with each other.
</pre>
<h2><a id="ASSEMBLE_MODE" href="#ASSEMBLE_MODE"></a>ASSEMBLE MODE  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       Usage: <b>mdadm --assemble </b><i>md-device options-and-component-devices...</i>

       Usage: <b>mdadm --assemble --scan </b><i>md-devices-and-options...</i>

       Usage: <b>mdadm --assemble --scan </b><i>options...</i>

       This usage assembles one or more RAID arrays from pre-existing
       components.  For each array, mdadm needs to know the md device, the
       identity of the array, and a number of component-devices.  These can
       be found in a number of ways.

       In the first usage example (without the <b>--scan</b>) the first device
       given is the md device.  In the second usage example, all devices
       listed are treated as md devices and assembly is attempted.  In the
       third (where no devices are listed) all md devices that are listed in
       the configuration file are assembled.  If no arrays are described by
       the configuration file, then any arrays that can be found on unused
       devices will be assembled.

       If precisely one device is listed, but <b>--scan </b>is not given, then
       <i>mdadm</i> acts as though <b>--scan </b>was given and identity information is
       extracted from the configuration file.

       The identity can be given with the <b>--uuid </b>option, the <b>--name </b>option,
       or the <b>--super-minor </b>option, will be taken from the md-device record
       in the config file, or will be taken from the super block of the
       first component-device listed on the command line.

       Devices can be given on the <b>--assemble </b>command line or in the config
       file.  Only devices which have an md superblock which contains the
       right identity will be considered for any array.

       The config file is only used if explicitly named with <b>--config </b>or
       requested with (a possibly implicit) <b>--scan</b>.  In the later case,
       <b>/etc/mdadm.conf </b>or <b>/etc/mdadm/mdadm.conf </b>is used.

       If <b>--scan </b>is not given, then the config file will only be used to
       find the identity of md arrays.

       Normally the array will be started after it is assembled.  However if
       <b>--scan </b>is not given and not all expected drives were listed, then the
       array is not started (to guard against usage errors).  To insist that
       the array be started in this case (as may work for RAID1, 4, 5, 6, or
       10), give the <b>--run </b>flag.

       If <i>udev</i> is active, <i>mdadm</i> does not create any entries in <b>/dev </b>but
       leaves that to <i>udev</i>.  It does record information in <b>/run/mdadm/map</b>
       which will allow <i>udev</i> to choose the correct name.

       If <i>mdadm</i> detects that udev is not configured, it will create the
       devices in <b>/dev </b>itself.

       In Linux kernels prior to version 2.6.28 there were two distinctly
       different types of md devices that could be created: one that could
       be partitioned using standard partitioning tools and one that could
       not.  Since 2.6.28 that distinction is no longer relevant as both
       type of devices can be partitioned.  <i>mdadm</i> will normally create the
       type that originally could not be partitioned as it has a well
       defined major number (9).

       Prior to 2.6.28, it is important that mdadm chooses the correct type
       of array device to use.  This can be controlled with the <b>--auto</b>
       option.  In particular, a value of "mdp" or "part" or "p" tells mdadm
       to use a partitionable device rather than the default.

       In the no-udev case, the value given to <b>--auto </b>can be suffixed by a
       number.  This tells <i>mdadm</i> to create that number of partition devices
       rather than the default of 4.

       The value given to <b>--auto </b>can also be given in the configuration file
       as a word starting <b>auto= </b>on the ARRAY line for the relevant array.

   <b>Auto Assembly</b>
       When <b>--assemble </b>is used with <b>--scan </b>and no devices are listed, <i>mdadm</i>
       will first attempt to assemble all the arrays listed in the config
       file.

       If no arrays are listed in the config (other than those marked
       <b>&lt;ignore&gt;</b>) it will look through the available devices for possible
       arrays and will try to assemble anything that it finds.  Arrays which
       are tagged as belonging to the given homehost will be assembled and
       started normally.  Arrays which do not obviously belong to this host
       are given names that are expected not to conflict with anything
       local, and are started "read-auto" so that nothing is written to any
       device until the array is written to. i.e.  automatic resync etc is
       delayed.

       If <i>mdadm</i> finds a consistent set of devices that look like they should
       comprise an array, and if the superblock is tagged as belonging to
       the given home host, it will automatically choose a device name and
       try to assemble the array.  If the array uses version-0.90 metadata,
       then the <b>minor </b>number as recorded in the superblock is used to create
       a name in <b>/dev/md/ </b>so for example <b>/dev/md/3</b>.  If the array uses
       version-1 metadata, then the <b>name </b>from the superblock is used to
       similarly create a name in <b>/dev/md/ </b>(the name will have any 'host'
       prefix stripped first).

       This behaviour can be modified by the <i>AUTO</i> line in the <i>mdadm.conf</i>
       configuration file.  This line can indicate that specific metadata
       type should, or should not, be automatically assembled.  If an array
       is found which is not listed in <i>mdadm.conf</i> and has a metadata format
       that is denied by the <i>AUTO</i> line, then it will not be assembled.  The
       <i>AUTO</i> line can also request that all arrays identified as being for
       this homehost should be assembled regardless of their metadata type.
       See <a href="../man5/mdadm.conf.5.html">mdadm.conf(5)</a> for further details.

       Note: Auto assembly cannot be used for assembling and activating some
       arrays which are undergoing reshape.  In particular as the
       <b>backup-file </b>cannot be given, any reshape which requires a backup-file
       to continue cannot be started by auto assembly.  An array which is
       growing to more devices and has passed the critical section can be
       assembled using auto-assembly.
</pre>
<h2><a id="BUILD_MODE" href="#BUILD_MODE"></a>BUILD MODE  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       Usage: <b>mdadm --build </b><i>md-device</i> <b>--chunk=</b><i>X</i> <b>--level=</b><i>Y</i> <b>--raid-devices=</b><i>Z</i>
                   <i>devices</i>

       This usage is similar to <b>--create</b>.  The difference is that it creates
       an array without a superblock.  With these arrays there is no
       difference between initially creating the array and subsequently
       assembling the array, except that hopefully there is useful data
       there in the second case.

       The level may raid0, linear, raid1, raid10, multipath, or faulty, or
       one of their synonyms.  All devices must be listed and the array will
       be started once complete.  It will often be appropriate to use
       <b>--assume-clean </b>with levels raid1 or raid10.
</pre>
<h2><a id="CREATE_MODE" href="#CREATE_MODE"></a>CREATE MODE  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       Usage: <b>mdadm --create </b><i>md-device</i> <b>--chunk=</b><i>X</i> <b>--level=</b><i>Y</i>
                   <b>--raid-devices=</b><i>Z devices</i>

       This usage will initialise a new md array, associate some devices
       with it, and activate the array.

       The named device will normally not exist when <i>mdadm --create</i> is run,
       but will be created by <i>udev</i> once the array becomes active.

       As devices are added, they are checked to see if they contain RAID
       superblocks or filesystems.  They are also checked to see if the
       variance in device size exceeds 1%.

       If any discrepancy is found, the array will not automatically be run,
       though the presence of a <b>--run </b>can override this caution.

       To create a "degraded" array in which some devices are missing,
       simply give the word "<b>missing</b>" in place of a device name.  This will
       cause <i>mdadm</i> to leave the corresponding slot in the array empty.  For
       a RAID4 or RAID5 array at most one slot can be "<b>missing</b>"; for a RAID6
       array at most two slots.  For a RAID1 array, only one real device
       needs to be given.  All of the others can be "<b>missing</b>".

       When creating a RAID5 array, <i>mdadm</i> will automatically create a
       degraded array with an extra spare drive.  This is because building
       the spare into a degraded array is in general faster than resyncing
       the parity on a non-degraded, but not clean, array.  This feature can
       be overridden with the <b>--force </b>option.

       When creating an array with version-1 metadata a name for the array
       is required.  If this is not given with the <b>--name </b>option, <i>mdadm</i> will
       choose a name based on the last component of the name of the device
       being created.  So if <b>/dev/md3 </b>is being created, then the name <b>3 </b>will
       be chosen.  If <b>/dev/md/home </b>is being created, then the name <b>home </b>will
       be used.

       When creating a partition based array, using <i>mdadm</i> with version-1.x
       metadata, the partition type should be set to <b>0xDA </b>(non fs-data).
       This type selection allows for greater precision since using any
       other [RAID auto-detect (0xFD) or a GNU/Linux partition (0x83)],
       might create problems in the event of array recovery through a live
       cdrom.

       A new array will normally get a randomly assigned 128bit UUID which
       is very likely to be unique.  If you have a specific need, you can
       choose a UUID for the array by giving the <b>--uuid= </b>option.  Be warned
       that creating two arrays with the same UUID is a recipe for disaster.
       Also, using <b>--uuid= </b>when creating a v0.90 array will silently
       override any <b>--homehost= </b>setting.

       If the array type supports a write-intent bitmap, and if the devices
       in the array exceed 100G is size, an internal write-intent bitmap
       will automatically be added unless some other option is explicitly
       requested with the <b>--bitmap </b>option.  In any case space for a bitmap
       will be reserved so that one can be added layer with <b>--grow</b>
       <b>--bitmap=internal</b>.

       If the metadata type supports it (currently only 1.x metadata), space
       will be allocated to store a bad block list.  This allows a modest
       number of bad blocks to be recorded, allowing the drive to remain in
       service while only partially functional.

       When creating an array within a <b>CONTAINER </b><i>mdadm</i> can be given either
       the list of devices to use, or simply the name of the container.  The
       former case gives control over which devices in the container will be
       used for the array.  The latter case allows <i>mdadm</i> to automatically
       choose which devices to use based on how much spare space is
       available.

       The General Management options that are valid with <b>--create </b>are:

       <b>--run  </b>insist on running the array even if some devices look like
              they might be in use.

       <b>--readonly</b>
              start the array readonly — not supported yet.
</pre>
<h2><a id="MANAGE_MODE" href="#MANAGE_MODE"></a>MANAGE MODE  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       Usage: <b>mdadm </b><i>device options... devices...</i>

       This usage will allow individual devices in an array to be failed,
       removed or added.  It is possible to perform multiple operations with
       on command.  For example:
         <b>mdadm /dev/md0 -f /dev/hda1 -r /dev/hda1 -a /dev/hda1</b>
       will firstly mark <b>/dev/hda1 </b>as faulty in <b>/dev/md0 </b>and will then
       remove it from the array and finally add it back in as a spare.
       However only one md array can be affected by a single command.

       When a device is added to an active array, mdadm checks to see if it
       has metadata on it which suggests that it was recently a member of
       the array.  If it does, it tries to "re-add" the device.  If there
       have been no changes since the device was removed, or if the array
       has a write-intent bitmap which has recorded whatever changes there
       were, then the device will immediately become a full member of the
       array and those differences recorded in the bitmap will be resolved.
</pre>
<h2><a id="MISC_MODE" href="#MISC_MODE"></a>MISC MODE  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       Usage: <b>mdadm </b><i>options ...</i>  <i>devices ...</i>

       MISC mode includes a number of distinct operations that operate on
       distinct devices.  The operations are:

       <b>--query</b>
              The device is examined to see if it is (1) an active md array,
              or (2) a component of an md array.  The information discovered
              is reported.

       <b>--detail</b>
              The device should be an active md device.  <b>mdadm </b>will display
              a detailed description of the array.  <b>--brief </b>or <b>--scan </b>will
              cause the output to be less detailed and the format to be
              suitable for inclusion in <b>mdadm.conf</b>.  The exit status of
              <i>mdadm</i> will normally be 0 unless <i>mdadm</i> failed to get useful
              information about the device(s); however, if the <b>--test </b>option
              is given, then the exit status will be:

              0      The array is functioning normally.

              1      The array has at least one failed device.

              2      The array has multiple failed devices such that it is
                     unusable.

              4      There was an error while trying to get information
                     about the device.

       <b>--detail-platform</b>
              Print detail of the platform's RAID capabilities (firmware /
              hardware topology).  If the metadata is specified with <b>-e </b>or
              <b>--metadata= </b>then the return status will be:

              0      metadata successfully enumerated its platform
                     components on this system

              1      metadata is platform independent

              2      metadata failed to find its platform components on this
                     system

       <b>--update-subarray=</b>
              If the device is a container and the argument to
              --update-subarray specifies a subarray in the container, then
              attempt to update the given superblock field in the subarray.
              Similar to updating an array in "assemble" mode, the field to
              update is selected by <b>-U </b>or <b>--update= </b>option.  Currently only
              <b>name </b>is supported.

              The <b>name </b>option updates the subarray name in the metadata, it
              may not affect the device node name or the device node symlink
              until the subarray is re-assembled.  If updating <b>name </b>would
              change the UUID of an active subarray this operation is
              blocked, and the command will end in an error.

       <b>--examine</b>
              The device should be a component of an md array.  <i>mdadm</i> will
              read the md superblock of the device and display the contents.
              If <b>--brief </b>or <b>--scan </b>is given, then multiple devices that are
              components of the one array are grouped together and reported
              in a single entry suitable for inclusion in <b>mdadm.conf</b>.

              Having <b>--scan </b>without listing any devices will cause all
              devices listed in the config file to be examined.

       <b>--dump=</b><i>directory</i>
              If the device contains RAID metadata, a file will be created
              in the <i>directory</i> and the metadata will be written to it.  The
              file will be the same size as the device and have the metadata
              written in the file at the same locate that it exists in the
              device.  However the file will be "sparse" so that only those
              blocks containing metadata will be allocated. The total space
              used will be small.

              The file name used in the <i>directory</i> will be the base name of
              the device.   Further if any links appear in <i>/dev/disk/by-id</i>
              which point to the device, then hard links to the file will be
              created in <i>directory</i> based on these <i>by-id</i> names.

              Multiple devices can be listed and their metadata will all be
              stored in the one directory.

       <b>--restore=</b><i>directory</i>
              This is the reverse of <b>--dump</b>.  <i>mdadm</i> will locate a file in
              the directory that has a name appropriate for the given device
              and will restore metadata from it.  Names that match
              <i>/dev/disk/by-id</i> names are preferred, however if two of those
              refer to different files, <i>mdadm</i> will not choose between them
              but will abort the operation.

              If a file name is given instead of a <i>directory</i> then <i>mdadm</i> will
              restore from that file to a single device, always provided the
              size of the file matches that of the device, and the file
              contains valid metadata.

       <b>--stop </b>The devices should be active md arrays which will be
              deactivated, as long as they are not currently in use.

       <b>--run  </b>This will fully activate a partially assembled md array.

       <b>--readonly</b>
              This will mark an active array as read-only, providing that it
              is not currently being used.

       <b>--readwrite</b>
              This will change a <b>readonly </b>array back to being read/write.

       <b>--scan </b>For all operations except <b>--examine</b>, <b>--scan </b>will cause the
              operation to be applied to all arrays listed in <b>/proc/mdstat</b>.
              For <b>--examine, --scan </b>causes all devices listed in the config
              file to be examined.

       <b>-b</b>, <b>--brief</b>
              Be less verbose.  This is used with <b>--detail </b>and <b>--examine</b>.
              Using <b>--brief </b>with <b>--verbose </b>gives an intermediate level of
              verbosity.
</pre>
<h2><a id="MONITOR_MODE" href="#MONITOR_MODE"></a>MONITOR MODE  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       Usage: <b>mdadm --monitor </b><i>options... devices...</i>

       This usage causes <i>mdadm</i> to periodically poll a number of md arrays
       and to report on any events noticed.  <i>mdadm</i> will never exit once it
       decides that there are arrays to be checked, so it should normally be
       run in the background.

       As well as reporting events, <i>mdadm</i> may move a spare drive from one
       array to another if they are in the same <b>spare-group </b>or <b>domain </b>and if
       the destination array has a failed drive but no spares.

       If any devices are listed on the command line, <i>mdadm</i> will only
       monitor those devices.  Otherwise all arrays listed in the
       configuration file will be monitored.  Further, if <b>--scan </b>is given,
       then any other md devices that appear in <b>/proc/mdstat </b>will also be
       monitored.

       The result of monitoring the arrays is the generation of events.
       These events are passed to a separate program (if specified) and may
       be mailed to a given E-mail address.

       When passing events to a program, the program is run once for each
       event, and is given 2 or 3 command-line arguments: the first is the
       name of the event (see below), the second is the name of the md
       device which is affected, and the third is the name of a related
       device if relevant (such as a component device that has failed).

       If <b>--scan </b>is given, then a program or an E-mail address must be
       specified on the command line or in the config file.  If neither are
       available, then <i>mdadm</i> will not monitor anything.  Without <b>--scan,</b>
       <i>mdadm</i> will continue monitoring as long as something was found to
       monitor.  If no program or email is given, then each event is
       reported to <b>stdout</b>.

       The different events are:

           <b>DeviceDisappeared</b>
                  An md array which previously was configured appears to no
                  longer be configured. (syslog priority: Critical)

                  If <i>mdadm</i> was told to monitor an array which is RAID0 or
                  Linear, then it will report <b>DeviceDisappeared </b>with the
                  extra information <b>Wrong-Level</b>.  This is because RAID0 and
                  Linear do not support the device-failed, hot-spare and
                  resync operations which are monitored.

           <b>RebuildStarted</b>
                  An md array started reconstruction (e.g. recovery, resync,
                  reshape, check, repair). (syslog priority: Warning)

           <b>Rebuild</b><i>NN</i>
                  Where <i>NN</i> is a two-digit number (ie. 05, 48). This
                  indicates that rebuild has passed that many percent of the
                  total. The events are generated with fixed increment since
                  0. Increment size may be specified with a commandline
                  option (default is 20). (syslog priority: Warning)

           <b>RebuildFinished</b>
                  An md array that was rebuilding, isn't any more, either
                  because it finished normally or was aborted. (syslog
                  priority: Warning)

           <b>Fail   </b>An active component device of an array has been marked as
                  faulty. (syslog priority: Critical)

           <b>FailSpare</b>
                  A spare component device which was being rebuilt to
                  replace a faulty device has failed. (syslog priority:
                  Critical)

           <b>SpareActive</b>
                  A spare component device which was being rebuilt to
                  replace a faulty device has been successfully rebuilt and
                  has been made active.  (syslog priority: Info)

           <b>NewArray</b>
                  A new md array has been detected in the <b>/proc/mdstat </b>file.
                  (syslog priority: Info)

           <b>DegradedArray</b>
                  A newly noticed array appears to be degraded.  This
                  message is not generated when <i>mdadm</i> notices a drive
                  failure which causes degradation, but only when <i>mdadm</i>
                  notices that an array is degraded when it first sees the
                  array.  (syslog priority: Critical)

           <b>MoveSpare</b>
                  A spare drive has been moved from one array in a <b>spare-</b>
                  <b>group </b>or <b>domain </b>to another to allow a failed drive to be
                  replaced.  (syslog priority: Info)

           <b>SparesMissing</b>
                  If <i>mdadm</i> has been told, via the config file, that an array
                  should have a certain number of spare devices, and <i>mdadm</i>
                  detects that it has fewer than this number when it first
                  sees the array, it will report a <b>SparesMissing </b>message.
                  (syslog priority: Warning)

           <b>TestMessage</b>
                  An array was found at startup, and the <b>--test </b>flag was
                  given.  (syslog priority: Info)

       Only <b>Fail, FailSpare, DegradedArray, SparesMissing </b>and <b>TestMessage</b>
       cause Email to be sent.  All events cause the program to be run.  The
       program is run with two or three arguments: the event name, the array
       device and possibly a second device.

       Each event has an associated array device (e.g.  <b>/dev/md1</b>) and
       possibly a second device.  For <b>Fail</b>, <b>FailSpare</b>, and <b>SpareActive </b>the
       second device is the relevant component device.  For <b>MoveSpare </b>the
       second device is the array that the spare was moved from.

       For <i>mdadm</i> to move spares from one array to another, the different
       arrays need to be labeled with the same <b>spare-group </b>or the spares
       must be allowed to migrate through matching POLICY domains in the
       configuration file.  The <b>spare-group </b>name can be any string; it is
       only necessary that different spare groups use different names.

       When <i>mdadm</i> detects that an array in a spare group has fewer active
       devices than necessary for the complete array, and has no spare
       devices, it will look for another array in the same spare group that
       has a full complement of working drive and a spare.  It will then
       attempt to remove the spare from the second drive and add it to the
       first.  If the removal succeeds but the adding fails, then it is
       added back to the original array.

       If the spare group for a degraded array is not defined, <i>mdadm</i> will
       look at the rules of spare migration specified by POLICY lines in
       <b>mdadm.conf </b>and then follow similar steps as above if a matching spare
       is found.
</pre>
<h2><a id="GROW_MODE" href="#GROW_MODE"></a>GROW MODE  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       The GROW mode is used for changing the size or shape of an active
       array.  For this to work, the kernel must support the necessary
       change.  Various types of growth are being added during 2.6
       development.

       Currently the supported changes include

       ·   change the "size" attribute for RAID1, RAID4, RAID5 and RAID6.

       ·   increase or decrease the "raid-devices" attribute of RAID0,
           RAID1, RAID4, RAID5, and RAID6.

       ·   change the chunk-size and layout of RAID0, RAID4, RAID5, RAID6
           and RAID10.

       ·   convert between RAID1 and RAID5, between RAID5 and RAID6, between
           RAID0, RAID4, and RAID5, and between RAID0 and RAID10 (in the
           near-2 mode).

       ·   add a write-intent bitmap to any array which supports these
           bitmaps, or remove a write-intent bitmap from such an array.

       Using GROW on containers is currently supported only for Intel's IMSM
       container format.  The number of devices in a container can be
       increased - which affects all arrays in the container - or an array
       in a container can be converted between levels where those levels are
       supported by the container, and the conversion is on of those listed
       above.  Resizing arrays in an IMSM container with <b>--grow --size </b>is
       not yet supported.

       Grow functionality (e.g. expand a number of raid devices) for Intel's
       IMSM container format has an experimental status. It is guarded by
       the <b>MDADM_EXPERIMENTAL </b>environment variable which must be set to '1'
       for a GROW command to succeed.  This is for the following reasons:

       1.     Intel's native IMSM check-pointing is not fully tested yet.
              This can causes IMSM incompatibility during the grow process:
              an array which is growing cannot roam between Microsoft
              Windows(R) and Linux systems.

       2.     Interrupting a grow operation is not recommended, because it
              has not been fully tested for Intel's IMSM container format
              yet.

       Note: Intel's native checkpointing doesn't use <b>--backup-file </b>option
       and it is transparent for assembly feature.

   <b>SIZE CHANGES</b>
       Normally when an array is built the "size" is taken from the smallest
       of the drives.  If all the small drives in an arrays are, one at a
       time, removed and replaced with larger drives, then you could have an
       array of large drives with only a small amount used.  In this
       situation, changing the "size" with "GROW" mode will allow the extra
       space to start being used.  If the size is increased in this way, a
       "resync" process will start to make sure the new parts of the array
       are synchronised.

       Note that when an array changes size, any filesystem that may be
       stored in the array will not automatically grow or shrink to use or
       vacate the space.  The filesystem will need to be explicitly told to
       use the extra space after growing, or to reduce its size <b>prior </b>to
       shrinking the array.

       Also the size of an array cannot be changed while it has an active
       bitmap.  If an array has a bitmap, it must be removed before the size
       can be changed. Once the change is complete a new bitmap can be
       created.

   <b>RAID-DEVICES CHANGES</b>
       A RAID1 array can work with any number of devices from 1 upwards
       (though 1 is not very useful).  There may be times which you want to
       increase or decrease the number of active devices.  Note that this is
       different to hot-add or hot-remove which changes the number of
       inactive devices.

       When reducing the number of devices in a RAID1 array, the slots which
       are to be removed from the array must already be vacant.  That is,
       the devices which were in those slots must be failed and removed.

       When the number of devices is increased, any hot spares that are
       present will be activated immediately.

       Changing the number of active devices in a RAID5 or RAID6 is much
       more effort.  Every block in the array will need to be read and
       written back to a new location.  From 2.6.17, the Linux Kernel is
       able to increase the number of devices in a RAID5 safely, including
       restarting an interrupted "reshape".  From 2.6.31, the Linux Kernel
       is able to increase or decrease the number of devices in a RAID5 or
       RAID6.

       From 2.6.35, the Linux Kernel is able to convert a RAID0 in to a
       RAID4 or RAID5.  <i>mdadm</i> uses this functionality and the ability to add
       devices to a RAID4 to allow devices to be added to a RAID0.  When
       requested to do this, <i>mdadm</i> will convert the RAID0 to a RAID4, add
       the necessary disks and make the reshape happen, and then convert the
       RAID4 back to RAID0.

       When decreasing the number of devices, the size of the array will
       also decrease.  If there was data in the array, it could get
       destroyed and this is not reversible, so you should firstly shrink
       the filesystem on the array to fit within the new size.  To help
       prevent accidents, <i>mdadm</i> requires that the size of the array be
       decreased first with <b>mdadm --grow --array-size</b>.  This is a reversible
       change which simply makes the end of the array inaccessible.  The
       integrity of any data can then be checked before the non-reversible
       reduction in the number of devices is request.

       When relocating the first few stripes on a RAID5 or RAID6, it is not
       possible to keep the data on disk completely consistent and crash-
       proof.  To provide the required safety, mdadm disables writes to the
       array while this "critical section" is reshaped, and takes a backup
       of the data that is in that section.  For grows, this backup may be
       stored in any spare devices that the array has, however it can also
       be stored in a separate file specified with the <b>--backup-file </b>option,
       and is required to be specified for shrinks, RAID level changes and
       layout changes.  If this option is used, and the system does crash
       during the critical period, the same file must be passed to
       <b>--assemble </b>to restore the backup and reassemble the array.  When
       shrinking rather than growing the array, the reshape is done from the
       end towards the beginning, so the "critical section" is at the end of
       the reshape.

   <b>LEVEL CHANGES</b>
       Changing the RAID level of any array happens instantaneously.
       However in the RAID5 to RAID6 case this requires a non-standard
       layout of the RAID6 data, and in the RAID6 to RAID5 case that non-
       standard layout is required before the change can be accomplished.
       So while the level change is instant, the accompanying layout change
       can take quite a long time.  A <b>--backup-file </b>is required.  If the
       array is not simultaneously being grown or shrunk, so that the array
       size will remain the same - for example, reshaping a 3-drive RAID5
       into a 4-drive RAID6 - the backup file will be used not just for a
       "cricital section" but throughout the reshape operation, as described
       below under LAYOUT CHANGES.

   <b>CHUNK-SIZE AND LAYOUT CHANGES</b>
       Changing the chunk-size of layout without also changing the number of
       devices as the same time will involve re-writing all blocks in-place.
       To ensure against data loss in the case of a crash, a <b>--backup-file</b>
       must be provided for these changes.  Small sections of the array will
       be copied to the backup file while they are being rearranged.  This
       means that all the data is copied twice, once to the backup and once
       to the new layout on the array, so this type of reshape will go very
       slowly.

       If the reshape is interrupted for any reason, this backup file must
       be made available to <b>mdadm --assemble </b>so the array can be
       reassembled.  Consequently the file cannot be stored on the device
       being reshaped.

   <b>BITMAP CHANGES</b>
       A write-intent bitmap can be added to, or removed from, an active
       array.  Either internal bitmaps, or bitmaps stored in a separate
       file, can be added.  Note that if you add a bitmap stored in a file
       which is in a filesystem that is on the RAID array being affected,
       the system will deadlock.  The bitmap must be on a separate
       filesystem.
</pre>
<h2><a id="INCREMENTAL_MODE" href="#INCREMENTAL_MODE"></a>INCREMENTAL MODE  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       Usage: <b>mdadm --incremental </b>[<b>--run</b>] [<b>--quiet</b>] <i>component-device</i>
                   [<i>optional-aliases-for-device</i>]

       Usage: <b>mdadm --incremental --fail </b><i>component-device</i>

       Usage: <b>mdadm --incremental --rebuild-map</b>

       Usage: <b>mdadm --incremental --run --scan</b>

       This mode is designed to be used in conjunction with a device
       discovery system.  As devices are found in a system, they can be
       passed to <b>mdadm --incremental </b>to be conditionally added to an
       appropriate array.

       Conversely, it can also be used with the <b>--fail </b>flag to do just the
       opposite and find whatever array a particular device is part of and
       remove the device from that array.

       If the device passed is a <b>CONTAINER </b>device created by a previous call
       to <i>mdadm</i>, then rather than trying to add that device to an array, all
       the arrays described by the metadata of the container will be
       started.

       <i>mdadm</i> performs a number of tests to determine if the device is part
       of an array, and which array it should be part of.  If an appropriate
       array is found, or can be created, <i>mdadm</i> adds the device to the array
       and conditionally starts the array.

       Note that <i>mdadm</i> will normally only add devices to an array which were
       previously working (active or spare) parts of that array.  The
       support for automatic inclusion of a new drive as a spare in some
       array requires a configuration through POLICY in config file.

       The tests that <i>mdadm</i> makes are as follow:

       +      Is the device permitted by <b>mdadm.conf</b>?  That is, is it listed
              in a <b>DEVICES </b>line in that file.  If <b>DEVICES </b>is absent then the
              default it to allow any device.  Similarly if <b>DEVICES </b>contains
              the special word <b>partitions </b>then any device is allowed.
              Otherwise the device name given to <i>mdadm</i>, or one of the
              aliases given, or an alias found in the filesystem, must match
              one of the names or patterns in a <b>DEVICES </b>line.

              This is the only context where the aliases are used.  They are
              usually provided by a <i>udev</i> rules mentioning <b>${DEVLINKS}</b>.

       +      Does the device have a valid md superblock?  If a specific
              metadata version is requested with <b>--metadata </b>or <b>-e </b>then only
              that style of metadata is accepted, otherwise <i>mdadm</i> finds any
              known version of metadata.  If no <i>md</i> metadata is found, the
              device may be still added to an array as a spare if POLICY
              allows.

       <i>mdadm</i> keeps a list of arrays that it has partially assembled in
       <b>/run/mdadm/map</b>.  If no array exists which matches the metadata on the
       new device, <i>mdadm</i> must choose a device name and unit number.  It does
       this based on any name given in <b>mdadm.conf </b>or any name information
       stored in the metadata.  If this name suggests a unit number, that
       number will be used, otherwise a free unit number will be chosen.
       Normally <i>mdadm</i> will prefer to create a partitionable array, however
       if the <b>CREATE </b>line in <b>mdadm.conf </b>suggests that a non-partitionable
       array is preferred, that will be honoured.

       If the array is not found in the config file and its metadata does
       not identify it as belonging to the "homehost", then <i>mdadm</i> will
       choose a name for the array which is certain not to conflict with any
       array which does belong to this host.  It does this be adding an
       underscore and a small number to the name preferred by the metadata.

       Once an appropriate array is found or created and the device is
       added, <i>mdadm</i> must decide if the array is ready to be started.  It
       will normally compare the number of available (non-spare) devices to
       the number of devices that the metadata suggests need to be active.
       If there are at least that many, the array will be started.  This
       means that if any devices are missing the array will not be
       restarted.

       As an alternative, <b>--run </b>may be passed to <i>mdadm</i> in which case the
       array will be run as soon as there are enough devices present for the
       data to be accessible.  For a RAID1, that means one device will start
       the array.  For a clean RAID5, the array will be started as soon as
       all but one drive is present.

       Note that neither of these approaches is really ideal.  If it can be
       known that all device discovery has completed, then
          <b>mdadm -IRs</b>
       can be run which will try to start all arrays that are being
       incrementally assembled.  They are started in "read-auto" mode in
       which they are read-only until the first write request.  This means
       that no metadata updates are made and no attempt at resync or
       recovery happens.  Further devices that are found before the first
       write can still be added safely.
</pre>
<h2><a id="ENVIRONMENT" href="#ENVIRONMENT"></a>ENVIRONMENT  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       This section describes environment variables that affect how mdadm
       operates.

       <b>MDADM_NO_MDMON</b>
              Setting this value to 1 will prevent mdadm from automatically
              launching mdmon.  This variable is intended primarily for
              debugging mdadm/mdmon.

       <b>MDADM_NO_UDEV</b>
              Normally, <i>mdadm</i> does not create any device nodes in /dev, but
              leaves that task to <i>udev</i>.  If <i>udev</i> appears not to be
              configured, or if this environment variable is set to '1', the
              <i>mdadm</i> will create and devices that are needed.

       <b>MDADM_NO_SYSTEMCTL</b>
              If <i>mdadm</i> detects that <i>systemd</i> is in use it will normally
              request <i>systemd</i> to start various background tasks
              (particularly <i>mdmon</i>) rather than forking and running them in
              the background.  This can be suppressed by setting
              <b>MDADM_NO_SYSTEMCTL=1</b>.

       <b>IMSM_NO_PLATFORM</b>
              A key value of IMSM metadata is that it allows
              interoperability with boot ROMs on Intel platforms, and with
              other major operating systems.  Consequently, <i>mdadm</i> will only
              allow an IMSM array to be created or modified if detects that
              it is running on an Intel platform which supports IMSM, and
              supports the particular configuration of IMSM that is being
              requested (some functionality requires newer OROM support).

              These checks can be suppressed by setting IMSM_NO_PLATFORM=1
              in the environment.  This can be useful for testing or for
              disaster recovery.  You should be aware that interoperability
              may be compromised by setting this value.

       <b>MDADM_GROW_ALLOW_OLD</b>
              If an array is stopped while it is performing a reshape and
              that reshape was making use of a backup file, then when the
              array is re-assembled <i>mdadm</i> will sometimes complain that the
              backup file is too old.  If this happens and you are certain
              it is the right backup file, you can over-ride this check by
              setting <b>MDADM_GROW_ALLOW_OLD=1 </b>in the environment.

       <b>MDADM_CONF_AUTO</b>
              Any string given in this variable is added to the start of the
              <b>AUTO </b>line in the config file, or treated as the whole <b>AUTO</b>
              line if none is given.  It can be used to disable certain
              metadata types when <i>mdadm</i> is called from a boot script.  For
              example
                  <b>export MDADM_CONF_AUTO='-ddf -imsm'</b>
              will make sure that <i>mdadm</i> does not automatically assemble any
              DDF or IMSM arrays that are found.  This can be useful on
              systems configured to manage such arrays with <b>dmraid</b>.
</pre>
<h2><a id="EXAMPLES" href="#EXAMPLES"></a>EXAMPLES  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
         <b>mdadm --query /dev/name-of-device</b>
       This will find out if a given device is a RAID array, or is part of
       one, and will provide brief information about the device.

         <b>mdadm --assemble --scan</b>
       This will assemble and start all arrays listed in the standard config
       file.  This command will typically go in a system startup file.

         <b>mdadm --stop --scan</b>
       This will shut down all arrays that can be shut down (i.e. are not
       currently in use).  This will typically go in a system shutdown
       script.

         <b>mdadm --follow --scan --delay=120</b>
       If (and only if) there is an Email address or program given in the
       standard config file, then monitor the status of all arrays listed in
       that file by polling them ever 2 minutes.

         <b>mdadm --create /dev/md0 --level=1 --raid-devices=2 /dev/hd[ac]1</b>
       Create /dev/md0 as a RAID1 array consisting of /dev/hda1 and
       /dev/hdc1.

         <b>echo 'DEVICE /dev/hd*[0-9] /dev/sd*[0-9]' &gt; mdadm.conf</b>
         <b>mdadm --detail --scan &gt;&gt; mdadm.conf</b>
       This will create a prototype config file that describes currently
       active arrays that are known to be made from partitions of IDE or
       SCSI drives.  This file should be reviewed before being used as it
       may contain unwanted detail.

         <b>echo 'DEVICE /dev/hd[a-z] /dev/sd*[a-z]' &gt; mdadm.conf</b>
         <b>mdadm --examine --scan --config=mdadm.conf &gt;&gt; mdadm.conf</b>
       This will find arrays which could be assembled from existing IDE and
       SCSI whole drives (not partitions), and store the information in the
       format of a config file.  This file is very likely to contain
       unwanted detail, particularly the <b>devices= </b>entries.  It should be
       reviewed and edited before being used as an actual config file.

         <b>mdadm --examine --brief --scan --config=partitions</b>
         <b>mdadm -Ebsc partitions</b>
       Create a list of devices by reading <b>/proc/partitions</b>, scan these for
       RAID superblocks, and printout a brief listing of all that were
       found.

         <b>mdadm -Ac partitions -m 0 /dev/md0</b>
       Scan all partitions and devices listed in <b>/proc/partitions </b>and
       assemble <b>/dev/md0 </b>out of all such devices with a RAID superblock with
       a minor number of 0.

         <b>mdadm --monitor --scan --daemonise &gt; /run/mdadm/mon.pid</b>
       If config file contains a mail address or alert program, run mdadm in
       the background in monitor mode monitoring all md devices.  Also write
       pid of mdadm daemon to <b>/run/mdadm/mon.pid</b>.

         <b>mdadm -Iq /dev/somedevice</b>
       Try to incorporate newly discovered device into some array as
       appropriate.

         <b>mdadm --incremental --rebuild-map --run --scan</b>
       Rebuild the array map from any current arrays, and then start any
       that can be started.

         <b>mdadm /dev/md4 --fail detached --remove detached</b>
       Any devices which are components of /dev/md4 will be marked as faulty
       and then remove from the array.

         <b>mdadm --grow /dev/md4 --level=6 --backup-file=/root/backup-md4</b>
       The array <b>/dev/md4 </b>which is currently a RAID5 array will be converted
       to RAID6.  There should normally already be a spare drive attached to
       the array as a RAID6 needs one more drive than a matching RAID5.

         <b>mdadm --create /dev/md/ddf --metadata=ddf --raid-disks 6 /dev/sd[a-</b>
       <b>f]</b>
       Create a DDF array over 6 devices.

         <b>mdadm --create /dev/md/home -n3 -l5 -z 30000000 /dev/md/ddf</b>
       Create a RAID5 array over any 3 devices in the given DDF set.  Use
       only 30 gigabytes of each device.

         <b>mdadm -A /dev/md/ddf1 /dev/sd[a-f]</b>
       Assemble a pre-exist ddf array.

         <b>mdadm -I /dev/md/ddf1</b>
       Assemble all arrays contained in the ddf array, assigning names as
       appropriate.

         <b>mdadm --create --help</b>
       Provide help about the Create mode.

         <b>mdadm --config --help</b>
       Provide help about the format of the config file.

         <b>mdadm --help</b>
       Provide general help.
</pre>
<h2><a id="FILES" href="#FILES"></a>FILES  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
   <b>/proc/mdstat</b>
       If you're using the <b>/proc </b>filesystem, <b>/proc/mdstat </b>lists all active
       md devices with information about them.  <i>mdadm</i> uses this to find
       arrays when <b>--scan </b>is given in Misc mode, and to monitor array
       reconstruction on Monitor mode.

   <b>/etc/mdadm.conf</b>
       The config file lists which devices may be scanned to see if they
       contain MD super block, and gives identifying information (e.g. UUID)
       about known MD arrays.  See <a href="../man5/mdadm.conf.5.html">mdadm.conf(5)</a> for more details.

   <b>/etc/mdadm.conf.d</b>
       A directory containing configuration files which are read in lexical
       order.

   <b>/run/mdadm/map</b>
       When <b>--incremental </b>mode is used, this file gets a list of arrays
       currently being created.
</pre>
<h2><a id="DEVICE_NAMES" href="#DEVICE_NAMES"></a>DEVICE NAMES  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       <i>mdadm</i> understand two sorts of names for array devices.

       The first is the so-called 'standard' format name, which matches the
       names used by the kernel and which appear in <i>/proc/mdstat</i>.

       The second sort can be freely chosen, but must reside in <i>/dev/md/</i>.
       When giving a device name to <i>mdadm</i> to create or assemble an array,
       either full path name such as <i>/dev/md0</i> or <i>/dev/md/home</i> can be given,
       or just the suffix of the second sort of name, such as <i>home</i> can be
       given.

       When <i>mdadm</i> chooses device names during auto-assembly or incremental
       assembly, it will sometimes add a small sequence number to the end of
       the name to avoid conflicted between multiple arrays that have the
       same name.  If <i>mdadm</i> can reasonably determine that the array really
       is meant for this host, either by a hostname in the metadata, or by
       the presence of the array in <b>mdadm.conf</b>, then it will leave off the
       suffix if possible.  Also if the homehost is specified as <b>&lt;ignore&gt;</b>
       <i>mdadm</i> will only use a suffix if a different array of the same name
       already exists or is listed in the config file.

       The standard names for non-partitioned arrays (the only sort of md
       array available in 2.4 and earlier) are of the form

              /dev/md<b>NN</b>

       where NN is a number.  The standard names for partitionable arrays
       (as available from 2.6 onwards) are of the form:

              /dev/md_d<b>NN</b>

       Partition numbers should be indicated by adding "pMM" to these, thus
       "/dev/md/d1p2".

       From kernel version 2.6.28 the "non-partitioned array" can actually
       be partitioned.  So the "md_d<b>NN</b>" names are no longer needed, and
       partitions such as "/dev/md<b>NN</b>p<b>XX</b>" are possible.

       From kernel version 2.6.29 standard names can be non-numeric
       following the form:

              /dev/md_<b>XXX</b>

       where <b>XXX </b>is any string.  These names are supported by <i>mdadm</i> since
       version 3.3 provided they are enabled in <i>mdadm.conf</i>.
</pre>
<h2><a id="NOTE" href="#NOTE"></a>NOTE  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       <i>mdadm</i> was previously known as <i>mdctl</i>.
</pre>
<h2><a id="SEE_ALSO" href="#SEE_ALSO"></a>SEE ALSO  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       For further information on mdadm usage, MD and the various levels of
       RAID, see:

              <b><a href="http://raid.wiki.kernel.org/">http://raid.wiki.kernel.org/</a> </b>

       (based upon Jakob Østergaard's Software-RAID.HOWTO)

       The latest version of <i>mdadm</i> should always be available from

              <b><a href="http://www.kernel.org/pub/linux/utils/raid/mdadm/">http://www.kernel.org/pub/linux/utils/raid/mdadm/</a> </b>

       Related man pages:

       <a href="mdmon.8.html">mdmon(8)</a>, <a href="../man5/mdadm.conf.5.html">mdadm.conf(5)</a>, <a href="../man4/md.4.html">md(4)</a>.
</pre>
<h2><a id="COLOPHON" href="#COLOPHON"></a>COLOPHON  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       This page is part of the <i>mdadm</i> (Tool for managing md arrays in Linux)
       project.  Information about the project can be found at 
       ⟨<a href="http://neil.brown.name/blog/mdadm">http://neil.brown.name/blog/mdadm</a>⟩.  If you have a bug report for
       this manual page, send it to linux-raid@vger.kernl.org.  This page
       was obtained from the project's upstream Git repository 
       ⟨git://neil.brown.name/mdadm⟩ on 2017-07-05.  If you discover any ren‐
       dering problems in this HTML version of the page, or you believe
       there is a better or more up-to-date source for the page, or you have
       corrections or improvements to the information in this COLOPHON
       (which is <i>not</i> part of the original manual page), send a mail to
       man-pages@man7.org

<span class="footline">v4.0                                                                MDADM(8)</span>
</pre>

<hr class="end-man-text" />
<p>Pages that refer to this page: 
    <a href="../man4/md.4.html">md(4)</a>,&nbsp; 
    <a href="../man5/mdadm.conf.5.html">mdadm.conf(5)</a>,&nbsp; 
    <a href="blkdeactivate.8.html">blkdeactivate(8)</a>,&nbsp; 
    <a href="mdassemble.8.html">mdassemble(8)</a>,&nbsp; 
    <a href="mdmon.8.html">mdmon(8)</a>,&nbsp; 
    <a href="raid6check.8.html">raid6check(8)</a>
</p>
<hr/>

 
<hr class="start-footer" />

<div class="footer"> 

<table class="colophon-table">
    <tr>
    <td class="pub-info">
        <p>
            HTML rendering created 2017-07-13
            by <a href="http://man7.org/mtk/index.html">Michael Kerrisk</a>, 
            author of 
            <a href="http://man7.org/tlpi/"><em>The Linux Programming Interface</em></a>, 
            maintainer of the 
            <a href="https://www.kernel.org/doc/man-pages/">Linux <em>man-pages</em> project</a>.
        </p>
        <p>
            For details of in-depth
            <strong>Linux/UNIX system programming training courses</strong>
            that I teach, look <a href="http://man7.org/training/">here</a>.
        </p>
        <p>
            Hosting by <a href="http://www.jambit.com/index_en.html">jambit GmbH</a>.
        </p>
        <p>
            <a href="http://validator.w3.org/check?uri=referer">
            <img src="http://www.w3.org/Icons/valid-xhtml11"
                alt="Valid XHTML 1.1" height="31" width="88" />
            </a>
        </p>
    </td>
    <td class="colophon-divider">
    </td>
    <td class="tlpi-cover">
        <a href="http://man7.org/tlpi/"><img src="../../../tlpi/cover/TLPI-front-cover-vsmall.png" alt="Cover of TLPI" /></a>
    </td>
    </tr>
</table>

</div>

<hr class="end-footer" />



<!--BEGIN-SITETRACKING-->
<!-- SITETRACKING.man7.org_linux_man-pages -->

<!-- Start of StatCounter Code (xhtml) -->

<script type="text/javascript">
//<![CDATA[
var sc_project=7422636; 
var sc_invisible=1; 
var sc_security="9b6714ff"; 
//]]>
</script>
<script type="text/javascript"
src="../../../../www.statcounter.com/counter/counter_xhtml.js"></script>
<noscript><div class="statcounter"><a title="website
statistics" href="http://statcounter.com/"
class="statcounter"><img class="statcounter"
src="http://c.statcounter.com/7422636/0/9b6714ff/1/"
alt="website statistics" /></a></div></noscript>

<!-- End of StatCounter Code -->


<!-- Start of Google Analytics Code -->

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-9830363-8']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<!-- End of Google Analytics Code -->

<!--END-SITETRACKING-->

</body>
</html>
