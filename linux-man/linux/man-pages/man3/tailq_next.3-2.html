
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
        "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
    <link rel="stylesheet" type="text/css" href="../../../style.css" title="style" />
    <link rel="stylesheet" type="text/css" href="../style.css" title="style" />
    <meta http-equiv="content-type" content="text/html;charset=utf-8" />

    <title>queue(3) - Linux manual page</title>
</head>

<body>

<div class="page-top"><a id="top_of_page"></a></div>
<!--%%%TOP_BAR%%%-->
    <div class="nav-bar">
        <table class="nav-table">
            <tr>
                <td class="nav-cell">
                    <p class="nav-text">
                        <a href="http://man7.org/index.html">man7.org</a> &gt; Linux &gt; <a href="../index.html">man-pages</a>
                    </p>
                </td>
                <td class="training-cell">
                    <p class="training-text"><a class="training-link" href="http://man7.org/training/">Linux/UNIX system programming training</a></p>
                </td>
            </tr>
        </table>
    </div>

<hr class="nav-end" />

<!--%%%PAGE_START%%%-->


<table class="sec-table">
<tr>
    <td>
        <p class="section-dir">
<a href="#NAME">NAME</a> | <a href="#SYNOPSIS">SYNOPSIS</a> | <a href="#DESCRIPTION">DESCRIPTION</a> | <a href="#CONFORMING_TO">CONFORMING&nbsp;TO</a> | <a href="#SEE_ALSO">SEE&nbsp;ALSO</a> | <a href="#COLOPHON">COLOPHON</a>
        </p>
    </td>
    <td class="search-box">
        <div class="man-search-box">

            <form method="get" action="http://www.google.com/search">
                <fieldset class="man-search">
                    <input type="text" name="q" size="10" maxlength="255" value="" />
                    <input type="hidden" name="sitesearch" value="man7.org/linux/man-pages" />
                    <input type="submit" name="sa" value="Search online pages" />
                </fieldset>
            </form>

        </div>
    </td>
    <td> </td>
</tr>
</table>

<pre>
<span class="headline">QUEUE(3)                BSD Library Functions Manual                QUEUE(3)</span>
</pre>
<h2><a id="NAME" href="#NAME"></a>NAME  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
     <b>SLIST_EMPTY</b>, <b>SLIST_ENTRY</b>, <b>SLIST_FIRST</b>, <b>SLIST_FOREACH</b>, <b>SLIST_HEAD</b>,
     <b>SLIST_HEAD_INITIALIZER</b>, <b>SLIST_INIT</b>, <b>SLIST_INSERT_AFTER</b>,
     <b>SLIST_INSERT_HEAD</b>, <b>SLIST_NEXT</b>, <b>SLIST_REMOVE_HEAD</b>, <b>SLIST_REMOVE</b>,
     <b>STAILQ_CONCAT</b>, <b>STAILQ_EMPTY</b>, <b>STAILQ_ENTRY</b>, <b>STAILQ_FIRST</b>,
     <b>STAILQ_FOREACH</b>, <b>STAILQ_HEAD</b>, <b>STAILQ_HEAD_INITIALIZER</b>, <b>STAILQ_INIT</b>,
     <b>STAILQ_INSERT_AFTER</b>, <b>STAILQ_INSERT_HEAD</b>, <b>STAILQ_INSERT_TAIL</b>,
     <b>STAILQ_NEXT</b>, <b>STAILQ_REMOVE_HEAD</b>, <b>STAILQ_REMOVE</b>, <b>LIST_EMPTY</b>, <b>LIST_ENTRY</b>,
     <b>LIST_FIRST</b>, <b>LIST_FOREACH</b>, <b>LIST_HEAD</b>, <b>LIST_HEAD_INITIALIZER</b>, <b>LIST_INIT</b>,
     <b>LIST_INSERT_AFTER</b>, <b>LIST_INSERT_BEFORE</b>, <b>LIST_INSERT_HEAD</b>, <b>LIST_NEXT</b>,
     <b>LIST_REMOVE</b>, <b>TAILQ_CONCAT</b>, <b>TAILQ_EMPTY</b>, <b>TAILQ_ENTRY</b>, <b>TAILQ_FIRST</b>,
     <b>TAILQ_FOREACH</b>, <b>TAILQ_FOREACH_REVERSE</b>, <b>TAILQ_HEAD</b>,
     <b>TAILQ_HEAD_INITIALIZER</b>, <b>TAILQ_INIT</b>, <b>TAILQ_INSERT_AFTER</b>,
     <b>TAILQ_INSERT_BEFORE</b>, <b>TAILQ_INSERT_HEAD</b>, <b>TAILQ_INSERT_TAIL</b>, <b>TAILQ_LAST</b>,
     <b>TAILQ_NEXT</b>, <b>TAILQ_PREV</b>, <b>TAILQ_REMOVE</b>, <b>TAILQ_SWAP </b>— implementations of
     singly-linked lists, singly-linked tail queues, lists and tail queues
</pre>
<h2><a id="SYNOPSIS" href="#SYNOPSIS"></a>SYNOPSIS  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
     <b>#include &lt;sys/queue.h&gt;</b>

     <b>SLIST_EMPTY</b>(<i>SLIST_HEAD *head</i>);

     <b>SLIST_ENTRY</b>(<i>TYPE</i>);

     <b>SLIST_FIRST</b>(<i>SLIST_HEAD *head</i>);

     <b>SLIST_FOREACH</b>(<i>TYPE *var</i>, <i>SLIST_HEAD *head</i>, <i>SLIST_ENTRY NAME</i>);

     <b>SLIST_HEAD</b>(<i>HEADNAME</i>, <i>TYPE</i>);

     <b>SLIST_HEAD_INITIALIZER</b>(<i>SLIST_HEAD head</i>);

     <b>SLIST_INIT</b>(<i>SLIST_HEAD *head</i>);

     <b>SLIST_INSERT_AFTER</b>(<i>TYPE *listelm</i>, <i>TYPE *elm</i>, <i>SLIST_ENTRY NAME</i>);

     <b>SLIST_INSERT_HEAD</b>(<i>SLIST_HEAD *head</i>, <i>TYPE *elm</i>, <i>SLIST_ENTRY NAME</i>);

     <b>SLIST_NEXT</b>(<i>TYPE *elm</i>, <i>SLIST_ENTRY NAME</i>);

     <b>SLIST_REMOVE_HEAD</b>(<i>SLIST_HEAD *head</i>, <i>SLIST_ENTRY NAME</i>);

     <b>SLIST_REMOVE</b>(<i>SLIST_HEAD *head</i>, <i>TYPE *elm</i>, <i>TYPE</i>, <i>SLIST_ENTRY NAME</i>);

     <b>STAILQ_CONCAT</b>(<i>STAILQ_HEAD *head1</i>, <i>STAILQ_HEAD *head2</i>);

     <b>STAILQ_EMPTY</b>(<i>STAILQ_HEAD *head</i>);

     <b>STAILQ_ENTRY</b>(<i>TYPE</i>);

     <b>STAILQ_FIRST</b>(<i>STAILQ_HEAD *head</i>);

     <b>STAILQ_FOREACH</b>(<i>TYPE *var</i>, <i>STAILQ_HEAD *head</i>, <i>STAILQ_ENTRY NAME</i>);

     <b>STAILQ_HEAD</b>(<i>HEADNAME</i>, <i>TYPE</i>);

     <b>STAILQ_HEAD_INITIALIZER</b>(<i>STAILQ_HEAD head</i>);

     <b>STAILQ_INIT</b>(<i>STAILQ_HEAD *head</i>);

     <b>STAILQ_INSERT_AFTER</b>(<i>STAILQ_HEAD *head</i>, <i>TYPE *listelm</i>, <i>TYPE *elm</i>,
         <i>STAILQ_ENTRY NAME</i>);

     <b>STAILQ_INSERT_HEAD</b>(<i>STAILQ_HEAD *head</i>, <i>TYPE *elm</i>, <i>STAILQ_ENTRY NAME</i>);

     <b>STAILQ_INSERT_TAIL</b>(<i>STAILQ_HEAD *head</i>, <i>TYPE *elm</i>, <i>STAILQ_ENTRY NAME</i>);

     <b>STAILQ_NEXT</b>(<i>TYPE *elm</i>, <i>STAILQ_ENTRY NAME</i>);

     <b>STAILQ_REMOVE_HEAD</b>(<i>STAILQ_HEAD *head</i>, <i>STAILQ_ENTRY NAME</i>);

     <b>STAILQ_REMOVE</b>(<i>STAILQ_HEAD *head</i>, <i>TYPE *elm</i>, <i>TYPE</i>, <i>STAILQ_ENTRY NAME</i>);

     <b>LIST_EMPTY</b>(<i>LIST_HEAD *head</i>);

     <b>LIST_ENTRY</b>(<i>TYPE</i>);

     <b>LIST_FIRST</b>(<i>LIST_HEAD *head</i>);

     <b>LIST_FOREACH</b>(<i>TYPE *var</i>, <i>LIST_HEAD *head</i>, <i>LIST_ENTRY NAME</i>);

     <b>LIST_HEAD</b>(<i>HEADNAME</i>, <i>TYPE</i>);

     <b>LIST_HEAD_INITIALIZER</b>(<i>LIST_HEAD head</i>);

     <b>LIST_INIT</b>(<i>LIST_HEAD *head</i>);

     <b>LIST_INSERT_AFTER</b>(<i>TYPE *listelm</i>, <i>TYPE *elm</i>, <i>LIST_ENTRY NAME</i>);

     <b>LIST_INSERT_BEFORE</b>(<i>TYPE *listelm</i>, <i>TYPE *elm</i>, <i>LIST_ENTRY NAME</i>);

     <b>LIST_INSERT_HEAD</b>(<i>LIST_HEAD *head</i>, <i>TYPE *elm</i>, <i>LIST_ENTRY NAME</i>);

     <b>LIST_NEXT</b>(<i>TYPE *elm</i>, <i>LIST_ENTRY NAME</i>);

     <b>LIST_REMOVE</b>(<i>TYPE *elm</i>, <i>LIST_ENTRY NAME</i>);

     <b>LIST_SWAP</b>(<i>LIST_HEAD *head1</i>, <i>LIST_HEAD *head2</i>, <i>TYPE</i>, <i>LIST_ENTRY NAME</i>);

     <b>TAILQ_CONCAT</b>(<i>TAILQ_HEAD *head1</i>, <i>TAILQ_HEAD *head2</i>, <i>TAILQ_ENTRY NAME</i>);

     <b>TAILQ_EMPTY</b>(<i>TAILQ_HEAD *head</i>);

     <b>TAILQ_ENTRY</b>(<i>TYPE</i>);

     <b>TAILQ_FIRST</b>(<i>TAILQ_HEAD *head</i>);

     <b>TAILQ_FOREACH</b>(<i>TYPE *var</i>, <i>TAILQ_HEAD *head</i>, <i>TAILQ_ENTRY NAME</i>);

     <b>TAILQ_FOREACH_REVERSE</b>(<i>TYPE *var</i>, <i>TAILQ_HEAD *head</i>, <i>HEADNAME</i>,
         <i>TAILQ_ENTRY NAME</i>);

     <b>TAILQ_HEAD</b>(<i>HEADNAME</i>, <i>TYPE</i>);

     <b>TAILQ_HEAD_INITIALIZER</b>(<i>TAILQ_HEAD head</i>);

     <b>TAILQ_INIT</b>(<i>TAILQ_HEAD *head</i>);

     <b>TAILQ_INSERT_AFTER</b>(<i>TAILQ_HEAD *head</i>, <i>TYPE *listelm</i>, <i>TYPE *elm</i>,
         <i>TAILQ_ENTRY NAME</i>);

     <b>TAILQ_INSERT_BEFORE</b>(<i>TYPE *listelm</i>, <i>TYPE *elm</i>, <i>TAILQ_ENTRY NAME</i>);

     <b>TAILQ_INSERT_HEAD</b>(<i>TAILQ_HEAD *head</i>, <i>TYPE *elm</i>, <i>TAILQ_ENTRY NAME</i>);

     <b>TAILQ_INSERT_TAIL</b>(<i>TAILQ_HEAD *head</i>, <i>TYPE *elm</i>, <i>TAILQ_ENTRY NAME</i>);

     <b>TAILQ_LAST</b>(<i>TAILQ_HEAD *head</i>, <i>HEADNAME</i>);

     <b>TAILQ_NEXT</b>(<i>TYPE *elm</i>, <i>TAILQ_ENTRY NAME</i>);

     <b>TAILQ_PREV</b>(<i>TYPE *elm</i>, <i>HEADNAME</i>, <i>TAILQ_ENTRY NAME</i>);

     <b>TAILQ_REMOVE</b>(<i>TAILQ_HEAD *head</i>, <i>TYPE *elm</i>, <i>TAILQ_ENTRY NAME</i>);

     <b>TAILQ_SWAP</b>(<i>TAILQ_HEAD *head1</i>, <i>TAILQ_HEAD *head2</i>, <i>TYPE</i>,
         <i>TAILQ_ENTRY NAME</i>);
</pre>
<h2><a id="DESCRIPTION" href="#DESCRIPTION"></a>DESCRIPTION  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
     These macros define and operate on four types of data structures:
     singly-linked lists, singly-linked tail queues, lists, and tail queues.
     All four structures support the following functionality:
           1.   Insertion of a new entry at the head of the list.
           2.   Insertion of a new entry after any element in the list.
           3.   O(1) removal of an entry from the head of the list.
           4.   Forward traversal through the list.
           5.   Swapping the contents of two lists.

     Singly-linked lists are the simplest of the four data structures and
     support only the above functionality.  Singly-linked lists are ideal
     for applications with large datasets and few or no removals, or for
     implementing a LIFO queue.  Singly-linked lists add the following func‐
     tionality:
           1.   O(n) removal of any entry in the list.

     Singly-linked tail queues add the following functionality:
           1.   Entries can be added at the end of a list.
           2.   O(n) removal of any entry in the list.
           3.   They may be concatenated.
     However:
           1.   All list insertions must specify the head of the list.
           2.   Each head entry requires two pointers rather than one.
           3.   Code size is about 15% greater and operations run about 20%
                slower than singly-linked lists.

     Singly-linked tail queues are ideal for applications with large
     datasets and few or no removals, or for implementing a FIFO queue.

     All doubly linked types of data structures (lists and tail queues)
     additionally allow:
           1.   Insertion of a new entry before any element in the list.
           2.   O(1) removal of any entry in the list.
     However:
           1.   Each element requires two pointers rather than one.
           2.   Code size and execution time of operations (except for
                removal) is about twice that of the singly-linked data-
                structures.

     Linked lists are the simplest of the doubly linked data structures.
     They add the following functionality over the above:
           1.   They may be traversed backwards.
     However:
           1.   To traverse backwards, an entry to begin the traversal and
                the list in which it is contained must be specified.

     Tail queues add the following functionality:
           1.   Entries can be added at the end of a list.
           2.   They may be traversed backwards, from tail to head.
           3.   They may be concatenated.
     However:
           1.   All list insertions and removals must specify the head of
                the list.
           2.   Each head entry requires two pointers rather than one.
           3.   Code size is about 15% greater and operations run about 20%
                slower than singly-linked lists.

     In the macro definitions, <i>TYPE</i> is the name of a user defined structure,
     that must contain a field of type SLIST_ENTRY, STAILQ_ENTRY,
     LIST_ENTRY, or TAILQ_ENTRY, named <i>NAME</i>.  The argument <i>HEADNAME</i> is the
     name of a user defined structure that must be declared using the macros
     SLIST_HEAD, STAILQ_HEAD, LIST_HEAD, or TAILQ_HEAD.  See the examples
     below for further explanation of how these macros are used.

   <b>Singly-linked lists</b>
     A singly-linked list is headed by a structure defined by the <b>SLIST_HEAD</b>
     macro.  This structure contains a single pointer to the first element
     on the list.  The elements are singly linked for minimum space and
     pointer manipulation overhead at the expense of O(n) removal for arbi‐
     trary elements.  New elements can be added to the list after an exist‐
     ing element or at the head of the list.  An <i>SLIST_HEAD</i> structure is
     declared as follows:

           SLIST_HEAD(HEADNAME, TYPE) head;

     where <i>HEADNAME</i> is the name of the structure to be defined, and <i>TYPE</i> is
     the type of the elements to be linked into the list.  A pointer to the
     head of the list can later be declared as:

           struct HEADNAME *headp;

     (The names head and headp are user selectable.)

     The macro <b>SLIST_HEAD_INITIALIZER </b>evaluates to an initializer for the
     list <i>head</i>.

     The macro <b>SLIST_EMPTY </b>evaluates to true if there are no elements in the
     list.

     The macro <b>SLIST_ENTRY </b>declares a structure that connects the elements
     in the list.

     The macro <b>SLIST_FIRST </b>returns the first element in the list or NULL if
     the list is empty.

     The macro <b>SLIST_FOREACH </b>traverses the list referenced by <i>head</i> in the
     forward direction, assigning each element in turn to <i>var</i>.

     The macro <b>SLIST_INIT </b>initializes the list referenced by <i>head</i>.

     The macro <b>SLIST_INSERT_HEAD </b>inserts the new element <i>elm</i> at the head of
     the list.

     The macro <b>SLIST_INSERT_AFTER </b>inserts the new element <i>elm</i> after the ele‐
     ment <i>listelm</i>.

     The macro <b>SLIST_NEXT </b>returns the next element in the list.

     The macro <b>SLIST_REMOVE_HEAD </b>removes the element <i>elm</i> from the head of
     the list.  For optimum efficiency, elements being removed from the head
     of the list should explicitly use this macro instead of the generic
     <i>SLIST_REMOVE</i> macro.

     The macro <b>SLIST_REMOVE </b>removes the element <i>elm</i> from the list.

   <b>Singly-linked list example</b>
     SLIST_HEAD(slisthead, entry) head =
         SLIST_HEAD_INITIALIZER(head);
     struct slisthead *headp;                /* Singly-linked List head. */
     struct entry {
             ...
             SLIST_ENTRY(entry) entries;     /* Singly-linked List. */
             ...
     } *n1, *n2, *n3, *np;

     SLIST_INIT(&amp;head);                      /* Initialize the list. */

     n1 = malloc(sizeof(struct entry));      /* Insert at the head. */
     SLIST_INSERT_HEAD(&amp;head, n1, entries);

     n2 = malloc(sizeof(struct entry));      /* Insert after. */
     SLIST_INSERT_AFTER(n1, n2, entries);

     SLIST_REMOVE(&amp;head, n2, entry, entries);/* Deletion. */
     free(n2);

     n3 = SLIST_FIRST(&amp;head);
     SLIST_REMOVE_HEAD(&amp;head, entries);      /* Deletion from the head. */
     free(n3);
                                             /* Forward traversal. */
     SLIST_FOREACH(np, &amp;head, entries)
             np-&gt; ...

     while (!SLIST_EMPTY(&amp;head)) {           /* List Deletion. */
             n1 = SLIST_FIRST(&amp;head);
             SLIST_REMOVE_HEAD(&amp;head, entries);
             free(n1);
     }

   <b>Singly-linked tail queues</b>
     A singly-linked tail queue is headed by a structure defined by the
     <b>STAILQ_HEAD </b>macro.  This structure contains a pair of pointers, one to
     the first element in the tail queue and the other to the last element
     in the tail queue.  The elements are singly linked for minimum space
     and pointer manipulation overhead at the expense of O(n) removal for
     arbitrary elements.  New elements can be added to the tail queue after
     an existing element, at the head of the tail queue, or at the end of
     the tail queue.  A <i>STAILQ_HEAD</i> structure is declared as follows:

           STAILQ_HEAD(HEADNAME, TYPE) head;

     where HEADNAME is the name of the structure to be defined, and TYPE is
     the type of the elements to be linked into the tail queue.  A pointer
     to the head of the tail queue can later be declared as:

           struct HEADNAME *headp;

     (The names head and headp are user selectable.)

     The macro <b>STAILQ_HEAD_INITIALIZER </b>evaluates to an initializer for the
     tail queue <i>head</i>.

     The macro <b>STAILQ_CONCAT </b>concatenates the tail queue headed by <i>head2</i>
     onto the end of the one headed by <i>head1</i> removing all entries from the
     former.

     The macro <b>STAILQ_EMPTY </b>evaluates to true if there are no items on the
     tail queue.

     The macro <b>STAILQ_ENTRY </b>declares a structure that connects the elements
     in the tail queue.

     The macro <b>STAILQ_FIRST </b>returns the first item on the tail queue or NULL
     if the tail queue is empty.

     The macro <b>STAILQ_FOREACH </b>traverses the tail queue referenced by <i>head</i> in
     the forward direction, assigning each element in turn to <i>var</i>.

     The macro <b>STAILQ_INIT </b>initializes the tail queue referenced by <i>head</i>.

     The macro <b>STAILQ_INSERT_HEAD </b>inserts the new element <i>elm</i> at the head of
     the tail queue.

     The macro <b>STAILQ_INSERT_TAIL </b>inserts the new element <i>elm</i> at the end of
     the tail queue.

     The macro <b>STAILQ_INSERT_AFTER </b>inserts the new element <i>elm</i> after the
     element <i>listelm</i>.

     The macro <b>STAILQ_NEXT </b>returns the next item on the tail queue, or NULL
     this item is the last.

     The macro <b>STAILQ_REMOVE_HEAD </b>removes the element at the head of the
     tail queue.  For optimum efficiency, elements being removed from the
     head of the tail queue should use this macro explicitly rather than the
     generic <i>STAILQ_REMOVE</i> macro.

     The macro <b>STAILQ_REMOVE </b>removes the element <i>elm</i> from the tail queue.

   <b>Singly-linked tail queue example</b>
     STAILQ_HEAD(stailhead, entry) head =
         STAILQ_HEAD_INITIALIZER(head);
     struct stailhead *headp;                /* Singly-linked tail queue head. */
     struct entry {
             ...
             STAILQ_ENTRY(entry) entries;    /* Tail queue. */
             ...
     } *n1, *n2, *n3, *np;

     STAILQ_INIT(&amp;head);                     /* Initialize the queue. */

     n1 = malloc(sizeof(struct entry));      /* Insert at the head. */
     STAILQ_INSERT_HEAD(&amp;head, n1, entries);

     n1 = malloc(sizeof(struct entry));      /* Insert at the tail. */
     STAILQ_INSERT_TAIL(&amp;head, n1, entries);

     n2 = malloc(sizeof(struct entry));      /* Insert after. */
     STAILQ_INSERT_AFTER(&amp;head, n1, n2, entries);
                                             /* Deletion. */
     STAILQ_REMOVE(&amp;head, n2, entry, entries);
     free(n2);
                                             /* Deletion from the head. */
     n3 = STAILQ_FIRST(&amp;head);
     STAILQ_REMOVE_HEAD(&amp;head, entries);
     free(n3);
                                             /* Forward traversal. */
     STAILQ_FOREACH(np, &amp;head, entries)
             np-&gt; ...
                                             /* TailQ Deletion. */
     while (!STAILQ_EMPTY(&amp;head)) {
             n1 = STAILQ_FIRST(&amp;head);
             STAILQ_REMOVE_HEAD(&amp;head, entries);
             free(n1);
     }
                                             /* Faster TailQ Deletion. */
     n1 = STAILQ_FIRST(&amp;head);
     while (n1 != NULL) {
             n2 = STAILQ_NEXT(n1, entries);
             free(n1);
             n1 = n2;
     }
     STAILQ_INIT(&amp;head);

   <b>Lists</b>
     A list is headed by a structure defined by the <b>LIST_HEAD </b>macro.  This
     structure contains a single pointer to the first element on the list.
     The elements are doubly linked so that an arbitrary element can be
     removed without traversing the list.  New elements can be added to the
     list after an existing element, before an existing element, or at the
     head of the list.  A <i>LIST_HEAD</i> structure is declared as follows:

           LIST_HEAD(HEADNAME, TYPE) head;

     where <i>HEADNAME</i> is the name of the structure to be defined, and <i>TYPE</i> is
     the type of the elements to be linked into the list.  A pointer to the
     head of the list can later be declared as:

           struct HEADNAME *headp;

     (The names head and headp are user selectable.)

     The macro <b>LIST_HEAD_INITIALIZER </b>evaluates to an initializer for the
     list <i>head</i>.

     The macro <b>LIST_EMPTY </b>evaluates to true if there are no elements in the
     list.

     The macro <b>LIST_ENTRY </b>declares a structure that connects the elements in
     the list.

     The macro <b>LIST_FIRST </b>returns the first element in the list or NULL if
     the list is empty.

     The macro <b>LIST_FOREACH </b>traverses the list referenced by <i>head</i> in the
     forward direction, assigning each element in turn to <i>var</i>.

     The macro <b>LIST_INIT </b>initializes the list referenced by <i>head</i>.

     The macro <b>LIST_INSERT_HEAD </b>inserts the new element <i>elm</i> at the head of
     the list.

     The macro <b>LIST_INSERT_AFTER </b>inserts the new element <i>elm</i> after the ele‐
     ment <i>listelm</i>.

     The macro <b>LIST_INSERT_BEFORE </b>inserts the new element <i>elm</i> before the
     element <i>listelm</i>.

     The macro <b>LIST_NEXT </b>returns the next element in the list, or NULL if
     this is the last.

     The macro <b>LIST_REMOVE </b>removes the element <i>elm</i> from the list.

   <b>List example</b>
     LIST_HEAD(listhead, entry) head =
         LIST_HEAD_INITIALIZER(head);
     struct listhead *headp;                 /* List head. */
     struct entry {
             ...
             LIST_ENTRY(entry) entries;      /* List. */
             ...
     } *n1, *n2, *n3, *np, *np_temp;

     LIST_INIT(&amp;head);                       /* Initialize the list. */

     n1 = malloc(sizeof(struct entry));      /* Insert at the head. */
     LIST_INSERT_HEAD(&amp;head, n1, entries);

     n2 = malloc(sizeof(struct entry));      /* Insert after. */
     LIST_INSERT_AFTER(n1, n2, entries);

     n3 = malloc(sizeof(struct entry));      /* Insert before. */
     LIST_INSERT_BEFORE(n2, n3, entries);

     LIST_REMOVE(n2, entries);               /* Deletion. */
     free(n2);
                                             /* Forward traversal. */
     LIST_FOREACH(np, &amp;head, entries)
             np-&gt; ...

     while (!LIST_EMPTY(&amp;head)) {            /* List Deletion. */
             n1 = LIST_FIRST(&amp;head);
             LIST_REMOVE(n1, entries);
             free(n1);
     }

     n1 = LIST_FIRST(&amp;head);                 /* Faster List Deletion. */
     while (n1 != NULL) {
             n2 = LIST_NEXT(n1, entries);
             free(n1);
             n1 = n2;
     }
     LIST_INIT(&amp;head);

   <b>Tail queues</b>
     A tail queue is headed by a structure defined by the <b>TAILQ_HEAD </b>macro.
     This structure contains a pair of pointers, one to the first element in
     the tail queue and the other to the last element in the tail queue.
     The elements are doubly linked so that an arbitrary element can be
     removed without traversing the tail queue.  New elements can be added
     to the tail queue after an existing element, before an existing ele‐
     ment, at the head of the tail queue, or at the end of the tail queue.
     A <i>TAILQ_HEAD</i> structure is declared as follows:

           TAILQ_HEAD(HEADNAME, TYPE) head;

     where HEADNAME is the name of the structure to be defined, and TYPE is
     the type of the elements to be linked into the tail queue.  A pointer
     to the head of the tail queue can later be declared as:

           struct HEADNAME *headp;

     (The names head and headp are user selectable.)

     The macro <b>TAILQ_HEAD_INITIALIZER </b>evaluates to an initializer for the
     tail queue <i>head</i>.

     The macro <b>TAILQ_CONCAT </b>concatenates the tail queue headed by <i>head2</i> onto
     the end of the one headed by <i>head1</i> removing all entries from the for‐
     mer.

     The macro <b>TAILQ_EMPTY </b>evaluates to true if there are no items on the
     tail queue.

     The macro <b>TAILQ_ENTRY </b>declares a structure that connects the elements
     in the tail queue.

     The macro <b>TAILQ_FIRST </b>returns the first item on the tail queue or NULL
     if the tail queue is empty.

     The macro <b>TAILQ_FOREACH </b>traverses the tail queue referenced by <i>head</i> in
     the forward direction, assigning each element in turn to <i>var</i>.  <i>var</i> is
     set to NULL if the loop completes normally, or if there were no ele‐
     ments.

     The macro <b>TAILQ_FOREACH_REVERSE </b>traverses the tail queue referenced by
     <i>head</i> in the reverse direction, assigning each element in turn to <i>var</i>.

     The macro <b>TAILQ_INIT </b>initializes the tail queue referenced by <i>head</i>.

     The macro <b>TAILQ_INSERT_HEAD </b>inserts the new element <i>elm</i> at the head of
     the tail queue.

     The macro <b>TAILQ_INSERT_TAIL </b>inserts the new element <i>elm</i> at the end of
     the tail queue.

     The macro <b>TAILQ_INSERT_AFTER </b>inserts the new element <i>elm</i> after the ele‐
     ment <i>listelm</i>.

     The macro <b>TAILQ_INSERT_BEFORE </b>inserts the new element <i>elm</i> before the
     element <i>listelm</i>.

     The macro <b>TAILQ_LAST </b>returns the last item on the tail queue.  If the
     tail queue is empty the return value is NULL.

     The macro <b>TAILQ_NEXT </b>returns the next item on the tail queue, or NULL
     if this item is the last.

     The macro <b>TAILQ_PREV </b>returns the previous item on the tail queue, or
     NULL if this item is the first.

     The macro <b>TAILQ_REMOVE </b>removes the element <i>elm</i> from the tail queue.

     The macro <b>TAILQ_SWAP </b>swaps the contents of <i>head1</i> and <i>head2</i>.

   <b>Tail queue example</b>
     TAILQ_HEAD(tailhead, entry) head =
         TAILQ_HEAD_INITIALIZER(head);
     struct tailhead *headp;                 /* Tail queue head. */
     struct entry {
             ...
             TAILQ_ENTRY(entry) entries;     /* Tail queue. */
             ...
     } *n1, *n2, *n3, *np;

     TAILQ_INIT(&amp;head);                      /* Initialize the queue. */

     n1 = malloc(sizeof(struct entry));      /* Insert at the head. */
     TAILQ_INSERT_HEAD(&amp;head, n1, entries);

     n1 = malloc(sizeof(struct entry));      /* Insert at the tail. */
     TAILQ_INSERT_TAIL(&amp;head, n1, entries);

     n2 = malloc(sizeof(struct entry));      /* Insert after. */
     TAILQ_INSERT_AFTER(&amp;head, n1, n2, entries);

     n3 = malloc(sizeof(struct entry));      /* Insert before. */
     TAILQ_INSERT_BEFORE(n2, n3, entries);

     TAILQ_REMOVE(&amp;head, n2, entries);       /* Deletion. */
     free(n2);
                                             /* Forward traversal. */
     TAILQ_FOREACH(np, &amp;head, entries)
             np-&gt; ...
                                             /* Reverse traversal. */
     TAILQ_FOREACH_REVERSE(np, &amp;head, tailhead, entries)
             np-&gt; ...
                                             /* TailQ Deletion. */
     while (!TAILQ_EMPTY(&amp;head)) {
             n1 = TAILQ_FIRST(&amp;head);
             TAILQ_REMOVE(&amp;head, n1, entries);
             free(n1);
     }
                                             /* Faster TailQ Deletion. */
     n1 = TAILQ_FIRST(&amp;head);
     while (n1 != NULL) {
             n2 = TAILQ_NEXT(n1, entries);
             free(n1);
             n1 = n2;
     }

     TAILQ_INIT(&amp;head);
     n2 = malloc(sizeof(struct entry));  /* Insert before. */
     CIRCLEQ_INSERT_BEFORE(&amp;head, n1, n2, entries);
                                         /* Forward traversal. */
     for (np = head.cqh_first; np != (void *)&amp;head;
             np = np-&gt;entries.cqe_next)
         np-&gt; ...
                                         /* Reverse traversal. */
     for (np = head.cqh_last; np != (void *)&amp;head; np = np-&gt;entries.cqe_prev)
         np-&gt; ...
                                         /* Delete. */
     while (head.cqh_first != (void *)&amp;head)
         CIRCLEQ_REMOVE(&amp;head, head.cqh_first, entries);
</pre>
<h2><a id="CONFORMING_TO" href="#CONFORMING_TO"></a>CONFORMING TO  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
     Not in POSIX.1, POSIX.1-2001 or POSIX.1-2008.  Present on the BSDs.
     <b>queue </b>functions first appeared in 4.4BSD.
</pre>
<h2><a id="SEE_ALSO" href="#SEE_ALSO"></a>SEE ALSO  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
     insque(3)
</pre>
<h2><a id="COLOPHON" href="#COLOPHON"></a>COLOPHON  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
     This page is part of release 4.12 of the Linux <i>man-pages</i> project.  A
     description of the project, information about reporting bugs, and the
     latest version of this page, can be found at
     <a href="https://www.kernel.org/doc/man-pages/">https://www.kernel.org/doc/man-pages/</a>.

<span class="footline">BSD                           February 7, 2015                           BSD</span>
</pre>

<hr class="end-man-text" />
<p>Pages that refer to this page: 
    <a href="insque.3.html">insque(3)</a>
</p>
<hr/>

<p class="page-copyright"><a href="queue.3.license.html">Copyright and license for this manual page</a></p> 
<hr class="start-footer" />

<div class="footer"> 

<table class="colophon-table">
    <tr>
    <td class="pub-info">
        <p>
            HTML rendering created 2017-07-13
            by <a href="http://man7.org/mtk/index.html">Michael Kerrisk</a>, 
            author of 
            <a href="http://man7.org/tlpi/"><em>The Linux Programming Interface</em></a>, 
            maintainer of the 
            <a href="https://www.kernel.org/doc/man-pages/">Linux <em>man-pages</em> project</a>.
        </p>
        <p>
            For details of in-depth
            <strong>Linux/UNIX system programming training courses</strong>
            that I teach, look <a href="http://man7.org/training/">here</a>.
        </p>
        <p>
            Hosting by <a href="http://www.jambit.com/index_en.html">jambit GmbH</a>.
        </p>
        <p>
            <a href="http://validator.w3.org/check?uri=referer">
            <img src="http://www.w3.org/Icons/valid-xhtml11"
                alt="Valid XHTML 1.1" height="31" width="88" />
            </a>
        </p>
    </td>
    <td class="colophon-divider">
    </td>
    <td class="tlpi-cover">
        <a href="http://man7.org/tlpi/"><img src="../../../tlpi/cover/TLPI-front-cover-vsmall.png" alt="Cover of TLPI" /></a>
    </td>
    </tr>
</table>

</div>

<hr class="end-footer" />



<!--BEGIN-SITETRACKING-->
<!-- SITETRACKING.man7.org_linux_man-pages -->

<!-- Start of StatCounter Code (xhtml) -->

<script type="text/javascript">
//<![CDATA[
var sc_project=7422636; 
var sc_invisible=1; 
var sc_security="9b6714ff"; 
//]]>
</script>
<script type="text/javascript"
src="../../../../www.statcounter.com/counter/counter_xhtml.js"></script>
<noscript><div class="statcounter"><a title="website
statistics" href="http://statcounter.com/"
class="statcounter"><img class="statcounter"
src="http://c.statcounter.com/7422636/0/9b6714ff/1/"
alt="website statistics" /></a></div></noscript>

<!-- End of StatCounter Code -->


<!-- Start of Google Analytics Code -->

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-9830363-8']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<!-- End of Google Analytics Code -->

<!--END-SITETRACKING-->

</body>
</html>
