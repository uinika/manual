
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
        "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
    <link rel="stylesheet" type="text/css" href="../../../style.css" title="style" />
    <link rel="stylesheet" type="text/css" href="../style.css" title="style" />
    <meta http-equiv="content-type" content="text/html;charset=utf-8" />

    <title>pthread_mutexattr_destroy.3p - Linux manual page</title>
</head>

<body>

<div class="page-top"><a id="top_of_page"></a></div>
<!--%%%TOP_BAR%%%-->
    <div class="nav-bar">
        <table class="nav-table">
            <tr>
                <td class="nav-cell">
                    <p class="nav-text">
                        <a href="http://man7.org/index.html">man7.org</a> &gt; Linux &gt; <a href="../index.html">man-pages</a>
                    </p>
                </td>
                <td class="training-cell">
                    <p class="training-text"><a class="training-link" href="http://man7.org/training/">Linux/UNIX system programming training</a></p>
                </td>
            </tr>
        </table>
    </div>

<hr class="nav-end" />

<!--%%%PAGE_START%%%-->


<table class="sec-table">
<tr>
    <td>
        <p class="section-dir">
<a href="#PROLOG">PROLOG</a> | <a href="#NAME">NAME</a> | <a href="#SYNOPSIS">SYNOPSIS</a> | <a href="#DESCRIPTION">DESCRIPTION</a> | <a href="#RETURN_VALUE">RETURN&nbsp;VALUE</a> | <a href="#ERRORS">ERRORS</a> | <a href="#EXAMPLES">EXAMPLES</a> | <a href="#APPLICATION_USAGE">APPLICATION&nbsp;USAGE</a> | <a href="#RATIONALE">RATIONALE</a> | <a href="#FUTURE_DIRECTIONS">FUTURE&nbsp;DIRECTIONS</a> | <a href="#SEE_ALSO">SEE&nbsp;ALSO</a> | <a href="#COPYRIGHT">COPYRIGHT</a>
        </p>
    </td>
    <td class="search-box">
        <div class="man-search-box">

            <form method="get" action="http://www.google.com/search">
                <fieldset class="man-search">
                    <input type="text" name="q" size="10" maxlength="255" value="" />
                    <input type="hidden" name="sitesearch" value="man7.org/linux/man-pages" />
                    <input type="submit" name="sa" value="Search online pages" />
                </fieldset>
            </form>

        </div>
    </td>
    <td> </td>
</tr>
</table>

<pre>
<span class="headline">PTHREAD_MUTEXATTR_DESTROY(3P)IX Programmer's ManualEAD_MUTEXATTR_DESTROY(3P)</span>
</pre>
<h2><a id="PROLOG" href="#PROLOG"></a>PROLOG  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       This manual page is part of the POSIX Programmer's Manual.  The Linux
       implementation of this interface may differ (consult the
       corresponding Linux manual page for details of Linux behavior), or
       the interface may not be implemented on Linux.
</pre>
<h2><a id="NAME" href="#NAME"></a>NAME  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       pthread_mutexattr_destroy, pthread_mutexattr_init — destroy and
       initialize the mutex attributes object
</pre>
<h2><a id="SYNOPSIS" href="#SYNOPSIS"></a>SYNOPSIS  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       #include &lt;pthread.h&gt;

       int pthread_mutexattr_destroy(pthread_mutexattr_t *<i>attr</i>);
       int pthread_mutexattr_init(pthread_mutexattr_t *<i>attr</i>);
</pre>
<h2><a id="DESCRIPTION" href="#DESCRIPTION"></a>DESCRIPTION  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       The <i>pthread_mutexattr_destroy</i>() function shall destroy a mutex
       attributes object; the object becomes, in effect, uninitialized. An
       implementation may cause <i>pthread_mutexattr_destroy</i>() to set the
       object referenced by <i>attr</i> to an invalid value.

       A destroyed <i>attr</i> attributes object can be reinitialized using
       <i>pthread_mutexattr_init</i>(); the results of otherwise referencing the
       object after it has been destroyed are undefined.

       The <i>pthread_mutexattr_init</i>() function shall initialize a mutex
       attributes object <i>attr</i> with the default value for all of the
       attributes defined by the implementation.

       Results are undefined if <i>pthread_mutexattr_init</i>() is called
       specifying an already initialized <i>attr</i> attributes object.

       After a mutex attributes object has been used to initialize one or
       more mutexes, any function affecting the attributes object (including
       destruction) shall not affect any previously initialized mutexes.

       The behavior is undefined if the value specified by the <i>attr</i> argument
       to <i>pthread_mutexattr_destroy</i>() does not refer to an initialized mutex
       attributes object.
</pre>
<h2><a id="RETURN_VALUE" href="#RETURN_VALUE"></a>RETURN VALUE  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       Upon successful completion, <i>pthread_mutexattr_destroy</i>() and
       <i>pthread_mutexattr_init</i>() shall return zero; otherwise, an error
       number shall be returned to indicate the error.
</pre>
<h2><a id="ERRORS" href="#ERRORS"></a>ERRORS  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       The <i>pthread_mutexattr_init</i>() function shall fail if:

       <b>ENOMEM </b>Insufficient memory exists to initialize the mutex attributes
              object.

       These functions shall not return an error code of <b>[EINTR]</b>.

       <i>The following sections are informative.</i>
</pre>
<h2><a id="EXAMPLES" href="#EXAMPLES"></a>EXAMPLES  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       None.
</pre>
<h2><a id="APPLICATION_USAGE" href="#APPLICATION_USAGE"></a>APPLICATION USAGE  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       None.
</pre>
<h2><a id="RATIONALE" href="#RATIONALE"></a>RATIONALE  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       If an implementation detects that the value specified by the <i>attr</i>
       argument to <i>pthread_mutexattr_destroy</i>() does not refer to an
       initialized mutex attributes object, it is recommended that the
       function should fail and report an <b>[EINVAL] </b>error.

       See <a href="pthread_attr_destroy.3p.html">pthread_attr_destroy(3p)</a> for a general explanation of attributes.
       Attributes objects allow implementations to experiment with useful
       extensions and permit extension of this volume of POSIX.1‐2008
       without changing the existing functions. Thus, they provide for
       future extensibility of this volume of POSIX.1‐2008 and reduce the
       temptation to standardize prematurely on semantics that are not yet
       widely implemented or understood.

       Examples of possible additional mutex attributes that have been
       discussed are <i>spin_only</i>, <i>limited_spin</i>, <i>no_spin</i>, <i>recursive</i>, and
       <i>metered</i>.  (To explain what the latter attributes might mean:
       recursive mutexes would allow for multiple re-locking by the current
       owner; metered mutexes would transparently keep records of queue
       length, wait time, and so on.) Since there is not yet wide agreement
       on the usefulness of these resulting from shared implementation and
       usage experience, they are not yet specified in this volume of
       POSIX.1‐2008. Mutex attributes objects, however, make it possible to
       test out these concepts for possible standardization at a later time.

   <b>Mutex Attributes and Performance</b>
       Care has been taken to ensure that the default values of the mutex
       attributes have been defined such that mutexes initialized with the
       defaults have simple enough semantics so that the locking and
       unlocking can be done with the equivalent of a test-and-set
       instruction (plus possibly a few other basic instructions).

       There is at least one implementation method that can be used to
       reduce the cost of testing at lock-time if a mutex has non-default
       attributes. One such method that an implementation can employ (and
       this can be made fully transparent to fully conforming POSIX
       applications) is to secretly pre-lock any mutexes that are
       initialized to non-default attributes. Any later attempt to lock such
       a mutex causes the implementation to branch to the ``slow path'' as
       if the mutex were unavailable; then, on the slow path, the
       implementation can do the ``real work'' to lock a non-default mutex.
       The underlying unlock operation is more complicated since the
       implementation never really wants to release the pre-lock on this
       kind of mutex. This illustrates that, depending on the hardware,
       there may be certain optimizations that can be used so that whatever
       mutex attributes are considered ``most frequently used'' can be
       processed most efficiently.

   <b>Process Shared Memory and Synchronization</b>
       The existence of memory mapping functions in this volume of
       POSIX.1‐2008 leads to the possibility that an application may
       allocate the synchronization objects from this section in memory that
       is accessed by multiple processes (and therefore, by threads of
       multiple processes).

       In order to permit such usage, while at the same time keeping the
       usual case (that is, usage within a single process) efficient, a
       <i>process-shared</i> option has been defined.

       If an implementation supports the _POSIX_THREAD_PROCESS_SHARED
       option, then the <i>process-shared</i> attribute can be used to indicate
       that mutexes or condition variables may be accessed by threads of
       multiple processes.

       The default setting of PTHREAD_PROCESS_PRIVATE has been chosen for
       the <i>process-shared</i> attribute so that the most efficient forms of
       these synchronization objects are created by default.

       Synchronization variables that are initialized with the
       PTHREAD_PROCESS_PRIVATE <i>process-shared</i> attribute may only be operated
       on by threads in the process that initialized them. Synchronization
       variables that are initialized with the PTHREAD_PROCESS_SHARED
       <i>process-shared</i> attribute may be operated on by any thread in any
       process that has access to it. In particular, these processes may
       exist beyond the lifetime of the initializing process. For example,
       the following code implements a simple counting semaphore in a mapped
       file that may be used by many processes.

           <b>/* sem.h */</b>
           <b>struct semaphore {</b>
               <b>pthread_mutex_t lock;</b>
               <b>pthread_cond_t nonzero;</b>
               <b>unsigned count;</b>
           <b>};</b>
           <b>typedef struct semaphore semaphore_t;</b>

           semaphore_t *semaphore_create(char *semaphore_name);
           semaphore_t *semaphore_open(char *semaphore_name);
           void semaphore_post(semaphore_t *semap);
           void semaphore_wait(semaphore_t *semap);
           void semaphore_close(semaphore_t *semap);

           /* sem.c */
           #include &lt;sys/types.h&gt;
           #include &lt;sys/stat.h&gt;
           #include &lt;sys/mman.h&gt;
           #include &lt;fcntl.h&gt;
           #include &lt;pthread.h&gt;
           #include "sem.h"

           semaphore_t *
           semaphore_create(char *semaphore_name)
           {
           int fd;
               semaphore_t *semap;
               pthread_mutexattr_t psharedm;
               pthread_condattr_t psharedc;

               fd = open(semaphore_name, O_RDWR | O_CREAT | O_EXCL, 0666);
               if (fd &lt; 0)
                   return (NULL);
               (void) ftruncate(fd, sizeof(semaphore_t));
               (void) pthread_mutexattr_init(&amp;psharedm);
               (void) pthread_mutexattr_setpshared(&amp;psharedm,
                   PTHREAD_PROCESS_SHARED);
               (void) pthread_condattr_init(&amp;psharedc);
               (void) pthread_condattr_setpshared(&amp;psharedc,
                   PTHREAD_PROCESS_SHARED);
               semap = (semaphore_t *) mmap(NULL, sizeof(semaphore_t),
                       PROT_READ | PROT_WRITE, MAP_SHARED,
                       fd, 0);
               close (fd);
               (void) pthread_mutex_init(&amp;semap-&gt;lock, &amp;psharedm);
               (void) pthread_cond_init(&amp;semap-&gt;nonzero, &amp;psharedc);
               semap-&gt;count = 0;
               return (semap);
           }

           semaphore_t *
           semaphore_open(char *semaphore_name)
           {
               int fd;
               semaphore_t *semap;

               fd = open(semaphore_name, O_RDWR, 0666);
               if (fd &lt; 0)
                   return (NULL);
               semap = (semaphore_t *) mmap(NULL, sizeof(semaphore_t),
                       PROT_READ | PROT_WRITE, MAP_SHARED,
                       fd, 0);
               close (fd);
               return (semap);
           }

           void
           semaphore_post(semaphore_t *semap)
           {
               pthread_mutex_lock(&amp;semap-&gt;lock);
               if (semap-&gt;count == 0)
                   pthread_cond_signal(&amp;semapx-&gt;nonzero);
               semap-&gt;count++;
               pthread_mutex_unlock(&amp;semap-&gt;lock);
           }

           void
           semaphore_wait(semaphore_t *semap)
           {
               pthread_mutex_lock(&amp;semap-&gt;lock);
               while (semap-&gt;count == 0)
                   pthread_cond_wait(&amp;semap-&gt;nonzero, &amp;semap-&gt;lock);
               semap-&gt;count--;
               pthread_mutex_unlock(&amp;semap-&gt;lock);
           }

           void
           semaphore_close(semaphore_t *semap)
           {
               munmap((void *) semap, sizeof(semaphore_t));
           }

       The following code is for three separate processes that create, post,
       and wait on a semaphore in the file <b>/tmp/semaphore</b>.  Once the file is
       created, the post and wait programs increment and decrement the
       counting semaphore (waiting and waking as required) even though they
       did not initialize the semaphore.

           <b>/* create.c */</b>
           <b>#include "pthread.h"</b>
           <b>#include "sem.h"</b>

           int
           main()
           {
               semaphore_t *semap;

               semap = semaphore_create("/tmp/semaphore");
               if (semap == NULL)
                   exit(1);
               semaphore_close(semap);
               return (0);
           }

           /* post */
           #include "pthread.h"
           #include "sem.h"

           int
           main()
           {
               semaphore_t *semap;

               semap = semaphore_open("/tmp/semaphore");
               if (semap == NULL)
                   exit(1);
               semaphore_post(semap);
               semaphore_close(semap);
               return (0);
           }

           /* wait */
           #include "pthread.h"
           #include "sem.h"

           int
           main()
           {
               semaphore_t *semap;

               semap = semaphore_open("/tmp/semaphore");
               if (semap == NULL)
                   exit(1);
               semaphore_wait(semap);
               semaphore_close(semap);
               return (0);
           }
</pre>
<h2><a id="FUTURE_DIRECTIONS" href="#FUTURE_DIRECTIONS"></a>FUTURE DIRECTIONS  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       None.
</pre>
<h2><a id="SEE_ALSO" href="#SEE_ALSO"></a>SEE ALSO  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       <a href="pthread_cond_destroy.3p.html">pthread_cond_destroy(3p)</a>, <a href="pthread_create.3p.html">pthread_create(3p)</a>,
       <a href="pthread_mutex_destroy.3p.html">pthread_mutex_destroy(3p)</a>

       The Base Definitions volume of POSIX.1‐2008, <a href="../man0/pthread.h.0p.html">pthread.h(0p)</a>
</pre>
<h2><a id="COPYRIGHT" href="#COPYRIGHT"></a>COPYRIGHT  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       Portions of this text are reprinted and reproduced in electronic form
       from IEEE Std 1003.1, 2013 Edition, Standard for Information
       Technology -- Portable Operating System Interface (POSIX), The Open
       Group Base Specifications Issue 7, Copyright (C) 2013 by the
       Institute of Electrical and Electronics Engineers, Inc and The Open
       Group.  (This is POSIX.1-2008 with the 2013 Technical Corrigendum 1
       applied.) In the event of any discrepancy between this version and
       the original IEEE and The Open Group Standard, the original IEEE and
       The Open Group Standard is the referee document. The original
       Standard can be obtained online at <a href="http://www.unix.org/online.html">http://www.unix.org/online.html</a> .

       Any typographical or formatting errors that appear in this page are
       most likely to have been introduced during the conversion of the
       source files to man page format. To report such errors, see
       <a href="https://www.kernel.org/doc/man-pages/reporting_bugs.html">https://www.kernel.org/doc/man-pages/reporting_bugs.html</a> .

<span class="footline">IEEE/The Open Group                 2013       PTHREAD_MUTEXATTR_DESTROY(3P)</span>
</pre>

<hr class="end-man-text" />
<p>Pages that refer to this page: 
    <a href="../man0/pthread.h.0p.html">pthread.h(0p)</a>,&nbsp; 
    <a href="pthread_mutexattr_getpshared.3p.html">pthread_mutexattr_getpshared(3p)</a>,&nbsp; 
    <a href="pthread_mutexattr_init.3p.html">pthread_mutexattr_init(3p)</a>
</p>
<hr/>

 
<hr class="start-footer" />

<div class="footer"> 

<table class="colophon-table">
    <tr>
    <td class="pub-info">
        <p>
            HTML rendering created 2017-07-13
            by <a href="http://man7.org/mtk/index.html">Michael Kerrisk</a>, 
            author of 
            <a href="http://man7.org/tlpi/"><em>The Linux Programming Interface</em></a>, 
            maintainer of the 
            <a href="https://www.kernel.org/doc/man-pages/">Linux <em>man-pages</em> project</a>.
        </p>
        <p>
            For details of in-depth
            <strong>Linux/UNIX system programming training courses</strong>
            that I teach, look <a href="http://man7.org/training/">here</a>.
        </p>
        <p>
            Hosting by <a href="http://www.jambit.com/index_en.html">jambit GmbH</a>.
        </p>
        <p>
            <a href="http://validator.w3.org/check?uri=referer">
            <img src="http://www.w3.org/Icons/valid-xhtml11"
                alt="Valid XHTML 1.1" height="31" width="88" />
            </a>
        </p>
    </td>
    <td class="colophon-divider">
    </td>
    <td class="tlpi-cover">
        <a href="http://man7.org/tlpi/"><img src="../../../tlpi/cover/TLPI-front-cover-vsmall.png" alt="Cover of TLPI" /></a>
    </td>
    </tr>
</table>

</div>

<hr class="end-footer" />



<!--BEGIN-SITETRACKING-->
<!-- SITETRACKING.man7.org_linux_man-pages -->

<!-- Start of StatCounter Code (xhtml) -->

<script type="text/javascript">
//<![CDATA[
var sc_project=7422636; 
var sc_invisible=1; 
var sc_security="9b6714ff"; 
//]]>
</script>
<script type="text/javascript"
src="../../../../www.statcounter.com/counter/counter_xhtml.js"></script>
<noscript><div class="statcounter"><a title="website
statistics" href="http://statcounter.com/"
class="statcounter"><img class="statcounter"
src="http://c.statcounter.com/7422636/0/9b6714ff/1/"
alt="website statistics" /></a></div></noscript>

<!-- End of StatCounter Code -->


<!-- Start of Google Analytics Code -->

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-9830363-8']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<!-- End of Google Analytics Code -->

<!--END-SITETRACKING-->

</body>
</html>
