
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
        "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
    <link rel="stylesheet" type="text/css" href="../../../style.css" title="style" />
    <link rel="stylesheet" type="text/css" href="../style.css" title="style" />
    <meta http-equiv="content-type" content="text/html;charset=utf-8" />

    <title>exec.3p - Linux manual page</title>
</head>

<body>

<div class="page-top"><a id="top_of_page"></a></div>
<!--%%%TOP_BAR%%%-->
    <div class="nav-bar">
        <table class="nav-table">
            <tr>
                <td class="nav-cell">
                    <p class="nav-text">
                        <a href="http://man7.org/index.html">man7.org</a> &gt; Linux &gt; <a href="../index.html">man-pages</a>
                    </p>
                </td>
                <td class="training-cell">
                    <p class="training-text"><a class="training-link" href="http://man7.org/training/">Linux/UNIX system programming training</a></p>
                </td>
            </tr>
        </table>
    </div>

<hr class="nav-end" />

<!--%%%PAGE_START%%%-->


<table class="sec-table">
<tr>
    <td>
        <p class="section-dir">
<a href="#PROLOG">PROLOG</a> | <a href="#NAME">NAME</a> | <a href="#SYNOPSIS">SYNOPSIS</a> | <a href="#DESCRIPTION">DESCRIPTION</a> | <a href="#RETURN_VALUE">RETURN&nbsp;VALUE</a> | <a href="#ERRORS">ERRORS</a> | <a href="#EXAMPLES">EXAMPLES</a> | <a href="#APPLICATION_USAGE">APPLICATION&nbsp;USAGE</a> | <a href="#RATIONALE">RATIONALE</a> | <a href="#FUTURE_DIRECTIONS">FUTURE&nbsp;DIRECTIONS</a> | <a href="#SEE_ALSO">SEE&nbsp;ALSO</a> | <a href="#COPYRIGHT">COPYRIGHT</a>
        </p>
    </td>
    <td class="search-box">
        <div class="man-search-box">

            <form method="get" action="http://www.google.com/search">
                <fieldset class="man-search">
                    <input type="text" name="q" size="10" maxlength="255" value="" />
                    <input type="hidden" name="sitesearch" value="man7.org/linux/man-pages" />
                    <input type="submit" name="sa" value="Search online pages" />
                </fieldset>
            </form>

        </div>
    </td>
    <td> </td>
</tr>
</table>

<pre>
<span class="headline">EXEC(3P)                  POSIX Programmer's Manual                 EXEC(3P)</span>
</pre>
<h2><a id="PROLOG" href="#PROLOG"></a>PROLOG  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       This manual page is part of the POSIX Programmer's Manual.  The Linux
       implementation of this interface may differ (consult the
       corresponding Linux manual page for details of Linux behavior), or
       the interface may not be implemented on Linux.
</pre>
<h2><a id="NAME" href="#NAME"></a>NAME  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       environ, execl, execle, execlp, execv, execve, execvp, fexecve —
       execute a file
</pre>
<h2><a id="SYNOPSIS" href="#SYNOPSIS"></a>SYNOPSIS  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       #include &lt;unistd.h&gt;

       extern char **environ;
       int execl(const char *<i>path</i>, const char *<i>arg0</i>, ... /*, (char *)0 */);
       int execle(const char *<i>path</i>, const char *<i>arg0</i>, ... /*,
           (char *)0, char *const <i>envp</i>[]*/);
       int execlp(const char *<i>file</i>, const char *<i>arg0</i>, ... /*, (char *)0 */);
       int execv(const char *<i>path</i>, char *const <i>argv</i>[]);
       int execve(const char *<i>path</i>, char *const <i>argv</i>[], char *const <i>envp</i>[]);
       int execvp(const char *<i>file</i>, char *const <i>argv</i>[]);
       int fexecve(int <i>fd</i>, char *const <i>argv</i>[], char *const <i>envp</i>[]);
</pre>
<h2><a id="DESCRIPTION" href="#DESCRIPTION"></a>DESCRIPTION  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       The <i>exec</i> family of functions shall replace the current process image
       with a new process image. The new image shall be constructed from a
       regular, executable file called the <i>new process image file</i>.  There
       shall be no return from a successful <i>exec</i>, because the calling
       process image is overlaid by the new process image.

       The <i>fexecve</i>() function shall be equivalent to the <i>execve</i>() function
       except that the file to be executed is determined by the file
       descriptor <i>fd</i> instead of a pathname. The file offset of <i>fd</i> is
       ignored.

       When a C-language program is executed as a result of a call to one of
       the <i>exec</i> family of functions, it shall be entered as a C-language
       function call as follows:

           <b>int main (</b><i>int argc, char *argv</i><b>[]);</b>

       where <i>argc</i> is the argument count and <i>argv</i> is an array of character
       pointers to the arguments themselves.  In addition, the following
       variable, which must be declared by the user if it is to be used
       directly:

           <b>extern char **environ;</b>

       is initialized as a pointer to an array of character pointers to the
       environment strings. The <i>argv</i> and <i>environ</i> arrays are each terminated
       by a null pointer. The null pointer terminating the <i>argv</i> array is not
       counted in <i>argc</i>.

       Applications can change the entire environment in a single operation
       by assigning the <i>environ</i> variable to point to an array of character
       pointers to the new environment strings. After assigning a new value
       to <i>environ</i>, applications should not rely on the new environment
       strings remaining part of the environment, as a call to <i>getenv</i>(),
       <i>putenv</i>(), <i>setenv</i>(), <i>unsetenv</i>(), or any function that is dependent on
       an environment variable may, on noticing that <i>environ</i> has changed,
       copy the environment strings to a new array and assign <i>environ</i> to
       point to it.

       Any application that directly modifies the pointers to which the
       <i>environ</i> variable points has undefined behavior.

       Conforming multi-threaded applications shall not use the <i>environ</i>
       variable to access or modify any environment variable while any other
       thread is concurrently modifying any environment variable. A call to
       any function dependent on any environment variable shall be
       considered a use of the <i>environ</i> variable to access that environment
       variable.

       The arguments specified by a program with one of the <i>exec</i> functions
       shall be passed on to the new process image in the corresponding
       <i>main</i>() arguments.

       The argument <i>path</i> points to a pathname that identifies the new
       process image file.

       The argument <i>file</i> is used to construct a pathname that identifies the
       new process image file. If the <i>file</i> argument contains a &lt;slash&gt;
       character, the <i>file</i> argument shall be used as the pathname for this
       file. Otherwise, the path prefix for this file is obtained by a
       search of the directories passed as the environment variable <i>PATH</i>
       (see the Base Definitions volume of POSIX.1‐2008, <i>Chapter 8</i>,
       <i>Environment Variables</i>).  If this environment variable is not present,
       the results of the search are implementation-defined.

       There are two distinct ways in which the contents of the process
       image file may cause the execution to fail, distinguished by the
       setting of <i><a href="errno.3.html">errno</a></i> to either <b>[ENOEXEC] </b>or <b>[EINVAL] </b>(see the ERRORS
       section). In the cases where the other members of the <i>exec</i> family of
       functions would fail and set <i><a href="errno.3.html">errno</a></i> to <b>[ENOEXEC]</b>, the <i>execlp</i>() and
       <i>execvp</i>() functions shall execute a command interpreter and the
       environment of the executed command shall be as if the process
       invoked the <i>sh</i> utility using <i>execl</i>() as follows:

           <b>execl(&lt;shell path&gt;, arg0, file, arg1, ..., (char *)0);</b>

       where &lt;<i>shell path</i>&gt; is an unspecified pathname for the <i>sh</i> utility,
       <i>file</i> is the process image file, and for <i>execvp</i>(), where <i>arg</i>0, <i>arg</i>1,
       and so on correspond to the values passed to <i>execvp</i>() in <i>argv</i>[0],
       <i>argv</i>[1], and so on.

       The arguments represented by <i>arg0</i>,...  are pointers to null-
       terminated character strings. These strings shall constitute the
       argument list available to the new process image. The list is
       terminated by a null pointer. The argument <i>arg0</i> should point to a
       filename string that is associated with the process being started by
       one of the <i>exec</i> functions.

       The argument <i>argv</i> is an array of character pointers to null-
       terminated strings. The application shall ensure that the last member
       of this array is a null pointer. These strings shall constitute the
       argument list available to the new process image. The value in
       <i>argv</i>[0] should point to a filename string that is associated with the
       process being started by one of the <i>exec</i> functions.

       The argument <i>envp</i> is an array of character pointers to null-
       terminated strings. These strings shall constitute the environment
       for the new process image.  The <i>envp</i> array is terminated by a null
       pointer.

       For those forms not containing an <i>envp</i> pointer (<i>execl</i>(), <i>execv</i>(),
       <i>execlp</i>(), and <i>execvp</i>()), the environment for the new process image
       shall be taken from the external variable <i>environ</i> in the calling
       process.

       The number of bytes available for the new process' combined argument
       and environment lists is {ARG_MAX}.  It is implementation-defined
       whether null terminators, pointers, and/or any alignment bytes are
       included in this total.

       File descriptors open in the calling process image shall remain open
       in the new process image, except for those whose close-on-<i>exec</i> flag
       FD_CLOEXEC is set.  For those file descriptors that remain open, all
       attributes of the open file description remain unchanged. For any
       file descriptor that is closed for this reason, file locks are
       removed as a result of the close as described in <i>close</i>().  Locks that
       are not removed by closing of file descriptors remain unchanged.

       If file descriptor 0, 1, or 2 would otherwise be closed after a
       successful call to one of the <i>exec</i> family of functions,
       implementations may open an unspecified file for the file descriptor
       in the new process image. If a standard utility or a conforming
       application is executed with file descriptor 0 not open for reading
       or with file descriptor 1 or 2 not open for writing, the environment
       in which the utility or application is executed shall be deemed non-
       conforming, and consequently the utility or application might not
       behave as described in this standard.

       Directory streams open in the calling process image shall be closed
       in the new process image.

       The state of the floating-point environment in the initial thread of
       the new process image shall be set to the default.

       The state of conversion descriptors and message catalog descriptors
       in the new process image is undefined.

       For the new process image, the equivalent of:

           <b>setlocale(LC_ALL, "C")</b>

       shall be executed at start-up.

       Signals set to the default action (SIG_DFL) in the calling process
       image shall be set to the default action in the new process image.
       Except for SIGCHLD, signals set to be ignored (SIG_IGN) by the
       calling process image shall be set to be ignored by the new process
       image. Signals set to be caught by the calling process image shall be
       set to the default action in the new process image (see <i>&lt;signal.h&gt;</i>).

       If the SIGCHLD signal is set to be ignored by the calling process
       image, it is unspecified whether the SIGCHLD signal is set to be
       ignored or to the default action in the new process image.

       After a successful call to any of the <i>exec</i> functions, alternate
       signal stacks are not preserved and the SA_ONSTACK flag shall be
       cleared for all signals.

       After a successful call to any of the <i>exec</i> functions, any functions
       previously registered by the <i>atexit</i>() or <i>pthread_atfork</i>() functions
       are no longer registered.

       If the ST_NOSUID bit is set for the file system containing the new
       process image file, then the effective user ID, effective group ID,
       saved set-user-ID, and saved set-group-ID are unchanged in the new
       process image. Otherwise, if the set-user-ID mode bit of the new
       process image file is set, the effective user ID of the new process
       image shall be set to the user ID of the new process image file.
       Similarly, if the set-group-ID mode bit of the new process image file
       is set, the effective group ID of the new process image shall be set
       to the group ID of the new process image file. The real user ID, real
       group ID, and supplementary group IDs of the new process image shall
       remain the same as those of the calling process image. The effective
       user ID and effective group ID of the new process image shall be
       saved (as the saved set-user-ID and the saved set-group-ID) for use
       by <i>setuid</i>().

       Any shared memory segments attached to the calling process image
       shall not be attached to the new process image.

       Any named semaphores open in the calling process shall be closed as
       if by appropriate calls to <i>sem_close</i>().

       Any blocks of typed memory that were mapped in the calling process
       are unmapped, as if <i>munmap</i>() was implicitly called to unmap them.

       Memory locks established by the calling process via calls to
       <i>mlockall</i>() or <i>mlock</i>() shall be removed. If locked pages in the
       address space of the calling process are also mapped into the address
       spaces of other processes and are locked by those processes, the
       locks established by the other processes shall be unaffected by the
       call by this process to the <i>exec</i> function. If the <i>exec</i> function
       fails, the effect on memory locks is unspecified.

       Memory mappings created in the process are unmapped before the
       address space is rebuilt for the new process image.

       When the calling process image does not use the SCHED_FIFO, SCHED_RR,
       or SCHED_SPORADIC scheduling policies, the scheduling policy and
       parameters of the new process image and the initial thread in that
       new process image are implementation-defined.

       When the calling process image uses the SCHED_FIFO, SCHED_RR, or
       SCHED_SPORADIC scheduling policies, the process policy and scheduling
       parameter settings shall not be changed by a call to an <i>exec</i>
       function.  The initial thread in the new process image shall inherit
       the process scheduling policy and parameters. It shall have the
       default system contention scope, but shall inherit its allocation
       domain from the calling process image.

       Per-process timers created by the calling process shall be deleted
       before replacing the current process image with the new process
       image.

       All open message queue descriptors in the calling process shall be
       closed, as described in <i>mq_close</i>().

       Any outstanding asynchronous I/O operations may be canceled. Those
       asynchronous I/O operations that are not canceled shall complete as
       if the <i>exec</i> function had not yet occurred, but any associated signal
       notifications shall be suppressed. It is unspecified whether the <i>exec</i>
       function itself blocks awaiting such I/O completion. In no event,
       however, shall the new process image created by the <i>exec</i> function be
       affected by the presence of outstanding asynchronous I/O operations
       at the time the <i>exec</i> function is called. Whether any I/O is canceled,
       and which I/O may be canceled upon <i>exec</i>, is implementation-defined.

       The new process image shall inherit the CPU-time clock of the calling
       process image. This inheritance means that the process CPU-time clock
       of the process being <i>exec</i>-ed shall not be reinitialized or altered as
       a result of the <i>exec</i> function other than to reflect the time spent by
       the process executing the <i>exec</i> function itself.

       The initial value of the CPU-time clock of the initial thread of the
       new process image shall be set to zero.

       If the calling process is being traced, the new process image shall
       continue to be traced into the same trace stream as the original
       process image, but the new process image shall not inherit the
       mapping of trace event names to trace event type identifiers that was
       defined by calls to the <i>posix_trace_eventid_open</i>() or the
       <i>posix_trace_trid_eventid_open</i>() functions in the calling process
       image.

       If the calling process is a trace controller process, any trace
       streams that were created by the calling process shall be shut down
       as described in the <i>posix_trace_shutdown</i>() function.

       The thread ID of the initial thread in the new process image is
       unspecified.

       The size and location of the stack on which the initial thread in the
       new process image runs is unspecified.

       The initial thread in the new process image shall have its
       cancellation type set to PTHREAD_CANCEL_DEFERRED and its cancellation
       state set to PTHREAD_CANCEL_ENABLED.

       The initial thread in the new process image shall have all thread-
       specific data values set to NULL and all thread-specific data keys
       shall be removed by the call to <i>exec</i> without running destructors.

       The initial thread in the new process image shall be joinable, as if
       created with the <i>detachstate</i> attribute set to
       PTHREAD_CREATE_JOINABLE.

       The new process shall inherit at least the following attributes from
       the calling process image:

        *  Nice value (see <i>nice</i>())

        *  <i>semadj</i> values (see <i>semop</i>())

        *  Process ID

        *  Parent process ID

        *  Process group ID

        *  Session membership

        *  Real user ID

        *  Real group ID

        *  Supplementary group IDs

        *  Time left until an alarm clock signal (see <i>alarm</i>())

        *  Current working directory

        *  Root directory

        *  File mode creation mask (see <i>umask</i>())

        *  File size limit (see <i>getrlimit</i>() and <i>setrlimit</i>())

        *  Process signal mask (see <i>pthread_sigmask</i>())

        *  Pending signal (see <i>sigpending</i>())

        *  <i>tms_utime</i>, <i>tms_stime</i>, <i>tms_cutime</i>, and <i>tms_cstime</i> (see <i>times</i>())

        *  Resource limits

        *  Controlling terminal

        *  Interval timers

       The initial thread of the new process shall inherit at least the
       following attributes from the calling thread:

        *  Signal mask (see <i>sigprocmask</i>() and <i>pthread_sigmask</i>())

        *  Pending signals (see <i>sigpending</i>())

       All other process attributes defined in this volume of POSIX.1‐2008
       shall be inherited in the new process image from the old process
       image. All other thread attributes defined in this volume of
       POSIX.1‐2008 shall be inherited in the initial thread in the new
       process image from the calling thread in the old process image.  The
       inheritance of process or thread attributes not defined by this
       volume of POSIX.1‐2008 is implementation-defined.

       A call to any <i>exec</i> function from a process with more than one thread
       shall result in all threads being terminated and the new executable
       image being loaded and executed. No destructor functions or cleanup
       handlers shall be called.

       Upon successful completion, the <i>exec</i> functions shall mark for update
       the last data access timestamp of the file. If an <i>exec</i> function
       failed but was able to locate the process image file, whether the
       last data access timestamp is marked for update is unspecified.
       Should the <i>exec</i> function succeed, the process image file shall be
       considered to have been opened with <i>open</i>().  The corresponding
       <i>close</i>() shall be considered to occur at a time after this open, but
       before process termination or successful completion of a subsequent
       call to one of the <i>exec</i> functions, <i>posix_spawn</i>(), or <i>posix_spawnp</i>().
       The <i>argv</i>[] and <i>envp</i>[] arrays of pointers and the strings to which
       those arrays point shall not be modified by a call to one of the <i>exec</i>
       functions, except as a consequence of replacing the process image.

       The saved resource limits in the new process image are set to be a
       copy of the process' corresponding hard and soft limits.
</pre>
<h2><a id="RETURN_VALUE" href="#RETURN_VALUE"></a>RETURN VALUE  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       If one of the <i>exec</i> functions returns to the calling process image, an
       error has occurred; the return value shall be −1, and <i><a href="errno.3.html">errno</a></i> shall be
       set to indicate the error.
</pre>
<h2><a id="ERRORS" href="#ERRORS"></a>ERRORS  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       The <i>exec</i> functions shall fail if:

       <b>E2BIG  </b>The number of bytes used by the new process image's argument
              list and environment list is greater than the system-imposed
              limit of {ARG_MAX} bytes.

       <b>EACCES </b>The new process image file is not a regular file and the
              implementation does not support execution of files of its
              type.

       <b>EINVAL </b>The new process image file has appropriate privileges and has
              a recognized executable binary format, but the system does not
              support execution of a file with this format.

       The <i>exec</i> functions, except for <i>fexecve</i>(), shall fail if:

       <b>EACCES </b>Search permission is denied for a directory listed in the new
              process image file's path prefix, or the new process image
              file denies execution permission.

       <b>ELOOP  </b>A loop exists in symbolic links encountered during resolution
              of the <i>path</i> or <i>file</i> argument.

       <b>ENAMETOOLONG</b>
              The length of a component of a pathname is longer than
              {NAME_MAX}.

       <b>ENOENT </b>A component of <i>path</i> or <i>file</i> does not name an existing file or
              <i>path</i> or <i>file</i> is an empty string.

       <b>ENOTDIR</b>
              A component of the new process image file's path prefix names
              an existing file that is neither a directory nor a symbolic
              link to a directory, or the new process image file's pathname
              contains at least one non-&lt;slash&gt; character and ends with one
              or more trailing &lt;slash&gt; characters and the last pathname
              component names an existing file that is neither a directory
              nor a symbolic link to a directory.

       The <i>exec</i> functions, except for <i>execlp</i>() and <i>execvp</i>(), shall fail if:

       <b>ENOEXEC</b>
              The new process image file has the appropriate access
              permission but has an unrecognized format.

       The <i>fexecve</i>() function shall fail if:

       <b>EBADF  </b>The <i>fd</i> argument is not a valid file descriptor open for
              executing.

       The <i>exec</i> functions may fail if:

       <b>ENOMEM </b>The new process image requires more memory than is allowed by
              the hardware or system-imposed memory management constraints.

       The <i>exec</i> functions, except for <i>fexecve</i>(), may fail if:

       <b>ELOOP  </b>More than {SYMLOOP_MAX} symbolic links were encountered during
              resolution of the <i>path</i> or <i>file</i> argument.

       <b>ENAMETOOLONG</b>
              The length of the <i>path</i> argument or the length of the pathname
              constructed from the <i>file</i> argument exceeds {PATH_MAX}, or
              pathname resolution of a symbolic link produced an
              intermediate result with a length that exceeds {PATH_MAX}.

       <b>ETXTBSY</b>
              The new process image file is a pure procedure (shared text)
              file that is currently open for writing by some process.

       <i>The following sections are informative.</i>
</pre>
<h2><a id="EXAMPLES" href="#EXAMPLES"></a>EXAMPLES  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
   <b>Using execl()</b>
       The following example executes the <i>ls</i> command, specifying the
       pathname of the executable (<b>/bin/ls</b>) and using arguments supplied
       directly to the command to produce single-column output.

           <b>#include &lt;unistd.h&gt;</b>

           int ret;
           ...
           ret = execl ("/bin/ls", "ls", "-1", (char *)0);

   <b>Using execle()</b>
       The following example is similar to <i>Using execl()</i>.  In addition, it
       specifies the environment for the new process image using the <i>env</i>
       argument.

           <b>#include &lt;unistd.h&gt;</b>

           int ret;
           char *env[] = { "HOME=/usr/home", "LOGNAME=home", (char *)0 };
           ...
           ret = execle ("/bin/ls", "ls", "-l", (char *)0, env);

   <b>Using execlp()</b>
       The following example searches for the location of the <i>ls</i> command
       among the directories specified by the <i>PATH</i> environment variable.

           <b>#include &lt;unistd.h&gt;</b>

           int ret;
           ...
           ret = execlp ("ls", "ls", "-l", (char *)0);

   <b>Using execv()</b>
       The following example passes arguments to the <i>ls</i> command in the <i>cmd</i>
       array.

           <b>#include &lt;unistd.h&gt;</b>

           int ret;
           char *cmd[] = { "ls", "-l", (char *)0 };
           ...
           ret = execv ("/bin/ls", cmd);

   <b>Using execve()</b>
       The following example passes arguments to the <i>ls</i> command in the <i>cmd</i>
       array, and specifies the environment for the new process image using
       the <i>env</i> argument.

           <b>#include &lt;unistd.h&gt;</b>

           int ret;
           char *cmd[] = { "ls", "-l", (char *)0 };
           char *env[] = { "HOME=/usr/home", "LOGNAME=home", (char *)0 };
           ...
           ret = execve ("/bin/ls", cmd, env);

   <b>Using execvp()</b>
       The following example searches for the location of the <i>ls</i> command
       among the directories specified by the <i>PATH</i> environment variable, and
       passes arguments to the <i>ls</i> command in the <i>cmd</i> array.

           <b>#include &lt;unistd.h&gt;</b>

           int ret;
           char *cmd[] = { "ls", "-l", (char *)0 };
           ...
           ret = execvp ("ls", cmd);
</pre>
<h2><a id="APPLICATION_USAGE" href="#APPLICATION_USAGE"></a>APPLICATION USAGE  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       As the state of conversion descriptors and message catalog
       descriptors in the new process image is undefined, conforming
       applications should not rely on their use and should close them prior
       to calling one of the <i>exec</i> functions.

       Applications that require other than the default POSIX locale as the
       global locale in the new process image should call <i>setlocale</i>() with
       the appropriate parameters.

       When assigning a new value to the <i>environ</i> variable, applications
       should ensure that the environment to which it will point contains at
       least the following:

        1. Any implementation-defined variables required by the
           implementation to provide a conforming environment. See the
           _CS_V7_ENV entry in <i>&lt;unistd.h&gt;</i> and <i>confstr</i>() for details.

        2. A value for <i>PATH</i> which finds conforming versions of all standard
           utilities before any other versions.

       The same constraint applies to the <i>envp</i> array passed to <i>execle</i>() or
       <i>execve</i>(), in order to ensure that the new process image is invoked in
       a conforming environment.

       Applications should not execute programs with file descriptor 0 not
       open for reading or with file descriptor 1 or 2 not open for writing,
       as this might cause the executed program to misbehave. In order not
       to pass on these file descriptors to an executed program,
       applications should not just close them but should reopen them on,
       for example, <b>/dev/null</b>.  Some implementations may reopen them
       automatically, but applications should not rely on this being done.

       If an application wants to perform a checksum test of the file being
       executed before executing it, the file will need to be opened with
       read permission to perform the checksum test.

       Since execute permission is checked by <i>fexecve</i>(), the file
       description <i>fd</i> need not have been opened with the O_EXEC flag.
       However, if the file to be executed denies read and write permission
       for the process preparing to do the <i>exec</i>, the only way to provide the
       <i>fd</i> to <i>fexecve</i>() will be to use the O_EXEC flag when opening <i>fd</i>.  In
       this case, the application will not be able to perform a checksum
       test since it will not be able to read the contents of the file.

       Note that when a file descriptor is opened with O_RDONLY, O_RDWR, or
       O_WRONLY mode, the file descriptor can be used to read, read and
       write, or write the file, respectively, even if the mode of the file
       changes after the file was opened. Using the O_EXEC open mode is
       different; <i>fexecve</i>() will ignore the mode that was used when the file
       descriptor was opened and the <i>exec</i> will fail if the mode of the file
       associated with <i>fd</i> does not grant execute permission to the calling
       process at the time <i>fexecve</i>() is called.
</pre>
<h2><a id="RATIONALE" href="#RATIONALE"></a>RATIONALE  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       Early proposals required that the value of <i>argc</i> passed to <i>main</i>() be
       ``one or greater''. This was driven by the same requirement in drafts
       of the ISO C standard.  In fact, historical implementations have
       passed a value of zero when no arguments are supplied to the caller
       of the <i>exec</i> functions. This requirement was removed from the ISO C
       standard and subsequently removed from this volume of POSIX.1‐2008 as
       well. The wording, in particular the use of the word <i>should</i>, requires
       a Strictly Conforming POSIX Application to pass at least one argument
       to the <i>exec</i> function, thus guaranteeing that <i>argc</i> be one or greater
       when invoked by such an application. In fact, this is good practice,
       since many existing applications reference <i>argv</i>[0] without first
       checking the value of <i>argc</i>.

       The requirement on a Strictly Conforming POSIX Application also
       states that the value passed as the first argument be a filename
       string associated with the process being started. Although some
       existing applications pass a pathname rather than a filename string
       in some circumstances, a filename string is more generally useful,
       since the common usage of <i>argv</i>[0] is in printing diagnostics. In some
       cases the filename passed is not the actual filename of the file; for
       example, many implementations of the <i>login</i> utility use a convention
       of prefixing a &lt;hyphen&gt; (<b>'‐'</b>) to the actual filename, which indicates
       to the command interpreter being invoked that it is a ``login
       shell''.

       Historically, there have been two ways that implementations can <i>exec</i>
       shell scripts.

       One common historical implementation is that the <i>execl</i>(), <i>execv</i>(),
       <i>execle</i>(), and <i>execve</i>() functions return an <b>[ENOEXEC] </b>error for any
       file not recognizable as executable, including a shell script. When
       the <i>execlp</i>() and <i>execvp</i>() functions encounter such a file, they
       assume the file to be a shell script and invoke a known command
       interpreter to interpret such files.  This is now required by
       POSIX.1‐2008. These implementations of <i>execvp</i>() and <i>execlp</i>() only
       give the <b>[ENOEXEC] </b>error in the rare case of a problem with the
       command interpreter's executable file. Because of these
       implementations, the <b>[ENOEXEC] </b>error is not mentioned for <i>execlp</i>() or
       <i>execvp</i>(), although implementations can still give it.

       Another way that some historical implementations handle shell scripts
       is by recognizing the first two bytes of the file as the character
       string <b>"#!" </b>and using the remainder of the first line of the file as
       the name of the command interpreter to execute.

       One potential source of confusion noted by the standard developers is
       over how the contents of a process image file affect the behavior of
       the <i>exec</i> family of functions. The following is a description of the
       actions taken:

        1. If the process image file is a valid executable (in a format that
           is executable and valid and having appropriate privileges) for
           this system, then the system executes the file.

        2. If the process image file has appropriate privileges and is in a
           format that is executable but not valid for this system (such as
           a recognized binary for another architecture), then this is an
           error and <i><a href="errno.3.html">errno</a></i> is set to <b>[EINVAL] </b>(see later RATIONALE on
           <b>[EINVAL]</b>).

        3. If the process image file has appropriate privileges but is not
           otherwise recognized:

            a. If this is a call to <i>execlp</i>() or <i>execvp</i>(), then they invoke a
               command interpreter assuming that the process image file is a
               shell script.

            b. If this is not a call to <i>execlp</i>() or <i>execvp</i>(), then an error
               occurs and <i><a href="errno.3.html">errno</a></i> is set to <b>[ENOEXEC]</b>.

       Applications that do not require to access their arguments may use
       the form:

           <b>main(void)</b>

       as specified in the ISO C standard. However, the implementation will
       always provide the two arguments <i>argc</i> and <i>argv</i>, even if they are not
       used.

       Some implementations provide a third argument to <i>main</i>() called <i>envp</i>.
       This is defined as a pointer to the environment. The ISO C standard
       specifies invoking <i>main</i>() with two arguments, so implementations must
       support applications written this way. Since this volume of
       POSIX.1‐2008 defines the global variable <i>environ</i>, which is also
       provided by historical implementations and can be used anywhere that
       <i>envp</i> could be used, there is no functional need for the <i>envp</i>
       argument. Applications should use the <i>getenv</i>() function rather than
       accessing the environment directly via either <i>envp</i> or <i>environ</i>.
       Implementations are required to support the two-argument calling
       sequence, but this does not prohibit an implementation from
       supporting <i>envp</i> as an optional third argument.

       This volume of POSIX.1‐2008 specifies that signals set to SIG_IGN
       remain set to SIG_IGN, and that the new process image inherits the
       signal mask of the thread that called <i>exec</i> in the old process image.
       This is consistent with historical implementations, and it permits
       some useful functionality, such as the <i>nohup</i> command. However, it
       should be noted that many existing applications wrongly assume that
       they start with certain signals set to the default action and/or
       unblocked. In particular, applications written with a simpler signal
       model that does not include blocking of signals, such as the one in
       the ISO C standard, may not behave properly if invoked with some
       signals blocked. Therefore, it is best not to block or ignore signals
       across <i>exec</i>s without explicit reason to do so, and especially not to
       block signals across <i>exec</i>s of arbitrary (not closely cooperating)
       programs.

       The <i>exec</i> functions always save the value of the effective user ID and
       effective group ID of the process at the completion of the <i>exec</i>,
       whether or not the set-user-ID or the set-group-ID bit of the process
       image file is set.

       The statement about <i>argv</i>[] and <i>envp</i>[] being constants is included to
       make explicit to future writers of language bindings that these
       objects are completely constant. Due to a limitation of the ISO C
       standard, it is not possible to state that idea in standard C.
       Specifying two levels of <i>const</i>−<i>qualification</i> for the <i>argv</i>[] and
       <i>envp</i>[] parameters for the <i>exec</i> functions may seem to be the natural
       choice, given that these functions do not modify either the array of
       pointers or the characters to which the function points, but this
       would disallow existing correct code.  Instead, only the array of
       pointers is noted as constant. The table of assignment compatibility
       for <i>dst</i>=<i>src</i> derived from the ISO C standard summarizes the
       compatibility:

┌────────────────────┬──────────┬────────────────┬───────────────┬─────────────────────┐
│               <i>dst</i>: │ <b>char *[] </b>│ <b>const char *[] </b>│ <b>char *const[] </b>│ <b>const char *const[] </b>│
├────────────────────┼──────────┼────────────────┼───────────────┼─────────────────────┤
│<i>src</i><b>:                </b>│          │                │               │                     │
│<b>char *[]            </b>│  VALID   │       —        │     VALID     │          —          │
│<b>const char *[]      </b>│    —     │     VALID      │       —       │        VALID        │
│<b>char * const []     </b>│    —     │       —        │     VALID     │          —          │
│<b>const char *const[] </b>│    —     │       —        │       —       │        VALID        │
└────────────────────┴──────────┴────────────────┴───────────────┴─────────────────────┘
       Since all existing code has a source type matching the first row, the
       column that gives the most valid combinations is the third column.
       The only other possibility is the fourth column, but using it would
       require a cast on the <i>argv</i> or <i>envp</i> arguments. It is unfortunate that
       the fourth column cannot be used, because the declaration a non-
       expert would naturally use would be that in the second row.

       The ISO C standard and this volume of POSIX.1‐2008 do not conflict on
       the use of <i>environ</i>, but some historical implementations of <i>environ</i>
       may cause a conflict. As long as <i>environ</i> is treated in the same way
       as an entry point (for example, <i>fork</i>()), it conforms to both
       standards. A library can contain <i>fork</i>(), but if there is a user-
       provided <i>fork</i>(), that <i>fork</i>() is given precedence and no problem
       ensues. The situation is similar for <i>environ</i>: the definition in this
       volume of POSIX.1‐2008 is to be used if there is no user-provided
       <i>environ</i> to take precedence. At least three implementations are known
       to exist that solve this problem.

       <b>E2BIG  </b>The limit {ARG_MAX} applies not just to the size of the
              argument list, but to the sum of that and the size of the
              environment list.

       <b>EFAULT </b>Some historical systems return <b>[EFAULT] </b>rather than <b>[ENOEXEC]</b>
              when the new process image file is corrupted. They are non-
              conforming.

       <b>EINVAL </b>This error condition was added to POSIX.1‐2008 to allow an
              implementation to detect executable files generated for
              different architectures, and indicate this situation to the
              application. Historical implementations of shells, <i>execvp</i>(),
              and <i>execlp</i>() that encounter an <b>[ENOEXEC] </b>error will execute a
              shell on the assumption that the file is a shell script. This
              will not produce the desired effect when the file is a valid
              executable for a different architecture. An implementation may
              now choose to avoid this problem by returning <b>[EINVAL] </b>when a
              valid executable for a different architecture is encountered.
              Some historical implementations return <b>[EINVAL] </b>to indicate
              that the <i>path</i> argument contains a character with the high
              order bit set. The standard developers chose to deviate from
              historical practice for the following reasons:

                    1. The new utilization of <b>[EINVAL] </b>will provide some
                       measure of utility to the user community.

                    2. Historical use of <b>[EINVAL] </b>is not acceptable in an
                       internationalized operating environment.

       <b>ENAMETOOLONG</b>
              Since the file pathname may be constructed by taking elements
              in the <i>PATH</i> variable and putting them together with the
              filename, the <b>[ENAMETOOLONG] </b>error condition could also be
              reached this way.

       <b>ETXTBSY</b>
              System V returns this error when the executable file is
              currently open for writing by some process. This volume of
              POSIX.1‐2008 neither requires nor prohibits this behavior.

       Other systems (such as System V) may return <b>[EINTR] </b>from <i>exec</i>.  This
       is not addressed by this volume of POSIX.1‐2008, but implementations
       may have a window between the call to <i>exec</i> and the time that a signal
       could cause one of the <i>exec</i> calls to return with <b>[EINTR]</b>.

       An explicit statement regarding the floating-point environment (as
       defined in the <i>&lt;fenv.h&gt;</i> header) was added to make it clear that the
       floating-point environment is set to its default when a call to one
       of the <i>exec</i> functions succeeds. The requirements for inheritance or
       setting to the default for other process and thread start-up
       functions is covered by more generic statements in their descriptions
       and can be summarized as follows:

       <i>posix_spawn (3p) 14</i>
              Set to default.

       <i>fork (3p) 14</i>
              Inherit.

       <i>pthread_create (3p) 14</i>
              Inherit.

       The purpose of the <i>fexecve</i>() function is to enable executing a file
       which has been verified to be the intended file. It is possible to
       actively check the file by reading from the file descriptor and be
       sure that the file is not exchanged for another between the reading
       and the execution. Alternatively, an function like <i>openat</i>() can be
       used to open a file which has been found by reading the content of a
       directory using <i>readdir</i>().
</pre>
<h2><a id="FUTURE_DIRECTIONS" href="#FUTURE_DIRECTIONS"></a>FUTURE DIRECTIONS  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       None.
</pre>
<h2><a id="SEE_ALSO" href="#SEE_ALSO"></a>SEE ALSO  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       <a href="alarm.3p.html">alarm(3p)</a>, <a href="atexit.3p.html">atexit(3p)</a>, <a href="chmod.3p.html">chmod(3p)</a>, <a href="close.3p.html">close(3p)</a>, <a href="confstr.3p.html">confstr(3p)</a>, <a href="exit.3p.html">exit(3p)</a>,
       <a href="fcntl.3p.html">fcntl(3p)</a>, <a href="fork.3p.html">fork(3p)</a>, <a href="fstatvfs.3p.html">fstatvfs(3p)</a>, <a href="getenv.3p.html">getenv(3p)</a>, <a href="getitimer.3p.html">getitimer(3p)</a>,
       <a href="getrlimit.3p.html">getrlimit(3p)</a>, <a href="mknod.3p.html">mknod(3p)</a>, <a href="mmap.3p.html">mmap(3p)</a>, <a href="nice.3p.html">nice(3p)</a>, <a href="open.3p.html">open(3p)</a>,
       <a href="posix_spawn.3p.html">posix_spawn(3p)</a>, <a href="posix_trace_create.3p.html">posix_trace_create(3p)</a>, <a href="posix_trace_event.3p.html">posix_trace_event(3p)</a>,
       <a href="posix_trace_eventid_equal.3p.html">posix_trace_eventid_equal(3p)</a>, <a href="pthread_atfork.3p.html">pthread_atfork(3p)</a>,
       <a href="pthread_sigmask.3p.html">pthread_sigmask(3p)</a>, <a href="putenv.3p.html">putenv(3p)</a>, <a href="readdir.3p.html">readdir(3p)</a>, <a href="semop.3p.html">semop(3p)</a>,
       <a href="setlocale.3p.html">setlocale(3p)</a>, <a href="shmat.3p.html">shmat(3p)</a>, <a href="sigaction.3p.html">sigaction(3p)</a>, <a href="sigaltstack.3p.html">sigaltstack(3p)</a>,
       <a href="sigpending.3p.html">sigpending(3p)</a>, <a href="system.3p.html">system(3p)</a>, <a href="times.3p.html">times(3p)</a>, <a href="ulimit.3p.html">ulimit(3p)</a>, <a href="umask.3p.html">umask(3p)</a>

       The  Base  Definitions volume of POSIX.1‐2008, <i>Chapter 8</i>, <i>Environment</i>
       <i>Variables</i>, <a href="../man0/unistd.h.0p.html">unistd.h(0p)</a>
</pre>
<h2><a id="COPYRIGHT" href="#COPYRIGHT"></a>COPYRIGHT  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       Portions of this text are reprinted and reproduced in electronic form
       from IEEE Std 1003.1, 2013 Edition, Standard for Information
       Technology -- Portable Operating System Interface (POSIX), The Open
       Group Base Specifications Issue 7, Copyright (C) 2013 by the
       Institute of Electrical and Electronics Engineers, Inc and The Open
       Group.  (This is POSIX.1-2008 with the 2013 Technical Corrigendum 1
       applied.) In the event of any discrepancy between this version and
       the original IEEE and The Open Group Standard, the original IEEE and
       The Open Group Standard is the referee document. The original
       Standard can be obtained online at <a href="http://www.unix.org/online.html">http://www.unix.org/online.html</a> .

       Any typographical or formatting errors that appear in this page are
       most likely to have been introduced during the conversion of the
       source files to man page format. To report such errors, see
       <a href="https://www.kernel.org/doc/man-pages/reporting_bugs.html">https://www.kernel.org/doc/man-pages/reporting_bugs.html</a> .

<span class="footline">IEEE/The Open Group                 2013                            EXEC(3P)</span>
</pre>

<hr class="end-man-text" />

 
<hr class="start-footer" />

<div class="footer"> 

<table class="colophon-table">
    <tr>
    <td class="pub-info">
        <p>
            HTML rendering created 2017-07-13
            by <a href="http://man7.org/mtk/index.html">Michael Kerrisk</a>, 
            author of 
            <a href="http://man7.org/tlpi/"><em>The Linux Programming Interface</em></a>, 
            maintainer of the 
            <a href="https://www.kernel.org/doc/man-pages/">Linux <em>man-pages</em> project</a>.
        </p>
        <p>
            For details of in-depth
            <strong>Linux/UNIX system programming training courses</strong>
            that I teach, look <a href="http://man7.org/training/">here</a>.
        </p>
        <p>
            Hosting by <a href="http://www.jambit.com/index_en.html">jambit GmbH</a>.
        </p>
        <p>
            <a href="http://validator.w3.org/check?uri=referer">
            <img src="http://www.w3.org/Icons/valid-xhtml11"
                alt="Valid XHTML 1.1" height="31" width="88" />
            </a>
        </p>
    </td>
    <td class="colophon-divider">
    </td>
    <td class="tlpi-cover">
        <a href="http://man7.org/tlpi/"><img src="../../../tlpi/cover/TLPI-front-cover-vsmall.png" alt="Cover of TLPI" /></a>
    </td>
    </tr>
</table>

</div>

<hr class="end-footer" />



<!--BEGIN-SITETRACKING-->
<!-- SITETRACKING.man7.org_linux_man-pages -->

<!-- Start of StatCounter Code (xhtml) -->

<script type="text/javascript">
//<![CDATA[
var sc_project=7422636; 
var sc_invisible=1; 
var sc_security="9b6714ff"; 
//]]>
</script>
<script type="text/javascript"
src="../../../../www.statcounter.com/counter/counter_xhtml.js"></script>
<noscript><div class="statcounter"><a title="website
statistics" href="http://statcounter.com/"
class="statcounter"><img class="statcounter"
src="http://c.statcounter.com/7422636/0/9b6714ff/1/"
alt="website statistics" /></a></div></noscript>

<!-- End of StatCounter Code -->


<!-- Start of Google Analytics Code -->

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-9830363-8']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<!-- End of Google Analytics Code -->

<!--END-SITETRACKING-->

</body>
</html>
