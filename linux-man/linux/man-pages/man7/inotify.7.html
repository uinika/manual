
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
        "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
    <link rel="stylesheet" type="text/css" href="../../../style.css" title="style" />
    <link rel="stylesheet" type="text/css" href="../style.css" title="style" />
    <meta http-equiv="content-type" content="text/html;charset=utf-8" />

    <title>inotify(7) - Linux manual page</title>
</head>

<body>

<div class="page-top"><a id="top_of_page"></a></div>
<!--%%%TOP_BAR%%%-->
    <div class="nav-bar">
        <table class="nav-table">
            <tr>
                <td class="nav-cell">
                    <p class="nav-text">
                        <a href="http://man7.org/index.html">man7.org</a> &gt; Linux &gt; <a href="../index.html">man-pages</a>
                    </p>
                </td>
                <td class="training-cell">
                    <p class="training-text"><a class="training-link" href="http://man7.org/training/">Linux/UNIX system programming training</a></p>
                </td>
            </tr>
        </table>
    </div>

<hr class="nav-end" />

<!--%%%PAGE_START%%%-->


<table class="sec-table">
<tr>
    <td>
        <p class="section-dir">
<a href="#NAME">NAME</a> | <a href="#DESCRIPTION">DESCRIPTION</a> | <a href="#VERSIONS">VERSIONS</a> | <a href="#CONFORMING_TO">CONFORMING&nbsp;TO</a> | <a href="#NOTES">NOTES</a> | <a href="#BUGS">BUGS</a> | <a href="#EXAMPLE">EXAMPLE</a> | <a href="#SEE_ALSO">SEE&nbsp;ALSO</a> | <a href="#COLOPHON">COLOPHON</a>
        </p>
    </td>
    <td class="search-box">
        <div class="man-search-box">

            <form method="get" action="http://www.google.com/search">
                <fieldset class="man-search">
                    <input type="text" name="q" size="10" maxlength="255" value="" />
                    <input type="hidden" name="sitesearch" value="man7.org/linux/man-pages" />
                    <input type="submit" name="sa" value="Search online pages" />
                </fieldset>
            </form>

        </div>
    </td>
    <td> </td>
</tr>
</table>

<pre>
<span class="headline">INOTIFY(7)                Linux Programmer's Manual               INOTIFY(7)</span>
</pre>
<h2><a id="NAME" href="#NAME"></a>NAME  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       inotify - monitoring filesystem events
</pre>
<h2><a id="DESCRIPTION" href="#DESCRIPTION"></a>DESCRIPTION  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       The <i>inotify</i> API provides a mechanism for monitoring filesystem
       events.  Inotify can be used to monitor individual files, or to
       monitor directories.  When a directory is monitored, inotify will
       return events for the directory itself, and for files inside the
       directory.

       The following system calls are used with this API:

       *  <a href="../man2/inotify_init.2.html">inotify_init(2)</a> creates an inotify instance and returns a file
          descriptor referring to the inotify instance.  The more recent
          <a href="../man2/inotify_init1.2.html">inotify_init1(2)</a> is like <a href="../man2/inotify_init.2.html">inotify_init(2)</a>, but has a <i>flags</i> argument
          that provides access to some extra functionality.

       *  <a href="../man2/inotify_add_watch.2.html">inotify_add_watch(2)</a> manipulates the "watch list" associated with
          an inotify instance.  Each item ("watch") in the watch list
          specifies the pathname of a file or directory, along with some set
          of events that the kernel should monitor for the file referred to
          by that pathname.  <a href="../man2/inotify_add_watch.2.html">inotify_add_watch(2)</a> either creates a new watch
          item, or modifies an existing watch.  Each watch has a unique
          "watch descriptor", an integer returned by <a href="../man2/inotify_add_watch.2.html">inotify_add_watch(2)</a>
          when the watch is created.

       *  When events occur for monitored files and directories, those
          events are made available to the application as structured data
          that can be read from the inotify file descriptor using <a href="../man2/read.2.html">read(2)</a>
          (see below).

       *  <a href="../man2/inotify_rm_watch.2.html">inotify_rm_watch(2)</a> removes an item from an inotify watch list.

       *  When all file descriptors referring to an inotify instance have
          been closed (using <a href="../man2/close.2.html">close(2)</a>), the underlying object and its
          resources are freed for reuse by the kernel; all associated
          watches are automatically freed.

       With careful programming, an application can use inotify to
       efficiently monitor and cache the state of a set of filesystem
       objects.  However, robust applications should allow for the fact that
       bugs in the monitoring logic or races of the kind described below may
       leave the cache inconsistent with the filesystem state.  It is
       probably wise to do some consistency checking, and rebuild the cache
       when inconsistencies are detected.

   <b>Reading events from an inotify file descriptor</b>
       To determine what events have occurred, an application <a href="../man2/read.2.html">read(2)</a>s from
       the inotify file descriptor.  If no events have so far occurred,
       then, assuming a blocking file descriptor, <a href="../man2/read.2.html">read(2)</a> will block until
       at least one event occurs (unless interrupted by a signal, in which
       case the call fails with the error <b>EINTR</b>; see <a href="signal.7.html">signal(7)</a>).

       Each successful <a href="../man2/read.2.html">read(2)</a> returns a buffer containing one or more of
       the following structures:

           struct inotify_event {
               int      wd;       /* Watch descriptor */
               uint32_t mask;     /* Mask describing event */
               uint32_t cookie;   /* Unique cookie associating related
                                     events (for rename(2)) */
               uint32_t len;      /* Size of <i>name</i> field */
               char     name[];   /* Optional null-terminated name */
           };

       <i>wd</i> identifies the watch for which this event occurs.  It is one of
       the watch descriptors returned by a previous call to
       <a href="../man2/inotify_add_watch.2.html">inotify_add_watch(2)</a>.

       <i>mask</i> contains bits that describe the event that occurred (see below).

       <i>cookie</i> is a unique integer that connects related events.  Currently,
       this is used only for rename events, and allows the resulting pair of
       <b>IN_MOVED_FROM </b>and <b>IN_MOVED_TO </b>events to be connected by the
       application.  For all other event types, <i>cookie</i> is set to 0.

       The <i>name</i> field is present only when an event is returned for a file
       inside a watched directory; it identifies the filename within to the
       watched directory.  This filename is null-terminated, and may include
       further null bytes ('\0') to align subsequent reads to a suitable
       address boundary.

       The <i>len</i> field counts all of the bytes in <i>name</i>, including the null
       bytes; the length of each <i>inotify_event</i> structure is thus
       <i>sizeof(struct inotify_event)+len</i>.

       The behavior when the buffer given to <a href="../man2/read.2.html">read(2)</a> is too small to return
       information about the next event depends on the kernel version: in
       kernels before 2.6.21, <a href="../man2/read.2.html">read(2)</a> returns 0; since kernel 2.6.21,
       <a href="../man2/read.2.html">read(2)</a> fails with the error <b>EINVAL</b>.  Specifying a buffer of size

           sizeof(struct inotify_event) + NAME_MAX + 1

       will be sufficient to read at least one event.

   <b>inotify events</b>
       The <a href="../man2/inotify_add_watch.2.html">inotify_add_watch(2)</a> <i>mask</i> argument and the <i>mask</i> field of the
       <i>inotify_event</i> structure returned when <a href="../man2/read.2.html">read(2)</a>ing an inotify file
       descriptor are both bit masks identifying inotify events.  The
       following bits can be specified in <i>mask</i> when calling
       <a href="../man2/inotify_add_watch.2.html">inotify_add_watch(2)</a> and may be returned in the <i>mask</i> field returned
       by <a href="../man2/read.2.html">read(2)</a>:

           <b>IN_ACCESS </b>(+)
                  File was accessed (e.g., <a href="../man2/read.2.html">read(2)</a>, <a href="../man2/execve.2.html">execve(2)</a>).

           <b>IN_ATTRIB </b>(*)
                  Metadata changedâ€”for example, permissions (e.g.,
                  <a href="../man2/chmod.2.html">chmod(2)</a>), timestamps (e.g., <a href="../man2/utimensat.2.html">utimensat(2)</a>), extended
                  attributes (<a href="../man2/setxattr.2.html">setxattr(2)</a>), link count (since Linux 2.6.25;
                  e.g., for the target of <a href="../man2/link.2.html">link(2)</a> and for <a href="../man2/unlink.2.html">unlink(2)</a>), and
                  user/group ID (e.g., <a href="../man2/chown.2.html">chown(2)</a>).

           <b>IN_CLOSE_WRITE </b>(+)
                  File opened for writing was closed.

           <b>IN_CLOSE_NOWRITE </b>(*)
                  File or directory not opened for writing was closed.

           <b>IN_CREATE </b>(+)
                  File/directory created in watched directory (e.g., <a href="../man2/open.2.html">open(2)</a>
                  <b>O_CREAT</b>, <a href="../man2/mkdir.2.html">mkdir(2)</a>, <a href="../man2/link.2.html">link(2)</a>, <a href="../man2/symlink.2.html">symlink(2)</a>, <a href="../man2/bind.2.html">bind(2)</a> on a UNIX
                  domain socket).

           <b>IN_DELETE </b>(+)
                  File/directory deleted from watched directory.

           <b>IN_DELETE_SELF</b>
                  Watched file/directory was itself deleted.  (This event
                  also occurs if an object is moved to another filesystem,
                  since <a href="../man1/mv.1.html">mv(1)</a> in effect copies the file to the other
                  filesystem and then deletes it from the original
                  filesystem.)  In addition, an <b>IN_IGNORED </b>event will
                  subsequently be generated for the watch descriptor.

           <b>IN_MODIFY </b>(+)
                  File was modified (e.g., <a href="../man2/write.2.html">write(2)</a>, <a href="../man2/truncate.2.html">truncate(2)</a>).

           <b>IN_MOVE_SELF</b>
                  Watched file/directory was itself moved.

           <b>IN_MOVED_FROM </b>(+)
                  Generated for the directory containing the old filename
                  when a file is renamed.

           <b>IN_MOVED_TO </b>(+)
                  Generated for the directory containing the new filename
                  when a file is renamed.

           <b>IN_OPEN </b>(*)
                  File or directory was opened.

       Inotify monitoring is inode-based: when monitoring a file (but not
       when monitoring the directory containing a file), an event can be
       generated for activity on any link to the file (in the same or a
       different directory).

       When monitoring a directory:

       *  the events marked above with an asterisk (*) can occur both for
          the directory itself and for objects inside the directory; and

       *  the events marked with a plus sign (+) occur only for objects
          inside the directory (not for the directory itself).

       <i>Note</i>: when monitoring a directory, events are not generated for the
       files inside the directory when the events are performed via a
       pathname (i.e., a link) that lies outside the monitored directory.

       When events are generated for objects inside a watched directory, the
       <i>name</i> field in the returned <i>inotify_event</i> structure identifies the
       name of the file within the directory.

       The <b>IN_ALL_EVENTS </b>macro is defined as a bit mask of all of the above
       events.  This macro can be used as the <i>mask</i> argument when calling
       <a href="../man2/inotify_add_watch.2.html">inotify_add_watch(2)</a>.

       Two additional convenience macros are defined:

           <b>IN_MOVE</b>
                  Equates to <b>IN_MOVED_FROM | IN_MOVED_TO</b>.

           <b>IN_CLOSE</b>
                  Equates to <b>IN_CLOSE_WRITE | IN_CLOSE_NOWRITE</b>.

       The following further bits can be specified in <i>mask</i> when calling
       <a href="../man2/inotify_add_watch.2.html">inotify_add_watch(2)</a>:

           <b>IN_DONT_FOLLOW </b>(since Linux 2.6.15)
                  Don't dereference <i>pathname</i> if it is a symbolic link.

           <b>IN_EXCL_UNLINK </b>(since Linux 2.6.36)
                  By default, when watching events on the children of a
                  directory, events are generated for children even after
                  they have been unlinked from the directory.  This can
                  result in large numbers of uninteresting events for some
                  applications (e.g., if watching <i>/tmp</i>, in which many
                  applications create temporary files whose names are
                  immediately unlinked).  Specifying <b>IN_EXCL_UNLINK </b>changes
                  the default behavior, so that events are not generated for
                  children after they have been unlinked from the watched
                  directory.

           <b>IN_MASK_ADD</b>
                  If a watch instance already exists for the filesystem
                  object corresponding to <i>pathname</i>, add (OR) the events in
                  <i>mask</i> to the watch mask (instead of replacing the mask).

           <b>IN_ONESHOT</b>
                  Monitor the filesystem object corresponding to <i>pathname</i>
                  for one event, then remove from watch list.

           <b>IN_ONLYDIR </b>(since Linux 2.6.15)
                  Watch <i>pathname</i> only if it is a directory.  Using this flag
                  provides an application with a race-free way of ensuring
                  that the monitored object is a directory.

       The following bits may be set in the <i>mask</i> field returned by <a href="../man2/read.2.html">read(2)</a>:

           <b>IN_IGNORED</b>
                  Watch was removed explicitly (<a href="../man2/inotify_rm_watch.2.html">inotify_rm_watch(2)</a>) or
                  automatically (file was deleted, or filesystem was
                  unmounted).  See also BUGS.

           <b>IN_ISDIR</b>
                  Subject of this event is a directory.

           <b>IN_Q_OVERFLOW</b>
                  Event queue overflowed (<i>wd</i> is -1 for this event).

           <b>IN_UNMOUNT</b>
                  Filesystem containing watched object was unmounted.  In
                  addition, an <b>IN_IGNORED </b>event will subsequently be
                  generated for the watch descriptor.

   <b>Examples</b>
       Suppose an application is watching the directory <i>dir</i> and the file
       <i>dir/myfile</i> for all events.  The examples below show some events that
       will be generated for these two objects.

           fd = open("dir/myfile", O_RDWR);
                  Generates <b>IN_OPEN </b>events for both <i>dir</i> and <i>dir/myfile</i>.

           read(fd, buf, count);
                  Generates <b>IN_ACCESS </b>events for both <i>dir</i> and <i>dir/myfile</i>.

           write(fd, buf, count);
                  Generates <b>IN_MODIFY </b>events for both <i>dir</i> and <i>dir/myfile</i>.

           fchmod(fd, mode);
                  Generates <b>IN_ATTRIB </b>events for both <i>dir</i> and <i>dir/myfile</i>.

           close(fd);
                  Generates <b>IN_CLOSE_WRITE </b>events for both <i>dir</i> and
                  <i>dir/myfile</i>.

       Suppose an application is watching the directories <i>dir1</i> and <i>dir2</i>, and
       the file <i>dir1/myfile</i>.  The following examples show some events that
       may be generated.

           link("dir1/myfile", "dir2/new");
                  Generates an <b>IN_ATTRIB </b>event for <i>myfile</i> and an <b>IN_CREATE</b>
                  event for <i>dir2</i>.

           rename("dir1/myfile", "dir2/myfile");
                  Generates an <b>IN_MOVED_FROM </b>event for <i>dir1</i>, an <b>IN_MOVED_TO</b>
                  event for <i>dir2</i>, and an <b>IN_MOVE_SELF </b>event for <i>myfile</i>.  The
                  <b>IN_MOVED_FROM </b>and <b>IN_MOVED_TO </b>events will have the same
                  <i>cookie</i> value.

       Suppose that <i>dir1/xx</i> and <i>dir2/yy</i> are (the only) links to the same
       file, and an application is watching <i>dir1</i>, <i>dir2</i>, <i>dir1/xx</i>, and
       <i>dir2/yy</i>.  Executing the following calls in the order given below will
       generate the following events:

           unlink("dir2/yy");
                  Generates an <b>IN_ATTRIB </b>event for <i>xx</i> (because its link
                  count changes) and an <b>IN_DELETE </b>event for <i>dir2</i>.

           unlink("dir1/xx");
                  Generates <b>IN_ATTRIB</b>, <b>IN_DELETE_SELF</b>, and <b>IN_IGNORED </b>events
                  for <i>xx</i>, and an <b>IN_DELETE </b>event for <i>dir1</i>.

       Suppose an application is watching the directory <i>dir</i> and (the empty)
       directory <i>dir/subdir</i>.  The following examples show some events that
       may be generated.

           mkdir("dir/new", mode);
                  Generates an <b>IN_CREATE | IN_ISDIR </b>event for <i>dir</i>.

           rmdir("dir/subdir");
                  Generates <b>IN_DELETE_SELF </b>and <b>IN_IGNORED </b>events for <i>subdir</i>,
                  and an <b>IN_DELETE | IN_ISDIR </b>event for <i>dir</i>.

   <b>/proc interfaces</b>
       The following interfaces can be used to limit the amount of kernel
       memory consumed by inotify:

       <i>/proc/sys/fs/inotify/max_queued_events</i>
              The value in this file is used when an application calls
              <a href="../man2/inotify_init.2.html">inotify_init(2)</a> to set an upper limit on the number of events
              that can be queued to the corresponding inotify instance.
              Events in excess of this limit are dropped, but an
              <b>IN_Q_OVERFLOW </b>event is always generated.

       <i>/proc/sys/fs/inotify/max_user_instances</i>
              This specifies an upper limit on the number of inotify
              instances that can be created per real user ID.

       <i>/proc/sys/fs/inotify/max_user_watches</i>
              This specifies an upper limit on the number of watches that
              can be created per real user ID.
</pre>
<h2><a id="VERSIONS" href="#VERSIONS"></a>VERSIONS  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       Inotify was merged into the 2.6.13 Linux kernel.  The required
       library interfaces were added to glibc in version 2.4.
       (<b>IN_DONT_FOLLOW</b>, <b>IN_MASK_ADD</b>, and <b>IN_ONLYDIR </b>were added in glibc
       version 2.5.)
</pre>
<h2><a id="CONFORMING_TO" href="#CONFORMING_TO"></a>CONFORMING TO  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       The inotify API is Linux-specific.
</pre>
<h2><a id="NOTES" href="#NOTES"></a>NOTES  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       Inotify file descriptors can be monitored using <a href="../man2/select.2.html">select(2)</a>, <a href="../man2/poll.2.html">poll(2)</a>,
       and <a href="epoll.7.html">epoll(7)</a>.  When an event is available, the file descriptor
       indicates as readable.

       Since Linux 2.6.25, signal-driven I/O notification is available for
       inotify file descriptors; see the discussion of <b>F_SETFL </b>(for setting
       the <b>O_ASYNC </b>flag), <b>F_SETOWN</b>, and <b>F_SETSIG </b>in <a href="../man2/fcntl.2.html">fcntl(2)</a>.  The <i>siginfo_t</i>
       structure (described in <a href="../man2/sigaction.2.html">sigaction(2)</a>) that is passed to the signal
       handler has the following fields set: <i>si_fd</i> is set to the inotify
       file descriptor number; <i>si_signo</i> is set to the signal number; <i>si_code</i>
       is set to <b>POLL_IN</b>; and <b>POLLIN </b>is set in <i>si_band</i>.

       If successive output inotify events produced on the inotify file
       descriptor are identical (same <i>wd</i>, <i>mask</i>, <i>cookie</i>, and <i>name</i>), then they
       are coalesced into a single event if the older event has not yet been
       read (but see BUGS).  This reduces the amount of kernel memory
       required for the event queue, but also means that an application
       can't use inotify to reliably count file events.

       The events returned by reading from an inotify file descriptor form
       an ordered queue.  Thus, for example, it is guaranteed that when
       renaming from one directory to another, events will be produced in
       the correct order on the inotify file descriptor.

       The set of watch descriptors that is being monitored via an inotify
       file descriptor can be viewed via the entry for the inotify file
       descriptor in the process's <i>/proc/[pid]/fdinfo</i> directory.  See
       <a href="../man5/proc.5.html">proc(5)</a> for further details.  The <b>FIONREAD ioctl</b>(2) returns the
       number of bytes available to read from an inotify file descriptor.

   <b>Limitations and caveats</b>
       The inotify API provides no information about the user or process
       that triggered the inotify event.  In particular, there is no easy
       way for a process that is monitoring events via inotify to
       distinguish events that it triggers itself from those that are
       triggered by other processes.

       Inotify reports only events that a user-space program triggers
       through the filesystem API.  As a result, it does not catch remote
       events that occur on network filesystems.  (Applications must fall
       back to polling the filesystem to catch such events.)  Furthermore,
       various pseudo-filesystems such as <i>/proc</i>, <i>/sys</i>, and <i>/dev/pts</i> are not
       monitorable with inotify.

       The inotify API does not report file accesses and modifications that
       may occur because of <a href="../man2/mmap.2.html">mmap(2)</a>, <a href="../man2/msync.2.html">msync(2)</a>, and <a href="../man2/munmap.2.html">munmap(2)</a>.

       The inotify API identifies affected files by filename.  However, by
       the time an application processes an inotify event, the filename may
       already have been deleted or renamed.

       The inotify API identifies events via watch descriptors.  It is the
       application's responsibility to cache a mapping (if one is needed)
       between watch descriptors and pathnames.  Be aware that directory
       renamings may affect multiple cached pathnames.

       Inotify monitoring of directories is not recursive: to monitor
       subdirectories under a directory, additional watches must be created.
       This can take a significant amount time for large directory trees.

       If monitoring an entire directory subtree, and a new subdirectory is
       created in that tree or an existing directory is renamed into that
       tree, be aware that by the time you create a watch for the new
       subdirectory, new files (and subdirectories) may already exist inside
       the subdirectory.  Therefore, you may want to scan the contents of
       the subdirectory immediately after adding the watch (and, if desired,
       recursively add watches for any subdirectories that it contains).

       Note that the event queue can overflow.  In this case, events are
       lost.  Robust applications should handle the possibility of lost
       events gracefully.  For example, it may be necessary to rebuild part
       or all of the application cache.  (One simple, but possibly
       expensive, approach is to close the inotify file descriptor, empty
       the cache, create a new inotify file descriptor, and then re-create
       watches and cache entries for the objects to be monitored.)

       If a filesystem is mounted on top of a monitored directory, no event
       is generated, and no events are generated for objects immediately
       under the new mount point.  If the filesystem is subsequently
       unmounted, events will subsequently be generated for the directory
       and the objects it contains.

   <b>Dealing with rename() events</b>
       As noted above, the <b>IN_MOVED_FROM </b>and <b>IN_MOVED_TO </b>event pair that is
       generated by <a href="../man2/rename.2.html">rename(2)</a> can be matched up via their shared cookie
       value.  However, the task of matching has some challenges.

       These two events are usually consecutive in the event stream
       available when reading from the inotify file descriptor.  However,
       this is not guaranteed.  If multiple processes are triggering events
       for monitored objects, then (on rare occasions) an arbitrary number
       of other events may appear between the <b>IN_MOVED_FROM </b>and <b>IN_MOVED_TO</b>
       events.  Furthermore, it is not guaranteed that the event pair is
       atomically inserted into the queue: there may be a brief interval
       where the <b>IN_MOVED_FROM </b>has appeared, but the <b>IN_MOVED_TO </b>has not.

       Matching up the <b>IN_MOVED_FROM </b>and <b>IN_MOVED_TO </b>event pair generated by
       <a href="../man2/rename.2.html">rename(2)</a> is thus inherently racy.  (Don't forget that if an object
       is renamed outside of a monitored directory, there may not even be an
       <b>IN_MOVED_TO </b>event.)  Heuristic approaches (e.g., assume the events
       are always consecutive) can be used to ensure a match in most cases,
       but will inevitably miss some cases, causing the application to
       perceive the <b>IN_MOVED_FROM </b>and <b>IN_MOVED_TO </b>events as being unrelated.
       If watch descriptors are destroyed and re-created as a result, then
       those watch descriptors will be inconsistent with the watch
       descriptors in any pending events.  (Re-creating the inotify file
       descriptor and rebuilding the cache may be useful to deal with this
       scenario.)

       Applications should also allow for the possibility that the
       <b>IN_MOVED_FROM </b>event was the last event that could fit in the buffer
       returned by the current call to <a href="../man2/read.2.html">read(2)</a>, and the accompanying
       <b>IN_MOVED_TO </b>event might be fetched only on the next <a href="../man2/read.2.html">read(2)</a>, which
       should be done with a (small) timeout to allow for the fact that
       insertion of the <b>IN_MOVED_FROM</b>-<b>IN_MOVED_TO </b>event pair is not atomic,
       and also the possibility that there may not be any <b>IN_MOVED_TO </b>event.
</pre>
<h2><a id="BUGS" href="#BUGS"></a>BUGS  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       Before Linux 3.19, <a href="../man2/fallocate.2.html">fallocate(2)</a> did not create any inotify events.
       Since Linux 3.19, calls to <a href="../man2/fallocate.2.html">fallocate(2)</a> generate <b>IN_MODIFY </b>events.

       In kernels before 2.6.16, the <b>IN_ONESHOT </b><i>mask</i> flag does not work.

       As originally designed and implemented, the <b>IN_ONESHOT </b>flag did not
       cause an <b>IN_IGNORED </b>event to be generated when the watch was dropped
       after one event.  However, as an unintended effect of other changes,
       since Linux 2.6.36, an <b>IN_IGNORED </b>event is generated in this case.

       Before kernel 2.6.25, the kernel code that was intended to coalesce
       successive identical events (i.e., the two most recent events could
       potentially be coalesced if the older had not yet been read) instead
       checked if the most recent event could be coalesced with the <i>oldest</i>
       unread event.

       When a watch descriptor is removed by calling <a href="../man2/inotify_rm_watch.2.html">inotify_rm_watch(2)</a> (or
       because a watch file is deleted or the filesystem that contains it is
       unmounted), any pending unread events for that watch descriptor
       remain available to read.  As watch descriptors are subsequently
       allocated with <a href="../man2/inotify_add_watch.2.html">inotify_add_watch(2)</a>, the kernel cycles through the
       range of possible watch descriptors (0 to <b>INT_MAX</b>) incrementally.
       When allocating a free watch descriptor, no check is made to see
       whether that watch descriptor number has any pending unread events in
       the inotify queue.  Thus, it can happen that a watch descriptor is
       reallocated even when pending unread events exist for a previous
       incarnation of that watch descriptor number, with the result that the
       application might then read those events and interpret them as
       belonging to the file associated with the newly recycled watch
       descriptor.  In practice, the likelihood of hitting this bug may be
       extremely low, since it requires that an application cycle through
       <b>INT_MAX </b>watch descriptors, release a watch descriptor while leaving
       unread events for that watch descriptor in the queue, and then
       recycle that watch descriptor.  For this reason, and because there
       have been no reports of the bug occurring in real-world applications,
       as of Linux 3.15, no kernel changes have yet been made to eliminate
       this possible bug.
</pre>
<h2><a id="EXAMPLE" href="#EXAMPLE"></a>EXAMPLE  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       The following program demonstrates the usage of the inotify API.  It
       marks the directories passed as a command-line arguments and waits
       for events of type <b>IN_OPEN</b>, <b>IN_CLOSE_NOWRITE </b>and <b>IN_CLOSE_WRITE</b>.

       The following output was recorded while editing the file
       <i>/home/user/temp/foo</i> and listing directory <i>/tmp</i>.  Before the file and
       the directory were opened, <b>IN_OPEN </b>events occurred.  After the file
       was closed, an <b>IN_CLOSE_WRITE </b>event occurred.  After the directory
       was closed, an <b>IN_CLOSE_NOWRITE </b>event occurred.  Execution of the
       program ended when the user pressed the ENTER key.

   <b>Example output</b>
           $ <b>./a.out /tmp /home/user/temp</b>
           Press enter key to terminate.
           Listening for events.
           IN_OPEN: /home/user/temp/foo [file]
           IN_CLOSE_WRITE: /home/user/temp/foo [file]
           IN_OPEN: /tmp/ [directory]
           IN_CLOSE_NOWRITE: /tmp/ [directory]

           Listening for events stopped.

   <b>Program source</b>
       #include &lt;errno.h&gt;
       #include &lt;poll.h&gt;
       #include &lt;stdio.h&gt;
       #include &lt;stdlib.h&gt;
       #include &lt;sys/inotify.h&gt;
       #include &lt;unistd.h&gt;

       /* Read all available inotify events from the file descriptor 'fd'.
          wd is the table of watch descriptors for the directories in argv.
          argc is the length of wd and argv.
          argv is the list of watched directories.
          Entry 0 of wd and argv is unused. */

       static void
       handle_events(int fd, int *wd, int argc, char* argv[])
       {
           /* Some systems cannot read integer variables if they are not
              properly aligned. On other systems, incorrect alignment may
              decrease performance. Hence, the buffer used for reading from
              the inotify file descriptor should have the same alignment as
              struct inotify_event. */

           char buf[4096]
               __attribute__ ((aligned(__alignof__(struct inotify_event))));
           const struct inotify_event *event;
           int i;
           ssize_t len;
           char *ptr;

           /* Loop while events can be read from inotify file descriptor. */

           for (;;) {

               /* Read some events. */

               len = read(fd, buf, sizeof buf);
               if (len == -1 &amp;&amp; errno != EAGAIN) {
                   perror("read");
                   exit(EXIT_FAILURE);
               }

               /* If the nonblocking read() found no events to read, then
                  it returns -1 with errno set to EAGAIN. In that case,
                  we exit the loop. */

               if (len &lt;= 0)
                   break;

               /* Loop over all events in the buffer */

               for (ptr = buf; ptr &lt; buf + len;
                       ptr += sizeof(struct inotify_event) + event-&gt;len) {

                   event = (const struct inotify_event *) ptr;

                   /* Print event type */

                   if (event-&gt;mask &amp; IN_OPEN)
                       printf("IN_OPEN: ");
                   if (event-&gt;mask &amp; IN_CLOSE_NOWRITE)
                       printf("IN_CLOSE_NOWRITE: ");
                   if (event-&gt;mask &amp; IN_CLOSE_WRITE)
                       printf("IN_CLOSE_WRITE: ");

                   /* Print the name of the watched directory */

                   for (i = 1; i &lt; argc; ++i) {
                       if (wd[i] == event-&gt;wd) {
                           printf("%s/", argv[i]);
                           break;
                       }
                   }

                   /* Print the name of the file */

                   if (event-&gt;len)
                       printf("%s", event-&gt;name);

                   /* Print type of filesystem object */

                   if (event-&gt;mask &amp; IN_ISDIR)
                       printf(" [directory]\n");
                   else
                       printf(" [file]\n");
               }
           }
       }

       int
       main(int argc, char* argv[])
       {
           char buf;
           int fd, i, poll_num;
           int *wd;
           nfds_t nfds;
           struct pollfd fds[2];

           if (argc &lt; 2) {
               printf("Usage: %s PATH [PATH ...]\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           printf("Press ENTER key to terminate.\n");

           /* Create the file descriptor for accessing the inotify API */

           fd = inotify_init1(IN_NONBLOCK);
           if (fd == -1) {
               perror("inotify_init1");
               exit(EXIT_FAILURE);
           }

           /* Allocate memory for watch descriptors */

           wd = calloc(argc, sizeof(int));
           if (wd == NULL) {
               perror("calloc");
               exit(EXIT_FAILURE);
           }

           /* Mark directories for events
              - file was opened
              - file was closed */

           for (i = 1; i &lt; argc; i++) {
               wd[i] = inotify_add_watch(fd, argv[i],
                                         IN_OPEN | IN_CLOSE);
               if (wd[i] == -1) {
                   fprintf(stderr, "Cannot watch '%s'\n", argv[i]);
                   perror("inotify_add_watch");
                   exit(EXIT_FAILURE);
               }
           }

           /* Prepare for polling */

           nfds = 2;

           /* Console input */

           fds[0].fd = STDIN_FILENO;
           fds[0].events = POLLIN;

           /* Inotify input */

           fds[1].fd = fd;
           fds[1].events = POLLIN;

           /* Wait for events and/or terminal input */

           printf("Listening for events.\n");
           while (1) {
               poll_num = poll(fds, nfds, -1);
               if (poll_num == -1) {
                   if (errno == EINTR)
                       continue;
                   perror("poll");
                   exit(EXIT_FAILURE);
               }

               if (poll_num &gt; 0) {

                   if (fds[0].revents &amp; POLLIN) {

                       /* Console input is available. Empty stdin and quit */

                       while (read(STDIN_FILENO, &amp;buf, 1) &gt; 0 &amp;&amp; buf != '\n')
                           continue;
                       break;
                   }

                   if (fds[1].revents &amp; POLLIN) {

                       /* Inotify events are available */

                       handle_events(fd, wd, argc, argv);
                   }
               }
           }

           printf("Listening for events stopped.\n");

           /* Close inotify file descriptor */

           close(fd);

           free(wd);
           exit(EXIT_SUCCESS);
       }
</pre>
<h2><a id="SEE_ALSO" href="#SEE_ALSO"></a>SEE ALSO  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       <a href="../man1/inotifywait.1.html">inotifywait(1)</a>, <a href="../man1/inotifywatch.1.html">inotifywatch(1)</a>, <a href="../man2/inotify_add_watch.2.html">inotify_add_watch(2)</a>,
       <a href="../man2/inotify_init.2.html">inotify_init(2)</a>, <a href="../man2/inotify_init1.2.html">inotify_init1(2)</a>, <a href="../man2/inotify_rm_watch.2.html">inotify_rm_watch(2)</a>, <a href="../man2/read.2.html">read(2)</a>,
       <a href="../man2/stat.2.html">stat(2)</a>, <a href="fanotify.7.html">fanotify(7)</a>

       <i>Documentation/filesystems/inotify.txt</i> in the Linux kernel source tree
</pre>
<h2><a id="COLOPHON" href="#COLOPHON"></a>COLOPHON  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       This page is part of release 4.12 of the Linux <i>man-pages</i> project.  A
       description of the project, information about reporting bugs, and the
       latest version of this page, can be found at
       <a href="https://www.kernel.org/doc/man-pages/">https://www.kernel.org/doc/man-pages/</a>.

<span class="footline">Linux                            2017-05-03                       INOTIFY(7)</span>
</pre>

<hr class="end-man-text" />
<p>Pages that refer to this page: 
    <a href="../man1/inotifywait.1.html">inotifywait(1)</a>,&nbsp; 
    <a href="../man1/inotifywatch.1.html">inotifywatch(1)</a>,&nbsp; 
    <a href="../man2/fcntl.2.html">fcntl(2)</a>,&nbsp; 
    <a href="../man2/inotify_add_watch.2.html">inotify_add_watch(2)</a>,&nbsp; 
    <a href="../man2/inotify_init.2.html">inotify_init(2)</a>,&nbsp; 
    <a href="../man2/inotify_rm_watch.2.html">inotify_rm_watch(2)</a>,&nbsp; 
    <a href="../man2/ptrace.2.html">ptrace(2)</a>,&nbsp; 
    <a href="../man5/proc.5.html">proc(5)</a>,&nbsp; 
    <a href="../man5/systemd.path.5.html">systemd.path(5)</a>,&nbsp; 
    <a href="cgroups.7.html">cgroups(7)</a>,&nbsp; 
    <a href="credentials.7.html">credentials(7)</a>,&nbsp; 
    <a href="fanotify.7.html">fanotify(7)</a>,&nbsp; 
    <a href="signal.7.html">signal(7)</a>,&nbsp; 
    <a href="../man8/agetty.8.html">agetty(8)</a>,&nbsp; 
    <a href="../man8/cron.8.html">cron(8)</a>,&nbsp; 
    <a href="../man8/nscd.8.html">nscd(8)</a>
</p>
<hr/>

<p class="page-copyright"><a href="inotify.7.license.html">Copyright and license for this manual page</a></p> 
<hr class="start-footer" />

<div class="footer"> 

<table class="colophon-table">
    <tr>
    <td class="pub-info">
        <p>
            HTML rendering created 2017-07-13
            by <a href="http://man7.org/mtk/index.html">Michael Kerrisk</a>, 
            author of 
            <a href="http://man7.org/tlpi/"><em>The Linux Programming Interface</em></a>, 
            maintainer of the 
            <a href="https://www.kernel.org/doc/man-pages/">Linux <em>man-pages</em> project</a>.
        </p>
        <p>
            For details of in-depth
            <strong>Linux/UNIX system programming training courses</strong>
            that I teach, look <a href="http://man7.org/training/">here</a>.
        </p>
        <p>
            Hosting by <a href="http://www.jambit.com/index_en.html">jambit GmbH</a>.
        </p>
        <p>
            <a href="http://validator.w3.org/check?uri=referer">
            <img src="http://www.w3.org/Icons/valid-xhtml11"
                alt="Valid XHTML 1.1" height="31" width="88" />
            </a>
        </p>
    </td>
    <td class="colophon-divider">
    </td>
    <td class="tlpi-cover">
        <a href="http://man7.org/tlpi/"><img src="../../../tlpi/cover/TLPI-front-cover-vsmall.png" alt="Cover of TLPI" /></a>
    </td>
    </tr>
</table>

</div>

<hr class="end-footer" />



<!--BEGIN-SITETRACKING-->
<!-- SITETRACKING.man7.org_linux_man-pages -->

<!-- Start of StatCounter Code (xhtml) -->

<script type="text/javascript">
//<![CDATA[
var sc_project=7422636; 
var sc_invisible=1; 
var sc_security="9b6714ff"; 
//]]>
</script>
<script type="text/javascript"
src="../../../../www.statcounter.com/counter/counter_xhtml.js"></script>
<noscript><div class="statcounter"><a title="website
statistics" href="http://statcounter.com/"
class="statcounter"><img class="statcounter"
src="http://c.statcounter.com/7422636/0/9b6714ff/1/"
alt="website statistics" /></a></div></noscript>

<!-- End of StatCounter Code -->


<!-- Start of Google Analytics Code -->

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-9830363-8']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<!-- End of Google Analytics Code -->

<!--END-SITETRACKING-->

</body>
</html>
