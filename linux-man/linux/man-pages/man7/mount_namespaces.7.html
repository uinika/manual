
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
        "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
    <link rel="stylesheet" type="text/css" href="../../../style.css" title="style" />
    <link rel="stylesheet" type="text/css" href="../style.css" title="style" />
    <meta http-equiv="content-type" content="text/html;charset=utf-8" />

    <title>mount_namespaces(7) - Linux manual page</title>
</head>

<body>

<div class="page-top"><a id="top_of_page"></a></div>
<!--%%%TOP_BAR%%%-->
    <div class="nav-bar">
        <table class="nav-table">
            <tr>
                <td class="nav-cell">
                    <p class="nav-text">
                        <a href="http://man7.org/index.html">man7.org</a> &gt; Linux &gt; <a href="../index.html">man-pages</a>
                    </p>
                </td>
                <td class="training-cell">
                    <p class="training-text"><a class="training-link" href="http://man7.org/training/">Linux/UNIX system programming training</a></p>
                </td>
            </tr>
        </table>
    </div>

<hr class="nav-end" />

<!--%%%PAGE_START%%%-->


<table class="sec-table">
<tr>
    <td>
        <p class="section-dir">
<a href="#NAME">NAME</a> | <a href="#DESCRIPTION">DESCRIPTION</a> | <a href="#SHARED_SUBTREES">SHARED&nbsp;SUBTREES</a> | <a href="#VERSIONS">VERSIONS</a> | <a href="#CONFORMING_TO">CONFORMING&nbsp;TO</a> | <a href="#NOTES">NOTES</a> | <a href="#SEE_ALSO">SEE&nbsp;ALSO</a> | <a href="#COLOPHON">COLOPHON</a>
        </p>
    </td>
    <td class="search-box">
        <div class="man-search-box">

            <form method="get" action="http://www.google.com/search">
                <fieldset class="man-search">
                    <input type="text" name="q" size="10" maxlength="255" value="" />
                    <input type="hidden" name="sitesearch" value="man7.org/linux/man-pages" />
                    <input type="submit" name="sa" value="Search online pages" />
                </fieldset>
            </form>

        </div>
    </td>
    <td> </td>
</tr>
</table>

<pre>
<span class="headline">MOUNT_NAMESPACES(7)       Linux Programmer's Manual      MOUNT_NAMESPACES(7)</span>
</pre>
<h2><a id="NAME" href="#NAME"></a>NAME  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       mount_namespaces - overview of Linux mount namespaces
</pre>
<h2><a id="DESCRIPTION" href="#DESCRIPTION"></a>DESCRIPTION  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       For an overview of namespaces, see <a href="namespaces.7.html">namespaces(7)</a>.

       Mount namespaces provide isolation of the list of mount points seen
       by the processes in each namespace instance.  Thus, the processes in
       each of the mount namespace instances will see distinct single-
       directory hierarchies.

       The views provided by the <i>/proc/[pid]/mounts</i>, <i>/proc/[pid]/mountinfo</i>,
       and <i>/proc/[pid]/mountstats</i> files (all described in <a href="../man5/proc.5.html">proc(5)</a>)
       correspond to the mount namespace in which the process with the PID
       <i>[pid]</i> resides.  (All of the processes that reside in the same mount
       namespace will see the same view in these files.)

       When a process creates a new mount namespace using <a href="../man2/clone.2.html">clone(2)</a> or
       <a href="../man2/unshare.2.html">unshare(2)</a> with the <b>CLONE_NEWNS </b>flag, the mount point list for the
       new namespace is a <i>copy</i> of the caller's mount point list.  Subsequent
       modifications to the mount point list (<a href="../man2/mount.2.html">mount(2)</a> and <a href="../man2/umount.2.html">umount(2)</a>) in
       either mount namespace will not (by default) affect the mount point
       list seen in the other namespace (but see the following discussion of
       shared subtrees).

   <b>Restrictions on mount namespaces</b>
       Note the following points with respect to mount namespaces:

       *  A mount namespace has an owner user namespace.  A mount namespace
          whose owner user namespace is different from the owner user
          namespace of its parent mount namespace is considered a less
          privileged mount namespace.

       *  When creating a less privileged mount namespace, shared mounts are
          reduced to slave mounts.  (Shared and slave mounts are discussed
          below.)  This ensures that mappings performed in less privileged
          mount namespaces will not propagate to more privileged mount
          namespaces.

       *  Mounts that come as a single unit from more privileged mount are
          locked together and may not be separated in a less privileged
          mount namespace.  (The <a href="../man2/unshare.2.html">unshare(2)</a> <b>CLONE_NEWNS </b>operation brings
          across all of the mounts from the original mount namespace as a
          single unit, and recursive mounts that propagate between mount
          namespaces propagate as a single unit.)

       *  The <a href="../man2/mount.2.html">mount(2)</a> flags <b>MS_RDONLY</b>, <b>MS_NOSUID</b>, <b>MS_NOEXEC</b>, and the
          "atime" flags (<b>MS_NOATIME</b>, <b>MS_NODIRATIME</b>, <b>MS_RELATIME</b>) settings
          become locked when propagated from a more privileged to a less
          privileged mount namespace, and may not be changed in the less
          privileged mount namespace.

       *  A file or directory that is a mount point in one namespace that is
          not a mount point in another namespace, may be renamed, unlinked,
          or removed (<a href="../man2/rmdir.2.html">rmdir(2)</a>) in the mount namespace in which it is not a
          mount point (subject to the usual permission checks).

          Previously, attempting to unlink, rename, or remove a file or
          directory that was a mount point in another mount namespace would
          result in the error <b>EBUSY</b>.  That behavior had technical problems
          of enforcement (e.g., for NFS) and permitted denial-of-service
          attacks against more privileged users.  (i.e., preventing
          individual files from being updated by bind mounting on top of
          them).
</pre>
<h2><a id="SHARED_SUBTREES" href="#SHARED_SUBTREES"></a>SHARED SUBTREES  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       After the implementation of mount namespaces was completed,
       experience showed that the isolation that they provided was, in some
       cases, too great.  For example, in order to make a newly loaded
       optical disk available in all mount namespaces, a mount operation was
       required in each namespace.  For this use case, and others, the
       shared subtree feature was introduced in Linux 2.6.15.  This feature
       allows for automatic, controlled propagation of mount and unmount
       <i>events</i> between namespaces (or, more precisely, between the members of
       a <i>peer group</i> that are propagating events to one another).

       Each mount point is marked (via <a href="../man2/mount.2.html">mount(2)</a>) as having one of the
       following <i>propagation types</i>:

       <b>MS_SHARED</b>
              This mount point shares events with members of a peer group.
              Mount and unmount events immediately under this mount point
              will propagate to the other mount points that are members of
              the peer group.  <i>Propagation</i> here means that the same mount or
              unmount will automatically occur under all of the other mount
              points in the peer group.  Conversely, mount and unmount
              events that take place under peer mount points will propagate
              to this mount point.

       <b>MS_PRIVATE</b>
              This mount point is private; it does not have a peer group.
              Mount and unmount events do not propagate into or out of this
              mount point.

       <b>MS_SLAVE</b>
              Mount and unmount events propagate into this mount point from
              a (master) shared peer group.  Mount and unmount events under
              this mount point do not propagate to any peer.

              Note that a mount point can be the slave of another peer group
              while at the same time sharing mount and unmount events with a
              peer group of which it is a member.  (More precisely, one peer
              group can be the slave of another peer group.)

       <b>MS_UNBINDABLE</b>
              This is like a private mount, and in addition this mount can't
              be bind mounted.  Attempts to bind mount this mount (<a href="../man2/mount.2.html">mount(2)</a>
              with the <b>MS_BIND </b>flag) will fail.

              When a recursive bind mount (<a href="../man2/mount.2.html">mount(2)</a> with the <b>MS_BIND </b>and
              <b>MS_REC </b>flags) is performed on a directory subtree, any bind
              mounts within the subtree are automatically pruned (i.e., not
              replicated) when replicating that subtree to produce the
              target subtree.

       For a discussion of the propagation type assigned to a new mount, see
       NOTES.

       The propagation type is a per-mount-point setting; some mount points
       may be marked as shared (with each shared mount point being a member
       of a distinct peer group), while others are private (or slaved or
       unbindable).

       Note that a mount's propagation type determines whether mounts and
       unmounts of mount points <i>immediately under</i> the mount point are
       propagated.  Thus, the propagation type does not affect propagation
       of events for grandchildren and further removed descendant mount
       points.  What happens if the mount point itself is unmounted is
       determined by the propagation type that is in effect for the <i>parent</i>
       of the mount point.

       Members are added to a <i>peer group</i> when a mount point is marked as
       shared and either:

       *  the mount point is replicated during the creation of a new mount
          namespace; or

       *  a new bind mount is created from the mount point.

       In both of these cases, the new mount point joins the peer group of
       which the existing mount point is a member.  A mount ceases to be a
       member of a peer group when either the mount is explicitly unmounted,
       or when the mount is implicitly unmounted because a mount namespace
       is removed (because it has no more member processes).

       The propagation type of the mount points in a mount namespace can be
       discovered via the "optional fields" exposed in
       <i>/proc/[pid]/mountinfo</i>.  (See <a href="../man5/proc.5.html">proc(5)</a> for details of this file.)  The
       following tags can appear in the optional fields for a record in that
       file:

       <i>shared:X</i>
              This mount point is shared in peer group <i>X</i>.  Each peer group
              has a unique ID that is automatically generated by the kernel,
              and all mount points in the same peer group will show the same
              ID.  (These IDs are assigned starting from the value 1, and
              may be recycled when a peer group ceases to have any members.)

       <i>master:X</i>
              This mount is a slave to shared peer group <i>X</i>.

       <i>propagate_from:X</i> (since Linux 2.6.26)
              This mount is a slave and receives propagation from shared
              peer group <i>X</i>.  This tag will always appear in conjunction with
              a <i>master:X</i> tag.  Here, <i>X</i> is the closest dominant peer group
              under the process's root directory.  If <i>X</i> is the immediate
              master of the mount, or if there is no dominant peer group
              under the same root, then only the <i>master:X</i> field is present
              and not the <i>propagate_from:X</i> field.  For further details, see
              below.

       <i>unbindable</i>
              This is an unbindable mount.

       If none of the above tags is present, then this is a private mount.

   <b>MS_SHARED and MS_PRIVATE example</b>
       Suppose that on a terminal in the initial mount namespace, we mark
       one mount point as shared and another as private, and then view the
       mounts in <i>/proc/self/mountinfo</i>:

           sh1# <b>mount --make-shared /mntS</b>
           sh1# <b>mount --make-private /mntP</b>
           sh1# <b>cat /proc/self/mountinfo | grep '/mnt' | sed 's/ - .*//'</b>
           77 61 8:17 / /mntS rw,relatime shared:1
           83 61 8:15 / /mntP rw,relatime

       From the <i>/proc/self/mountinfo</i> output, we see that <i>/mntS</i> is a shared
       mount in peer group 1, and that <i>/mntP</i> has no optional tags,
       indicating that it is a private mount.  The first two fields in each
       record in this file are the unique ID for this mount, and the mount
       ID of the parent mount.  We can further inspect this file to see that
       the parent mount point of <i>/mntS</i> and <i>/mntP</i> is the root directory, <i>/</i>,
       which is mounted as private:

           sh1# <b>cat /proc/self/mountinfo | awk '$1 == 61' | sed 's/ - .*//'</b>
           61 0 8:2 / / rw,relatime

       On a second terminal, we create a new mount namespace where we run a
       second shell and inspect the mounts:

           $ <b>PS1='sh2# ' sudo unshare -m --propagation unchanged sh</b>
           sh2# <b>cat /proc/self/mountinfo | grep '/mnt' | sed 's/ - .*//'</b>
           222 145 8:17 / /mntS rw,relatime shared:1
           225 145 8:15 / /mntP rw,relatime

       The new mount namespace received a copy of the initial mount
       namespace's mount points.  These new mount points maintain the same
       propagation types, but have unique mount IDs.  (The
       <i>--propagation unchanged</i> option prevents <a href="../man1/unshare.1.html">unshare(1)</a> from marking all
       mounts as private when creating a new mount namespace, which it does
       by default.)

       In the second terminal, we then create submounts under each of <i>/mntS</i>
       and <i>/mntP</i> and inspect the set-up:

           sh2# <b>mkdir /mntS/a</b>
           sh2# <b>mount /dev/sdb6 /mntS/a</b>
           sh2# <b>mkdir /mntP/b</b>
           sh2# <b>mount /dev/sdb7 /mntP/b</b>
           sh2# <b>cat /proc/self/mountinfo | grep '/mnt' | sed 's/ - .*//'</b>
           222 145 8:17 / /mntS rw,relatime shared:1
           225 145 8:15 / /mntP rw,relatime
           178 222 8:22 / /mntS/a rw,relatime shared:2
           230 225 8:23 / /mntP/b rw,relatime

       From the above, it can be seen that <i>/mntS/a</i> was created as shared
       (inheriting this setting from its parent mount) and <i>/mntP/b</i> was
       created as a private mount.

       Returning to the first terminal and inspecting the set-up, we see
       that the new mount created under the shared mount point <i>/mntS</i>
       propagated to its peer mount (in the initial mount namespace), but
       the new mount created under the private mount point <i>/mntP</i> did not
       propagate:

           sh1# <b>cat /proc/self/mountinfo | grep '/mnt' | sed 's/ - .*//'</b>
           77 61 8:17 / /mntS rw,relatime shared:1
           83 61 8:15 / /mntP rw,relatime
           179 77 8:22 / /mntS/a rw,relatime shared:2

   <b>MS_SLAVE example</b>
       Making a mount point a slave allows it to receive propagated mount
       and unmount events from a master shared peer group, while preventing
       it from propagating events to that master.  This is useful if we want
       to (say) receive a mount event when an optical disk is mounted in the
       master shared peer group (in another mount namespace), but want to
       prevent mount and unmount events under the slave mount from having
       side effects in other namespaces.

       We can demonstrate the effect of slaving by first marking two mount
       points as shared in the initial mount namespace:

           sh1# <b>mount --make-shared /mntX</b>
           sh1# <b>mount --make-shared /mntY</b>
           sh1# <b>cat /proc/self/mountinfo | grep '/mnt' | sed 's/ - .*//'</b>
           132 83 8:23 / /mntX rw,relatime shared:1
           133 83 8:22 / /mntY rw,relatime shared:2

       On a second terminal, we create a new mount namespace and inspect the
       mount points:

           sh2# <b>unshare -m --propagation unchanged sh</b>
           sh2# <b>cat /proc/self/mountinfo | grep '/mnt' | sed 's/ - .*//'</b>
           168 167 8:23 / /mntX rw,relatime shared:1
           169 167 8:22 / /mntY rw,relatime shared:2

       In the new mount namespace, we then mark one of the mount points as a
       slave:

           sh2# <b>mount --make-slave /mntY</b>
           sh2# <b>cat /proc/self/mountinfo | grep '/mnt' | sed 's/ - .*//'</b>
           168 167 8:23 / /mntX rw,relatime shared:1
           169 167 8:22 / /mntY rw,relatime master:2

       From the above output, we see that <i>/mntY</i> is now a slave mount that is
       receiving propagation events from the shared peer group with the ID
       2.

       Continuing in the new namespace, we create submounts under each of
       <i>/mntX</i> and <i>/mntY</i>:

           sh2# <b>mkdir /mntX/a</b>
           sh2# <b>mount /dev/sda3 /mntX/a</b>
           sh2# <b>mkdir /mntY/b</b>
           sh2# <b>mount /dev/sda5 /mntY/b</b>

       When we inspect the state of the mount points in the new mount
       namespace, we see that <i>/mntX/a</i> was created as a new shared mount
       (inheriting the "shared" setting from its parent mount) and <i>/mntY/b</i>
       was created as a private mount:

           sh2# <b>cat /proc/self/mountinfo | grep '/mnt' | sed 's/ - .*//'</b>
           168 167 8:23 / /mntX rw,relatime shared:1
           169 167 8:22 / /mntY rw,relatime master:2
           173 168 8:3 / /mntX/a rw,relatime shared:3
           175 169 8:5 / /mntY/b rw,relatime

       Returning to the first terminal (in the initial mount namespace), we
       see that the mount <i>/mntX/a</i> propagated to the peer (the shared <i>/mntX</i>),
       but the mount <i>/mntY/b</i> was not propagated:

           sh1# <b>cat /proc/self/mountinfo | grep '/mnt' | sed 's/ - .*//'</b>
           132 83 8:23 / /mntX rw,relatime shared:1
           133 83 8:22 / /mntY rw,relatime shared:2
           174 132 8:3 / /mntX/a rw,relatime shared:3

       Now we create a new mount point under <i>/mntY</i> in the first shell:

           sh1# <b>mkdir /mntY/c</b>
           sh1# <b>mount /dev/sda1 /mntY/c</b>
           sh1# <b>cat /proc/self/mountinfo | grep '/mnt' | sed 's/ - .*//'</b>
           132 83 8:23 / /mntX rw,relatime shared:1
           133 83 8:22 / /mntY rw,relatime shared:2
           174 132 8:3 / /mntX/a rw,relatime shared:3
           178 133 8:1 / /mntY/c rw,relatime shared:4

       When we examine the mount points in the second mount namespace, we
       see that in this case the new mount has been propagated to the slave
       mount point, and that the new mount is itself a slave mount (to peer
       group 4):

           sh2# <b>cat /proc/self/mountinfo | grep '/mnt' | sed 's/ - .*//'</b>
           168 167 8:23 / /mntX rw,relatime shared:1
           169 167 8:22 / /mntY rw,relatime master:2
           173 168 8:3 / /mntX/a rw,relatime shared:3
           175 169 8:5 / /mntY/b rw,relatime
           179 169 8:1 / /mntY/c rw,relatime master:4

   <b>MS_UNBINDABLE example</b>
       One of the primary purposes of unbindable mounts is to avoid the
       "mount point explosion" problem when repeatedly performing bind
       mounts of a higher-level subtree at a lower-level mount point.  The
       problem is illustrated by the following shell session.

       Suppose we have a system with the following mount points:

           # <b>mount | awk '{print $1, $2, $3}'</b>
           /dev/sda1 on /
           /dev/sdb6 on /mntX
           /dev/sdb7 on /mntY

       Suppose furthermore that we wish to recursively bind mount the root
       directory under several users' home directories.  We do this for the
       first user, and inspect the mount points:

           # <b>mount --rbind / /home/cecilia/</b>
           # <b>mount | awk '{print $1, $2, $3}'</b>
           /dev/sda1 on /
           /dev/sdb6 on /mntX
           /dev/sdb7 on /mntY
           /dev/sda1 on /home/cecilia
           /dev/sdb6 on /home/cecilia/mntX
           /dev/sdb7 on /home/cecilia/mntY

       When we repeat this operation for the second user, we start to see
       the explosion problem:

           # <b>mount --rbind / /home/henry</b>
           # <b>mount | awk '{print $1, $2, $3}'</b>
           /dev/sda1 on /
           /dev/sdb6 on /mntX
           /dev/sdb7 on /mntY
           /dev/sda1 on /home/cecilia
           /dev/sdb6 on /home/cecilia/mntX
           /dev/sdb7 on /home/cecilia/mntY
           /dev/sda1 on /home/henry
           /dev/sdb6 on /home/henry/mntX
           /dev/sdb7 on /home/henry/mntY
           /dev/sda1 on /home/henry/home/cecilia
           /dev/sdb6 on /home/henry/home/cecilia/mntX
           /dev/sdb7 on /home/henry/home/cecilia/mntY

       Under <i>/home/henry</i>, we have not only recursively added the <i>/mntX</i> and
       <i>/mntY</i> mounts, but also the recursive mounts of those directories
       under <i>/home/cecilia</i> that were created in the previous step.  Upon
       repeating the step for a third user, it becomes obvious that the
       explosion is exponential in nature:

           # <b>mount --rbind / /home/otto</b>
           # <b>mount | awk '{print $1, $2, $3}'</b>
           /dev/sda1 on /
           /dev/sdb6 on /mntX
           /dev/sdb7 on /mntY
           /dev/sda1 on /home/cecilia
           /dev/sdb6 on /home/cecilia/mntX
           /dev/sdb7 on /home/cecilia/mntY
           /dev/sda1 on /home/henry
           /dev/sdb6 on /home/henry/mntX
           /dev/sdb7 on /home/henry/mntY
           /dev/sda1 on /home/henry/home/cecilia
           /dev/sdb6 on /home/henry/home/cecilia/mntX
           /dev/sdb7 on /home/henry/home/cecilia/mntY
           /dev/sda1 on /home/otto
           /dev/sdb6 on /home/otto/mntX
           /dev/sdb7 on /home/otto/mntY
           /dev/sda1 on /home/otto/home/cecilia
           /dev/sdb6 on /home/otto/home/cecilia/mntX
           /dev/sdb7 on /home/otto/home/cecilia/mntY
           /dev/sda1 on /home/otto/home/henry
           /dev/sdb6 on /home/otto/home/henry/mntX
           /dev/sdb7 on /home/otto/home/henry/mntY
           /dev/sda1 on /home/otto/home/henry/home/cecilia
           /dev/sdb6 on /home/otto/home/henry/home/cecilia/mntX
           /dev/sdb7 on /home/otto/home/henry/home/cecilia/mntY

       The mount explosion problem in the above scenario can be avoided by
       making each of the new mounts unbindable.  The effect of doing this
       is that recursive mounts of the root directory will not replicate the
       unbindable mounts.  We make such a mount for the first user:

           # <b>mount --rbind --make-unbindable / /home/cecilia</b>

       Before going further, we show that unbindable mounts are indeed
       unbindable:

           # <b>mkdir /mntZ</b>
           # <b>mount --bind /home/cecilia /mntZ</b>
           mount: wrong fs type, bad option, bad superblock on /home/cecilia,
                  missing codepage or helper program, or other error

                  In some cases useful info is found in syslog - try
                  dmesg | tail or so.

       Now we create unbindable recursive bind mounts for the other two
       users:

           # <b>mount --rbind --make-unbindable / /home/henry</b>
           # <b>mount --rbind --make-unbindable / /home/otto</b>

       Upon examining the list of mount points, we see there has been no
       explosion of mount points, because the unbindable mounts were not
       replicated under each user's directory:

           # <b>mount | awk '{print $1, $2, $3}'</b>
           /dev/sda1 on /
           /dev/sdb6 on /mntX
           /dev/sdb7 on /mntY
           /dev/sda1 on /home/cecilia
           /dev/sdb6 on /home/cecilia/mntX
           /dev/sdb7 on /home/cecilia/mntY
           /dev/sda1 on /home/henry
           /dev/sdb6 on /home/henry/mntX
           /dev/sdb7 on /home/henry/mntY
           /dev/sda1 on /home/otto
           /dev/sdb6 on /home/otto/mntX
           /dev/sdb7 on /home/otto/mntY

   <b>Propagation type transitions</b>
       The following table shows the effect that applying a new propagation
       type (i.e., <i>mount --make-xxxx</i>) has on the existing propagation type
       of a mount point.  The rows correspond to existing propagation types,
       and the columns are the new propagation settings.  For reasons of
       space, "private" is abbreviated as "priv" and "unbindable" as
       "unbind".

                     <b>make-shared   make-slave      make-priv  make-unbind</b>

       <b>shared        </b>shared        slave/priv [1]  priv       unbind
       <b>slave         </b>slave+shared  slave [2]       priv       unbind
       <b>slave+shared  </b>slave+shared  slave           priv       unbind
       <b>private       </b>shared        priv [2]        priv       unbind
       <b>unbindable    </b>shared        unbind [2]      priv       unbind

       Note the following details to the table:

       [1] If a shared mount is the only mount in its peer group, making it
           a slave automatically makes it private.

       [2] Slaving a nonshared mount has no effect on the mount.

   <b>Bind (MS_BIND) semantics</b>
       Suppose that the following command is performed:

           mount --bind A/a B/b

       Here, <i>A</i> is the source mount point, <i>B</i> is the destination mount point,
       <i>a</i> is a subdirectory path under the mount point <i>A</i>, and <i>b</i> is a
       subdirectory path under the mount point <i>B</i>.  The propagation type of
       the resulting mount, <i>B/b</i>, depends on the propagation types of the
       mount points <i>A</i> and <i>B</i>, and is summarized in the following table.

                                    <b>source(A)</b>
                            <b>shared  private    slave         unbind</b>
       ───────────────────────────────────────────────────────────────
       <b>dest(B)  shared    | </b>shared  shared     slave+shared  invalid
                <b>nonshared | </b>shared  private    slave         invalid

       Note that a recursive bind of a subtree follows the same semantics as
       for a bind operation on each mount in the subtree.  (Unbindable
       mounts are automatically pruned at the target mount point.)

       For further details, see <i>Documentation/filesystems/sharedsubtree.txt</i>
       in the kernel source tree.

   <b>Move (MS_MOVE) semantics</b>
       Suppose that the following command is performed:

           mount --move A B/b

       Here, <i>A</i> is the source mount point, <i>B</i> is the destination mount point,
       and <i>b</i> is a subdirectory path under the mount point <i>B</i>.  The
       propagation type of the resulting mount, <i>B/b</i>, depends on the
       propagation types of the mount points <i>A</i> and <i>B</i>, and is summarized in
       the following table.

                                    <b>source(A)</b>
                            <b>shared  private    slave         unbind</b>
       ──────────────────────────────────────────────────────────────────
       <b>dest(B)  shared    | </b>shared  shared     slave+shared  invalid
                <b>nonshared | </b>shared  private    slave         unbindable

       Note: moving a mount that resides under a shared mount is invalid.

       For further details, see <i>Documentation/filesystems/sharedsubtree.txt</i>
       in the kernel source tree.

   <b>Mount semantics</b>
       Suppose that we use the following command to create a mount point:

           mount device B/b

       Here, <i>B</i> is the destination mount point, and <i>b</i> is a subdirectory path
       under the mount point <i>B</i>.  The propagation type of the resulting
       mount, <i>B/b</i>, follows the same rules as for a bind mount, where the
       propagation type of the source mount is considered always to be
       private.

   <b>Unmount semantics</b>
       Suppose that we use the following command to tear down a mount point:

           unmount A

       Here, <i>A</i> is a mount point on <i>B/b</i>, where <i>B</i> is the parent mount and <i>b</i> is
       a subdirectory path under the mount point <i>B</i>.  If <b>B </b>is shared, then
       all most-recently-mounted mounts at <i>b</i> on mounts that receive
       propagation from mount <i>B</i> and do not have submounts under them are
       unmounted.

   <b>The /proc/[pid]/mountinfo propagate_from tag</b>
       The <i>propagate_from:X</i> tag is shown in the optional fields of a
       <i>/proc/[pid]/mountinfo</i> record in cases where a process can't see a
       slave's immediate master (i.e., the pathname of the master is not
       reachable from the filesystem root directory) and so cannot determine
       the chain of propagation between the mounts it can see.

       In the following example, we first create a two-link master-slave
       chain between the mounts <i>/mnt</i>, <i>/tmp/etc</i>, and <i>/mnt/tmp/etc</i>.  Then the
       <a href="../man1/chroot.1.html">chroot(1)</a> command is used to make the <i>/tmp/etc</i> mount point
       unreachable from the root directory, creating a situation where the
       master of <i>/mnt/tmp/etc</i> is not reachable from the (new) root directory
       of the process.

       First, we bind mount the root directory onto <i>/mnt</i> and then bind mount
       <i>/proc</i> at <i>/mnt/proc</i> so that after the later <a href="../man1/chroot.1.html">chroot(1)</a> the <a href="../man5/proc.5.html">proc(5)</a>
       filesystem remains visible at the correct location in the chroot-ed
       environment.

           # <b>mkdir -p /mnt/proc</b>
           # <b>mount --bind / /mnt</b>
           # <b>mount --bind /proc /mnt/proc</b>

       Next, we ensure that the <i>/mnt</i> mount is a shared mount in a new peer
       group (with no peers):

           # <b>mount --make-private /mnt  </b># Isolate from any previous peer group
           # <b>mount --make-shared /mnt</b>
           # <b>cat /proc/self/mountinfo | grep '/mnt' | sed 's/ - .*//'</b>
           239 61 8:2 / /mnt ... shared:102
           248 239 0:4 / /mnt/proc ... shared:5

       Next, we bind mount <i>/mnt/etc</i> onto <i>/tmp/etc</i>:

           # <b>mkdir -p /tmp/etc</b>
           # <b>mount --bind /mnt/etc /tmp/etc</b>
           # <b>cat /proc/self/mountinfo | egrep '/mnt|/tmp/' | sed 's/ - .*//'</b>
           239 61 8:2 / /mnt ... shared:102
           248 239 0:4 / /mnt/proc ... shared:5
           267 40 8:2 /etc /tmp/etc ... shared:102

       Initially, these two mount points are in the same peer group, but we
       then make the <i>/tmp/etc</i> a slave of <i>/mnt/etc</i>, and then make <i>/tmp/etc</i>
       shared as well, so that it can propagate events to the next slave in
       the chain:

           # <b>mount --make-slave /tmp/etc</b>
           # <b>mount --make-shared /tmp/etc</b>
           # <b>cat /proc/self/mountinfo | egrep '/mnt|/tmp/' | sed 's/ - .*//'</b>
           239 61 8:2 / /mnt ... shared:102
           248 239 0:4 / /mnt/proc ... shared:5
           267 40 8:2 /etc /tmp/etc ... shared:105 master:102

       Then we bind mount <i>/tmp/etc</i> onto <i>/mnt/tmp/etc</i>.  Again, the two mount
       points are initially in the same peer group, but we then make
       <i>/mnt/tmp/etc</i> a slave of <i>/tmp/etc</i>:

           # <b>mkdir -p /mnt/tmp/etc</b>
           # <b>mount --bind /tmp/etc /mnt/tmp/etc</b>
           # <b>mount --make-slave /mnt/tmp/etc</b>
           # <b>cat /proc/self/mountinfo | egrep '/mnt|/tmp/' | sed 's/ - .*//'</b>
           239 61 8:2 / /mnt ... shared:102
           248 239 0:4 / /mnt/proc ... shared:5
           267 40 8:2 /etc /tmp/etc ... shared:105 master:102
           273 239 8:2 /etc /mnt/tmp/etc ... master:105

       From the above, we see that <i>/mnt</i> is the master of the slave <i>/tmp/etc</i>,
       which in turn is the master of the slave <i>/mnt/tmp/etc</i>.

       We then <a href="../man1/chroot.1.html">chroot(1)</a> to the <i>/mnt</i> directory, which renders the mount with
       ID 267 unreachable from the (new) root directory:

           # <b>chroot /mnt</b>

       When we examine the state of the mounts inside the chroot-ed
       environment, we see the following:

           # <b>cat /proc/self/mountinfo | sed 's/ - .*//'</b>
           239 61 8:2 / / ... shared:102
           248 239 0:4 / /proc ... shared:5
           273 239 8:2 /etc /tmp/etc ... master:105 propagate_from:102

       Above, we see that the mount with ID 273 is a slave whose master is
       the peer group 105.  The mount point for that master is unreachable,
       and so a <i>propagate_from</i> tag is displayed, indicating that the closest
       dominant peer group (i.e., the nearest reachable mount in the slave
       chain) is the peer group with the ID 102 (corresponding to the <i>/mnt</i>
       mount point before the <a href="../man1/chroot.1.html">chroot(1)</a> was performed.
</pre>
<h2><a id="VERSIONS" href="#VERSIONS"></a>VERSIONS  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       Mount namespaces first appeared in Linux 2.4.19.
</pre>
<h2><a id="CONFORMING_TO" href="#CONFORMING_TO"></a>CONFORMING TO  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       Namespaces are a Linux-specific feature.
</pre>
<h2><a id="NOTES" href="#NOTES"></a>NOTES  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       The propagation type assigned to a new mount point depends on the
       propagation type of the parent directory.  If the mount point has a
       parent (i.e., it is a non-root mount point) and the propagation type
       of the parent is <b>MS_SHARED</b>, then the propagation type of the new
       mount is also <b>MS_SHARED</b>.  Otherwise, the propagation type of the new
       mount is <b>MS_PRIVATE</b>.  But see also NOTES.

       Notwithstanding the fact that the default propagation type for new
       mount points is in many cases <b>MS_PRIVATE</b>, <b>MS_SHARED </b>is typically more
       useful.  For this reason, <a href="../man1/systemd.1.html">systemd(1)</a> automatically remounts all mount
       points as <b>MS_SHARED </b>on system startup.  Thus, on most modern systems,
       the default propagation type is in practice <b>MS_SHARED</b>.

       Since, when one uses <a href="../man1/unshare.1.html">unshare(1)</a> to create a mount namespace, the goal
       is commonly to provide full isolation of the mount points in the new
       namespace, <a href="../man1/unshare.1.html">unshare(1)</a> (since <i>util-linux</i> version 2.27) in turn
       reverses the step performed by <a href="../man1/systemd.1.html">systemd(1)</a>, by making all mount points
       private in the new namespace.  That is, <a href="../man1/unshare.1.html">unshare(1)</a> performs the
       equivalent of the following in the new mount namespace:

           mount --make-rprivate /

       To prevent this, one can use the <i>--propagation unchanged</i> option to
       <a href="../man1/unshare.1.html">unshare(1)</a>.

       For a discussion of propagation types when moving mounts (<b>MS_MOVE</b>)
       and creating bind mounts (<b>MS_BIND</b>), see
       <i>Documentation/filesystems/sharedsubtree.txt</i>.
</pre>
<h2><a id="SEE_ALSO" href="#SEE_ALSO"></a>SEE ALSO  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       <a href="../man1/unshare.1.html">unshare(1)</a>, <a href="../man2/clone.2.html">clone(2)</a>, <a href="../man2/mount.2.html">mount(2)</a>, <a href="../man2/setns.2.html">setns(2)</a>, <a href="../man2/umount.2.html">umount(2)</a>, <a href="../man2/unshare.2.html">unshare(2)</a>,
       <a href="../man5/proc.5.html">proc(5)</a>, <a href="namespaces.7.html">namespaces(7)</a>, <a href="user_namespaces.7.html">user_namespaces(7)</a>

       <i>Documentation/filesystems/sharedsubtree.txt</i> in the kernel source
       tree.
</pre>
<h2><a id="COLOPHON" href="#COLOPHON"></a>COLOPHON  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       This page is part of release 4.12 of the Linux <i>man-pages</i> project.  A
       description of the project, information about reporting bugs, and the
       latest version of this page, can be found at
       <a href="https://www.kernel.org/doc/man-pages/">https://www.kernel.org/doc/man-pages/</a>.

<span class="footline">Linux                            2016-12-12              MOUNT_NAMESPACES(7)</span>
</pre>

<hr class="end-man-text" />
<p>Pages that refer to this page: 
    <a href="../man1/nsenter.1.html">nsenter(1)</a>,&nbsp; 
    <a href="../man1/unshare.1.html">unshare(1)</a>,&nbsp; 
    <a href="../man2/clone.2.html">clone(2)</a>,&nbsp; 
    <a href="../man2/mount.2.html">mount(2)</a>,&nbsp; 
    <a href="../man2/umount.2.html">umount(2)</a>,&nbsp; 
    <a href="../man2/unshare.2.html">unshare(2)</a>,&nbsp; 
    <a href="../man5/core.5.html">core(5)</a>,&nbsp; 
    <a href="../man5/proc.5.html">proc(5)</a>,&nbsp; 
    <a href="namespaces.7.html">namespaces(7)</a>
</p>
<hr/>

<p class="page-copyright"><a href="mount_namespaces.7.license.html">Copyright and license for this manual page</a></p> 
<hr class="start-footer" />

<div class="footer"> 

<table class="colophon-table">
    <tr>
    <td class="pub-info">
        <p>
            HTML rendering created 2017-07-13
            by <a href="http://man7.org/mtk/index.html">Michael Kerrisk</a>, 
            author of 
            <a href="http://man7.org/tlpi/"><em>The Linux Programming Interface</em></a>, 
            maintainer of the 
            <a href="https://www.kernel.org/doc/man-pages/">Linux <em>man-pages</em> project</a>.
        </p>
        <p>
            For details of in-depth
            <strong>Linux/UNIX system programming training courses</strong>
            that I teach, look <a href="http://man7.org/training/">here</a>.
        </p>
        <p>
            Hosting by <a href="http://www.jambit.com/index_en.html">jambit GmbH</a>.
        </p>
        <p>
            <a href="http://validator.w3.org/check?uri=referer">
            <img src="http://www.w3.org/Icons/valid-xhtml11"
                alt="Valid XHTML 1.1" height="31" width="88" />
            </a>
        </p>
    </td>
    <td class="colophon-divider">
    </td>
    <td class="tlpi-cover">
        <a href="http://man7.org/tlpi/"><img src="../../../tlpi/cover/TLPI-front-cover-vsmall.png" alt="Cover of TLPI" /></a>
    </td>
    </tr>
</table>

</div>

<hr class="end-footer" />



<!--BEGIN-SITETRACKING-->
<!-- SITETRACKING.man7.org_linux_man-pages -->

<!-- Start of StatCounter Code (xhtml) -->

<script type="text/javascript">
//<![CDATA[
var sc_project=7422636; 
var sc_invisible=1; 
var sc_security="9b6714ff"; 
//]]>
</script>
<script type="text/javascript"
src="../../../../www.statcounter.com/counter/counter_xhtml.js"></script>
<noscript><div class="statcounter"><a title="website
statistics" href="http://statcounter.com/"
class="statcounter"><img class="statcounter"
src="http://c.statcounter.com/7422636/0/9b6714ff/1/"
alt="website statistics" /></a></div></noscript>

<!-- End of StatCounter Code -->


<!-- Start of Google Analytics Code -->

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-9830363-8']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<!-- End of Google Analytics Code -->

<!--END-SITETRACKING-->

</body>
</html>
