
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
        "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
    <link rel="stylesheet" type="text/css" href="../../../style.css" title="style" />
    <link rel="stylesheet" type="text/css" href="../style.css" title="style" />
    <meta http-equiv="content-type" content="text/html;charset=utf-8" />

    <title>signal(7) - Linux manual page</title>
</head>

<body>

<div class="page-top"><a id="top_of_page"></a></div>
<!--%%%TOP_BAR%%%-->
    <div class="nav-bar">
        <table class="nav-table">
            <tr>
                <td class="nav-cell">
                    <p class="nav-text">
                        <a href="http://man7.org/index.html">man7.org</a> &gt; Linux &gt; <a href="../index.html">man-pages</a>
                    </p>
                </td>
                <td class="training-cell">
                    <p class="training-text"><a class="training-link" href="http://man7.org/training/">Linux/UNIX system programming training</a></p>
                </td>
            </tr>
        </table>
    </div>

<hr class="nav-end" />

<!--%%%PAGE_START%%%-->


<table class="sec-table">
<tr>
    <td>
        <p class="section-dir">
<a href="#NAME">NAME</a> | <a href="#DESCRIPTION">DESCRIPTION</a> | <a href="#CONFORMING_TO">CONFORMING&nbsp;TO</a> | <a href="#NOTES">NOTES</a> | <a href="#SEE_ALSO">SEE&nbsp;ALSO</a> | <a href="#COLOPHON">COLOPHON</a>
        </p>
    </td>
    <td class="search-box">
        <div class="man-search-box">

            <form method="get" action="http://www.google.com/search">
                <fieldset class="man-search">
                    <input type="text" name="q" size="10" maxlength="255" value="" />
                    <input type="hidden" name="sitesearch" value="man7.org/linux/man-pages" />
                    <input type="submit" name="sa" value="Search online pages" />
                </fieldset>
            </form>

        </div>
    </td>
    <td> </td>
</tr>
</table>

<pre>
<span class="headline">SIGNAL(7)                 Linux Programmer's Manual                SIGNAL(7)</span>
</pre>
<h2><a id="NAME" href="#NAME"></a>NAME  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       signal - overview of signals
</pre>
<h2><a id="DESCRIPTION" href="#DESCRIPTION"></a>DESCRIPTION  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       Linux supports both POSIX reliable signals (hereinafter "standard
       signals") and POSIX real-time signals.

   <b>Signal dispositions</b>
       Each signal has a current <i>disposition</i>, which determines how the
       process behaves when it is delivered the signal.

       The entries in the "Action" column of the tables below specify the
       default disposition for each signal, as follows:

       Term   Default action is to terminate the process.

       Ign    Default action is to ignore the signal.

       Core   Default action is to terminate the process and dump core (see
              <a href="../man5/core.5.html">core(5)</a>).

       Stop   Default action is to stop the process.

       Cont   Default action is to continue the process if it is currently
              stopped.

       A process can change the disposition of a signal using <a href="../man2/sigaction.2.html">sigaction(2)</a>
       or <a href="../man2/signal.2.html">signal(2)</a>.  (The latter is less portable when establishing a
       signal handler; see <a href="../man2/signal.2.html">signal(2)</a> for details.)  Using these system
       calls, a process can elect one of the following behaviors to occur on
       delivery of the signal: perform the default action; ignore the
       signal; or catch the signal with a <i>signal handler</i>, a programmer-
       defined function that is automatically invoked when the signal is
       delivered.  (By default, the signal handler is invoked on the normal
       process stack.  It is possible to arrange that the signal handler
       uses an alternate stack; see <a href="../man2/sigaltstack.2.html">sigaltstack(2)</a> for a discussion of how
       to do this and when it might be useful.)

       The signal disposition is a per-process attribute: in a multithreaded
       application, the disposition of a particular signal is the same for
       all threads.

       A child created via <a href="../man2/fork.2.html">fork(2)</a> inherits a copy of its parent's signal
       dispositions.  During an <a href="../man2/execve.2.html">execve(2)</a>, the dispositions of handled
       signals are reset to the default; the dispositions of ignored signals
       are left unchanged.

   <b>Sending a signal</b>
       The following system calls and library functions allow the caller to
       send a signal:

       <a href="../man3/raise.3.html">raise(3)</a>        Sends a signal to the calling thread.

       <a href="../man2/kill.2.html">kill(2)</a>         Sends a signal to a specified process, to all members
                       of a specified process group, or to all processes on
                       the system.

       <a href="../man3/killpg.3.html">killpg(3)</a>       Sends a signal to all of the members of a specified
                       process group.

       <a href="../man3/pthread_kill.3.html">pthread_kill(3)</a> Sends a signal to a specified POSIX thread in the
                       same process as the caller.

       <a href="../man2/tgkill.2.html">tgkill(2)</a>       Sends a signal to a specified thread within a
                       specific process.  (This is the system call used to
                       implement <a href="../man3/pthread_kill.3.html">pthread_kill(3)</a>.)

       <a href="../man3/sigqueue.3.html">sigqueue(3)</a>     Sends a real-time signal with accompanying data to a
                       specified process.

   <b>Waiting for a signal to be caught</b>
       The following system calls suspend execution of the calling process
       or thread until a signal is caught (or an unhandled signal terminates
       the process):

       <a href="../man2/pause.2.html">pause(2)</a>        Suspends execution until any signal is caught.

       <a href="../man2/sigsuspend.2.html">sigsuspend(2)</a>   Temporarily changes the signal mask (see below) and
                       suspends execution until one of the unmasked signals
                       is caught.

   <b>Synchronously accepting a signal</b>
       Rather than asynchronously catching a signal via a signal handler, it
       is possible to synchronously accept the signal, that is, to block
       execution until the signal is delivered, at which point the kernel
       returns information about the signal to the caller.  There are two
       general ways to do this:

       * <a href="../man2/sigwaitinfo.2.html">sigwaitinfo(2)</a>, <a href="../man2/sigtimedwait.2.html">sigtimedwait(2)</a>, and <a href="../man3/sigwait.3.html">sigwait(3)</a> suspend execution
         until one of the signals in a specified set is delivered.  Each of
         these calls returns information about the delivered signal.

       * <a href="../man2/signalfd.2.html">signalfd(2)</a> returns a file descriptor that can be used to read
         information about signals that are delivered to the caller.  Each
         <a href="../man2/read.2.html">read(2)</a> from this file descriptor blocks until one of the signals
         in the set specified in the <a href="../man2/signalfd.2.html">signalfd(2)</a> call is delivered to the
         caller.  The buffer returned by <a href="../man2/read.2.html">read(2)</a> contains a structure
         describing the signal.

   <b>Signal mask and pending signals</b>
       A signal may be <i>blocked</i>, which means that it will not be delivered
       until it is later unblocked.  Between the time when it is generated
       and when it is delivered a signal is said to be <i>pending</i>.

       Each thread in a process has an independent <i>signal mask</i>, which
       indicates the set of signals that the thread is currently blocking.
       A thread can manipulate its signal mask using <a href="../man3/pthread_sigmask.3.html">pthread_sigmask(3)</a>.  In
       a traditional single-threaded application, <a href="../man2/sigprocmask.2.html">sigprocmask(2)</a> can be used
       to manipulate the signal mask.

       A child created via <a href="../man2/fork.2.html">fork(2)</a> inherits a copy of its parent's signal
       mask; the signal mask is preserved across <a href="../man2/execve.2.html">execve(2)</a>.

       A signal may be generated (and thus pending) for a process as a whole
       (e.g., when sent using <a href="../man2/kill.2.html">kill(2)</a>) or for a specific thread (e.g.,
       certain signals, such as <b>SIGSEGV </b>and <b>SIGFPE</b>, generated as a
       consequence of executing a specific machine-language instruction are
       thread directed, as are signals targeted at a specific thread using
       <a href="../man3/pthread_kill.3.html">pthread_kill(3)</a>).  A process-directed signal may be delivered to any
       one of the threads that does not currently have the signal blocked.
       If more than one of the threads has the signal unblocked, then the
       kernel chooses an arbitrary thread to which to deliver the signal.

       A thread can obtain the set of signals that it currently has pending
       using <a href="../man2/sigpending.2.html">sigpending(2)</a>.  This set will consist of the union of the set
       of pending process-directed signals and the set of signals pending
       for the calling thread.

       A child created via <a href="../man2/fork.2.html">fork(2)</a> initially has an empty pending signal
       set; the pending signal set is preserved across an <a href="../man2/execve.2.html">execve(2)</a>.

   <b>Standard signals</b>
       Linux supports the standard signals listed below.  Several signal
       numbers are architecture-dependent, as indicated in the "Value"
       column.  (Where three values are given, the first one is usually
       valid for alpha and sparc, the middle one for x86, arm, and most
       other architectures, and the last one for mips.  (Values for parisc
       are <i>not</i> shown; see the Linux kernel source for signal numbering on
       that architecture.)  A dash (-) denotes that a signal is absent on
       the corresponding architecture.

       First the signals described in the original POSIX.1-1990 standard.

       Signal     Value     Action   Comment
       ──────────────────────────────────────────────────────────────────────
       <b>SIGHUP        </b>1       Term    Hangup detected on controlling terminal
                                     or death of controlling process
       <b>SIGINT        </b>2       Term    Interrupt from keyboard
       <b>SIGQUIT       </b>3       Core    Quit from keyboard
       <b>SIGILL        </b>4       Core    Illegal Instruction
       <b>SIGABRT       </b>6       Core    Abort signal from <a href="../man3/abort.3.html">abort(3)</a>
       <b>SIGFPE        </b>8       Core    Floating-point exception
       <b>SIGKILL       </b>9       Term    Kill signal
       <b>SIGSEGV      </b>11       Core    Invalid memory reference
       <b>SIGPIPE      </b>13       Term    Broken pipe: write to pipe with no
                                     readers; see <a href="pipe.7.html">pipe(7)</a>
       <b>SIGALRM      </b>14       Term    Timer signal from <a href="../man2/alarm.2.html">alarm(2)</a>
       <b>SIGTERM      </b>15       Term    Termination signal
       <b>SIGUSR1   </b>30,10,16    Term    User-defined signal 1
       <b>SIGUSR2   </b>31,12,17    Term    User-defined signal 2
       <b>SIGCHLD   </b>20,17,18    Ign     Child stopped or terminated
       <b>SIGCONT   </b>19,18,25    Cont    Continue if stopped
       <b>SIGSTOP   </b>17,19,23    Stop    Stop process
       <b>SIGTSTP   </b>18,20,24    Stop    Stop typed at terminal
       <b>SIGTTIN   </b>21,21,26    Stop    Terminal input for background process
       <b>SIGTTOU   </b>22,22,27    Stop    Terminal output for background process

       The signals <b>SIGKILL </b>and <b>SIGSTOP </b>cannot be caught, blocked, or
       ignored.

       Next the signals not in the POSIX.1-1990 standard but described in
       SUSv2 and POSIX.1-2001.

       Signal       Value     Action   Comment
       ────────────────────────────────────────────────────────────────────
       <b>SIGBUS      </b>10,7,10     Core    Bus error (bad memory access)
       <b>SIGPOLL                 </b>Term    Pollable event (Sys V).
                                       Synonym for <b>SIGIO</b>
       <b>SIGPROF     </b>27,27,29    Term    Profiling timer expired
       <b>SIGSYS      </b>12,31,12    Core    Bad system call (SVr4);
                                       see also <a href="../man2/seccomp.2.html">seccomp(2)</a>
       <b>SIGTRAP        </b>5        Core    Trace/breakpoint trap
       <b>SIGURG      </b>16,23,21    Ign     Urgent condition on socket (4.2BSD)
       <b>SIGVTALRM   </b>26,26,28    Term    Virtual alarm clock (4.2BSD)
       <b>SIGXCPU     </b>24,24,30    Core    CPU time limit exceeded (4.2BSD);
                                       see <a href="../man2/setrlimit.2.html">setrlimit(2)</a>
       <b>SIGXFSZ     </b>25,25,31    Core    File size limit exceeded (4.2BSD);
                                       see <a href="../man2/setrlimit.2.html">setrlimit(2)</a>

       Up to and including Linux 2.2, the default behavior for <b>SIGSYS</b>,
       <b>SIGXCPU</b>, <b>SIGXFSZ</b>, and (on architectures other than SPARC and MIPS)
       <b>SIGBUS </b>was to terminate the process (without a core dump).  (On some
       other UNIX systems the default action for <b>SIGXCPU </b>and <b>SIGXFSZ </b>is to
       terminate the process without a core dump.)  Linux 2.4 conforms to
       the POSIX.1-2001 requirements for these signals, terminating the
       process with a core dump.

       Next various other signals.

       Signal       Value     Action   Comment
       ────────────────────────────────────────────────────────────────────
       <b>SIGIOT         </b>6        Core    IOT trap. A synonym for <b>SIGABRT</b>
       <b>SIGEMT       </b>7,-,7      Term    Emulator trap
       <b>SIGSTKFLT    </b>-,16,-     Term    Stack fault on coprocessor (unused)
       <b>SIGIO       </b>23,29,22    Term    I/O now possible (4.2BSD)
       <b>SIGCLD       </b>-,-,18     Ign     A synonym for <b>SIGCHLD</b>
       <b>SIGPWR      </b>29,30,19    Term    Power failure (System V)
       <b>SIGINFO      </b>29,-,-             A synonym for <b>SIGPWR</b>
       <b>SIGLOST      </b>-,-,-      Term    File lock lost (unused)
       <b>SIGWINCH    </b>28,28,20    Ign     Window resize signal (4.3BSD, Sun)
       <b>SIGUNUSED    </b>-,31,-     Core    Synonymous with <b>SIGSYS</b>

       (Signal 29 is <b>SIGINFO </b>/ <b>SIGPWR </b>on an alpha but <b>SIGLOST </b>on a sparc.)

       <b>SIGEMT </b>is not specified in POSIX.1-2001, but nevertheless appears on
       most other UNIX systems, where its default action is typically to
       terminate the process with a core dump.

       <b>SIGPWR </b>(which is not specified in POSIX.1-2001) is typically ignored
       by default on those other UNIX systems where it appears.

       <b>SIGIO </b>(which is not specified in POSIX.1-2001) is ignored by default
       on several other UNIX systems.

       Where defined, <b>SIGUNUSED </b>is synonymous with <b>SIGSYS </b>on most
       architectures.

   <b>Real-time signals</b>
       Starting with version 2.2, Linux supports real-time signals as
       originally defined in the POSIX.1b real-time extensions (and now
       included in POSIX.1-2001).  The range of supported real-time signals
       is defined by the macros <b>SIGRTMIN </b>and <b>SIGRTMAX</b>.  POSIX.1-2001
       requires that an implementation support at least <b>_POSIX_RTSIG_MAX </b>(8)
       real-time signals.

       The Linux kernel supports a range of 33 different real-time signals,
       numbered 32 to 64.  However, the glibc POSIX threads implementation
       internally uses two (for NPTL) or three (for LinuxThreads) real-time
       signals (see <a href="pthreads.7.html">pthreads(7)</a>), and adjusts the value of <b>SIGRTMIN </b>suitably
       (to 34 or 35).  Because the range of available real-time signals
       varies according to the glibc threading implementation (and this
       variation can occur at run time according to the available kernel and
       glibc), and indeed the range of real-time signals varies across UNIX
       systems, programs should <i>never refer to real-time signals using hard-</i>
       <i>coded numbers</i>, but instead should always refer to real-time signals
       using the notation <b>SIGRTMIN</b>+n, and include suitable (run-time) checks
       that <b>SIGRTMIN</b>+n does not exceed <b>SIGRTMAX</b>.

       Unlike standard signals, real-time signals have no predefined
       meanings: the entire set of real-time signals can be used for
       application-defined purposes.

       The default action for an unhandled real-time signal is to terminate
       the receiving process.

       Real-time signals are distinguished by the following:

       1.  Multiple instances of real-time signals can be queued.  By
           contrast, if multiple instances of a standard signal are
           delivered while that signal is currently blocked, then only one
           instance is queued.

       2.  If the signal is sent using <a href="../man3/sigqueue.3.html">sigqueue(3)</a>, an accompanying value
           (either an integer or a pointer) can be sent with the signal.  If
           the receiving process establishes a handler for this signal using
           the <b>SA_SIGINFO </b>flag to <a href="../man2/sigaction.2.html">sigaction(2)</a>, then it can obtain this data
           via the <i>si_value</i> field of the <i>siginfo_t</i> structure passed as the
           second argument to the handler.  Furthermore, the <i>si_pid</i> and
           <i>si_uid</i> fields of this structure can be used to obtain the PID and
           real user ID of the process sending the signal.

       3.  Real-time signals are delivered in a guaranteed order.  Multiple
           real-time signals of the same type are delivered in the order
           they were sent.  If different real-time signals are sent to a
           process, they are delivered starting with the lowest-numbered
           signal.  (I.e., low-numbered signals have highest priority.)  By
           contrast, if multiple standard signals are pending for a process,
           the order in which they are delivered is unspecified.

       If both standard and real-time signals are pending for a process,
       POSIX leaves it unspecified which is delivered first.  Linux, like
       many other implementations, gives priority to standard signals in
       this case.

       According to POSIX, an implementation should permit at least
       <b>_POSIX_SIGQUEUE_MAX </b>(32) real-time signals to be queued to a process.
       However, Linux does things differently.  In kernels up to and
       including 2.6.7, Linux imposes a system-wide limit on the number of
       queued real-time signals for all processes.  This limit can be viewed
       and (with privilege) changed via the <i>/proc/sys/kernel/rtsig-max</i> file.
       A related file, <i>/proc/sys/kernel/rtsig-nr</i>, can be used to find out
       how many real-time signals are currently queued.  In Linux 2.6.8,
       these <i>/proc</i> interfaces were replaced by the <b>RLIMIT_SIGPENDING</b>
       resource limit, which specifies a per-user limit for queued signals;
       see <a href="../man2/setrlimit.2.html">setrlimit(2)</a> for further details.

       The addition of real-time signals required the widening of the signal
       set structure (<i>sigset_t</i>) from 32 to 64 bits.  Consequently, various
       system calls were superseded by new system calls that supported the
       larger signal sets.  The old and new system calls are as follows:

       <b>Linux 2.0 and earlier   Linux 2.2 and later</b>
       <a href="../man2/sigaction.2.html">sigaction(2)</a>            <a href="../man2/rt_sigaction.2.html">rt_sigaction(2)</a>
       <a href="../man2/sigpending.2.html">sigpending(2)</a>           <a href="../man2/rt_sigpending.2.html">rt_sigpending(2)</a>
       <a href="../man2/sigprocmask.2.html">sigprocmask(2)</a>          <a href="../man2/rt_sigprocmask.2.html">rt_sigprocmask(2)</a>
       <a href="../man2/sigreturn.2.html">sigreturn(2)</a>            <a href="../man2/rt_sigreturn.2.html">rt_sigreturn(2)</a>
       <a href="../man2/sigsuspend.2.html">sigsuspend(2)</a>           <a href="../man2/rt_sigsuspend.2.html">rt_sigsuspend(2)</a>
       <a href="../man2/sigtimedwait.2.html">sigtimedwait(2)</a>         <a href="../man2/rt_sigtimedwait.2.html">rt_sigtimedwait(2)</a>

   <b>Interruption of system calls and library functions by signal handlers</b>
       If a signal handler is invoked while a system call or library
       function call is blocked, then either:

       * the call is automatically restarted after the signal handler
         returns; or

       * the call fails with the error <b>EINTR</b>.

       Which of these two behaviors occurs depends on the interface and
       whether or not the signal handler was established using the
       <b>SA_RESTART </b>flag (see <a href="../man2/sigaction.2.html">sigaction(2)</a>).  The details vary across UNIX
       systems; below, the details for Linux.

       If a blocked call to one of the following interfaces is interrupted
       by a signal handler, then the call will be automatically restarted
       after the signal handler returns if the <b>SA_RESTART </b>flag was used;
       otherwise the call will fail with the error <b>EINTR</b>:

       * <a href="../man2/read.2.html">read(2)</a>, <a href="../man2/readv.2.html">readv(2)</a>, <a href="../man2/write.2.html">write(2)</a>, <a href="../man2/writev.2.html">writev(2)</a>, and <a href="../man2/ioctl.2.html">ioctl(2)</a> calls on
         "slow" devices.  A "slow" device is one where the I/O call may
         block for an indefinite time, for example, a terminal, pipe, or
         socket.  If an I/O call on a slow device has already transferred
         some data by the time it is interrupted by a signal handler, then
         the call will return a success status (normally, the number of
         bytes transferred).  Note that a (local) disk is not a slow device
         according to this definition; I/O operations on disk devices are
         not interrupted by signals.

       * <a href="../man2/open.2.html">open(2)</a>, if it can block (e.g., when opening a FIFO; see <a href="fifo.7.html">fifo(7)</a>).

       * <a href="../man2/wait.2.html">wait(2)</a>, <a href="../man2/wait3.2.html">wait3(2)</a>, <a href="../man2/wait4.2.html">wait4(2)</a>, <a href="../man2/waitid.2.html">waitid(2)</a>, and <a href="../man2/waitpid.2.html">waitpid(2)</a>.

       * Socket interfaces: <a href="../man2/accept.2.html">accept(2)</a>, <a href="../man2/connect.2.html">connect(2)</a>, <a href="../man2/recv.2.html">recv(2)</a>, <a href="../man2/recvfrom.2.html">recvfrom(2)</a>,
         <a href="../man2/recvmmsg.2.html">recvmmsg(2)</a>, <a href="../man2/recvmsg.2.html">recvmsg(2)</a>, <a href="../man2/send.2.html">send(2)</a>, <a href="../man2/sendto.2.html">sendto(2)</a>, and <a href="../man2/sendmsg.2.html">sendmsg(2)</a>, unless
         a timeout has been set on the socket (see below).

       * File locking interfaces: <a href="../man2/flock.2.html">flock(2)</a> and the <b>F_SETLKW </b>and <b>F_OFD_SETLKW</b>
         operations of <a href="../man2/fcntl.2.html">fcntl(2)</a>

       * POSIX message queue interfaces: <a href="../man3/mq_receive.3.html">mq_receive(3)</a>, <a href="../man3/mq_timedreceive.3.html">mq_timedreceive(3)</a>,
         <a href="../man3/mq_send.3.html">mq_send(3)</a>, and <a href="../man3/mq_timedsend.3.html">mq_timedsend(3)</a>.

       * <a href="../man2/futex.2.html">futex(2)</a> <b>FUTEX_WAIT </b>(since Linux 2.6.22; beforehand, always failed
         with <b>EINTR</b>).

       * <a href="../man2/getrandom.2.html">getrandom(2)</a>.

       * <b>pthread_mutex_lock</b>(3), <b>pthread_cond_wait</b>(3), and related APIs.

       * <a href="../man2/futex.2.html">futex(2)</a> <b>FUTEX_WAIT_BITSET</b>.

       * POSIX semaphore interfaces: <a href="../man3/sem_wait.3.html">sem_wait(3)</a> and <a href="../man3/sem_timedwait.3.html">sem_timedwait(3)</a> (since
         Linux 2.6.22; beforehand, always failed with <b>EINTR</b>).

       * <a href="../man2/read.2.html">read(2)</a> from an <a href="inotify.7.html">inotify(7)</a> file descriptor (since Linux 3.8;
         beforehand, always failed with <b>EINTR</b>).

       The following interfaces are never restarted after being interrupted
       by a signal handler, regardless of the use of <b>SA_RESTART</b>; they always
       fail with the error <b>EINTR </b>when interrupted by a signal handler:

       * "Input" socket interfaces, when a timeout (<b>SO_RCVTIMEO</b>) has been
         set on the socket using <a href="../man2/setsockopt.2.html">setsockopt(2)</a>: <a href="../man2/accept.2.html">accept(2)</a>, <a href="../man2/recv.2.html">recv(2)</a>,
         <a href="../man2/recvfrom.2.html">recvfrom(2)</a>, <a href="../man2/recvmmsg.2.html">recvmmsg(2)</a> (also with a non-NULL <i>timeout</i> argument),
         and <a href="../man2/recvmsg.2.html">recvmsg(2)</a>.

       * "Output" socket interfaces, when a timeout (<b>SO_RCVTIMEO</b>) has been
         set on the socket using <a href="../man2/setsockopt.2.html">setsockopt(2)</a>: <a href="../man2/connect.2.html">connect(2)</a>, <a href="../man2/send.2.html">send(2)</a>,
         <a href="../man2/sendto.2.html">sendto(2)</a>, and <a href="../man2/sendmsg.2.html">sendmsg(2)</a>.

       * Interfaces used to wait for signals: <a href="../man2/pause.2.html">pause(2)</a>, <a href="../man2/sigsuspend.2.html">sigsuspend(2)</a>,
         <a href="../man2/sigtimedwait.2.html">sigtimedwait(2)</a>, and <a href="../man2/sigwaitinfo.2.html">sigwaitinfo(2)</a>.

       * File descriptor multiplexing interfaces: <a href="../man2/epoll_wait.2.html">epoll_wait(2)</a>,
         <a href="../man2/epoll_pwait.2.html">epoll_pwait(2)</a>, <a href="../man2/poll.2.html">poll(2)</a>, <a href="../man2/ppoll.2.html">ppoll(2)</a>, <a href="../man2/select.2.html">select(2)</a>, and <a href="../man2/pselect.2.html">pselect(2)</a>.

       * System V IPC interfaces: <a href="../man2/msgrcv.2.html">msgrcv(2)</a>, <a href="../man2/msgsnd.2.html">msgsnd(2)</a>, <a href="../man2/semop.2.html">semop(2)</a>, and
         <a href="../man2/semtimedop.2.html">semtimedop(2)</a>.

       * Sleep interfaces: <a href="../man2/clock_nanosleep.2.html">clock_nanosleep(2)</a>, <a href="../man2/nanosleep.2.html">nanosleep(2)</a>, and <a href="../man3/usleep.3.html">usleep(3)</a>.

       * <a href="../man2/io_getevents.2.html">io_getevents(2)</a>.

       The <a href="../man3/sleep.3.html">sleep(3)</a> function is also never restarted if interrupted by a
       handler, but gives a success return: the number of seconds remaining
       to sleep.

   <b>Interruption of system calls and library functions by stop signals</b>
       On Linux, even in the absence of signal handlers, certain blocking
       interfaces can fail with the error <b>EINTR </b>after the process is stopped
       by one of the stop signals and then resumed via <b>SIGCONT</b>.  This
       behavior is not sanctioned by POSIX.1, and doesn't occur on other
       systems.

       The Linux interfaces that display this behavior are:

       * "Input" socket interfaces, when a timeout (<b>SO_RCVTIMEO</b>) has been
         set on the socket using <a href="../man2/setsockopt.2.html">setsockopt(2)</a>: <a href="../man2/accept.2.html">accept(2)</a>, <a href="../man2/recv.2.html">recv(2)</a>,
         <a href="../man2/recvfrom.2.html">recvfrom(2)</a>, <a href="../man2/recvmmsg.2.html">recvmmsg(2)</a> (also with a non-NULL <i>timeout</i> argument),
         and <a href="../man2/recvmsg.2.html">recvmsg(2)</a>.

       * "Output" socket interfaces, when a timeout (<b>SO_RCVTIMEO</b>) has been
         set on the socket using <a href="../man2/setsockopt.2.html">setsockopt(2)</a>: <a href="../man2/connect.2.html">connect(2)</a>, <a href="../man2/send.2.html">send(2)</a>,
         <a href="../man2/sendto.2.html">sendto(2)</a>, and <a href="../man2/sendmsg.2.html">sendmsg(2)</a>, if a send timeout (<b>SO_SNDTIMEO</b>) has been
         set.

       * <a href="../man2/epoll_wait.2.html">epoll_wait(2)</a>, <a href="../man2/epoll_pwait.2.html">epoll_pwait(2)</a>.

       * <a href="../man2/semop.2.html">semop(2)</a>, <a href="../man2/semtimedop.2.html">semtimedop(2)</a>.

       * <a href="../man2/sigtimedwait.2.html">sigtimedwait(2)</a>, <a href="../man2/sigwaitinfo.2.html">sigwaitinfo(2)</a>.

       * Linux 3.7 and earlier: <a href="../man2/read.2.html">read(2)</a> from an <a href="inotify.7.html">inotify(7)</a> file descriptor

       * Linux 2.6.21 and earlier: <a href="../man2/futex.2.html">futex(2)</a> <b>FUTEX_WAIT</b>, <a href="../man3/sem_timedwait.3.html">sem_timedwait(3)</a>,
         <a href="../man3/sem_wait.3.html">sem_wait(3)</a>.

       * Linux 2.6.8 and earlier: <a href="../man2/msgrcv.2.html">msgrcv(2)</a>, <a href="../man2/msgsnd.2.html">msgsnd(2)</a>.

       * Linux 2.4 and earlier: <a href="../man2/nanosleep.2.html">nanosleep(2)</a>.
</pre>
<h2><a id="CONFORMING_TO" href="#CONFORMING_TO"></a>CONFORMING TO  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       POSIX.1, except as noted.
</pre>
<h2><a id="NOTES" href="#NOTES"></a>NOTES  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       For a discussion of async-signal-safe functions, see
       <a href="signal-safety.7.html">signal-safety(7)</a>.
</pre>
<h2><a id="SEE_ALSO" href="#SEE_ALSO"></a>SEE ALSO  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       <a href="../man1/kill.1.html">kill(1)</a>, <a href="../man2/getrlimit.2.html">getrlimit(2)</a>, <a href="../man2/kill.2.html">kill(2)</a>, <a href="../man2/restart_syscall.2.html">restart_syscall(2)</a>,
       <a href="../man2/rt_sigqueueinfo.2.html">rt_sigqueueinfo(2)</a>, <a href="../man2/setitimer.2.html">setitimer(2)</a>, <a href="../man2/setrlimit.2.html">setrlimit(2)</a>, <a href="../man2/sgetmask.2.html">sgetmask(2)</a>,
       <a href="../man2/sigaction.2.html">sigaction(2)</a>, <a href="../man2/sigaltstack.2.html">sigaltstack(2)</a>, <a href="../man2/signal.2.html">signal(2)</a>, <a href="../man2/signalfd.2.html">signalfd(2)</a>, <a href="../man2/sigpending.2.html">sigpending(2)</a>,
       <a href="../man2/sigprocmask.2.html">sigprocmask(2)</a>, <a href="../man2/sigreturn.2.html">sigreturn(2)</a>, <a href="../man2/sigsuspend.2.html">sigsuspend(2)</a>, <a href="../man2/sigwaitinfo.2.html">sigwaitinfo(2)</a>,
       <a href="../man3/abort.3.html">abort(3)</a>, <a href="../man3/bsd_signal.3.html">bsd_signal(3)</a>, <a href="../man3/killpg.3.html">killpg(3)</a>, <a href="../man3/longjmp.3.html">longjmp(3)</a>, <a href="../man3/pthread_sigqueue.3.html">pthread_sigqueue(3)</a>,
       <a href="../man3/raise.3.html">raise(3)</a>, <a href="../man3/sigqueue.3.html">sigqueue(3)</a>, <a href="../man3/sigset.3.html">sigset(3)</a>, <a href="../man3/sigsetops.3.html">sigsetops(3)</a>, <a href="../man3/sigvec.3.html">sigvec(3)</a>,
       <a href="../man3/sigwait.3.html">sigwait(3)</a>, <a href="../man3/strsignal.3.html">strsignal(3)</a>, <a href="../man3/sysv_signal.3.html">sysv_signal(3)</a>, <a href="../man5/core.5.html">core(5)</a>, <a href="../man5/proc.5.html">proc(5)</a>, <a href="nptl.7.html">nptl(7)</a>,
       <a href="pthreads.7.html">pthreads(7)</a>, <a href="sigevent.7.html">sigevent(7)</a>
</pre>
<h2><a id="COLOPHON" href="#COLOPHON"></a>COLOPHON  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       This page is part of release 4.12 of the Linux <i>man-pages</i> project.  A
       description of the project, information about reporting bugs, and the
       latest version of this page, can be found at
       <a href="https://www.kernel.org/doc/man-pages/">https://www.kernel.org/doc/man-pages/</a>.

<span class="footline">Linux                            2017-05-03                        SIGNAL(7)</span>
</pre>

<hr class="end-man-text" />
<p>Pages that refer to this page: 
    <a href="../man1/kill.1.html">kill(1)</a>,&nbsp; 
    <a href="../man1/kill.1%40%40procps-ng.html">kill(1@@procps-ng)</a>,&nbsp; 
    <a href="../man1/pgrep.1.html">pgrep(1)</a>,&nbsp; 
    <a href="../man1/ps.1.html">ps(1)</a>,&nbsp; 
    <a href="../man1/skill.1.html">skill(1)</a>,&nbsp; 
    <a href="../man1/systemd-nspawn.1.html">systemd-nspawn(1)</a>,&nbsp; 
    <a href="../man1/xargs.1.html">xargs(1)</a>,&nbsp; 
    <a href="../man2/accept.2.html">accept(2)</a>,&nbsp; 
    <a href="../man2/clock_nanosleep.2.html">clock_nanosleep(2)</a>,&nbsp; 
    <a href="../man2/close.2.html">close(2)</a>,&nbsp; 
    <a href="../man2/connect.2.html">connect(2)</a>,&nbsp; 
    <a href="../man2/dup.2.html">dup(2)</a>,&nbsp; 
    <a href="../man2/epoll_wait.2.html">epoll_wait(2)</a>,&nbsp; 
    <a href="../man2/execve.2.html">execve(2)</a>,&nbsp; 
    <a href="../man2/fallocate.2.html">fallocate(2)</a>,&nbsp; 
    <a href="../man2/fcntl.2.html">fcntl(2)</a>,&nbsp; 
    <a href="../man2/flock.2.html">flock(2)</a>,&nbsp; 
    <a href="../man2/futex.2.html">futex(2)</a>,&nbsp; 
    <a href="../man2/getrandom.2.html">getrandom(2)</a>,&nbsp; 
    <a href="../man2/getrlimit.2.html">getrlimit(2)</a>,&nbsp; 
    <a href="../man2/intro.2.html">intro(2)</a>,&nbsp; 
    <a href="../man2/io_getevents.2.html">io_getevents(2)</a>,&nbsp; 
    <a href="../man2/kcmp.2.html">kcmp(2)</a>,&nbsp; 
    <a href="../man2/kill.2.html">kill(2)</a>,&nbsp; 
    <a href="../man2/msgop.2.html">msgop(2)</a>,&nbsp; 
    <a href="../man2/nanosleep.2.html">nanosleep(2)</a>,&nbsp; 
    <a href="../man2/open.2.html">open(2)</a>,&nbsp; 
    <a href="../man2/poll.2.html">poll(2)</a>,&nbsp; 
    <a href="../man2/ptrace.2.html">ptrace(2)</a>,&nbsp; 
    <a href="../man2/read.2.html">read(2)</a>,&nbsp; 
    <a href="../man2/recv.2.html">recv(2)</a>,&nbsp; 
    <a href="../man2/request_key.2.html">request_key(2)</a>,&nbsp; 
    <a href="../man2/restart_syscall.2.html">restart_syscall(2)</a>,&nbsp; 
    <a href="../man2/rt_sigqueueinfo.2.html">rt_sigqueueinfo(2)</a>,&nbsp; 
    <a href="../man2/s390_runtime_instr.2.html">s390_runtime_instr(2)</a>,&nbsp; 
    <a href="../man2/seccomp.2.html">seccomp(2)</a>,&nbsp; 
    <a href="../man2/select.2.html">select(2)</a>,&nbsp; 
    <a href="../man2/semop.2.html">semop(2)</a>,&nbsp; 
    <a href="../man2/send.2.html">send(2)</a>,&nbsp; 
    <a href="../man2/sgetmask.2.html">sgetmask(2)</a>,&nbsp; 
    <a href="../man2/sigaction.2.html">sigaction(2)</a>,&nbsp; 
    <a href="../man2/sigaltstack.2.html">sigaltstack(2)</a>,&nbsp; 
    <a href="../man2/signal.2.html">signal(2)</a>,&nbsp; 
    <a href="../man2/signalfd.2.html">signalfd(2)</a>,&nbsp; 
    <a href="../man2/sigpending.2.html">sigpending(2)</a>,&nbsp; 
    <a href="../man2/sigprocmask.2.html">sigprocmask(2)</a>,&nbsp; 
    <a href="../man2/sigreturn.2.html">sigreturn(2)</a>,&nbsp; 
    <a href="../man2/sigsuspend.2.html">sigsuspend(2)</a>,&nbsp; 
    <a href="../man2/sigwaitinfo.2.html">sigwaitinfo(2)</a>,&nbsp; 
    <a href="../man2/spu_run.2.html">spu_run(2)</a>,&nbsp; 
    <a href="../man2/statfs.2.html">statfs(2)</a>,&nbsp; 
    <a href="../man2/syscalls.2.html">syscalls(2)</a>,&nbsp; 
    <a href="../man2/timer_create.2.html">timer_create(2)</a>,&nbsp; 
    <a href="../man2/timer_getoverrun.2.html">timer_getoverrun(2)</a>,&nbsp; 
    <a href="../man2/truncate.2.html">truncate(2)</a>,&nbsp; 
    <a href="../man2/wait.2.html">wait(2)</a>,&nbsp; 
    <a href="../man2/wait4.2.html">wait4(2)</a>,&nbsp; 
    <a href="../man2/write.2.html">write(2)</a>,&nbsp; 
    <a href="../man3/aio_suspend.3.html">aio_suspend(3)</a>,&nbsp; 
    <a href="../man3/bsd_signal.3.html">bsd_signal(3)</a>,&nbsp; 
    <a href="../man3/errno.3.html">errno(3)</a>,&nbsp; 
    <a href="../man3/getgrent.3.html">getgrent(3)</a>,&nbsp; 
    <a href="../man3/getgrnam.3.html">getgrnam(3)</a>,&nbsp; 
    <a href="../man3/getpwent.3.html">getpwent(3)</a>,&nbsp; 
    <a href="../man3/getpwnam.3.html">getpwnam(3)</a>,&nbsp; 
    <a href="../man3/intro.3.html">intro(3)</a>,&nbsp; 
    <a href="../man3/killpg.3.html">killpg(3)</a>,&nbsp; 
    <a href="../man3/lio_listio.3.html">lio_listio(3)</a>,&nbsp; 
    <a href="../man3/mq_receive.3.html">mq_receive(3)</a>,&nbsp; 
    <a href="../man3/mq_send.3.html">mq_send(3)</a>,&nbsp; 
    <a href="../man3/psignal.3.html">psignal(3)</a>,&nbsp; 
    <a href="../man3/pthread_kill.3.html">pthread_kill(3)</a>,&nbsp; 
    <a href="../man3/pthread_sigmask.3.html">pthread_sigmask(3)</a>,&nbsp; 
    <a href="../man3/pthread_sigqueue.3.html">pthread_sigqueue(3)</a>,&nbsp; 
    <a href="../man3/raise.3.html">raise(3)</a>,&nbsp; 
    <a href="../man3/scanf.3.html">scanf(3)</a>,&nbsp; 
    <a href="../man3/sd_event_add_signal.3.html">sd_event_add_signal(3)</a>,&nbsp; 
    <a href="../man3/sd_journal_print.3.html">sd_journal_print(3)</a>,&nbsp; 
    <a href="../man3/sem_wait.3.html">sem_wait(3)</a>,&nbsp; 
    <a href="../man3/setjmp.3.html">setjmp(3)</a>,&nbsp; 
    <a href="../man3/sigqueue.3.html">sigqueue(3)</a>,&nbsp; 
    <a href="../man3/sigset.3.html">sigset(3)</a>,&nbsp; 
    <a href="../man3/sigvec.3.html">sigvec(3)</a>,&nbsp; 
    <a href="../man3/sigwait.3.html">sigwait(3)</a>,&nbsp; 
    <a href="../man3/sleep.3.html">sleep(3)</a>,&nbsp; 
    <a href="../man3/statvfs.3.html">statvfs(3)</a>,&nbsp; 
    <a href="../man3/system.3.html">system(3)</a>,&nbsp; 
    <a href="../man3/sysv_signal.3.html">sysv_signal(3)</a>,&nbsp; 
    <a href="../man3/tmpfile.3.html">tmpfile(3)</a>,&nbsp; 
    <a href="../man3/ualarm.3.html">ualarm(3)</a>,&nbsp; 
    <a href="../man3/usleep.3.html">usleep(3)</a>,&nbsp; 
    <a href="../man5/core.5.html">core(5)</a>,&nbsp; 
    <a href="../man5/proc.5.html">proc(5)</a>,&nbsp; 
    <a href="../man5/systemd.kill.5.html">systemd.kill(5)</a>,&nbsp; 
    <a href="../man5/systemd.nspawn.5.html">systemd.nspawn(5)</a>,&nbsp; 
    <a href="credentials.7.html">credentials(7)</a>,&nbsp; 
    <a href="fanotify.7.html">fanotify(7)</a>,&nbsp; 
    <a href="inotify.7.html">inotify(7)</a>,&nbsp; 
    <a href="nptl.7.html">nptl(7)</a>,&nbsp; 
    <a href="pthreads.7.html">pthreads(7)</a>,&nbsp; 
    <a href="random.7.html">random(7)</a>,&nbsp; 
    <a href="signal-safety.7.html">signal-safety(7)</a>,&nbsp; 
    <a href="../man8/cmirrord.8.html">cmirrord(8)</a>
</p>
<hr/>

<p class="page-copyright"><a href="signal.7.license.html">Copyright and license for this manual page</a></p> 
<hr class="start-footer" />

<div class="footer"> 

<table class="colophon-table">
    <tr>
    <td class="pub-info">
        <p>
            HTML rendering created 2017-07-13
            by <a href="http://man7.org/mtk/index.html">Michael Kerrisk</a>, 
            author of 
            <a href="http://man7.org/tlpi/"><em>The Linux Programming Interface</em></a>, 
            maintainer of the 
            <a href="https://www.kernel.org/doc/man-pages/">Linux <em>man-pages</em> project</a>.
        </p>
        <p>
            For details of in-depth
            <strong>Linux/UNIX system programming training courses</strong>
            that I teach, look <a href="http://man7.org/training/">here</a>.
        </p>
        <p>
            Hosting by <a href="http://www.jambit.com/index_en.html">jambit GmbH</a>.
        </p>
        <p>
            <a href="http://validator.w3.org/check?uri=referer">
            <img src="http://www.w3.org/Icons/valid-xhtml11"
                alt="Valid XHTML 1.1" height="31" width="88" />
            </a>
        </p>
    </td>
    <td class="colophon-divider">
    </td>
    <td class="tlpi-cover">
        <a href="http://man7.org/tlpi/"><img src="../../../tlpi/cover/TLPI-front-cover-vsmall.png" alt="Cover of TLPI" /></a>
    </td>
    </tr>
</table>

</div>

<hr class="end-footer" />



<!--BEGIN-SITETRACKING-->
<!-- SITETRACKING.man7.org_linux_man-pages -->

<!-- Start of StatCounter Code (xhtml) -->

<script type="text/javascript">
//<![CDATA[
var sc_project=7422636; 
var sc_invisible=1; 
var sc_security="9b6714ff"; 
//]]>
</script>
<script type="text/javascript"
src="../../../../www.statcounter.com/counter/counter_xhtml.js"></script>
<noscript><div class="statcounter"><a title="website
statistics" href="http://statcounter.com/"
class="statcounter"><img class="statcounter"
src="http://c.statcounter.com/7422636/0/9b6714ff/1/"
alt="website statistics" /></a></div></noscript>

<!-- End of StatCounter Code -->


<!-- Start of Google Analytics Code -->

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-9830363-8']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<!-- End of Google Analytics Code -->

<!--END-SITETRACKING-->

</body>
</html>
