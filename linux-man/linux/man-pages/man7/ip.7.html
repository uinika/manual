
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
        "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
    <link rel="stylesheet" type="text/css" href="../../../style.css" title="style" />
    <link rel="stylesheet" type="text/css" href="../style.css" title="style" />
    <meta http-equiv="content-type" content="text/html;charset=utf-8" />

    <title>ip(7) - Linux manual page</title>
</head>

<body>

<div class="page-top"><a id="top_of_page"></a></div>
<!--%%%TOP_BAR%%%-->
    <div class="nav-bar">
        <table class="nav-table">
            <tr>
                <td class="nav-cell">
                    <p class="nav-text">
                        <a href="http://man7.org/index.html">man7.org</a> &gt; Linux &gt; <a href="../index.html">man-pages</a>
                    </p>
                </td>
                <td class="training-cell">
                    <p class="training-text"><a class="training-link" href="http://man7.org/training/">Linux/UNIX system programming training</a></p>
                </td>
            </tr>
        </table>
    </div>

<hr class="nav-end" />

<!--%%%PAGE_START%%%-->


<table class="sec-table">
<tr>
    <td>
        <p class="section-dir">
<a href="#NAME">NAME</a> | <a href="#SYNOPSIS">SYNOPSIS</a> | <a href="#DESCRIPTION">DESCRIPTION</a> | <a href="#ERRORS">ERRORS</a> | <a href="#NOTES">NOTES</a> | <a href="#BUGS">BUGS</a> | <a href="#SEE_ALSO">SEE&nbsp;ALSO</a> | <a href="#COLOPHON">COLOPHON</a>
        </p>
    </td>
    <td class="search-box">
        <div class="man-search-box">

            <form method="get" action="http://www.google.com/search">
                <fieldset class="man-search">
                    <input type="text" name="q" size="10" maxlength="255" value="" />
                    <input type="hidden" name="sitesearch" value="man7.org/linux/man-pages" />
                    <input type="submit" name="sa" value="Search online pages" />
                </fieldset>
            </form>

        </div>
    </td>
    <td> </td>
</tr>
</table>

<pre>
<span class="headline">IP(7)                     Linux Programmer's Manual                    IP(7)</span>
</pre>
<h2><a id="NAME" href="#NAME"></a>NAME  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       ip - Linux IPv4 protocol implementation
</pre>
<h2><a id="SYNOPSIS" href="#SYNOPSIS"></a>SYNOPSIS  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       <b>#include &lt;sys/socket.h&gt;</b>
       <b>#include &lt;netinet/in.h&gt;</b>
       <b>#include &lt;netinet/ip.h&gt; </b>/* superset of previous */

       <i>tcp_socket</i> <b>= socket(AF_INET, SOCK_STREAM, 0);</b>
       <i>udp_socket</i> <b>= socket(AF_INET, SOCK_DGRAM, 0);</b>
       <i>raw_socket</i> <b>= socket(AF_INET, SOCK_RAW, </b><i>protocol</i><b>);</b>
</pre>
<h2><a id="DESCRIPTION" href="#DESCRIPTION"></a>DESCRIPTION  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       Linux implements the Internet Protocol, version 4, described in
       RFC 791 and RFC 1122.  <b>ip </b>contains a level 2 multicasting
       implementation conforming to RFC 1112.  It also contains an IP router
       including a packet filter.

       The programming interface is BSD-sockets compatible.  For more
       information on sockets, see <a href="socket.7.html">socket(7)</a>.

       An IP socket is created using <a href="../man2/socket.2.html">socket(2)</a>:

           socket(AF_INET, socket_type, protocol);

       Valid socket types are <b>SOCK_STREAM </b>to open a <a href="tcp.7.html">tcp(7)</a> socket,
       <b>SOCK_DGRAM </b>to open a <a href="udp.7.html">udp(7)</a> socket, or <b>SOCK_RAW </b>to open a <a href="raw.7.html">raw(7)</a>
       socket to access the IP protocol directly.  <i>protocol</i> is the IP
       protocol in the IP header to be received or sent.  The only valid
       values for <i>protocol</i> are 0 and <b>IPPROTO_TCP </b>for TCP sockets, and 0 and
       <b>IPPROTO_UDP </b>for UDP sockets.  For <b>SOCK_RAW </b>you may specify a valid
       IANA IP protocol defined in RFC 1700 assigned numbers.

       When a process wants to receive new incoming packets or connections,
       it should bind a socket to a local interface address using <a href="../man2/bind.2.html">bind(2)</a>.
       In this case, only one IP socket may be bound to any given local
       (address, port) pair.  When <b>INADDR_ANY </b>is specified in the bind call,
       the socket will be bound to <i>all</i> local interfaces.  When <a href="../man2/listen.2.html">listen(2)</a> is
       called on an unbound socket, the socket is automatically bound to a
       random free port with the local address set to <b>INADDR_ANY</b>.  When
       <a href="../man2/connect.2.html">connect(2)</a> is called on an unbound socket, the socket is
       automatically bound to a random free port or to a usable shared port
       with the local address set to <b>INADDR_ANY</b>.

       A TCP local socket address that has been bound is unavailable for
       some time after closing, unless the <b>SO_REUSEADDR </b>flag has been set.
       Care should be taken when using this flag as it makes TCP less
       reliable.

   <b>Address format</b>
       An IP socket address is defined as a combination of an IP interface
       address and a 16-bit port number.  The basic IP protocol does not
       supply port numbers, they are implemented by higher level protocols
       like <a href="udp.7.html">udp(7)</a> and <a href="tcp.7.html">tcp(7)</a>.  On raw sockets <i>sin_port</i> is set to the IP
       protocol.

           struct sockaddr_in {
               sa_family_t    sin_family; /* address family: AF_INET */
               in_port_t      sin_port;   /* port in network byte order */
               struct in_addr sin_addr;   /* internet address */
           };

           /* Internet address. */
           struct in_addr {
               uint32_t       s_addr;     /* address in network byte order */
           };

       <i>sin_family</i> is always set to <b>AF_INET</b>.  This is required; in Linux 2.2
       most networking functions return <b>EINVAL </b>when this setting is missing.
       <i>sin_port</i> contains the port in network byte order.  The port numbers
       below 1024 are called <i>privileged ports</i> (or sometimes: <i>reserved</i>
       <i>ports</i>).  Only a privileged process (on Linux: a process that has the
       <b>CAP_NET_BIND_SERVICE </b>capability in the user namespace governing its
       network namespace) may <a href="../man2/bind.2.html">bind(2)</a> to these sockets.  Note that the raw
       IPv4 protocol as such has no concept of a port, they are implemented
       only by higher protocols like <a href="tcp.7.html">tcp(7)</a> and <a href="udp.7.html">udp(7)</a>.

       <i>sin_addr</i> is the IP host address.  The <i>s_addr</i> member of <i>struct in_addr</i>
       contains the host interface address in network byte order.  <i>in_addr</i>
       should be assigned one of the <b>INADDR_* </b>values (e.g., <b>INADDR_ANY</b>) or
       set using the <a href="../man3/inet_aton.3.html">inet_aton(3)</a>, <a href="../man3/inet_addr.3.html">inet_addr(3)</a>, <a href="../man3/inet_makeaddr.3.html">inet_makeaddr(3)</a> library
       functions or directly with the name resolver (see <a href="../man3/gethostbyname.3.html">gethostbyname(3)</a>).

       IPv4 addresses are divided into unicast, broadcast, and multicast
       addresses.  Unicast addresses specify a single interface of a host,
       broadcast addresses specify all hosts on a network, and multicast
       addresses address all hosts in a multicast group.  Datagrams to
       broadcast addresses can be sent or received only when the
       <b>SO_BROADCAST </b>socket flag is set.  In the current implementation,
       connection-oriented sockets are allowed to use only unicast
       addresses.

       Note that the address and the port are always stored in network byte
       order.  In particular, this means that you need to call <a href="../man3/htons.3.html">htons(3)</a> on
       the number that is assigned to a port.  All address/port manipulation
       functions in the standard library work in network byte order.

       There are several special addresses: <b>INADDR_LOOPBACK </b>(127.0.0.1)
       always refers to the local host via the loopback device; <b>INADDR_ANY</b>
       (0.0.0.0) means any address for binding; <b>INADDR_BROADCAST</b>
       (255.255.255.255) means any host and has the same effect on bind as
       <b>INADDR_ANY </b>for historical reasons.

   <b>Socket options</b>
       IP supports some protocol-specific socket options that can be set
       with <a href="../man2/setsockopt.2.html">setsockopt(2)</a> and read with <a href="../man2/getsockopt.2.html">getsockopt(2)</a>.  The socket option
       level for IP is <b>IPPROTO_IP</b>.  A boolean integer flag is zero when it
       is false, otherwise true.

       When an invalid socket option is specified, <a href="../man2/getsockopt.2.html">getsockopt(2)</a> and
       <a href="../man2/setsockopt.2.html">setsockopt(2)</a> fail with the error <b>ENOPROTOOPT</b>.

       <b>IP_ADD_MEMBERSHIP </b>(since Linux 1.2)
              Join a multicast group.  Argument is an <i>ip_mreqn</i> structure.

                  struct ip_mreqn {
                      struct in_addr imr_multiaddr; /* IP multicast group
                                                       address */
                      struct in_addr imr_address;   /* IP address of local
                                                       interface */
                      int            imr_ifindex;   /* interface index */
                  };

              <i>imr_multiaddr</i> contains the address of the multicast group the
              application wants to join or leave.  It must be a valid
              multicast address (or <a href="../man2/setsockopt.2.html">setsockopt(2)</a> fails with the error
              <b>EINVAL</b>).  <i>imr_address</i> is the address of the local interface
              with which the system should join the multicast group; if it
              is equal to <b>INADDR_ANY</b>, an appropriate interface is chosen by
              the system.  <i>imr_ifindex</i> is the interface index of the
              interface that should join/leave the <i>imr_multiaddr</i> group, or 0
              to indicate any interface.

              The <i>ip_mreqn</i> structure is available only since Linux 2.2.  For
              compatibility, the old <i>ip_mreq</i> structure (present since Linux
              1.2) is still supported; it differs from <i>ip_mreqn</i> only by not
              including the <i>imr_ifindex</i> field.  (The kernel determines which
              structure is being passed based on the size passed in <i>optlen</i>.)

              <b>IP_ADD_MEMBERSHIP </b>is valid only for <a href="../man2/setsockopt.2.html">setsockopt(2)</a>.

       <b>IP_ADD_SOURCE_MEMBERSHIP </b>(since Linux 2.4.22 / 2.5.68)
              Join a multicast group and allow receiving data only from a
              specified source.  Argument is an <i>ip_mreq_source</i> structure.

                  struct ip_mreq_source {
                      struct in_addr imr_multiaddr;  /* IP multicast group
                                                        address */
                      struct in_addr imr_interface;  /* IP address of local
                                                        interface */
                      struct in_addr imr_sourceaddr; /* IP address of
                                                        multicast source */
                  };

              The <i>ip_mreq_source</i> structure is similar to <i>ip_mreqn</i> described
              under <b>IP_ADD_MEMBERSIP</b>.  The <i>imr_multiaddr</i> field contains the
              address of the multicast group the application wants to join
              or leave.  The <i>imr_interface</i> field is the address of the local
              interface with which the system should join the multicast
              group.  Finally, the <i>imr_sourceaddr</i> field contains the address
              of the source the application wants to receive data from.

              This option can be used multiple times to allow receiving data
              from more than one source.

       <b>IP_BIND_ADDRESS_NO_PORT </b>(since Linux 4.2)
              Inform the kernel to not reserve an ephemeral port when using
              <a href="../man2/bind.2.html">bind(2)</a> with a port number of 0.  The port will later be
              automatically chosen at <a href="../man2/connect.2.html">connect(2)</a> time, in a way that allows
              sharing a source port as long as the 4-tuple is unique.

       <b>IP_BLOCK_SOURCE </b>(since Linux 2.4.22 / 2.5.68)
              Stop receiving multicast data from a specific source in a
              given group.  This is valid only after the application has
              subscribed to the multicast group using either
              <b>IP_ADD_MEMBERSHIP </b>or <b>IP_ADD_SOURCE_MEMBERSHIP</b>.

              Argument is an <i>ip_mreq_source</i> structure as described under
              <b>IP_ADD_SOURCE_MEMBERSHIP</b>.

       <b>IP_DROP_MEMBERSHIP </b>(since Linux 1.2)
              Leave a multicast group.  Argument is an <i>ip_mreqn</i> or <i>ip_mreq</i>
              structure similar to <b>IP_ADD_MEMBERSHIP</b>.

       <b>IP_DROP_SOURCE_MEMBERSHIP </b>(since Linux 2.4.22 / 2.5.68)
              Leave a source-specific group—that is, stop receiving data
              from a given multicast group that come from a given source.
              If the application has subscribed to multiple sources within
              the same group, data from the remaining sources will still be
              delivered.  To stop receiving data from all sources at once,
              use <b>IP_DROP_MEMBERSHIP</b>.

              Argument is an <i>ip_mreq_source</i> structure as described under
              <b>IP_ADD_SOURCE_MEMBERSHIP</b>.

       <b>IP_FREEBIND </b>(since Linux 2.4)
              If enabled, this boolean option allows binding to an IP
              address that is nonlocal or does not (yet) exist.  This
              permits listening on a socket, without requiring the
              underlying network interface or the specified dynamic IP
              address to be up at the time that the application is trying to
              bind to it.  This option is the per-socket equivalent of the
              <i>ip_nonlocal_bind /proc</i> interface described below.

       <b>IP_HDRINCL </b>(since Linux 2.0)
              If enabled, the user supplies an IP header in front of the
              user data.  Valid only for <b>SOCK_RAW </b>sockets; see <a href="raw.7.html">raw(7)</a> for
              more information.  When this flag is enabled, the values set
              by <b>IP_OPTIONS</b>, <b>IP_TTL</b>, and <b>IP_TOS </b>are ignored.

       <b>IP_MSFILTER </b>(since Linux 2.4.22 / 2.5.68)
              This option provides access to the advanced full-state
              filtering API.  Argument is an <i>ip_msfilter</i> structure.

                  struct ip_msfilter {
                      struct in_addr imsf_multiaddr; /* IP multicast group
                                                        address */
                      struct in_addr imsf_interface; /* IP address of local
                                                        interface */
                      uint32_t       imsf_fmode;     /* Filter-mode */

                      uint32_t       imsf_numsrc;    /* Number of sources in
                                                        the following array */
                      struct in_addr imsf_slist[1];  /* Array of source
                                                        addresses */
                  };

              There are two macros, <b>MCAST_INCLUDE </b>and <b>MCAST_EXCLUDE</b>, which
              can be used to specify the filtering mode.  Additionally, the
              <b>IP_MSFILTER_SIZE</b>(n) macro exists to determine how much memory
              is needed to store <i>ip_msfilter</i> structure with <i>n</i> sources in the
              source list.

              For the full description of multicast source filtering refer
              to RFC 3376.

       <b>IP_MTU </b>(since Linux 2.2)
              Retrieve the current known path MTU of the current socket.
              Returns an integer.

              <b>IP_MTU </b>is valid only for <a href="../man2/getsockopt.2.html">getsockopt(2)</a> and can be employed
              only when the socket has been connected.

       <b>IP_MTU_DISCOVER </b>(since Linux 2.2)
              Set or receive the Path MTU Discovery setting for a socket.
              When enabled, Linux will perform Path MTU Discovery as defined
              in RFC 1191 on <b>SOCK_STREAM </b>sockets.  For non-<b>SOCK_STREAM</b>
              sockets, <b>IP_PMTUDISC_DO </b>forces the don't-fragment flag to be
              set on all outgoing packets.  It is the user's responsibility
              to packetize the data in MTU-sized chunks and to do the
              retransmits if necessary.  The kernel will reject (with
              <b>EMSGSIZE</b>) datagrams that are bigger than the known path MTU.
              <b>IP_PMTUDISC_WANT </b>will fragment a datagram if needed according
              to the path MTU, or will set the don't-fragment flag
              otherwise.

              The system-wide default can be toggled between
              <b>IP_PMTUDISC_WANT </b>and <b>IP_PMTUDISC_DONT </b>by writing
              (respectively, zero and nonzero values) to the
              <i>/proc/sys/net/ipv4/ip_no_pmtu_disc</i> file.

              Path MTU discovery value   Meaning
              IP_PMTUDISC_WANT           Use per-route settings.
              IP_PMTUDISC_DONT           Never do Path MTU Discovery.
              IP_PMTUDISC_DO             Always do Path MTU Discovery.
              IP_PMTUDISC_PROBE          Set DF but ignore Path MTU.

              When PMTU discovery is enabled, the kernel automatically keeps
              track of the path MTU per destination host.  When it is
              connected to a specific peer with <a href="../man2/connect.2.html">connect(2)</a>, the currently
              known path MTU can be retrieved conveniently using the <b>IP_MTU</b>
              socket option (e.g., after an <b>EMSGSIZE </b>error occurred).  The
              path MTU may change over time.  For connectionless sockets
              with many destinations, the new MTU for a given destination
              can also be accessed using the error queue (see <b>IP_RECVERR</b>).
              A new error will be queued for every incoming MTU update.

              While MTU discovery is in progress, initial packets from
              datagram sockets may be dropped.  Applications using UDP
              should be aware of this and not take it into account for their
              packet retransmit strategy.

              To bootstrap the path MTU discovery process on unconnected
              sockets, it is possible to start with a big datagram size (up
              to 64K-headers bytes long) and let it shrink by updates of the
              path MTU.

              To get an initial estimate of the path MTU, connect a datagram
              socket to the destination address using <a href="../man2/connect.2.html">connect(2)</a> and
              retrieve the MTU by calling <a href="../man2/getsockopt.2.html">getsockopt(2)</a> with the <b>IP_MTU</b>
              option.

              It is possible to implement RFC 4821 MTU probing with
              <b>SOCK_DGRAM </b>or <b>SOCK_RAW </b>sockets by setting a value of
              <b>IP_PMTUDISC_PROBE </b>(available since Linux 2.6.22).  This is
              also particularly useful for diagnostic tools such as
              <a href="../man8/tracepath.8.html">tracepath(8)</a> that wish to deliberately send probe packets
              larger than the observed Path MTU.

       <b>IP_MULTICAST_ALL </b>(since Linux 2.6.31)
              This option can be used to modify the delivery policy of
              multicast messages to sockets bound to the wildcard <b>INADDR_ANY</b>
              address.  The argument is a boolean integer (defaults to 1).
              If set to 1, the socket will receive messages from all the
              groups that have been joined globally on the whole system.
              Otherwise, it will deliver messages only from the groups that
              have been explicitly joined (for example via the
              <b>IP_ADD_MEMBERSHIP </b>option) on this particular socket.

       <b>IP_MULTICAST_IF </b>(since Linux 1.2)
              Set the local device for a multicast socket.  The argument for
              <a href="../man2/setsockopt.2.html">setsockopt(2)</a> is an <i>ip_mreqn</i> or (since Linux 3.5) <i>ip_mreq</i>
              structure similar to <b>IP_ADD_MEMBERSHIP</b>, or an <i>in_addr</i>
              structure.  (The kernel determines which structure is being
              passed based on the size passed in <i>optlen</i>.)  For
              <a href="../man2/getsockopt.2.html">getsockopt(2)</a>, the argument is an <i>in_addr</i> structure.

       <b>IP_MULTICAST_LOOP </b>(since Linux 1.2)
              Set or read a boolean integer argument that determines whether
              sent multicast packets should be looped back to the local
              sockets.

       <b>IP_MULTICAST_TTL </b>(since Linux 1.2)
              Set or read the time-to-live value of outgoing multicast
              packets for this socket.  It is very important for multicast
              packets to set the smallest TTL possible.  The default is 1
              which means that multicast packets don't leave the local
              network unless the user program explicitly requests it.
              Argument is an integer.

       <b>IP_NODEFRAG </b>(since Linux 2.6.36)
              If enabled (argument is nonzero), the reassembly of outgoing
              packets is disabled in the netfilter layer.  The argument is
              an integer.

              This option is valid only for <b>SOCK_RAW </b>sockets.

       <b>IP_OPTIONS </b>(since Linux 2.0)
              Set or get the IP options to be sent with every packet from
              this socket.  The arguments are a pointer to a memory buffer
              containing the options and the option length.  The
              <a href="../man2/setsockopt.2.html">setsockopt(2)</a> call sets the IP options associated with a
              socket.  The maximum option size for IPv4 is 40 bytes.  See
              RFC 791 for the allowed options.  When the initial connection
              request packet for a <b>SOCK_STREAM </b>socket contains IP options,
              the IP options will be set automatically to the options from
              the initial packet with routing headers reversed.  Incoming
              packets are not allowed to change options after the connection
              is established.  The processing of all incoming source routing
              options is disabled by default and can be enabled by using the
              <i>accept_source_route /proc</i> interface.  Other options like
              timestamps are still handled.  For datagram sockets, IP
              options can be only set by the local user.  Calling
              <a href="../man2/getsockopt.2.html">getsockopt(2)</a> with <b>IP_OPTIONS </b>puts the current IP options used
              for sending into the supplied buffer.

       <b>IP_PKTINFO </b>(since Linux 2.2)
              Pass an <b>IP_PKTINFO </b>ancillary message that contains a <i>pktinfo</i>
              structure that supplies some information about the incoming
              packet.  This only works for datagram oriented sockets.  The
              argument is a flag that tells the socket whether the
              <b>IP_PKTINFO </b>message should be passed or not.  The message
              itself can only be sent/retrieved as control message with a
              packet using <a href="../man2/recvmsg.2.html">recvmsg(2)</a> or <a href="../man2/sendmsg.2.html">sendmsg(2)</a>.

                  struct in_pktinfo {
                      unsigned int   ipi_ifindex;  /* Interface index */
                      struct in_addr ipi_spec_dst; /* Local address */
                      struct in_addr ipi_addr;     /* Header Destination
                                                      address */
                  };

              <i>ipi_ifindex</i> is the unique index of the interface the packet
              was received on.  <i>ipi_spec_dst</i> is the local address of the
              packet and <i>ipi_addr</i> is the destination address in the packet
              header.  If <b>IP_PKTINFO </b>is passed to <a href="../man2/sendmsg.2.html">sendmsg(2)</a> and
              <i>ipi_spec_dst</i> is not zero, then it is used as the local source
              address for the routing table lookup and for setting up IP
              source route options.  When <i>ipi_ifindex</i> is not zero, the
              primary local address of the interface specified by the index
              overwrites <i>ipi_spec_dst</i> for the routing table lookup.

       <b>IP_RECVERR </b>(since Linux 2.2)
              Enable extended reliable error message passing.  When enabled
              on a datagram socket, all generated errors will be queued in a
              per-socket error queue.  When the user receives an error from
              a socket operation, the errors can be received by calling
              <a href="../man2/recvmsg.2.html">recvmsg(2)</a> with the <b>MSG_ERRQUEUE </b>flag set.  The
              <i>sock_extended_err</i> structure describing the error will be
              passed in an ancillary message with the type <b>IP_RECVERR </b>and
              the level <b>IPPROTO_IP</b>.  This is useful for reliable error
              handling on unconnected sockets.  The received data portion of
              the error queue contains the error packet.

              The <b>IP_RECVERR </b>control message contains a <i>sock_extended_err</i>
              structure:

                  #define SO_EE_ORIGIN_NONE    0
                  #define SO_EE_ORIGIN_LOCAL   1
                  #define SO_EE_ORIGIN_ICMP    2
                  #define SO_EE_ORIGIN_ICMP6   3

                  struct sock_extended_err {
                      uint32_t ee_errno;   /* error number */
                      uint8_t  ee_origin;  /* where the error originated */
                      uint8_t  ee_type;    /* type */
                      uint8_t  ee_code;    /* code */
                      uint8_t  ee_pad;
                      uint32_t ee_info;    /* additional information */
                      uint32_t ee_data;    /* other data */
                      /* More data may follow */
                  };

                  struct sockaddr *SO_EE_OFFENDER(struct sock_extended_err *);

              <i>ee_errno</i> contains the <i><a href="../man3/errno.3.html">errno</a></i> number of the queued error.
              <i>ee_origin</i> is the origin code of where the error originated.
              The other fields are protocol-specific.  The macro
              <b>SO_EE_OFFENDER </b>returns a pointer to the address of the network
              object where the error originated from given a pointer to the
              ancillary message.  If this address is not known, the
              <i>sa_family</i> member of the <i>sockaddr</i> contains <b>AF_UNSPEC </b>and the
              other fields of the <i>sockaddr</i> are undefined.

              IP uses the <i>sock_extended_err</i> structure as follows: <i>ee_origin</i>
              is set to <b>SO_EE_ORIGIN_ICMP </b>for errors received as an ICMP
              packet, or <b>SO_EE_ORIGIN_LOCAL </b>for locally generated errors.
              Unknown values should be ignored.  <i>ee_type</i> and <i>ee_code</i> are set
              from the type and code fields of the ICMP header.  <i>ee_info</i>
              contains the discovered MTU for <b>EMSGSIZE </b>errors.  The message
              also contains the <i>sockaddr_in of the node</i> caused the error,
              which can be accessed with the <b>SO_EE_OFFENDER </b>macro.  The
              <i>sin_family</i> field of the <b>SO_EE_OFFENDER </b>address is <b>AF_UNSPEC</b>
              when the source was unknown.  When the error originated from
              the network, all IP options (<b>IP_OPTIONS</b>, <b>IP_TTL</b>, etc.) enabled
              on the socket and contained in the error packet are passed as
              control messages.  The payload of the packet causing the error
              is returned as normal payload.  Note that TCP has no error
              queue; <b>MSG_ERRQUEUE </b>is not permitted on <b>SOCK_STREAM </b>sockets.
              <b>IP_RECVERR </b>is valid for TCP, but all errors are returned by
              socket function return or <b>SO_ERROR </b>only.

              For raw sockets, <b>IP_RECVERR </b>enables passing of all received
              ICMP errors to the application, otherwise errors are only
              reported on connected sockets

              It sets or retrieves an integer boolean flag.  <b>IP_RECVERR</b>
              defaults to off.

       <b>IP_RECVOPTS </b>(since Linux 2.2)
              Pass all incoming IP options to the user in a <b>IP_OPTIONS</b>
              control message.  The routing header and other options are
              already filled in for the local host.  Not supported for
              <b>SOCK_STREAM </b>sockets.

       <b>IP_RECVORIGDSTADDR </b>(since Linux 2.6.29)
              This boolean option enables the <b>IP_ORIGDSTADDR </b>ancillary
              message in <a href="../man2/recvmsg.2.html">recvmsg(2)</a>, in which the kernel returns the
              original destination address of the datagram being received.
              The ancillary message contains a <i>struct sockaddr_in</i>.

       <b>IP_RECVTOS </b>(since Linux 2.2)
              If enabled, the <b>IP_TOS </b>ancillary message is passed with
              incoming packets.  It contains a byte which specifies the Type
              of Service/Precedence field of the packet header.  Expects a
              boolean integer flag.

       <b>IP_RECVTTL </b>(since Linux 2.2)
              When this flag is set, pass a <b>IP_TTL </b>control message with the
              time-to-live field of the received packet as a byte.  Not
              supported for <b>SOCK_STREAM </b>sockets.

       <b>IP_RETOPTS </b>(since Linux 2.2)
              Identical to <b>IP_RECVOPTS</b>, but returns raw unprocessed options
              with timestamp and route record options not filled in for this
              hop.

       <b>IP_ROUTER_ALERT </b>(since Linux 2.2)
              Pass all to-be forwarded packets with the IP Router Alert
              option set to this socket.  Valid only for raw sockets.  This
              is useful, for instance, for user-space RSVP daemons.  The
              tapped packets are not forwarded by the kernel; it is the
              user's responsibility to send them out again.  Socket binding
              is ignored, such packets are only filtered by protocol.
              Expects an integer flag.

       <b>IP_TOS </b>(since Linux 1.0)
              Set or receive the Type-Of-Service (TOS) field that is sent
              with every IP packet originating from this socket.  It is used
              to prioritize packets on the network.  TOS is a byte.  There
              are some standard TOS flags defined: <b>IPTOS_LOWDELAY </b>to
              minimize delays for interactive traffic, <b>IPTOS_THROUGHPUT </b>to
              optimize throughput, <b>IPTOS_RELIABILITY </b>to optimize for
              reliability, <b>IPTOS_MINCOST </b>should be used for "filler data"
              where slow transmission doesn't matter.  At most one of these
              TOS values can be specified.  Other bits are invalid and shall
              be cleared.  Linux sends <b>IPTOS_LOWDELAY </b>datagrams first by
              default, but the exact behavior depends on the configured
              queueing discipline.  Some high-priority levels may require
              superuser privileges (the <b>CAP_NET_ADMIN </b>capability).

       <b>IP_TRANSPARENT </b>(since Linux 2.6.24)
              Setting this boolean option enables transparent proxying on
              this socket.  This socket option allows the calling
              application to bind to a nonlocal IP address and operate both
              as a client and a server with the foreign address as the local
              endpoint.  NOTE: this requires that routing be set up in a way
              that packets going to the foreign address are routed through
              the TProxy box (i.e., the system hosting the application that
              employs the <b>IP_TRANSPARENT </b>socket option).  Enabling this
              socket option requires superuser privileges (the <b>CAP_NET_ADMIN</b>
              capability).

              TProxy redirection with the iptables TPROXY target also
              requires that this option be set on the redirected socket.

       <b>IP_TTL </b>(since Linux 1.0)
              Set or retrieve the current time-to-live field that is used in
              every packet sent from this socket.

       <b>IP_UNBLOCK_SOURCE </b>(since Linux 2.4.22 / 2.5.68)
              Unblock previously blocked multicast source.  Returns
              <b>EADDRNOTAVAIL </b>when given source is not being blocked.

              Argument is an <i>ip_mreq_source</i> structure as described under
              <b>IP_ADD_SOURCE_MEMBERSHIP</b>.

   <b>/proc interfaces</b>
       The IP protocol supports a set of <i>/proc</i> interfaces to configure some
       global parameters.  The parameters can be accessed by reading or
       writing files in the directory <i>/proc/sys/net/ipv4/</i>.  Interfaces
       described as <i>Boolean</i> take an integer value, with a nonzero value
       ("true") meaning that the corresponding option is enabled, and a zero
       value ("false") meaning that the option is disabled.

       <i>ip_always_defrag</i> (Boolean; since Linux 2.2.13)
              [New with kernel 2.2.13; in earlier kernel versions this
              feature was controlled at compile time by the
              <b>CONFIG_IP_ALWAYS_DEFRAG </b>option; this option is not present in
              2.4.x and later]

              When this boolean flag is enabled (not equal 0), incoming
              fragments (parts of IP packets that arose when some host
              between origin and destination decided that the packets were
              too large and cut them into pieces) will be reassembled
              (defragmented) before being processed, even if they are about
              to be forwarded.

              Enable only if running either a firewall that is the sole link
              to your network or a transparent proxy; never ever use it for
              a normal router or host.  Otherwise, fragmented communication
              can be disturbed if the fragments travel over different links.
              Defragmentation also has a large memory and CPU time cost.

              This is automagically turned on when masquerading or
              transparent proxying are configured.

       <i>ip_autoconfig</i> (since Linux 2.2 to 2.6.17)
              Not documented.

       <i>ip_default_ttl</i> (integer; default: 64; since Linux 2.2)
              Set the default time-to-live value of outgoing packets.  This
              can be changed per socket with the <b>IP_TTL </b>option.

       <i>ip_dynaddr</i> (Boolean; default: disabled; since Linux 2.0.31)
              Enable dynamic socket address and masquerading entry rewriting
              on interface address change.  This is useful for dialup
              interface with changing IP addresses.  0 means no rewriting, 1
              turns it on and 2 enables verbose mode.

       <i>ip_forward</i> (Boolean; default: disabled; since Linux 1.2)
              Enable IP forwarding with a boolean flag.  IP forwarding can
              be also set on a per-interface basis.

       <i>ip_local_port_range</i> (since Linux 2.2)
              This file contains two integers that define the default local
              port range allocated to sockets that are not explicitly bound
              to a port number—that is, the range used for <i>ephemeral ports</i>.
              An ephemeral port is allocated to a socket in the following
              circumstances:

              *  the port number in a socket address is specified as 0 when
                 calling bind(2);

              *  <a href="../man2/listen.2.html">listen(2)</a> is called on a stream socket that was not
                 previously bound;

              *  <a href="../man2/connect.2.html">connect(2)</a> was called on a socket that was not previously
                 bound;

              *  <a href="../man2/sendto.2.html">sendto(2)</a> is called on a datagram socket that was not
                 previously bound.

              Allocation of ephemeral ports starts with the first number in
              <i>ip_local_port_range</i> and ends with the second number.  If the
              range of ephemeral ports is exhausted, then the relevant
              system call returns an error (but see BUGS).

              Note that the port range in <i>ip_local_port_range</i> should not
              conflict with the ports used by masquerading (although the
              case is handled).  Also, arbitrary choices may cause problems
              with some firewall packet filters that make assumptions about
              the local ports in use.  The first number should be at least
              greater than 1024, or better, greater than 4096, to avoid
              clashes with well known ports and to minimize firewall
              problems.

       <i>ip_no_pmtu_disc</i> (Boolean; default: disabled; since Linux 2.2)
              If enabled, don't do Path MTU Discovery for TCP sockets by
              default.  Path MTU discovery may fail if misconfigured
              firewalls (that drop all ICMP packets) or misconfigured
              interfaces (e.g., a point-to-point link where the both ends
              don't agree on the MTU) are on the path.  It is better to fix
              the broken routers on the path than to turn off Path MTU
              Discovery globally, because not doing it incurs a high cost to
              the network.

       <i>ip_nonlocal_bind</i> (Boolean; default: disabled; since Linux 2.4)
              If set, allows processes to <a href="../man2/bind.2.html">bind(2)</a> to nonlocal IP addresses,
              which can be quite useful, but may break some applications.

       <i>ip6frag_time</i> (integer; default: 30)
              Time in seconds to keep an IPv6 fragment in memory.

       <i>ip6frag_secret_interval</i> (integer; default: 600)
              Regeneration interval (in seconds) of the hash secret (or
              lifetime for the hash secret) for IPv6 fragments.

       <i>ipfrag_high_thresh</i> (integer), <i>ipfrag_low_thresh</i> (integer)
              If the amount of queued IP fragments reaches
              <i>ipfrag_high_thresh</i>, the queue is pruned down to
              <i>ipfrag_low_thresh</i>.  Contains an integer with the number of
              bytes.

       <i>neigh/*</i>
              See <a href="arp.7.html">arp(7)</a>.

   <b>Ioctls</b>
       All ioctls described in <a href="socket.7.html">socket(7)</a> apply to <b>ip</b>.

       Ioctls to configure generic device parameters are described in
       <a href="netdevice.7.html">netdevice(7)</a>.
</pre>
<h2><a id="ERRORS" href="#ERRORS"></a>ERRORS  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       <b>EACCES </b>The user tried to execute an operation without the necessary
              permissions.  These include: sending a packet to a broadcast
              address without having the <b>SO_BROADCAST </b>flag set; sending a
              packet via a <i>prohibit</i> route; modifying firewall settings
              without superuser privileges (the <b>CAP_NET_ADMIN </b>capability);
              binding to a privileged port without superuser privileges (the
              <b>CAP_NET_BIND_SERVICE </b>capability).

       <b>EADDRINUSE</b>
              Tried to bind to an address already in use.

       <b>EADDRNOTAVAIL</b>
              A nonexistent interface was requested or the requested source
              address was not local.

       <b>EAGAIN </b>Operation on a nonblocking socket would block.

       <b>EALREADY</b>
              A connection operation on a nonblocking socket is already in
              progress.

       <b>ECONNABORTED</b>
              A connection was closed during an <a href="../man2/accept.2.html">accept(2)</a>.

       <b>EHOSTUNREACH</b>
              No valid routing table entry matches the destination address.
              This error can be caused by an ICMP message from a remote
              router or for the local routing table.

       <b>EINVAL </b>Invalid argument passed.  For send operations this can be
              caused by sending to a <i>blackhole</i> route.

       <b>EISCONN</b>
              <a href="../man2/connect.2.html">connect(2)</a> was called on an already connected socket.

       <b>EMSGSIZE</b>
              Datagram is bigger than an MTU on the path and it cannot be
              fragmented.

       <b>ENOBUFS</b>, <b>ENOMEM</b>
              Not enough free memory.  This often means that the memory
              allocation is limited by the socket buffer limits, not by the
              system memory, but this is not 100% consistent.

       <b>ENOENT SIOCGSTAMP </b>was called on a socket where no packet arrived.

       <b>ENOPKG </b>A kernel subsystem was not configured.

       <b>ENOPROTOOPT </b>and <b>EOPNOTSUPP</b>
              Invalid socket option passed.

       <b>ENOTCONN</b>
              The operation is defined only on a connected socket, but the
              socket wasn't connected.

       <b>EPERM  </b>User doesn't have permission to set high priority, change
              configuration, or send signals to the requested process or
              group.

       <b>EPIPE  </b>The connection was unexpectedly closed or shut down by the
              other end.

       <b>ESOCKTNOSUPPORT</b>
              The socket is not configured or an unknown socket type was
              requested.

       Other errors may be generated by the overlaying protocols; see
       <a href="tcp.7.html">tcp(7)</a>, <a href="raw.7.html">raw(7)</a>, <a href="udp.7.html">udp(7)</a>, and <a href="socket.7.html">socket(7)</a>.
</pre>
<h2><a id="NOTES" href="#NOTES"></a>NOTES  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       <b>IP_FREEBIND</b>, <b>IP_MSFILTER</b>, <b>IP_MTU</b>, <b>IP_MTU_DISCOVER</b>,
       <b>IP_RECVORIGDSTADDR</b>, <b>IP_PKTINFO</b>, <b>IP_RECVERR</b>, <b>IP_ROUTER_ALERT</b>, and
       <b>IP_TRANSPARENT </b>are Linux-specific.

       Be very careful with the <b>SO_BROADCAST </b>option - it is not privileged
       in Linux.  It is easy to overload the network with careless
       broadcasts.  For new application protocols it is better to use a
       multicast group instead of broadcasting.  Broadcasting is
       discouraged.

       Some other BSD sockets implementations provide <b>IP_RCVDSTADDR </b>and
       <b>IP_RECVIF </b>socket options to get the destination address and the
       interface of received datagrams.  Linux has the more general
       <b>IP_PKTINFO </b>for the same task.

       Some BSD sockets implementations also provide an <b>IP_RECVTTL </b>option,
       but an ancillary message with type <b>IP_RECVTTL </b>is passed with the
       incoming packet.  This is different from the <b>IP_TTL </b>option used in
       Linux.

       Using the <b>SOL_IP </b>socket options level isn't portable; BSD-based
       stacks use the <b>IPPROTO_IP </b>level.

   <b>Compatibility</b>
       For compatibility with Linux 2.0, the obsolete <b>socket(AF_INET,</b>
       <b>SOCK_PACKET, </b><i>protocol</i><b>) </b>syntax is still supported to open a <a href="packet.7.html">packet(7)</a>
       socket.  This is deprecated and should be replaced by
       <b>socket(AF_PACKET, SOCK_RAW, </b><i>protocol</i><b>) </b>instead.  The main difference
       is the new <i>sockaddr_ll</i> address structure for generic link layer
       information instead of the old <b>sockaddr_pkt</b>.
</pre>
<h2><a id="BUGS" href="#BUGS"></a>BUGS  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       There are too many inconsistent error values.

       The error used to diagnose exhaustion of the ephemeral port range
       differs across the various system calls (<a href="../man2/connect.2.html">connect(2)</a>, <a href="../man2/bind.2.html">bind(2)</a>,
       <a href="../man2/listen.2.html">listen(2)</a>, <a href="../man2/sendto.2.html">sendto(2)</a>) that can assign ephemeral ports.

       The ioctls to configure IP-specific interface options and ARP tables
       are not described.

       Receiving the original destination address with <b>MSG_ERRQUEUE </b>in
       <i>msg_name</i> by <a href="../man2/recvmsg.2.html">recvmsg(2)</a> does not work in some 2.2 kernels.
</pre>
<h2><a id="SEE_ALSO" href="#SEE_ALSO"></a>SEE ALSO  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       <a href="../man2/recvmsg.2.html">recvmsg(2)</a>, <a href="../man2/sendmsg.2.html">sendmsg(2)</a>, <a href="../man3/byteorder.3.html">byteorder(3)</a>, <b>ipfw</b>(4), <a href="capabilities.7.html">capabilities(7)</a>,
       <a href="icmp.7.html">icmp(7)</a>, <a href="ipv6.7.html">ipv6(7)</a>, <a href="netlink.7.html">netlink(7)</a>, <a href="raw.7.html">raw(7)</a>, <a href="socket.7.html">socket(7)</a>, <a href="tcp.7.html">tcp(7)</a>, <a href="udp.7.html">udp(7)</a>,
       <a href="../man8/ip.8.html">ip(8)</a>

       RFC 791 for the original IP specification.  RFC 1122 for the IPv4
       host requirements.  RFC 1812 for the IPv4 router requirements.
</pre>
<h2><a id="COLOPHON" href="#COLOPHON"></a>COLOPHON  &nbsp; &nbsp; &nbsp; &nbsp; <a href="#top_of_page"><span class="top-link">top</span></a></h2><pre>
       This page is part of release 4.12 of the Linux <i>man-pages</i> project.  A
       description of the project, information about reporting bugs, and the
       latest version of this page, can be found at
       <a href="https://www.kernel.org/doc/man-pages/">https://www.kernel.org/doc/man-pages/</a>.

<span class="footline">Linux                            2017-03-13                            IP(7)</span>
</pre>

<hr class="end-man-text" />
<p>Pages that refer to this page: 
    <a href="../man2/bind.2.html">bind(2)</a>,&nbsp; 
    <a href="../man2/connect.2.html">connect(2)</a>,&nbsp; 
    <a href="../man2/getpeername.2.html">getpeername(2)</a>,&nbsp; 
    <a href="../man2/getsockname.2.html">getsockname(2)</a>,&nbsp; 
    <a href="../man2/getsockopt.2.html">getsockopt(2)</a>,&nbsp; 
    <a href="../man2/listen.2.html">listen(2)</a>,&nbsp; 
    <a href="../man2/recv.2.html">recv(2)</a>,&nbsp; 
    <a href="../man2/send.2.html">send(2)</a>,&nbsp; 
    <a href="../man2/socket.2.html">socket(2)</a>,&nbsp; 
    <a href="../man3/getaddrinfo.3.html">getaddrinfo(3)</a>,&nbsp; 
    <a href="../man3/getaddrinfo_a.3.html">getaddrinfo_a(3)</a>,&nbsp; 
    <a href="../man3/sctp_connectx.3.html">sctp_connectx(3)</a>,&nbsp; 
    <a href="../man3/sd_is_fifo.3.html">sd_is_fifo(3)</a>,&nbsp; 
    <a href="../man5/proc.5.html">proc(5)</a>,&nbsp; 
    <a href="../man5/systemd.socket.5.html">systemd.socket(5)</a>,&nbsp; 
    <a href="arp.7.html">arp(7)</a>,&nbsp; 
    <a href="icmp.7.html">icmp(7)</a>,&nbsp; 
    <a href="ipv6.7.html">ipv6(7)</a>,&nbsp; 
    <a href="netdevice.7.html">netdevice(7)</a>,&nbsp; 
    <a href="packet.7.html">packet(7)</a>,&nbsp; 
    <a href="raw.7.html">raw(7)</a>,&nbsp; 
    <a href="rtnetlink.7.html">rtnetlink(7)</a>,&nbsp; 
    <a href="sctp.7.html">sctp(7)</a>,&nbsp; 
    <a href="socket.7.html">socket(7)</a>,&nbsp; 
    <a href="tcp.7.html">tcp(7)</a>,&nbsp; 
    <a href="udp.7.html">udp(7)</a>,&nbsp; 
    <a href="udplite.7.html">udplite(7)</a>
</p>
<hr/>

<p class="page-copyright"><a href="ip.7.license.html">Copyright and license for this manual page</a></p> 
<hr class="start-footer" />

<div class="footer"> 

<table class="colophon-table">
    <tr>
    <td class="pub-info">
        <p>
            HTML rendering created 2017-07-13
            by <a href="http://man7.org/mtk/index.html">Michael Kerrisk</a>, 
            author of 
            <a href="http://man7.org/tlpi/"><em>The Linux Programming Interface</em></a>, 
            maintainer of the 
            <a href="https://www.kernel.org/doc/man-pages/">Linux <em>man-pages</em> project</a>.
        </p>
        <p>
            For details of in-depth
            <strong>Linux/UNIX system programming training courses</strong>
            that I teach, look <a href="http://man7.org/training/">here</a>.
        </p>
        <p>
            Hosting by <a href="http://www.jambit.com/index_en.html">jambit GmbH</a>.
        </p>
        <p>
            <a href="http://validator.w3.org/check?uri=referer">
            <img src="http://www.w3.org/Icons/valid-xhtml11"
                alt="Valid XHTML 1.1" height="31" width="88" />
            </a>
        </p>
    </td>
    <td class="colophon-divider">
    </td>
    <td class="tlpi-cover">
        <a href="http://man7.org/tlpi/"><img src="../../../tlpi/cover/TLPI-front-cover-vsmall.png" alt="Cover of TLPI" /></a>
    </td>
    </tr>
</table>

</div>

<hr class="end-footer" />



<!--BEGIN-SITETRACKING-->
<!-- SITETRACKING.man7.org_linux_man-pages -->

<!-- Start of StatCounter Code (xhtml) -->

<script type="text/javascript">
//<![CDATA[
var sc_project=7422636; 
var sc_invisible=1; 
var sc_security="9b6714ff"; 
//]]>
</script>
<script type="text/javascript"
src="../../../../www.statcounter.com/counter/counter_xhtml.js"></script>
<noscript><div class="statcounter"><a title="website
statistics" href="http://statcounter.com/"
class="statcounter"><img class="statcounter"
src="http://c.statcounter.com/7422636/0/9b6714ff/1/"
alt="website statistics" /></a></div></noscript>

<!-- End of StatCounter Code -->


<!-- Start of Google Analytics Code -->

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-9830363-8']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

<!-- End of Google Analytics Code -->

<!--END-SITETRACKING-->

</body>
</html>
